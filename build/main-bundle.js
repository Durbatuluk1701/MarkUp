/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/katex/dist/katex.js":
/*!******************************************!*\
  !*** ./node_modules/katex/dist/katex.js ***!
  \******************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __nested_webpack_require_514__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_514__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_514__.o(definition, key) && !__nested_webpack_require_514__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_514__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};

// EXPORTS
__nested_webpack_require_514__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ katex_webpack; }
});

;// CONCATENATED MODULE: ./src/ParseError.js


/**
 * This is the ParseError class, which is the main error thrown by KaTeX
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 */
class ParseError {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(message, // The error message
  token // An object providing position information
  ) {
    this.name = void 0;
    this.position = void 0;
    this.length = void 0;
    this.rawMessage = void 0;
    let error = "KaTeX parse error: " + message;
    let start;
    let end;
    const loc = token && token.loc;

    if (loc && loc.start <= loc.end) {
      // If we have the input and a position, make the error a bit fancier
      // Get the input
      const input = loc.lexer.input; // Prepend some information

      start = loc.start;
      end = loc.end;

      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": ";
      } // Underline token in question using combining underscores


      const underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332"); // Extract some context from the input and add it to the error

      let left;

      if (start > 15) {
        left = "…" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }

      let right;

      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "…";
      } else {
        right = input.slice(end);
      }

      error += left + underlined + right;
    } // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    // $FlowFixMe


    const self = new Error(error);
    self.name = "ParseError"; // $FlowFixMe

    self.__proto__ = ParseError.prototype;
    self.position = start;

    if (start != null && end != null) {
      self.length = end - start;
    }

    self.rawMessage = message;
    return self;
  }

} // $FlowFixMe More hackery


ParseError.prototype.__proto__ = Error.prototype;
/* harmony default export */ var src_ParseError = (ParseError);
;// CONCATENATED MODULE: ./src/utils.js
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Return whether an element is contained in a list
 */
const contains = function (list, elem) {
  return list.indexOf(elem) !== -1;
};
/**
 * Provide a default value if a setting is undefined
 * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.
 */


const deflt = function (setting, defaultIfUndefined) {
  return setting === undefined ? defaultIfUndefined : setting;
}; // hyphenate and escape adapted from Facebook's React under Apache 2 license


const uppercase = /([A-Z])/g;

const hyphenate = function (str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};

const ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  "\"": "&quot;",
  "'": "&#x27;"
};
const ESCAPE_REGEX = /[&><"']/g;
/**
 * Escapes text to prevent scripting attacks.
 */

function utils_escape(text) {
  return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);
}
/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */


const getBaseElem = function (group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem(group.body);
  } else {
    return group;
  }
};
/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */


const isCharacterBox = function (group) {
  const baseElem = getBaseElem(group); // These are all they types of groups which hold single characters

  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};

const assert = function (value) {
  if (!value) {
    throw new Error('Expected non-null, but got ' + String(value));
  }

  return value;
};
/**
 * Return the protocol of a URL, or "_relative" if the URL does not specify a
 * protocol (and thus is relative), or `null` if URL has invalid protocol
 * (so should be outright rejected).
 */

const protocolFromUrl = function (url) {
  // Check for possible leading protocol.
  // https://url.spec.whatwg.org/#url-parsing strips leading whitespace
  // (U+20) or C0 control (U+00-U+1F) characters.
  // eslint-disable-next-line no-control-regex
  const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);

  if (!protocol) {
    return "_relative";
  } // Reject weird colons


  if (protocol[2] !== ":") {
    return null;
  } // Reject invalid characters in scheme according to
  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1


  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  } // Lowercase the protocol


  return protocol[1].toLowerCase();
};
/* harmony default export */ var utils = ({
  contains,
  deflt,
  escape: utils_escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
});
;// CONCATENATED MODULE: ./src/Settings.js
/* eslint no-console:0 */

/**
 * This is a module for storing settings passed into KaTeX. It correctly handles
 * default settings.
 */



// TODO: automatically generate documentation
// TODO: check all properties on Settings exist
// TODO: check the type of a property on Settings matches
const SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in " + "display style (so \\int and \\sum are large, for example), and " + "centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: true,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) ins" + "tead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' " + "(no #). This option determines the color of errors rendered by the " + "-t option.",
    cliProcessor: color => "#" + color
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use " + "multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (def, defs) => {
      defs.push(def);
      return defs;
    }
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines," + " `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, " + "`\\hdashline`, `\\underline`, `\\overline`, and the borders of " + "`\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: t => Math.max(0, t),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, " + "instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an " + "error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: false
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: Infinity,
    description: "If non-zero, all user-specified sizes, e.g. in " + "\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, " + "elements and spaces can be arbitrarily large",
    processor: s => Math.max(0, s),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1000,
    description: "Limit the number of macro expansions to the specified " + "number, to prevent e.g. infinite macro loops. If set to Infinity, " + "the macro expander will try to fully expand as in LaTeX.",
    processor: n => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: n => n === "Infinity" ? Infinity : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: false
  }
};

function getDefaultValue(schema) {
  if (schema.default) {
    return schema.default;
  }

  const type = schema.type;
  const defaultType = Array.isArray(type) ? type[0] : type;

  if (typeof defaultType !== 'string') {
    return defaultType.enum[0];
  }

  switch (defaultType) {
    case 'boolean':
      return false;

    case 'string':
      return '';

    case 'number':
      return 0;

    case 'object':
      return {};
  }
}
/**
 * The main Settings object
 *
 * The current options stored are:
 *  - displayMode: Whether the expression should be typeset as inline math
 *                 (false, the default), meaning that the math starts in
 *                 \textstyle and is placed in an inline-block); or as display
 *                 math (true), meaning that the math starts in \displaystyle
 *                 and is placed in a block with vertical margin.
 */


class Settings {
  constructor(options) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    // allow null options
    options = options || {};

    for (const prop in SETTINGS_SCHEMA) {
      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
        // $FlowFixMe
        const schema = SETTINGS_SCHEMA[prop]; // TODO: validate options
        // $FlowFixMe

        this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
      }
    }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */


  reportNonstrict(errorCode, errorMsg, token) {
    let strict = this.strict;

    if (typeof strict === "function") {
      // Allow return value of strict function to be boolean or string
      // (or null/undefined, meaning no further processing).
      strict = strict(errorCode, errorMsg, token);
    }

    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      // won't happen in type-safe code
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */


  useStrictBehavior(errorCode, errorMsg, token) {
    let strict = this.strict;

    if (typeof strict === "function") {
      // Allow return value of strict function to be boolean or string
      // (or null/undefined, meaning no further processing).
      // But catch any exceptions thrown by function, treating them
      // like "error".
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error) {
        strict = "error";
      }
    }

    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      // won't happen in type-safe code
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */


  isTrusted(context) {
    if (context.url && !context.protocol) {
      const protocol = utils.protocolFromUrl(context.url);

      if (protocol == null) {
        return false;
      }

      context.protocol = protocol;
    }

    const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }

}
;// CONCATENATED MODULE: ./src/Style.js
/**
 * This file contains information and classes for the various kinds of styles
 * used in TeX. It provides a generic `Style` class, which holds information
 * about a specific style. It then provides instances of all the different kinds
 * of styles possible, and provides functions to move between them and get
 * information about them.
 */

/**
 * The main style class. Contains a unique id for the style, a size (which is
 * the same for cramped and uncramped version of a style), and a cramped flag.
 */
class Style {
  constructor(id, size, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */


  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */


  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */


  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */


  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */


  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */


  text() {
    return styles[Style_text[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */


  isTight() {
    return this.size >= 2;
  }

} // Export an interface for type checking, but don't expose the implementation.
// This way, no more styles can be generated.


// IDs of the different styles
const D = 0;
const Dc = 1;
const T = 2;
const Tc = 3;
const S = 4;
const Sc = 5;
const SS = 6;
const SSc = 7; // Instances of the different styles

const styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another

const sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
const sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
const fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
const fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
const cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
const Style_text = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.

/* harmony default export */ var src_Style = ({
  DISPLAY: styles[D],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
});
;// CONCATENATED MODULE: ./src/unicodeScripts.js
/*
 * This file defines the Unicode scripts and script families that we
 * support. To add new scripts or families, just add a new entry to the
 * scriptData array below. Adding scripts to the scriptData array allows
 * characters from that script to appear in \text{} environments.
 */

/**
 * Each script or script family has a name and an array of blocks.
 * Each block is an array of two numbers which specify the start and
 * end points (inclusive) of a block of Unicode codepoints.
 */

/**
 * Unicode block data for the families of scripts we support in \text{}.
 * Scripts only need to appear here if they do not have font metrics.
 */
const scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: 'latin',
  blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B
  [0x0300, 0x036f] // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: 'cyrillic',
  blocks: [[0x0400, 0x04ff]]
}, {
  // Armenian
  name: 'armenian',
  blocks: [[0x0530, 0x058F]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: 'brahmic',
  blocks: [[0x0900, 0x109F]]
}, {
  name: 'georgian',
  blocks: [[0x10A0, 0x10ff]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana
  [0x4E00, 0x9FAF], // CJK ideograms
  [0xFF00, 0xFF60] // Fullwidth punctuation
  // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: 'hangul',
  blocks: [[0xAC00, 0xD7AF]]
}];
/**
 * Given a codepoint, return the name of the script or script family
 * it is from, or null if it is not part of a known block
 */

function scriptFromCodepoint(codepoint) {
  for (let i = 0; i < scriptData.length; i++) {
    const script = scriptData[i];

    for (let i = 0; i < script.blocks.length; i++) {
      const block = script.blocks[i];

      if (codepoint >= block[0] && codepoint <= block[1]) {
        return script.name;
      }
    }
  }

  return null;
}
/**
 * A flattened version of all the supported blocks in a single array.
 * This is an optimization to make supportedCodepoint() fast.
 */

const allBlocks = [];
scriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));
/**
 * Given a codepoint, return true if it falls within one of the
 * scripts or script families defined above and false otherwise.
 *
 * Micro benchmarks shows that this is faster than
 * /[\u3000-\u30FF\u4E00-\u9FAF\uFF00-\uFF60\uAC00-\uD7AF\u0900-\u109F]/.test()
 * in Firefox, Chrome and Node.
 */

function supportedCodepoint(codepoint) {
  for (let i = 0; i < allBlocks.length; i += 2) {
    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
      return true;
    }
  }

  return false;
}
;// CONCATENATED MODULE: ./src/svgGeometry.js
/**
 * This file provides support to domTree.js and delimiter.js.
 * It's a storehouse of path geometry for SVG images.
 */
// In all paths below, the viewBox-to-em scale is 1000:1.
const hLinePad = 80; // padding above a sqrt vinculum. Prevents image cropping.
// The vinculum of a \sqrt can be made thicker by a KaTeX rendering option.
// Think of variable extraVinculum as two detours in the SVG path.
// The detour begins at the lower left of the area labeled extraVinculum below.
// The detour proceeds one extraVinculum distance up and slightly to the right,
// displacing the radiused corner between surd and vinculum. The radius is
// traversed as usual, then the detour resumes. It goes right, to the end of
// the very long vinculum, then down one extraVinculum distance,
// after which it resumes regular path geometry for the radical.

/*                                                  vinculum
                                                   /
         /▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒←extraVinculum
        / █████████████████████←0.04em (40 unit) std vinculum thickness
       / /
      / /
     / /\
    / / surd
*/

const sqrtMain = function (extraVinculum, hLinePad) {
  // sqrtMain path geometry is from glyph U221A in the font KaTeX Main
  return "M95," + (622 + extraVinculum + hLinePad) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad + "h400000v" + (40 + extraVinculum) + "h-400000z";
};

const sqrtSize1 = function (extraVinculum, hLinePad) {
  // size1 is from glyph U221A in the font KaTeX_Size1-Regular
  return "M263," + (601 + extraVinculum + hLinePad) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad + "h400000v" + (40 + extraVinculum) + "h-400000z";
};

const sqrtSize2 = function (extraVinculum, hLinePad) {
  // size2 is from glyph U221A in the font KaTeX_Size2-Regular
  return "M983 " + (10 + extraVinculum + hLinePad) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad + "h400000v" + (40 + extraVinculum) + "h-400000z";
};

const sqrtSize3 = function (extraVinculum, hLinePad) {
  // size3 is from glyph U221A in the font KaTeX_Size3-Regular
  return "M424," + (2398 + extraVinculum + hLinePad) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
};

const sqrtSize4 = function (extraVinculum, hLinePad) {
  // size4 is from glyph U221A in the font KaTeX_Size4-Regular
  return "M473," + (2713 + extraVinculum + hLinePad) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad + "h400000v" + (40 + extraVinculum) + "H1017.7z";
};

const phasePath = function (y) {
  const x = y / 2; // x coordinate at top of angle

  return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
};

const sqrtTall = function (extraVinculum, hLinePad, viewBoxHeight) {
  // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular
  // One path edge has a variable length. It runs vertically from the vinculum
  // to a point near (14 units) the bottom of the surd. The vinculum
  // is normally 40 units thick. So the length of the line in question is:
  const vertSegment = viewBoxHeight - 54 - hLinePad - extraVinculum;
  return "M702 " + (extraVinculum + hLinePad) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad + "H400000v" + (40 + extraVinculum) + "H742z";
};

const sqrtPath = function (size, extraVinculum, viewBoxHeight) {
  extraVinculum = 1000 * extraVinculum; // Convert from document ems to viewBox.

  let path = "";

  switch (size) {
    case "sqrtMain":
      path = sqrtMain(extraVinculum, hLinePad);
      break;

    case "sqrtSize1":
      path = sqrtSize1(extraVinculum, hLinePad);
      break;

    case "sqrtSize2":
      path = sqrtSize2(extraVinculum, hLinePad);
      break;

    case "sqrtSize3":
      path = sqrtSize3(extraVinculum, hLinePad);
      break;

    case "sqrtSize4":
      path = sqrtSize4(extraVinculum, hLinePad);
      break;

    case "sqrtTall":
      path = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
  }

  return path;
};
const innerPath = function (name, height) {
  // The inner part of stretchy tall delimiters
  switch (name) {
    case "\u239c":
      return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";

    case "\u2223":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";

    case "\u2225":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");

    case "\u239f":
      return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";

    case "\u23a2":
      return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";

    case "\u23a5":
      return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";

    case "\u23aa":
      return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";

    case "\u23d0":
      return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";

    case "\u2016":
      return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");

    default:
      return "";
  }
};
const path = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
const tallDelim = function (label, midHeight) {
  switch (label) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";

    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";

    case "vert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";

    case "doublevert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";

    case "lfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";

    case "rfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";

    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";

    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";

    case "lparen":
      return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";

    case "rparen":
      return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";

    default:
      // We should not ever get here.
      throw new Error("Unknown stretchy delimiter.");
  }
};
;// CONCATENATED MODULE: ./src/tree.js


/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. It only contains
 * children and doesn't have any DOM node properties.
 */
class DocumentFragment {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /** Convert the fragment into a node. */


  toNode() {
    const frag = document.createDocumentFragment();

    for (let i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }

    return frag;
  }
  /** Convert the fragment into HTML markup. */


  toMarkup() {
    let markup = ""; // Simply concatenate the markup for the children together.

    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */


  toText() {
    // To avoid this, we would subclass documentFragment separately for
    // MathML, but polyfills for subclassing is expensive per PR 1469.
    // $FlowFixMe: Only works for ChildType = MathDomNode.
    const toText = child => child.toText();

    return this.children.map(toText).join("");
  }

}
;// CONCATENATED MODULE: ./src/fontMetricsData.js
// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.
/* harmony default export */ var fontMetricsData = ({
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1.0],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1.0],
    "8603": [-0.13313, 0.36687, 0, 0, 1.0],
    "8606": [0.01354, 0.52239, 0, 0, 1.0],
    "8608": [0.01354, 0.52239, 0, 0, 1.0],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1.0],
    "8620": [0, 0.54986, 0, 0, 1.0],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1.0],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1.0],
    "8631": [0, 0.43056, 0, 0, 1.0],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1.0],
    "8646": [0.1808, 0.675, 0, 0, 1.0],
    "8647": [0.1808, 0.675, 0, 0, 1.0],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1.0],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1.0],
    "8652": [0.01354, 0.52239, 0, 0, 1.0],
    "8653": [-0.13313, 0.36687, 0, 0, 1.0],
    "8654": [-0.13313, 0.36687, 0, 0, 1.0],
    "8655": [-0.13313, 0.36687, 0, 0, 1.0],
    "8666": [0.13667, 0.63667, 0, 0, 1.0],
    "8667": [0.13667, 0.63667, 0, 0, 1.0],
    "8669": [-0.13313, 0.37788, 0, 0, 1.0],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 0.00965, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [0.00222, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [0.00222, 0.50222, 0, 0, 0.89444],
    "8801": [0.00222, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1.0],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1.0],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1.0],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1.0],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1.0],
    "8599": [0.19444, 0.69444, 0, 0, 1.0],
    "8600": [0.19444, 0.69444, 0, 0, 1.0],
    "8601": [0.19444, 0.69444, 0, 0, 1.0],
    "8614": [0.011, 0.511, 0, 0, 1.0],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1.0],
    "8637": [-0.13313, 0.36687, 0, 0, 1.0],
    "8640": [-0.13313, 0.36687, 0, 0, 1.0],
    "8641": [-0.13313, 0.36687, 0, 0, 1.0],
    "8652": [0.011, 0.671, 0, 0, 1.0],
    "8656": [-0.13313, 0.36687, 0, 0, 1.0],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1.0],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1.0],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1.0],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1.0],
    "8811": [0.0391, 0.5391, 0, 0, 1.0],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [0.005, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1.0],
    "8995": [-0.14236, 0.35764, 0, 0, 1.0],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1.0],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 0.00421, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 0.0088, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 0.00316, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 0.00981, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1.0],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 0.00316, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1.0],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-0.00099, 0.601, 0, 0, 0.77778],
    "8593": [1e-05, 0.6, 0, 0, 0.66667],
    "8595": [1e-05, 0.6, 0, 0, 0.66667],
    "8657": [1e-05, 0.6, 0, 0, 0.77778],
    "8659": [1e-05, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1.0],
    "8739": [-0.00599, 0.606, 0, 0, 0.33333],
    "8741": [-0.00599, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-0.00099, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.0],
    "732": [0, 0.75, 0, 0, 1.0],
    "770": [0, 0.75, 0, 0, 1.0],
    "771": [0, 0.75, 0, 0, 1.0],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1.0],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1.0],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1.0],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-05, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-05, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-0.00099, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-0.00099, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-05, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-05, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-0.00499, 0.605, 0, 0, 1.05556],
    "57345": [-0.00499, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
});
;// CONCATENATED MODULE: ./src/fontMetrics.js


/**
 * This file contains metrics regarding fonts and individual symbols. The sigma
 * and xi variables, as well as the metricMap map contain data extracted from
 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
 * `metrics` variable and the getCharacterMetrics function.
 */
// In TeX, there are actually three sets of dimensions, one for each of
// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:
// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are
// provided in the arrays below, in that order.
//
// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respectively.
// This was determined by running the following script:
//
//     latex -interaction=nonstopmode \
//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
//     '$a$ \expandafter\show\the\textfont2' \
//     '\expandafter\show\the\scriptfont2' \
//     '\expandafter\show\the\scriptscriptfont2' \
//     '\stop'
//
// The metrics themselves were retrieved using the following commands:
//
//     tftopl cmsy10
//     tftopl cmsy7
//     tftopl cmsy5
//
// The output of each of these commands is quite lengthy.  The only part we
// care about is the FONTDIMEN section. Each value is measured in EMs.
const sigmasAndXis = {
  slant: [0.250, 0.250, 0.250],
  // sigma1
  space: [0.000, 0.000, 0.000],
  // sigma2
  stretch: [0.000, 0.000, 0.000],
  // sigma3
  shrink: [0.000, 0.000, 0.000],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1.000, 1.171, 1.472],
  // sigma6
  extraSpace: [0.000, 0.000, 0.000],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.150, 0.143, 0.200],
  // sigma16
  sub2: [0.247, 0.286, 0.400],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.050, 0.071, 0.100],
  // sigma19
  delim1: [2.390, 1.700, 1.980],
  // sigma20
  delim2: [1.010, 1.157, 1.420],
  // sigma21
  axisHeight: [0.250, 0.250, 0.250],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10.0, 10.0, 10.0],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm

}; // This map contains a mapping from font name and character code to character
// metrics, including height, depth, italic correction, and skew (kern from the
// character to the corresponding \skewchar)
// This map is generated via `make metrics`. It should not be changed manually.

 // These are very rough approximations.  We default to Times New Roman which
// should have Latin-1 and Cyrillic characters, but may not depending on the
// operating system.  The metrics do not account for extra height from the
// accents.  In the case of Cyrillic characters which have both ascenders and
// descenders we prefer approximations with ascenders, primarily to prevent
// the fraction bar or root line from intersecting the glyph.
// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.

const extraCharacterMap = {
  // Latin-1
  'Å': 'A',
  'Ð': 'D',
  'Þ': 'o',
  'å': 'a',
  'ð': 'd',
  'þ': 'o',
  // Cyrillic
  'А': 'A',
  'Б': 'B',
  'В': 'B',
  'Г': 'F',
  'Д': 'A',
  'Е': 'E',
  'Ж': 'K',
  'З': '3',
  'И': 'N',
  'Й': 'N',
  'К': 'K',
  'Л': 'N',
  'М': 'M',
  'Н': 'H',
  'О': 'O',
  'П': 'N',
  'Р': 'P',
  'С': 'C',
  'Т': 'T',
  'У': 'y',
  'Ф': 'O',
  'Х': 'X',
  'Ц': 'U',
  'Ч': 'h',
  'Ш': 'W',
  'Щ': 'W',
  'Ъ': 'B',
  'Ы': 'X',
  'Ь': 'B',
  'Э': '3',
  'Ю': 'X',
  'Я': 'R',
  'а': 'a',
  'б': 'b',
  'в': 'a',
  'г': 'r',
  'д': 'y',
  'е': 'e',
  'ж': 'm',
  'з': 'e',
  'и': 'n',
  'й': 'n',
  'к': 'n',
  'л': 'n',
  'м': 'm',
  'н': 'n',
  'о': 'o',
  'п': 'n',
  'р': 'p',
  'с': 'c',
  'т': 'o',
  'у': 'y',
  'ф': 'b',
  'х': 'x',
  'ц': 'n',
  'ч': 'n',
  'ш': 'w',
  'щ': 'w',
  'ъ': 'a',
  'ы': 'm',
  'ь': 'a',
  'э': 'e',
  'ю': 'm',
  'я': 'r'
};

/**
 * This function adds new font metrics to default metricMap
 * It can also override existing metrics
 */
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
/**
 * This function is a convenience function for looking up information in the
 * metricMap table. It takes a character as a string, and a font.
 *
 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
 * built using `Make extended_metrics`.
 */

function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }

  let ch = character.charCodeAt(0);
  let metrics = fontMetricsData[font][ch];

  if (!metrics && character[0] in extraCharacterMap) {
    ch = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }

  if (!metrics && mode === 'text') {
    // We don't typically have font metrics for Asian scripts.
    // But since we support them in text mode, we need to return
    // some sort of metrics.
    // So if the character is in a script we support but we
    // don't have metrics for it, just use the metrics for
    // the Latin capital letter M. This is close enough because
    // we (currently) only care about the height of the glyph
    // not its width.
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'
    }
  }

  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
const fontMetricsBySizeIndex = {};
/**
 * Get the font metrics for a given size.
 */

function getGlobalMetrics(size) {
  let sizeIndex;

  if (size >= 5) {
    sizeIndex = 0;
  } else if (size >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }

  if (!fontMetricsBySizeIndex[sizeIndex]) {
    const metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };

    for (const key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }

  return fontMetricsBySizeIndex[sizeIndex];
}
;// CONCATENATED MODULE: ./src/Options.js
/**
 * This file contains information about the options that the Parser carries
 * around with it while parsing. Data is held in an `Options` object, and when
 * recursing, a new `Options` object can be created with the `.with*` and
 * `.reset` functions.
 */

const sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].
// The size mappings are taken from TeX with \normalsize=10pt.
[1, 1, 1], // size1: [5, 5, 5]              \tiny
[2, 1, 1], // size2: [6, 5, 5]
[3, 1, 1], // size3: [7, 5, 5]              \scriptsize
[4, 2, 1], // size4: [8, 6, 5]              \footnotesize
[5, 2, 1], // size5: [9, 6, 5]              \small
[6, 3, 1], // size6: [10, 7, 5]             \normalsize
[7, 4, 2], // size7: [12, 8, 6]             \large
[8, 6, 3], // size8: [14.4, 10, 7]          \Large
[9, 7, 6], // size9: [17.28, 12, 10]        \LARGE
[10, 8, 7], // size10: [20.74, 14.4, 12]     \huge
[11, 10, 9] // size11: [24.88, 20.74, 17.28] \HUGE
];
const sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if
// you change size indexes, change that function.
0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];

const sizeAtStyle = function (size, style) {
  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
}; // In these types, "" (empty string) means "no change".


/**
 * This is the main options class. It contains the current style, size, color,
 * and font.
 *
 * Options objects should not be modified. To create a new Options with
 * different properties, call a `.having*` method.
 */
class Options {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm

  /**
   * The base size index.
   */
  constructor(data) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data.style;
    this.color = data.color;
    this.size = data.size || Options.BASESIZE;
    this.textSize = data.textSize || this.size;
    this.phantom = !!data.phantom;
    this.font = data.font || "";
    this.fontFamily = data.fontFamily || "";
    this.fontWeight = data.fontWeight || '';
    this.fontShape = data.fontShape || '';
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data.maxSize;
    this.minRuleThickness = data.minRuleThickness;
    this._fontMetrics = undefined;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */


  extend(extension) {
    const data = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };

    for (const key in extension) {
      if (extension.hasOwnProperty(key)) {
        data[key] = extension[key];
      }
    }

    return new Options(data);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */


  havingStyle(style) {
    if (this.style === style) {
      return this;
    } else {
      return this.extend({
        style: style,
        size: sizeAtStyle(this.textSize, style)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */


  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */


  havingSize(size) {
    if (this.size === size && this.textSize === size) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size: size,
        textSize: size,
        sizeMultiplier: sizeMultipliers[size - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */


  havingBaseStyle(style) {
    style = style || this.style.text();
    const wantSize = sizeAtStyle(Options.BASESIZE, style);

    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
      return this;
    } else {
      return this.extend({
        style: style,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */


  havingBaseSizing() {
    let size;

    switch (this.style.id) {
      case 4:
      case 5:
        size = 3; // normalsize in scriptstyle

        break;

      case 6:
      case 7:
        size = 1; // normalsize in scriptscriptstyle

        break;

      default:
        size = 6;
      // normalsize in textstyle or displaystyle
    }

    return this.extend({
      style: this.style.text(),
      size: size
    });
  }
  /**
   * Create a new options object with the given color.
   */


  withColor(color) {
    return this.extend({
      color: color
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */


  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */


  withFont(font) {
    return this.extend({
      font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */


  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */


  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */


  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */


  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */


  baseSizingClasses() {
    if (this.size !== Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */


  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }

    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */


  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }

}

Options.BASESIZE = 6;
/* harmony default export */ var src_Options = (Options);
;// CONCATENATED MODULE: ./src/units.js
/**
 * This file does conversion between units.  In particular, it provides
 * calculateSize to convert other units into ems.
 */

 // This table gives the number of TeX pts in one of each *absolute* TeX unit.
// Thus, multiplying a length by this number converts the length from units
// into pts.  Dividing the result by ptPerEm gives the number of ems
// *assuming* a font size of ptPerEm (normal size, normal style).

const ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800 // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX

}; // Dictionary of relative units, for fast validity testing.

const relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};

/**
 * Determine whether the specified unit (either a string defining the unit
 * or a "size" parse node containing a unit field) is valid.
 */
const validUnit = function (unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }

  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
/*
 * Convert a "size" parse node (with numeric "number" and string "unit" fields,
 * as parsed by functions.js argType "size") into a CSS em value for the
 * current style/scale.  `options` gives the current options.
 */

const calculateSize = function (sizeValue, options) {
  let scale;

  if (sizeValue.unit in ptPerUnit) {
    // Absolute units
    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt
    / options.fontMetrics().ptPerEm // Convert pt to CSS em
    / options.sizeMultiplier; // Unscale to make absolute units
  } else if (sizeValue.unit === "mu") {
    // `mu` units scale with scriptstyle/scriptscriptstyle.
    scale = options.fontMetrics().cssEmPerMu;
  } else {
    // Other relative units always refer to the *textstyle* font
    // in the current size.
    let unitOptions;

    if (options.style.isTight()) {
      // isTight() means current style is script/scriptscript.
      unitOptions = options.havingStyle(options.style.text());
    } else {
      unitOptions = options;
    } // TODO: In TeX these units are relative to the quad of the current
    // *text* font, e.g. cmr10. KaTeX instead uses values from the
    // comparably-sized *Computer Modern symbol* font. At 10pt, these
    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;
    // cmr5=1.361133, cmsy5=1.472241. Consider $\scriptsize a\kern1emb$.
    // TeX \showlists shows a kern of 1.13889 * fontsize;
    // KaTeX shows a kern of 1.171 * fontsize.


    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }

    if (unitOptions !== options) {
      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
    }
  }

  return Math.min(sizeValue.number * scale, options.maxSize);
};
/**
 * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. See
 * https://github.com/KaTeX/KaTeX/pull/2460.
 */

const makeEm = function (n) {
  return +n.toFixed(4) + "em";
};
;// CONCATENATED MODULE: ./src/domTree.js
/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 *
 * TODO: refactor `span` and `anchor` into common superclass when
 * target environments support class inheritance
 */







/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove empty classes.
 */
const createClass = function (classes) {
  return classes.filter(cls => cls).join(" ");
};

const initNode = function (classes, options, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style || {};

  if (options) {
    if (options.style.isTight()) {
      this.classes.push("mtight");
    }

    const color = options.getColor();

    if (color) {
      this.style.color = color;
    }
  }
};
/**
 * Convert into an HTML node
 */


const toNode = function (tagName) {
  const node = document.createElement(tagName); // Apply the class

  node.className = createClass(this.classes); // Apply inline styles

  for (const style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      // $FlowFixMe Flow doesn't seem to understand span.style's type.
      node.style[style] = this.style[style];
    }
  } // Apply attributes


  for (const attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  } // Append the children, also as HTML nodes


  for (let i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }

  return node;
};
/**
 * https://w3c.github.io/html-reference/syntax.html#syntax-attributes
 *
 * > Attribute Names must consist of one or more characters
 * other than the space characters, U+0000 NULL,
 * '"', "'", ">", "/", "=", the control characters,
 * and any characters that are not defined by Unicode.
 */


const invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
/**
 * Convert into an HTML markup string
 */

const toMarkup = function (tagName) {
  let markup = "<" + tagName; // Add the class

  if (this.classes.length) {
    markup += " class=\"" + utils.escape(createClass(this.classes)) + "\"";
  }

  let styles = ""; // Add the styles, after hyphenation

  for (const style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
    }
  }

  if (styles) {
    markup += " style=\"" + utils.escape(styles) + "\"";
  } // Add the attributes


  for (const attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      if (invalidAttributeNameRegex.test(attr)) {
        throw new src_ParseError("Invalid attribute name '" + attr + "'");
      }

      markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
    }
  }

  markup += ">"; // Add the markup of the children, also as markup

  for (let i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }

  markup += "</" + tagName + ">";
  return markup;
}; // Making the type below exact with all optional fields doesn't work due to
// - https://github.com/facebook/flow/issues/4582
// - https://github.com/facebook/flow/issues/5688
// However, since *all* fields are optional, $Shape<> works as suggested in 5688
// above.
// This type does not include all CSS properties. Additional properties should
// be added as needed.


/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style. It also contains information about its height, depth, and
 * maxFontSize.
 *
 * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan
 * otherwise. This typesafety is important when HTML builders access a span's
 * children.
 */
class Span {
  constructor(classes, children, options, style) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options, style);
    this.children = children || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */


  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }

  toNode() {
    return toNode.call(this, "span");
  }

  toMarkup() {
    return toMarkup.call(this, "span");
  }

}
/**
 * This node represents an anchor (<a>) element with a hyperlink.  See `span`
 * for further details.
 */

class Anchor {
  constructor(href, classes, children, options) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options);
    this.children = children || [];
    this.setAttribute('href', href);
  }

  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }

  toNode() {
    return toNode.call(this, "a");
  }

  toMarkup() {
    return toMarkup.call(this, "a");
  }

}
/**
 * This node represents an image embed (<img>) element.
 */

class Img {
  constructor(src, alt, style) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }

  toNode() {
    const node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord"; // Apply inline styles

    for (const style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        // $FlowFixMe
        node.style[style] = this.style[style];
      }
    }

    return node;
  }

  toMarkup() {
    let markup = "<img src=\"" + utils.escape(this.src) + "\"" + (" alt=\"" + utils.escape(this.alt) + "\""); // Add the styles, after hyphenation

    let styles = "";

    for (const style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }

    if (styles) {
      markup += " style=\"" + utils.escape(styles) + "\"";
    }

    markup += "'/>";
    return markup;
  }

}
const iCombinations = {
  'î': '\u0131\u0302',
  'ï': '\u0131\u0308',
  'í': '\u0131\u0301',
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  'ì': '\u0131\u0300'
};
/**
 * A symbol node contains information about a single symbol. It either renders
 * to a single text node, or a span with a single text node in it, depending on
 * whether it has CSS classes, styles, or needs italic correction.
 */

class SymbolNode {
  constructor(text, height, depth, italic, skew, width, classes, style) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we
    // can specify which fonts to use.  This allows us to render these
    // characters with a serif font in situations where the browser would
    // either default to a sans serif or render a placeholder character.
    // We use CSS class names like cjk_fallback, hangul_fallback and
    // brahmic_fallback. See ./unicodeScripts.js for the set of possible
    // script names

    const script = scriptFromCodepoint(this.text.charCodeAt(0));

    if (script) {
      this.classes.push(script + "_fallback");
    }

    if (/[îïíì]/.test(this.text)) {
      // add ī when we add Extended Latin
      this.text = iCombinations[this.text];
    }
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */


  toNode() {
    const node = document.createTextNode(this.text);
    let span = null;

    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }

    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }

    for (const style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        span = span || document.createElement("span"); // $FlowFixMe Flow doesn't seem to understand span.style's type.

        span.style[style] = this.style[style];
      }
    }

    if (span) {
      span.appendChild(node);
      return span;
    } else {
      return node;
    }
  }
  /**
   * Creates markup for a symbol node.
   */


  toMarkup() {
    // TODO(alpert): More duplication than I'd like from
    // span.prototype.toMarkup and symbolNode.prototype.toNode...
    let needsSpan = false;
    let markup = "<span";

    if (this.classes.length) {
      needsSpan = true;
      markup += " class=\"";
      markup += utils.escape(createClass(this.classes));
      markup += "\"";
    }

    let styles = "";

    if (this.italic > 0) {
      styles += "margin-right:" + this.italic + "em;";
    }

    for (const style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }

    if (styles) {
      needsSpan = true;
      markup += " style=\"" + utils.escape(styles) + "\"";
    }

    const escaped = utils.escape(this.text);

    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }

}
/**
 * SVG nodes are used to render stretchy wide elements.
 */

class SvgNode {
  constructor(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }

  toNode() {
    const svgNS = "http://www.w3.org/2000/svg";
    const node = document.createElementNS(svgNS, "svg"); // Apply attributes

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  }

  toMarkup() {
    let markup = "<svg xmlns=\"http://www.w3.org/2000/svg\""; // Apply attributes

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
      }
    }

    markup += ">";

    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</svg>";
    return markup;
  }

}
class PathNode {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate; // Used only for \sqrt, \phase, & tall delims
  }

  toNode() {
    const svgNS = "http://www.w3.org/2000/svg";
    const node = document.createElementNS(svgNS, "path");

    if (this.alternate) {
      node.setAttribute("d", this.alternate);
    } else {
      node.setAttribute("d", path[this.pathName]);
    }

    return node;
  }

  toMarkup() {
    if (this.alternate) {
      return "<path d=\"" + utils.escape(this.alternate) + "\"/>";
    } else {
      return "<path d=\"" + utils.escape(path[this.pathName]) + "\"/>";
    }
  }

}
class LineNode {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }

  toNode() {
    const svgNS = "http://www.w3.org/2000/svg";
    const node = document.createElementNS(svgNS, "line"); // Apply attributes

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    return node;
  }

  toMarkup() {
    let markup = "<line";

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
      }
    }

    markup += "/>";
    return markup;
  }

}
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
;// CONCATENATED MODULE: ./src/symbols.js
/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are three properties they can have:
 * - font (required): the font to be used for this symbol. Either "main" (the
     normal font), or "ams" (the ams fonts).
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */
// Some of these have a "-token" suffix since these are also used as `ParseNode`
// types for raw text tokens, and we want to avoid conflicts with higher-level
// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
// looking up the `symbols` map.
const ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
const NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
const symbols = {
  "math": {},
  "text": {}
};
/* harmony default export */ var src_symbols = (symbols);
/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */

function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font,
    group,
    replace
  };

  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
} // Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.
// modes:

const math = "math";
const symbols_text = "text"; // fonts:

const main = "main";
const ams = "ams"; // groups:

const accent = "accent-token";
const bin = "bin";
const symbols_close = "close";
const inner = "inner";
const mathord = "mathord";
const op = "op-token";
const symbols_open = "open";
const punct = "punct";
const rel = "rel";
const spacing = "spacing";
const textord = "textord"; // Now comes the symbol table
// Relation Symbols

defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
defineSymbol(math, main, rel, "\u227a", "\\prec", true);
defineSymbol(math, main, rel, "\u227b", "\\succ", true);
defineSymbol(math, main, rel, "\u223c", "\\sim", true);
defineSymbol(math, main, rel, "\u22a5", "\\perp");
defineSymbol(math, main, rel, "\u2aaf", "\\preceq", true);
defineSymbol(math, main, rel, "\u2ab0", "\\succeq", true);
defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
defineSymbol(math, main, rel, "\u2223", "\\mid", true);
defineSymbol(math, main, rel, "\u226a", "\\ll", true);
defineSymbol(math, main, rel, "\u226b", "\\gg", true);
defineSymbol(math, main, rel, "\u224d", "\\asymp", true);
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22c8", "\\bowtie", true);
defineSymbol(math, main, rel, "\u2323", "\\smile", true);
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
defineSymbol(math, main, rel, "\u2322", "\\frown", true);
defineSymbol(math, main, rel, "\u220b", "\\ni", true);
defineSymbol(math, main, rel, "\u221d", "\\propto", true);
defineSymbol(math, main, rel, "\u22a2", "\\vdash", true);
defineSymbol(math, main, rel, "\u22a3", "\\dashv", true);
defineSymbol(math, main, rel, "\u220b", "\\owns"); // Punctuation

defineSymbol(math, main, punct, "\u002e", "\\ldotp");
defineSymbol(math, main, punct, "\u22c5", "\\cdotp"); // Misc Symbols

defineSymbol(math, main, textord, "\u0023", "\\#");
defineSymbol(symbols_text, main, textord, "\u0023", "\\#");
defineSymbol(math, main, textord, "\u0026", "\\&");
defineSymbol(symbols_text, main, textord, "\u0026", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
defineSymbol(math, main, textord, "\u2200", "\\forall", true);
defineSymbol(math, main, textord, "\u210f", "\\hbar", true);
defineSymbol(math, main, textord, "\u2203", "\\exists", true);
defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
defineSymbol(math, main, textord, "\u266d", "\\flat", true);
defineSymbol(math, main, textord, "\u2113", "\\ell", true);
defineSymbol(math, main, textord, "\u266e", "\\natural", true);
defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, main, textord, "\u2118", "\\wp", true);
defineSymbol(math, main, textord, "\u266f", "\\sharp", true);
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, main, textord, "\u211c", "\\Re", true);
defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, main, textord, "\u2111", "\\Im", true);
defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, main, textord, "\u00a7", "\\S", true);
defineSymbol(symbols_text, main, textord, "\u00a7", "\\S");
defineSymbol(math, main, textord, "\u00b6", "\\P", true);
defineSymbol(symbols_text, main, textord, "\u00b6", "\\P"); // Math and Text

defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(symbols_text, main, textord, "\u2020", "\\dag");
defineSymbol(symbols_text, main, textord, "\u2020", "\\textdagger");
defineSymbol(math, main, textord, "\u2021", "\\ddag");
defineSymbol(symbols_text, main, textord, "\u2021", "\\ddag");
defineSymbol(symbols_text, main, textord, "\u2021", "\\textdaggerdbl"); // Large Delimiters

defineSymbol(math, main, symbols_close, "\u23b1", "\\rmoustache", true);
defineSymbol(math, main, symbols_open, "\u23b0", "\\lmoustache", true);
defineSymbol(math, main, symbols_close, "\u27ef", "\\rgroup", true);
defineSymbol(math, main, symbols_open, "\u27ee", "\\lgroup", true); // Binary Operators

defineSymbol(math, main, bin, "\u2213", "\\mp", true);
defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
defineSymbol(math, main, bin, "\u228e", "\\uplus", true);
defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, main, bin, "\u25ef", "\\bigcirc", true);
defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr", true);
defineSymbol(math, main, bin, "\u2a3f", "\\amalg");
defineSymbol(math, main, bin, "\u0026", "\\And"); // from amsmath
// Arrow Symbols

defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow", true);
defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow", true);
defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow", true);
defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow", true);
defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow", true);
defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow", true);
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow", true);
defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21a6", "\\mapsto", true);
defineSymbol(math, main, rel, "\u27fc", "\\longmapsto", true);
defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow", true);
defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow", true);
defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup", true);
defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup", true);
defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown", true);
defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown", true);
defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons", true); // AMS Negated Binary Relations

defineSymbol(math, ams, rel, "\u226e", "\\nless", true); // Symbol names preceded by "@" each have a corresponding macro.

defineSymbol(math, ams, rel, "\ue010", "\\@nleqslant");
defineSymbol(math, ams, rel, "\ue011", "\\@nleqq");
defineSymbol(math, ams, rel, "\u2a87", "\\lneq", true);
defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, ams, rel, "\ue00c", "\\@lvertneqq");
defineSymbol(math, ams, rel, "\u22e6", "\\lnsim", true);
defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox", true);
defineSymbol(math, ams, rel, "\u2280", "\\nprec", true); // unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u22e0", "\\npreceq", true);
defineSymbol(math, ams, rel, "\u22e8", "\\precnsim", true);
defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox", true);
defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
defineSymbol(math, ams, rel, "\ue006", "\\@nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
defineSymbol(math, ams, rel, "\u22ac", "\\nvdash", true);
defineSymbol(math, ams, rel, "\u22ad", "\\nvDash", true);
defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq", true);
defineSymbol(math, ams, rel, "\u228a", "\\subsetneq", true);
defineSymbol(math, ams, rel, "\ue01a", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq", true);
defineSymbol(math, ams, rel, "\ue017", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "\u226f", "\\ngtr", true);
defineSymbol(math, ams, rel, "\ue00f", "\\@ngeqslant");
defineSymbol(math, ams, rel, "\ue00e", "\\@ngeqq");
defineSymbol(math, ams, rel, "\u2a88", "\\gneq", true);
defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, ams, rel, "\ue00d", "\\@gvertneqq");
defineSymbol(math, ams, rel, "\u22e7", "\\gnsim", true);
defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox", true);
defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true); // unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq", true);
defineSymbol(math, ams, rel, "\u22e9", "\\succnsim", true);
defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox", true); // unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
defineSymbol(math, ams, rel, "\ue007", "\\@nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, ams, rel, "\u22af", "\\nVDash", true);
defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq", true);
defineSymbol(math, ams, rel, "\ue018", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "\u228b", "\\supsetneq", true);
defineSymbol(math, ams, rel, "\ue01b", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq", true);
defineSymbol(math, ams, rel, "\ue019", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "\u22ae", "\\nVdash", true);
defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq", true);
defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq", true);
defineSymbol(math, ams, rel, "\ue016", "\\@nsubseteqq");
defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22b5", "\\unrhd"); // AMS Negated Arrows

defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow", true);
defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow", true);
defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow", true);
defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow", true);
defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow", true);
defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow", true); // AMS Misc

defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210f", "\\hslash");
defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
defineSymbol(symbols_text, ams, textord, "\u00ae", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, ams, textord, "\u2201", "\\complement", true); // unicode-math maps U+F0 to \matheth. We map to AMS function \eth

defineSymbol(math, ams, textord, "\u00f0", "\\eth", true);
defineSymbol(symbols_text, main, textord, "\u00f0", "\u00f0");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25a1", "\\square");
defineSymbol(math, ams, textord, "\u25a1", "\\Box");
defineSymbol(math, ams, textord, "\u25ca", "\\Diamond"); // unicode-math maps U+A5 to \mathyen. We map to AMS function \yen

defineSymbol(math, ams, textord, "\u00a5", "\\yen", true);
defineSymbol(symbols_text, ams, textord, "\u00a5", "\\yen", true);
defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
defineSymbol(symbols_text, ams, textord, "\u2713", "\\checkmark"); // AMS Hebrew

defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
defineSymbol(math, ams, textord, "\u2137", "\\gimel", true); // AMS Greek

defineSymbol(math, ams, textord, "\u03dd", "\\digamma", true);
defineSymbol(math, ams, textord, "\u03f0", "\\varkappa"); // AMS Delimiters

defineSymbol(math, ams, symbols_open, "\u250c", "\\@ulcorner", true);
defineSymbol(math, ams, symbols_close, "\u2510", "\\@urcorner", true);
defineSymbol(math, ams, symbols_open, "\u2514", "\\@llcorner", true);
defineSymbol(math, ams, symbols_close, "\u2518", "\\@lrcorner", true); // AMS Binary Relations

defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant", true);
defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless", true);
defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox", true);
defineSymbol(math, ams, rel, "\u224a", "\\approxeq", true);
defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22d8", "\\lll", true);
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr", true);
defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr", true);
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, ams, rel, "\u223d", "\\backsim", true);
defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq", true);
defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq", true);
defineSymbol(math, ams, rel, "\u22d0", "\\Subset", true);
defineSymbol(math, ams, rel, "\u228f", "\\sqsubset", true);
defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq", true);
defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec", true);
defineSymbol(math, ams, rel, "\u227e", "\\precsim", true);
defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox", true);
defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22a8", "\\vDash", true);
defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash", true);
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224f", "\\bumpeq", true);
defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq", true);
defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant", true);
defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr", true);
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox", true);
defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22d9", "\\ggg", true);
defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, ams, rel, "\u22db", "\\gtreqless", true);
defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless", true);
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
defineSymbol(math, ams, rel, "\u225c", "\\triangleq", true);
defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq", true);
defineSymbol(math, ams, rel, "\u22d1", "\\Supset", true);
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq", true);
defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc", true);
defineSymbol(math, ams, rel, "\u227f", "\\succsim", true);
defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox", true);
defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22a9", "\\Vdash", true);
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226c", "\\between", true);
defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork", true);
defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft"); // unicode-math says that \therefore is a mathord atom.
// We kept the amssymb atom type, which is rel.

defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright"); // unicode-math says that \because is a mathord atom.
// We kept the amssymb atom type, which is rel.

defineSymbol(math, ams, rel, "\u2235", "\\because", true);
defineSymbol(math, ams, rel, "\u22d8", "\\llless");
defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, main, rel, "\u22c8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true); // AMS Binary Operators

defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22d2", "\\Cap", true);
defineSymbol(math, ams, bin, "\u22d3", "\\Cup", true);
defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge", true);
defineSymbol(math, ams, bin, "\u229f", "\\boxminus", true);
defineSymbol(math, ams, bin, "\u229e", "\\boxplus", true);
defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes", true);
defineSymbol(math, ams, bin, "\u22c9", "\\ltimes", true);
defineSymbol(math, ams, bin, "\u22ca", "\\rtimes", true);
defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes", true);
defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes", true);
defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge", true);
defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee", true);
defineSymbol(math, ams, bin, "\u229d", "\\circleddash", true);
defineSymbol(math, ams, bin, "\u229b", "\\circledast", true);
defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22ba", "\\intercal", true);
defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes", true); // AMS Arrows
// Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
// We'll map it to AMS function \dashrightarrow. It produces the same atom.

defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow", true); // unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow", true);
defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows", true);
defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows", true);
defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow", true);
defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow", true);
defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail", true);
defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft", true);
defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons", true);
defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft", true); // unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft", true);
defineSymbol(math, ams, rel, "\u21b0", "\\Lsh", true);
defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows", true);
defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft", true);
defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft", true);
defineSymbol(math, main, rel, "\u22b6", "\\origof", true); // not in font

defineSymbol(math, main, rel, "\u22b7", "\\imageof", true); // not in font

defineSymbol(math, ams, rel, "\u22b8", "\\multimap", true);
defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows", true);
defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows", true);
defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow", true);
defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail", true);
defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright", true);
defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright", true); // unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright", true);
defineSymbol(math, ams, rel, "\u21b1", "\\Rsh", true);
defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows", true);
defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright", true);
defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright", true);
defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow", true);
defineSymbol(math, ams, rel, "\u21be", "\\restriction");
defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(symbols_text, main, textord, "$", "\\$");
defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(symbols_text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(symbols_text, main, textord, "_", "\\_");
defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
defineSymbol(math, main, textord, "\u2220", "\\angle", true);
defineSymbol(math, main, textord, "\u221e", "\\infty", true);
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25b3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
defineSymbol(math, main, textord, "\u039b", "\\Lambda", true);
defineSymbol(math, main, textord, "\u039e", "\\Xi", true);
defineSymbol(math, main, textord, "\u03a0", "\\Pi", true);
defineSymbol(math, main, textord, "\u03a3", "\\Sigma", true);
defineSymbol(math, main, textord, "\u03a5", "\\Upsilon", true);
defineSymbol(math, main, textord, "\u03a6", "\\Phi", true);
defineSymbol(math, main, textord, "\u03a8", "\\Psi", true);
defineSymbol(math, main, textord, "\u03a9", "\\Omega", true);
defineSymbol(math, main, textord, "A", "\u0391");
defineSymbol(math, main, textord, "B", "\u0392");
defineSymbol(math, main, textord, "E", "\u0395");
defineSymbol(math, main, textord, "Z", "\u0396");
defineSymbol(math, main, textord, "H", "\u0397");
defineSymbol(math, main, textord, "I", "\u0399");
defineSymbol(math, main, textord, "K", "\u039A");
defineSymbol(math, main, textord, "M", "\u039C");
defineSymbol(math, main, textord, "N", "\u039D");
defineSymbol(math, main, textord, "O", "\u039F");
defineSymbol(math, main, textord, "P", "\u03A1");
defineSymbol(math, main, textord, "T", "\u03A4");
defineSymbol(math, main, textord, "X", "\u03A7");
defineSymbol(math, main, textord, "\u00ac", "\\neg", true);
defineSymbol(math, main, textord, "\u00ac", "\\lnot");
defineSymbol(math, main, textord, "\u22a4", "\\top");
defineSymbol(math, main, textord, "\u22a5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03b1", "\\alpha", true);
defineSymbol(math, main, mathord, "\u03b2", "\\beta", true);
defineSymbol(math, main, mathord, "\u03b3", "\\gamma", true);
defineSymbol(math, main, mathord, "\u03b4", "\\delta", true);
defineSymbol(math, main, mathord, "\u03f5", "\\epsilon", true);
defineSymbol(math, main, mathord, "\u03b6", "\\zeta", true);
defineSymbol(math, main, mathord, "\u03b7", "\\eta", true);
defineSymbol(math, main, mathord, "\u03b8", "\\theta", true);
defineSymbol(math, main, mathord, "\u03b9", "\\iota", true);
defineSymbol(math, main, mathord, "\u03ba", "\\kappa", true);
defineSymbol(math, main, mathord, "\u03bb", "\\lambda", true);
defineSymbol(math, main, mathord, "\u03bc", "\\mu", true);
defineSymbol(math, main, mathord, "\u03bd", "\\nu", true);
defineSymbol(math, main, mathord, "\u03be", "\\xi", true);
defineSymbol(math, main, mathord, "\u03bf", "\\omicron", true);
defineSymbol(math, main, mathord, "\u03c0", "\\pi", true);
defineSymbol(math, main, mathord, "\u03c1", "\\rho", true);
defineSymbol(math, main, mathord, "\u03c3", "\\sigma", true);
defineSymbol(math, main, mathord, "\u03c4", "\\tau", true);
defineSymbol(math, main, mathord, "\u03c5", "\\upsilon", true);
defineSymbol(math, main, mathord, "\u03d5", "\\phi", true);
defineSymbol(math, main, mathord, "\u03c7", "\\chi", true);
defineSymbol(math, main, mathord, "\u03c8", "\\psi", true);
defineSymbol(math, main, mathord, "\u03c9", "\\omega", true);
defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon", true);
defineSymbol(math, main, mathord, "\u03d1", "\\vartheta", true);
defineSymbol(math, main, mathord, "\u03d6", "\\varpi", true);
defineSymbol(math, main, mathord, "\u03f1", "\\varrho", true);
defineSymbol(math, main, mathord, "\u03c2", "\\varsigma", true);
defineSymbol(math, main, mathord, "\u03c6", "\\varphi", true);
defineSymbol(math, main, bin, "\u2217", "*", true);
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-", true);
defineSymbol(math, main, bin, "\u22c5", "\\cdot", true);
defineSymbol(math, main, bin, "\u2218", "\\circ", true);
defineSymbol(math, main, bin, "\u00f7", "\\div", true);
defineSymbol(math, main, bin, "\u00b1", "\\pm", true);
defineSymbol(math, main, bin, "\u00d7", "\\times", true);
defineSymbol(math, main, bin, "\u2229", "\\cap", true);
defineSymbol(math, main, bin, "\u222a", "\\cup", true);
defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
defineSymbol(math, main, bin, "\u2228", "\\vee", true);
defineSymbol(math, main, textord, "\u221a", "\\surd");
defineSymbol(math, main, symbols_open, "\u27e8", "\\langle", true);
defineSymbol(math, main, symbols_open, "\u2223", "\\lvert");
defineSymbol(math, main, symbols_open, "\u2225", "\\lVert");
defineSymbol(math, main, symbols_close, "?", "?");
defineSymbol(math, main, symbols_close, "!", "!");
defineSymbol(math, main, symbols_close, "\u27e9", "\\rangle", true);
defineSymbol(math, main, symbols_close, "\u2223", "\\rvert");
defineSymbol(math, main, symbols_close, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx", true);
defineSymbol(math, main, rel, "\u2245", "\\cong", true);
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq", true);
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt", true);
defineSymbol(math, main, rel, "\u2208", "\\in", true);
defineSymbol(math, main, rel, "\ue020", "\\@not");
defineSymbol(math, main, rel, "\u2282", "\\subset", true);
defineSymbol(math, main, rel, "\u2283", "\\supset", true);
defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, main, rel, "\u22a8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq", true);
defineSymbol(math, main, rel, "<", "\\lt", true);
defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
defineSymbol(math, main, spacing, "\u00a0", "\\ ");
defineSymbol(math, main, spacing, "\u00a0", "\\space"); // Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%

defineSymbol(math, main, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(symbols_text, main, spacing, "\u00a0", "\\ ");
defineSymbol(symbols_text, main, spacing, "\u00a0", " ");
defineSymbol(symbols_text, main, spacing, "\u00a0", "\\space");
defineSymbol(symbols_text, main, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(math, main, spacing, null, "\\nobreak");
defineSymbol(math, main, spacing, null, "\\allowbreak");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, ams, bin, "\u22bc", "\\barwedge", true);
defineSymbol(math, ams, bin, "\u22bb", "\\veebar", true);
defineSymbol(math, main, bin, "\u2299", "\\odot", true);
defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
defineSymbol(math, main, textord, "\u2202", "\\partial", true);
defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
defineSymbol(math, ams, bin, "\u229a", "\\circledcirc", true);
defineSymbol(math, ams, bin, "\u22a1", "\\boxdot", true);
defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22c4", "\\diamond");
defineSymbol(math, main, bin, "\u22c6", "\\star");
defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
defineSymbol(math, main, symbols_open, "{", "\\{");
defineSymbol(symbols_text, main, textord, "{", "\\{");
defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
defineSymbol(math, main, symbols_close, "}", "\\}");
defineSymbol(symbols_text, main, textord, "}", "\\}");
defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
defineSymbol(math, main, symbols_open, "{", "\\lbrace");
defineSymbol(math, main, symbols_close, "}", "\\rbrace");
defineSymbol(math, main, symbols_open, "[", "\\lbrack", true);
defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
defineSymbol(math, main, symbols_close, "]", "\\rbrack", true);
defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
defineSymbol(math, main, symbols_open, "(", "\\lparen", true);
defineSymbol(math, main, symbols_close, ")", "\\rparen", true);
defineSymbol(symbols_text, main, textord, "<", "\\textless", true); // in T1 fontenc

defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true); // in T1 fontenc

defineSymbol(math, main, symbols_open, "\u230a", "\\lfloor", true);
defineSymbol(math, main, symbols_close, "\u230b", "\\rfloor", true);
defineSymbol(math, main, symbols_open, "\u2308", "\\lceil", true);
defineSymbol(math, main, symbols_close, "\u2309", "\\rceil", true);
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(symbols_text, main, textord, "|", "\\textbar", true); // in T1 fontenc

defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(symbols_text, main, textord, "\u2225", "\\textbardbl");
defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, main, rel, "\u21d1", "\\Uparrow", true);
defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, main, rel, "\u21d3", "\\Downarrow", true);
defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow", true);
defineSymbol(math, main, op, "\u2210", "\\coprod");
defineSymbol(math, main, op, "\u22c1", "\\bigvee");
defineSymbol(math, main, op, "\u22c0", "\\bigwedge");
defineSymbol(math, main, op, "\u2a04", "\\biguplus");
defineSymbol(math, main, op, "\u22c2", "\\bigcap");
defineSymbol(math, main, op, "\u22c3", "\\bigcup");
defineSymbol(math, main, op, "\u222b", "\\int");
defineSymbol(math, main, op, "\u222b", "\\intop");
defineSymbol(math, main, op, "\u222c", "\\iint");
defineSymbol(math, main, op, "\u222d", "\\iiint");
defineSymbol(math, main, op, "\u220f", "\\prod");
defineSymbol(math, main, op, "\u2211", "\\sum");
defineSymbol(math, main, op, "\u2a02", "\\bigotimes");
defineSymbol(math, main, op, "\u2a01", "\\bigoplus");
defineSymbol(math, main, op, "\u2a00", "\\bigodot");
defineSymbol(math, main, op, "\u222e", "\\oint");
defineSymbol(math, main, op, "\u222f", "\\oiint");
defineSymbol(math, main, op, "\u2230", "\\oiiint");
defineSymbol(math, main, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, main, op, "\u222b", "\\smallint");
defineSymbol(symbols_text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(symbols_text, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u22ef", "\\@cdots", true);
defineSymbol(math, main, inner, "\u22f1", "\\ddots", true); // \vdots is a macro that uses one of these two symbols (with made-up names):

defineSymbol(math, main, textord, "\u22ee", "\\varvdots");
defineSymbol(symbols_text, main, textord, "\u22ee", "\\varvdots");
defineSymbol(math, main, accent, "\u02ca", "\\acute");
defineSymbol(math, main, accent, "\u02cb", "\\grave");
defineSymbol(math, main, accent, "\u00a8", "\\ddot");
defineSymbol(math, main, accent, "\u007e", "\\tilde");
defineSymbol(math, main, accent, "\u02c9", "\\bar");
defineSymbol(math, main, accent, "\u02d8", "\\breve");
defineSymbol(math, main, accent, "\u02c7", "\\check");
defineSymbol(math, main, accent, "\u005e", "\\hat");
defineSymbol(math, main, accent, "\u20d7", "\\vec");
defineSymbol(math, main, accent, "\u02d9", "\\dot");
defineSymbol(math, main, accent, "\u02da", "\\mathring"); // \imath and \jmath should be invariant to \mathrm, \mathbf, etc., so use PUA

defineSymbol(math, main, mathord, "\ue131", "\\@imath");
defineSymbol(math, main, mathord, "\ue237", "\\@jmath");
defineSymbol(math, main, textord, "\u0131", "\u0131");
defineSymbol(math, main, textord, "\u0237", "\u0237");
defineSymbol(symbols_text, main, textord, "\u0131", "\\i", true);
defineSymbol(symbols_text, main, textord, "\u0237", "\\j", true);
defineSymbol(symbols_text, main, textord, "\u00df", "\\ss", true);
defineSymbol(symbols_text, main, textord, "\u00e6", "\\ae", true);
defineSymbol(symbols_text, main, textord, "\u0153", "\\oe", true);
defineSymbol(symbols_text, main, textord, "\u00f8", "\\o", true);
defineSymbol(symbols_text, main, textord, "\u00c6", "\\AE", true);
defineSymbol(symbols_text, main, textord, "\u0152", "\\OE", true);
defineSymbol(symbols_text, main, textord, "\u00d8", "\\O", true);
defineSymbol(symbols_text, main, accent, "\u02ca", "\\'"); // acute

defineSymbol(symbols_text, main, accent, "\u02cb", "\\`"); // grave

defineSymbol(symbols_text, main, accent, "\u02c6", "\\^"); // circumflex

defineSymbol(symbols_text, main, accent, "\u02dc", "\\~"); // tilde

defineSymbol(symbols_text, main, accent, "\u02c9", "\\="); // macron

defineSymbol(symbols_text, main, accent, "\u02d8", "\\u"); // breve

defineSymbol(symbols_text, main, accent, "\u02d9", "\\."); // dot above

defineSymbol(symbols_text, main, accent, "\u00b8", "\\c"); // cedilla

defineSymbol(symbols_text, main, accent, "\u02da", "\\r"); // ring above

defineSymbol(symbols_text, main, accent, "\u02c7", "\\v"); // caron

defineSymbol(symbols_text, main, accent, "\u00a8", '\\"'); // diaresis

defineSymbol(symbols_text, main, accent, "\u02dd", "\\H"); // double acute

defineSymbol(symbols_text, main, accent, "\u25ef", "\\textcircled"); // \bigcirc glyph
// These ligatures are detected and created in Parser.js's `formLigatures`.

const ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(symbols_text, main, textord, "\u2013", "--", true);
defineSymbol(symbols_text, main, textord, "\u2013", "\\textendash");
defineSymbol(symbols_text, main, textord, "\u2014", "---", true);
defineSymbol(symbols_text, main, textord, "\u2014", "\\textemdash");
defineSymbol(symbols_text, main, textord, "\u2018", "`", true);
defineSymbol(symbols_text, main, textord, "\u2018", "\\textquoteleft");
defineSymbol(symbols_text, main, textord, "\u2019", "'", true);
defineSymbol(symbols_text, main, textord, "\u2019", "\\textquoteright");
defineSymbol(symbols_text, main, textord, "\u201c", "``", true);
defineSymbol(symbols_text, main, textord, "\u201c", "\\textquotedblleft");
defineSymbol(symbols_text, main, textord, "\u201d", "''", true);
defineSymbol(symbols_text, main, textord, "\u201d", "\\textquotedblright"); //  \degree from gensymb package

defineSymbol(math, main, textord, "\u00b0", "\\degree", true);
defineSymbol(symbols_text, main, textord, "\u00b0", "\\degree"); // \textdegree from inputenc package

defineSymbol(symbols_text, main, textord, "\u00b0", "\\textdegree", true); // TODO: In LaTeX, \pounds can generate a different character in text and math
// mode, but among our fonts, only Main-Regular defines this character "163".

defineSymbol(math, main, textord, "\u00a3", "\\pounds");
defineSymbol(math, main, textord, "\u00a3", "\\mathsterling", true);
defineSymbol(symbols_text, main, textord, "\u00a3", "\\pounds");
defineSymbol(symbols_text, main, textord, "\u00a3", "\\textsterling", true);
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(symbols_text, ams, textord, "\u2720", "\\maltese"); // There are lots of symbols which are the same, so we add them in afterwards.
// All of these are textords in math mode

const mathTextSymbols = "0123456789/@.\"";

for (let i = 0; i < mathTextSymbols.length; i++) {
  const ch = mathTextSymbols.charAt(i);
  defineSymbol(math, main, textord, ch, ch);
} // All of these are textords in text mode


const textSymbols = "0123456789!@*()-=+\";:?/.,";

for (let i = 0; i < textSymbols.length; i++) {
  const ch = textSymbols.charAt(i);
  defineSymbol(symbols_text, main, textord, ch, ch);
} // All of these are textords in text mode, and mathords in math mode


const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

for (let i = 0; i < letters.length; i++) {
  const ch = letters.charAt(i);
  defineSymbol(math, main, mathord, ch, ch);
  defineSymbol(symbols_text, main, textord, ch, ch);
} // Blackboard bold and script letters in Unicode range


defineSymbol(math, ams, textord, "C", "\u2102"); // blackboard bold

defineSymbol(symbols_text, ams, textord, "C", "\u2102");
defineSymbol(math, ams, textord, "H", "\u210D");
defineSymbol(symbols_text, ams, textord, "H", "\u210D");
defineSymbol(math, ams, textord, "N", "\u2115");
defineSymbol(symbols_text, ams, textord, "N", "\u2115");
defineSymbol(math, ams, textord, "P", "\u2119");
defineSymbol(symbols_text, ams, textord, "P", "\u2119");
defineSymbol(math, ams, textord, "Q", "\u211A");
defineSymbol(symbols_text, ams, textord, "Q", "\u211A");
defineSymbol(math, ams, textord, "R", "\u211D");
defineSymbol(symbols_text, ams, textord, "R", "\u211D");
defineSymbol(math, ams, textord, "Z", "\u2124");
defineSymbol(symbols_text, ams, textord, "Z", "\u2124");
defineSymbol(math, main, mathord, "h", "\u210E"); // italic h, Planck constant

defineSymbol(symbols_text, main, mathord, "h", "\u210E"); // The next loop loads wide (surrogate pair) characters.
// We support some letters in the Unicode range U+1D400 to U+1D7FF,
// Mathematical Alphanumeric Symbols.
// Some editors do not deal well with wide characters. So don't write the
// string into this file. Instead, create the string from the surrogate pair.

let wideChar = "";

for (let i = 0; i < letters.length; i++) {
  const ch = letters.charAt(i); // The hex numbers in the next line are a surrogate pair.
  // 0xD835 is the high surrogate for all letters in the range we support.
  // 0xDC00 is the low surrogate for bold A.

  wideChar = String.fromCharCode(0xD835, 0xDC00 + i); // A-Z a-z bold

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDC34 + i); // A-Z a-z italic

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDC68 + i); // A-Z a-z bold italic

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDD04 + i); // A-Z a-z Fraktur

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDD6C + i); // A-Z a-z bold Fraktur

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDDA0 + i); // A-Z a-z sans-serif

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDDD4 + i); // A-Z a-z sans bold

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDE08 + i); // A-Z a-z sans italic

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDE70 + i); // A-Z a-z monospace

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);

  if (i < 26) {
    // KaTeX fonts have only capital letters for blackboard bold and script.
    // See exception for k below.
    wideChar = String.fromCharCode(0xD835, 0xDD38 + i); // A-Z double struck

    defineSymbol(math, main, mathord, ch, wideChar);
    defineSymbol(symbols_text, main, textord, ch, wideChar);
    wideChar = String.fromCharCode(0xD835, 0xDC9C + i); // A-Z script

    defineSymbol(math, main, mathord, ch, wideChar);
    defineSymbol(symbols_text, main, textord, ch, wideChar);
  } // TODO: Add bold script when it is supported by a KaTeX font.

} // "k" is the only double struck lower case letter in the KaTeX fonts.


wideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck

defineSymbol(math, main, mathord, "k", wideChar);
defineSymbol(symbols_text, main, textord, "k", wideChar); // Next, some wide character numerals

for (let i = 0; i < 10; i++) {
  const ch = i.toString();
  wideChar = String.fromCharCode(0xD835, 0xDFCE + i); // 0-9 bold

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDFE2 + i); // 0-9 sans serif

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDFEC + i); // 0-9 bold sans

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDFF6 + i); // 0-9 monospace

  defineSymbol(math, main, mathord, ch, wideChar);
  defineSymbol(symbols_text, main, textord, ch, wideChar);
} // We add these Latin-1 letters as symbols for backwards-compatibility,
// but they are not actually in the font, nor are they supported by the
// Unicode accent mechanism, so they fall back to Times font and look ugly.
// TODO(edemaine): Fix this.


const extraLatin = "\u00d0\u00de\u00fe";

for (let i = 0; i < extraLatin.length; i++) {
  const ch = extraLatin.charAt(i);
  defineSymbol(math, main, mathord, ch, ch);
  defineSymbol(symbols_text, main, textord, ch, ch);
}
;// CONCATENATED MODULE: ./src/wide-character.js
/**
 * This file provides support for Unicode range U+1D400 to U+1D7FF,
 * Mathematical Alphanumeric Symbols.
 *
 * Function wideCharacterFont takes a wide character as input and returns
 * the font information necessary to render it properly.
 */

/**
 * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf
 * That document sorts characters into groups by font type, say bold or italic.
 *
 * In the arrays below, each subarray consists three elements:
 *      * The CSS class of that group when in math mode.
 *      * The CSS class of that group when in text mode.
 *      * The font name, so that KaTeX can get font metrics.
 */

const wideLatinLetterData = [["mathbf", "textbf", "Main-Bold"], // A-Z bold upright
["mathbf", "textbf", "Main-Bold"], // a-z bold upright
["mathnormal", "textit", "Math-Italic"], // A-Z italic
["mathnormal", "textit", "Math-Italic"], // a-z italic
["boldsymbol", "boldsymbol", "Main-BoldItalic"], // A-Z bold italic
["boldsymbol", "boldsymbol", "Main-BoldItalic"], // a-z bold italic
// Map fancy A-Z letters to script, not calligraphic.
// This aligns with unicode-math and math fonts (except Cambria Math).
["mathscr", "textscr", "Script-Regular"], // A-Z script
["", "", ""], // a-z script.  No font
["", "", ""], // A-Z bold script. No font
["", "", ""], // a-z bold script. No font
["mathfrak", "textfrak", "Fraktur-Regular"], // A-Z Fraktur
["mathfrak", "textfrak", "Fraktur-Regular"], // a-z Fraktur
["mathbb", "textbb", "AMS-Regular"], // A-Z double-struck
["mathbb", "textbb", "AMS-Regular"], // k double-struck
// Note that we are using a bold font, but font metrics for regular Fraktur.
["mathboldfrak", "textboldfrak", "Fraktur-Regular"], // A-Z bold Fraktur
["mathboldfrak", "textboldfrak", "Fraktur-Regular"], // a-z bold Fraktur
["mathsf", "textsf", "SansSerif-Regular"], // A-Z sans-serif
["mathsf", "textsf", "SansSerif-Regular"], // a-z sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // A-Z bold sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // a-z bold sans-serif
["mathitsf", "textitsf", "SansSerif-Italic"], // A-Z italic sans-serif
["mathitsf", "textitsf", "SansSerif-Italic"], // a-z italic sans-serif
["", "", ""], // A-Z bold italic sans. No font
["", "", ""], // a-z bold italic sans. No font
["mathtt", "texttt", "Typewriter-Regular"], // A-Z monospace
["mathtt", "texttt", "Typewriter-Regular"] // a-z monospace
];
const wideNumeralData = [["mathbf", "textbf", "Main-Bold"], // 0-9 bold
["", "", ""], // 0-9 double-struck. No KaTeX font.
["mathsf", "textsf", "SansSerif-Regular"], // 0-9 sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // 0-9 bold sans-serif
["mathtt", "texttt", "Typewriter-Regular"] // 0-9 monospace
];
const wideCharacterFont = function (wideChar, mode) {
  // IE doesn't support codePointAt(). So work with the surrogate pair.
  const H = wideChar.charCodeAt(0); // high surrogate

  const L = wideChar.charCodeAt(1); // low surrogate

  const codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;
  const j = mode === "math" ? 0 : 1; // column index for CSS class.

  if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {
    // wideLatinLetterData contains exactly 26 chars on each row.
    // So we can calculate the relevant row. No traverse necessary.
    const i = Math.floor((codePoint - 0x1D400) / 26);
    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
  } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {
    // Numerals, ten per row.
    const i = Math.floor((codePoint - 0x1D7CE) / 10);
    return [wideNumeralData[i][2], wideNumeralData[i][j]];
  } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {
    // dotless i or j
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
  } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {
    // Greek letters. Not supported, yet.
    return ["", ""];
  } else {
    // We don't support any wide characters outside 1D400–1D7FF.
    throw new src_ParseError("Unsupported character: " + wideChar);
  }
};
;// CONCATENATED MODULE: ./src/buildCommon.js
/* eslint no-console:0 */

/**
 * This module contains general functions that can be used for building
 * different kinds of domTree nodes in a consistent manner.
 */







/**
 * Looks up the given symbol in fontMetrics, after applying any symbol
 * replacements defined in symbol.js
 */
const lookupSymbol = function (value, // TODO(#963): Use a union type for this.
fontName, mode) {
  // Replace the value with its replaced value from symbol.js
  if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
    value = src_symbols[mode][value].replace;
  }

  return {
    value: value,
    metrics: getCharacterMetrics(value, fontName, mode)
  };
};
/**
 * Makes a symbolNode after translation via the list of symbols in symbols.js.
 * Correctly pulls out metrics for the character, and optionally takes a list of
 * classes to be attached to the node.
 *
 * TODO: make argument order closer to makeSpan
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 * TODO(#953): Make `options` mandatory and always pass it in.
 */


const makeSymbol = function (value, fontName, mode, options, classes) {
  const lookup = lookupSymbol(value, fontName, mode);
  const metrics = lookup.metrics;
  value = lookup.value;
  let symbolNode;

  if (metrics) {
    let italic = metrics.italic;

    if (mode === "text" || options && options.font === "mathit") {
      italic = 0;
    }

    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
  } else {
    // TODO(emily): Figure out a good way to only print this in development
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
  }

  if (options) {
    symbolNode.maxFontSize = options.sizeMultiplier;

    if (options.style.isTight()) {
      symbolNode.classes.push("mtight");
    }

    const color = options.getColor();

    if (color) {
      symbolNode.style.color = color;
    }
  }

  return symbolNode;
};
/**
 * Makes a symbol in Main-Regular or AMS-Regular.
 * Used for rel, bin, open, close, inner, and punct.
 */


const mathsym = function (value, mode, options, classes) {
  if (classes === void 0) {
    classes = [];
  }

  // Decide what font to render the symbol in by its entry in the symbols
  // table.
  // Have a special case for when the value = \ because the \ is used as a
  // textord in unsupported command errors but cannot be parsed as a regular
  // text ordinal and is therefore not present as a symbol in the symbols
  // table for text, as well as a special case for boldsymbol because it
  // can be used for bold + and -
  if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
    return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
  } else if (value === "\\" || src_symbols[mode][value].font === "main") {
    return makeSymbol(value, "Main-Regular", mode, options, classes);
  } else {
    return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
  }
};
/**
 * Determines which of the two font names (Main-Bold and Math-BoldItalic) and
 * corresponding style tags (mathbf or boldsymbol) to use for font "boldsymbol",
 * depending on the symbol.  Use this function instead of fontMap for font
 * "boldsymbol".
 */


const boldsymbol = function (value, mode, options, classes, type) {
  if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    // Some glyphs do not exist in Math-BoldItalic so we need to use
    // Main-Bold instead.
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
/**
 * Makes either a mathord or textord in the correct font and color.
 */


const makeOrd = function (group, options, type) {
  const mode = group.mode;
  const text = group.text;
  const classes = ["mord"]; // Math mode or Old font (i.e. \rm)

  const isFont = mode === "math" || mode === "text" && options.font;
  const fontOrFamily = isFont ? options.font : options.fontFamily;
  let wideFontName = "";
  let wideFontClass = "";

  if (text.charCodeAt(0) === 0xD835) {
    [wideFontName, wideFontClass] = wideCharacterFont(text, mode);
  }

  if (wideFontName.length > 0) {
    // surrogate pairs get special treatment
    return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
  } else if (fontOrFamily) {
    let fontName;
    let fontClasses;

    if (fontOrFamily === "boldsymbol") {
      const fontData = boldsymbol(text, mode, options, classes, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
    }

    if (lookupSymbol(text, fontName, mode).metrics) {
      return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === "Typewriter") {
      // Deconstruct ligatures in monospace fonts (\texttt, \tt).
      const parts = [];

      for (let i = 0; i < text.length; i++) {
        parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
      }

      return makeFragment(parts);
    }
  } // Makes a symbol in the default font for mathords and textords.


  if (type === "mathord") {
    return makeSymbol(text, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
  } else if (type === "textord") {
    const font = src_symbols[mode][text] && src_symbols[mode][text].font;

    if (font === "ams") {
      const fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
      return makeSymbol(text, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
    } else if (font === "main" || !font) {
      const fontName = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
      return makeSymbol(text, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
    } else {
      // fonts added by plugins
      const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class

      return makeSymbol(text, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
/**
 * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,
 * and styles.
 */


const canCombine = (prev, next) => {
  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
    return false;
  } // If prev and next both are just "mbin"s or "mord"s we don't combine them
  // so that the proper spacing can be preserved.


  if (prev.classes.length === 1) {
    const cls = prev.classes[0];

    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }

  for (const style in prev.style) {
    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
      return false;
    }
  }

  for (const style in next.style) {
    if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
      return false;
    }
  }

  return true;
};
/**
 * Combine consecutive domTree.symbolNodes into a single symbolNode.
 * Note: this function mutates the argument.
 */


const tryCombineChars = chars => {
  for (let i = 0; i < chars.length - 1; i++) {
    const prev = chars[i];
    const next = chars[i + 1];

    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
      prev.text += next.text;
      prev.height = Math.max(prev.height, next.height);
      prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use
      // it to add padding to the right of the span created from
      // the combined characters.

      prev.italic = next.italic;
      chars.splice(i + 1, 1);
      i--;
    }
  }

  return chars;
};
/**
 * Calculate the height, depth, and maxFontSize of an element based on its
 * children.
 */


const sizeElementFromChildren = function (elem) {
  let height = 0;
  let depth = 0;
  let maxFontSize = 0;

  for (let i = 0; i < elem.children.length; i++) {
    const child = elem.children[i];

    if (child.height > height) {
      height = child.height;
    }

    if (child.depth > depth) {
      depth = child.depth;
    }

    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }

  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
/**
 * Makes a span with the given list of classes, list of children, and options.
 *
 * TODO(#953): Ensure that `options` is always provided (currently some call
 * sites don't pass it) and make the type below mandatory.
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */


const makeSpan = function (classes, children, options, style) {
  const span = new Span(classes, children, options, style);
  sizeElementFromChildren(span);
  return span;
}; // SVG one is simpler -- doesn't require height, depth, max-font setting.
// This is also a separate method for typesafety.


const makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);

const makeLineSpan = function (className, options, thickness) {
  const line = makeSpan([className], [], options);
  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
  line.style.borderBottomWidth = makeEm(line.height);
  line.maxFontSize = 1.0;
  return line;
};
/**
 * Makes an anchor with the given href, list of classes, list of children,
 * and options.
 */


const makeAnchor = function (href, classes, children, options) {
  const anchor = new Anchor(href, classes, children, options);
  sizeElementFromChildren(anchor);
  return anchor;
};
/**
 * Makes a document fragment with the given list of children.
 */


const makeFragment = function (children) {
  const fragment = new DocumentFragment(children);
  sizeElementFromChildren(fragment);
  return fragment;
};
/**
 * Wraps group in a span if it's a document fragment, allowing to apply classes
 * and styles
 */


const wrapFragment = function (group, options) {
  if (group instanceof DocumentFragment) {
    return makeSpan([], [group], options);
  }

  return group;
}; // These are exact object types to catch typos in the names of the optional fields.


// Computes the updated `children` list and the overall depth.
//
// This helper function for makeVList makes it easier to enforce type safety by
// allowing early exits (returns) in the logic.
const getVListChildrenAndDepth = function (params) {
  if (params.positionType === "individualShift") {
    const oldChildren = params.children;
    const children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be
    // shifted to the correct specified shift

    const depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
    let currPos = depth;

    for (let i = 1; i < oldChildren.length; i++) {
      const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
      const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size
      });
      children.push(oldChildren[i]);
    }

    return {
      children,
      depth
    };
  }

  let depth;

  if (params.positionType === "top") {
    // We always start at the bottom, so calculate the bottom by adding up
    // all the sizes
    let bottom = params.positionData;

    for (let i = 0; i < params.children.length; i++) {
      const child = params.children[i];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }

    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    const firstChild = params.children[0];

    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }

    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }

  return {
    children: params.children,
    depth
  };
};
/**
 * Makes a vertical list by stacking elements and kerns on top of each other.
 * Allows for many different ways of specifying the positioning method.
 *
 * See VListParam documentation above.
 */


const makeVList = function (params, options) {
  const {
    children,
    depth
  } = getVListChildrenAndDepth(params); // Create a strut that is taller than any list item. The strut is added to
  // each item, where it will determine the item's baseline. Since it has
  // `overflow:hidden`, the strut's top edge will sit on the item's line box's
  // top edge and the strut's bottom edge will sit on the item's baseline,
  // with no additional line-height spacing. This allows the item baseline to
  // be positioned precisely without worrying about font ascent and
  // line-height.

  let pstrutSize = 0;

  for (let i = 0; i < children.length; i++) {
    const child = children[i];

    if (child.type === "elem") {
      const elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }

  pstrutSize += 2;
  const pstrut = makeSpan(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize); // Create a new list of actual children at the correct offsets

  const realChildren = [];
  let minPos = depth;
  let maxPos = depth;
  let currPos = depth;

  for (let i = 0; i < children.length; i++) {
    const child = children[i];

    if (child.type === "kern") {
      currPos += child.size;
    } else {
      const elem = child.elem;
      const classes = child.wrapperClasses || [];
      const style = child.wrapperStyle || {};
      const childWrap = makeSpan(classes, [pstrut, elem], undefined, style);
      childWrap.style.top = makeEm(-pstrutSize - currPos - elem.depth);

      if (child.marginLeft) {
        childWrap.style.marginLeft = child.marginLeft;
      }

      if (child.marginRight) {
        childWrap.style.marginRight = child.marginRight;
      }

      realChildren.push(childWrap);
      currPos += elem.height + elem.depth;
    }

    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  } // The vlist contents go in a table-cell with `vertical-align:bottom`.
  // This cell's bottom edge will determine the containing table's baseline
  // without overly expanding the containing line-box.


  const vlist = makeSpan(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos); // A second row is used if necessary to represent the vlist's depth.

  let rows;

  if (minPos < 0) {
    // We will define depth in an empty span with display: table-cell.
    // It should render with the height that we define. But Chrome, in
    // contenteditable mode only, treats that span as if it contains some
    // text content. And that min-height over-rides our desired height.
    // So we put another empty span inside the depth strut span.
    const emptySpan = makeSpan([], []);
    const depthStrut = makeSpan(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos); // Safari wants the first row to have inline content; otherwise it
    // puts the bottom of the *second* row on the baseline.

    const topStrut = makeSpan(["vlist-s"], [new SymbolNode("\u200b")]);
    rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan(["vlist-r"], [vlist])];
  }

  const vtable = makeSpan(["vlist-t"], rows);

  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }

  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
}; // Glue is a concept from TeX which is a flexible space between elements in
// either a vertical or horizontal list. In KaTeX, at least for now, it's
// static space between elements in a horizontal layout.


const makeGlue = (measurement, options) => {
  // Make an empty span for the space
  const rule = makeSpan(["mspace"], [], options);
  const size = calculateSize(measurement, options);
  rule.style.marginRight = makeEm(size);
  return rule;
}; // Takes font options, and returns the appropriate fontLookup name


const retrieveTextFontName = function (fontFamily, fontWeight, fontShape) {
  let baseFontName = "";

  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;

    case "textrm":
      baseFontName = "Main";
      break;

    case "textsf":
      baseFontName = "SansSerif";
      break;

    case "texttt":
      baseFontName = "Typewriter";
      break;

    default:
      baseFontName = fontFamily;
    // use fonts added by a plugin
  }

  let fontStylesName;

  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }

  return baseFontName + "-" + fontStylesName;
};
/**
 * Maps TeX font commands to objects containing:
 * - variant: string used for "mathvariant" attribute in buildMathML.js
 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
 */
// A map between tex font commands an MathML mathvariant attribute values


const fontMap = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  "mathsfit": {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
const svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};

const staticSvg = function (value, options) {
  // Create a span with inline SVG for the element.
  const [pathName, width, height] = svgData[value];
  const path = new PathNode(pathName);
  const svgNode = new SvgNode([path], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1000 * width + " " + 1000 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  const span = makeSvgSpan(["overlay"], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return span;
};

/* harmony default export */ var buildCommon = ({
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
});
;// CONCATENATED MODULE: ./src/spacingData.js
/**
 * Describes spaces between different classes of atoms.
 */
const thinspace = {
  number: 3,
  unit: "mu"
};
const mediumspace = {
  number: 4,
  unit: "mu"
};
const thickspace = {
  number: 5,
  unit: "mu"
}; // Making the type below exact with all optional fields doesn't work due to
// - https://github.com/facebook/flow/issues/4582
// - https://github.com/facebook/flow/issues/5688
// However, since *all* fields are optional, $Shape<> works as suggested in 5688
// above.

// Spacing relationships for display and text styles
const spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
}; // Spacing relationships for script and scriptscript styles

const tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
;// CONCATENATED MODULE: ./src/defineFunction.js
/** Context provided to function handlers for error messages. */
// Note: reverse the order of the return type union will cause a flow error.
// See https://github.com/facebook/flow/issues/3663.
// More general version of `HtmlBuilder` for nodes (e.g. \sum, accent types)
// whose presence impacts super/subscripting. In this case, ParseNode<"supsub">
// delegates its HTML building to the HtmlBuilder corresponding to these nodes.

/**
 * Final function spec for use at parse time.
 * This is almost identical to `FunctionPropSpec`, except it
 * 1. includes the function handler, and
 * 2. requires all arguments except argTypes.
 * It is generated by `defineFunction()` below.
 */

/**
 * All registered functions.
 * `functions.js` just exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary.
 */
const _functions = {};
/**
 * All HTML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */

const _htmlGroupBuilders = {};
/**
 * All MathML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */

const _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  let {
    type,
    names,
    props,
    handler,
    htmlBuilder,
    mathmlBuilder
  } = _ref;
  // Set default values of functions
  const data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler: handler
  };

  for (let i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }

  if (type) {
    if (htmlBuilder) {
      _htmlGroupBuilders[type] = htmlBuilder;
    }

    if (mathmlBuilder) {
      _mathmlGroupBuilders[type] = mathmlBuilder;
    }
  }
}
/**
 * Use this to register only the HTML and MathML builders for a function (e.g.
 * if the function's ParseNode is generated in Parser.js rather than via a
 * stand-alone handler provided to `defineFunction`).
 */

function defineFunctionBuilders(_ref2) {
  let {
    type,
    htmlBuilder,
    mathmlBuilder
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },

    handler() {
      throw new Error('Should never be called.');
    },

    htmlBuilder,
    mathmlBuilder
  });
}
const normalizeArgument = function (arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
}; // Since the corresponding buildHTML/buildMathML function expects a
// list of elements, we normalize for different kinds of arguments

const ordargument = function (arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};
;// CONCATENATED MODULE: ./src/buildHTML.js
/**
 * This file does the main work of building a domTree structure from a parse
 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
 * Then, the buildExpression, buildGroup, and various groupBuilders functions
 * are called, to produce a final HTML tree.
 */









const buildHTML_makeSpan = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
// and the text before Rule 19.

const binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
const binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
const styleMap = {
  "display": src_Style.DISPLAY,
  "text": src_Style.TEXT,
  "script": src_Style.SCRIPT,
  "scriptscript": src_Style.SCRIPTSCRIPT
};
const DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};

/**
 * Take a list of nodes, build them in order, and return a list of the built
 * nodes. documentFragments are flattened into their contents, so the
 * returned list contains no fragments. `isRealGroup` is true if `expression`
 * is a real group (no atoms will be added on either side), as opposed to
 * a partial group (e.g. one created by \color). `surrounding` is an array
 * consisting type of nodes that will be added to the left and right.
 */
const buildExpression = function (expression, options, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }

  // Parse expressions into `groups`.
  const groups = [];

  for (let i = 0; i < expression.length; i++) {
    const output = buildGroup(expression[i], options);

    if (output instanceof DocumentFragment) {
      const children = output.children;
      groups.push(...children);
    } else {
      groups.push(output);
    }
  } // Combine consecutive domTree.symbolNodes into a single symbolNode.


  buildCommon.tryCombineChars(groups); // If `expression` is a partial group, let the parent handle spacings
  // to avoid processing groups multiple times.

  if (!isRealGroup) {
    return groups;
  }

  let glueOptions = options;

  if (expression.length === 1) {
    const node = expression[0];

    if (node.type === "sizing") {
      glueOptions = options.havingSize(node.size);
    } else if (node.type === "styling") {
      glueOptions = options.havingStyle(styleMap[node.style]);
    }
  } // Dummy spans for determining spacings between surrounding atoms.
  // If `expression` has no atoms on the left or right, class "leftmost"
  // or "rightmost", respectively, is used to indicate it.


  const dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
  const dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options); // TODO: These code assumes that a node's math class is the first element
  // of its `classes` array. A later cleanup should ensure this, for
  // instance by changing the signature of `makeSpan`.
  // Before determining what spaces to insert, perform bin cancellation.
  // Binary operators change to ordinary symbols in some contexts.

  const isRoot = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node, prev) => {
    const prevType = prev.classes[0];
    const type = node.classes[0];

    if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
      prev.classes[0] = "mord";
    } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
      node.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  traverseNonSpaceNodes(groups, (node, prev) => {
    const prevType = getTypeOfDomTree(prev);
    const type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.

    const space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;

    if (space) {
      // Insert glue (spacing) after the `prev`.
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  return groups;
}; // Depth-first traverse non-space `nodes`, calling `callback` with the current and
// previous node as arguments, optionally returning a node to insert after the
// previous node. `prev` is an object with the previous node and `insertAfter`
// function to insert after it. `next` is a node that will be added to the right.
// Used for bin cancellation and inserting spacings.

const traverseNonSpaceNodes = function (nodes, callback, prev, next, isRoot) {
  if (next) {
    // temporarily append the right node, if exists
    nodes.push(next);
  }

  let i = 0;

  for (; i < nodes.length; i++) {
    const node = nodes[i];
    const partialGroup = checkPartialGroup(node);

    if (partialGroup) {
      // Recursive DFS
      // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array
      traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);
      continue;
    } // Ignore explicit spaces (e.g., \;, \,) when determining what implicit
    // spacing should go between atoms of different classes


    const nonspace = !node.hasClass("mspace");

    if (nonspace) {
      const result = callback(node, prev.node);

      if (result) {
        if (prev.insertAfter) {
          prev.insertAfter(result);
        } else {
          // insert at front
          nodes.unshift(result);
          i++;
        }
      }
    }

    if (nonspace) {
      prev.node = node;
    } else if (isRoot && node.hasClass("newline")) {
      prev.node = buildHTML_makeSpan(["leftmost"]); // treat like beginning of line
    }

    prev.insertAfter = (index => n => {
      nodes.splice(index + 1, 0, n);
      i++;
    })(i);
  }

  if (next) {
    nodes.pop();
  }
}; // Check if given node is a partial group, i.e., does not affect spacing around.


const checkPartialGroup = function (node) {
  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
    return node;
  }

  return null;
}; // Return the outermost node of a domTree.


const getOutermostNode = function (node, side) {
  const partialGroup = checkPartialGroup(node);

  if (partialGroup) {
    const children = partialGroup.children;

    if (children.length) {
      if (side === "right") {
        return getOutermostNode(children[children.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode(children[0], "left");
      }
    }
  }

  return node;
}; // Return math atom class (mclass) of a domTree.
// If `side` is given, it will get the type of the outermost node at given side.


const getTypeOfDomTree = function (node, side) {
  if (!node) {
    return null;
  }

  if (side) {
    node = getOutermostNode(node, side);
  } // This makes a lot of assumptions as to where the type of atom
  // appears.  We should do a better job of enforcing this.


  return DomEnum[node.classes[0]] || null;
};
const makeNullDelimiter = function (options, classes) {
  const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
  return buildHTML_makeSpan(classes.concat(moreClasses));
};
/**
 * buildGroup is the function that takes a group and calls the correct groupType
 * function for it. It also handles the interaction of size and style changes
 * between parents and children.
 */

const buildGroup = function (group, options, baseOptions) {
  if (!group) {
    return buildHTML_makeSpan();
  }

  if (_htmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    // $FlowFixMe
    let groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account
    // for that size difference.

    if (baseOptions && options.size !== baseOptions.size) {
      groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
      const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }

    return groupNode;
  } else {
    throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
/**
 * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)
 * into an unbreakable HTML node of class .base, with proper struts to
 * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to
 * make up the entire expression as a sequence of unbreakable units.
 */

function buildHTMLUnbreakable(children, options) {
  // Compute height and depth of this chunk.
  const body = buildHTML_makeSpan(["base"], children, options); // Add strut, which ensures that the top of the HTML element falls at
  // the height of the expression, and the bottom of the HTML element
  // falls at the depth of the expression.

  const strut = buildHTML_makeSpan(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);

  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }

  body.children.unshift(strut);
  return body;
}
/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */


function buildHTML(tree, options) {
  // Strip off outer tag wrapper for processing below.
  let tag = null;

  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  } // Build the expression contained in the tree


  const expression = buildExpression(tree, options, "root");
  let eqnNum;

  if (expression.length === 2 && expression[1].hasClass("tag")) {
    // An environment with automatic equation numbers, e.g. {gather}.
    eqnNum = expression.pop();
  }

  const children = []; // Create one base node for each chunk between potential line breaks.
  // The TeXBook [p.173] says "A formula will be broken only after a
  // relation symbol like $=$ or $<$ or $\rightarrow$, or after a binary
  // operation symbol like $+$ or $-$ or $\times$, where the relation or
  // binary operation is on the ``outer level'' of the formula (i.e., not
  // enclosed in {...} and not part of an \over construction)."

  let parts = [];

  for (let i = 0; i < expression.length; i++) {
    parts.push(expression[i]);

    if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
      // Put any post-operator glue on same line as operator.
      // Watch for \nobreak along the way, and stop at \newline.
      let nobreak = false;

      while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
        i++;
        parts.push(expression[i]);

        if (expression[i].hasClass("nobreak")) {
          nobreak = true;
        }
      } // Don't allow break if \nobreak among the post-operator glue.


      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
    } else if (expression[i].hasClass("newline")) {
      // Write the line except the newline
      parts.pop();

      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      } // Put the newline at the top level


      children.push(expression[i]);
    }
  }

  if (parts.length > 0) {
    children.push(buildHTMLUnbreakable(parts, options));
  } // Now, if there was a tag, build it too and append it as a final child.


  let tagChild;

  if (tag) {
    tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  } else if (eqnNum) {
    children.push(eqnNum);
  }

  const htmlNode = buildHTML_makeSpan(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true"); // Adjust the strut of the tag to be the maximum height of all children
  // (the height of the enclosing htmlNode) for proper vertical alignment.

  if (tagChild) {
    const strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);

    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }

  return htmlNode;
}
;// CONCATENATED MODULE: ./src/mathMLTree.js
/**
 * These objects store data about MathML nodes. This is the MathML equivalent
 * of the types in domTree.js. Since MathML handles its own rendering, and
 * since we're mainly using MathML to improve accessibility, we don't manage
 * any of the styling state that the plain DOM nodes do.
 *
 * The `toNode` and `toMarkup` functions work similarly to how they do in
 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
 */




function newDocumentFragment(children) {
  return new DocumentFragment(children);
}
/**
 * This node represents a general purpose MathML node of any type. The
 * constructor requires the type of node to create (for example, `"mo"` or
 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
 */

class MathNode {
  constructor(type, children, classes) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */


  setAttribute(name, value) {
    this.attributes[name] = value;
  }
  /**
   * Gets an attribute on a MathML node.
   */


  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */


  toNode() {
    const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }

    for (let i = 0; i < this.children.length; i++) {
      // Combine multiple TextNodes into one TextNode, to prevent
      // screen readers from reading each as a separate word [#3995]
      if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
        let text = this.children[i].toText() + this.children[++i].toText();

        while (this.children[i + 1] instanceof TextNode) {
          text += this.children[++i].toText();
        }

        node.appendChild(new TextNode(text).toNode());
      } else {
        node.appendChild(this.children[i].toNode());
      }
    }

    return node;
  }
  /**
   * Converts the math node into an HTML markup string.
   */


  toMarkup() {
    let markup = "<" + this.type; // Add the attributes

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "=\"";
        markup += utils.escape(this.attributes[attr]);
        markup += "\"";
      }
    }

    if (this.classes.length > 0) {
      markup += " class =\"" + utils.escape(createClass(this.classes)) + "\"";
    }

    markup += ">";

    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */


  toText() {
    return this.children.map(child => child.toText()).join("");
  }

}
/**
 * This node represents a piece of text.
 */

class TextNode {
  constructor(text) {
    this.text = void 0;
    this.text = text;
  }
  /**
   * Converts the text node into a DOM text node.
   */


  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */


  toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */


  toText() {
    return this.text;
  }

}
/**
 * This node represents a space, but may render as <mspace.../> or as text,
 * depending on the width.
 */

class SpaceNode {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html
    // for a table of space-like characters.  We use Unicode
    // representations instead of &LongNames; as it's not clear how to
    // make the latter via document.createTextNode.

    if (width >= 0.05555 && width <= 0.05556) {
      this.character = "\u200a"; // &VeryThinSpace;
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = "\u2009"; // &ThinSpace;
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = "\u2005"; // &MediumSpace;
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "\u2005\u200a"; // &ThickSpace;
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = "\u200a\u2063"; // &NegativeVeryThinSpace;
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = "\u2009\u2063"; // &NegativeThinSpace;
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = "\u205f\u2063"; // &NegativeMediumSpace;
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = "\u2005\u2063"; // &NegativeThickSpace;
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */


  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node.setAttribute("width", makeEm(this.width));
      return node;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */


  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return "<mspace width=\"" + makeEm(this.width) + "\"/>";
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */


  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }

}

/* harmony default export */ var mathMLTree = ({
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
});
;// CONCATENATED MODULE: ./src/buildMathML.js
/**
 * This file converts a parse tree into a corresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */









/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
const makeText = function (text, mode, options) {
  if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
    text = src_symbols[mode][text].replace;
  }

  return new mathMLTree.TextNode(text);
};
/**
 * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
 * unless the array has length 1.  Always returns a single node.
 */

const makeRow = function (body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
/**
 * Returns the math variant as a string or null if none is required.
 */

const getVariant = function (group, options) {
  // Handle \text... font specifiers as best we can.
  // MathML has a limited list of allowable mathvariant specifiers; see
  // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt
  if (options.fontFamily === "texttt") {
    return "monospace";
  } else if (options.fontFamily === "textsf") {
    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options.fontShape === "textit") {
    return "italic";
  } else if (options.fontWeight === "textbf") {
    return "bold";
  }

  const font = options.font;

  if (!font || font === "mathnormal") {
    return null;
  }

  const mode = group.mode;

  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathsfit") {
    return "sans-serif-italic";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    // MathML makes no distinction between script and calligraphic
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }

  let text = group.text;

  if (utils.contains(["\\imath", "\\jmath"], text)) {
    return null;
  }

  if (src_symbols[mode][text] && src_symbols[mode][text].replace) {
    text = src_symbols[mode][text].replace;
  }

  const fontName = buildCommon.fontMap[font].fontName;

  if (getCharacterMetrics(text, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }

  return null;
};
/**
 * Check for <mi>.</mi> which is how a dot renders in MathML,
 * or <mo separator="true" lspace="0em" rspace="0em">,</mo>
 * which is how a braced comma {,} renders in MathML
 */

function isNumberPunctuation(group) {
  if (!group) {
    return false;
  }

  if (group.type === 'mi' && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '.';
  } else if (group.type === 'mo' && group.children.length === 1 && group.getAttribute('separator') === 'true' && group.getAttribute('lspace') === '0em' && group.getAttribute('rspace') === '0em') {
    const child = group.children[0];
    return child instanceof TextNode && child.text === ',';
  } else {
    return false;
  }
}
/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes.  Also combine consecutive <mtext> outputs into a single
 * <mtext> tag.
 */


const buildMathML_buildExpression = function (expression, options, isOrdgroup) {
  if (expression.length === 1) {
    const group = buildMathML_buildGroup(expression[0], options);

    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      // When TeX writers want to suppress spacing on an operator,
      // they often put the operator by itself inside braces.
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }

    return [group];
  }

  const groups = [];
  let lastGroup;

  for (let i = 0; i < expression.length; i++) {
    const group = buildMathML_buildGroup(expression[i], options);

    if (group instanceof MathNode && lastGroup instanceof MathNode) {
      // Concatenate adjacent <mtext>s
      if (group.type === 'mtext' && lastGroup.type === 'mtext' && group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {
        lastGroup.children.push(...group.children);
        continue; // Concatenate adjacent <mn>s
      } else if (group.type === 'mn' && lastGroup.type === 'mn') {
        lastGroup.children.push(...group.children);
        continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>
      } else if (isNumberPunctuation(group) && lastGroup.type === 'mn') {
        lastGroup.children.push(...group.children);
        continue; // Concatenate <mi>.</mi> followed by <mn>...</mn>
      } else if (group.type === 'mn' && isNumberPunctuation(lastGroup)) {
        group.children = [...lastGroup.children, ...group.children];
        groups.pop(); // Put preceding <mn>...</mn> or <mi>.</mi> inside base of
        // <msup><mn>...base...</mn>...exponent...</msup> (or <msub>)
      } else if ((group.type === 'msup' || group.type === 'msub') && group.children.length >= 1 && (lastGroup.type === 'mn' || isNumberPunctuation(lastGroup))) {
        const base = group.children[0];

        if (base instanceof MathNode && base.type === 'mn') {
          base.children = [...lastGroup.children, ...base.children];
          groups.pop();
        } // \not

      } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {
        const lastChild = lastGroup.children[0];

        if (lastChild instanceof TextNode && lastChild.text === '\u0338' && (group.type === 'mo' || group.type === 'mi' || group.type === 'mn')) {
          const child = group.children[0];

          if (child instanceof TextNode && child.text.length > 0) {
            // Overlay with combining character long solidus
            child.text = child.text.slice(0, 1) + "\u0338" + child.text.slice(1);
            groups.pop();
          }
        }
      }
    }

    groups.push(group);
    lastGroup = group;
  }

  return groups;
};
/**
 * Equivalent to buildExpression, but wraps the elements in an <mrow>
 * if there's more than one.  Returns a single node instead of an array.
 */

const buildExpressionRow = function (expression, options, isOrdgroup) {
  return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
};
/**
 * Takes a group from the parser and calls the appropriate groupBuilders function
 * on it to produce a MathML node.
 */

const buildMathML_buildGroup = function (group, options) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }

  if (_mathmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    // $FlowFixMe
    const result = _mathmlGroupBuilders[group.type](group, options); // $FlowFixMe

    return result;
  } else {
    throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it. In particular, we put the elements from building the parse tree into a
 * <semantics> tag so we can also include that TeX source as an annotation.
 *
 * Note that we actually return a domTree element with a `<math>` inside it so
 * we can do appropriate styling.
 */

function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
  const expression = buildMathML_buildExpression(tree, options); // TODO: Make a pass thru the MathML similar to buildHTML.traverseNonSpaceNodes
  // and add spacing nodes. This is necessary only adjacent to math operators
  // like \sin or \lim or to subsup elements that contain math operators.
  // MathML takes care of the other spacing issues.
  // Wrap up the expression in an mrow so it is presented in the semantics
  // tag correctly, unless it's a single <mrow> or <mtable>.

  let wrapper;

  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  } // Build a TeX annotation of the source


  const annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  const semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  const math = new mathMLTree.MathNode("math", [semantics]);
  math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");

  if (isDisplayMode) {
    math.setAttribute("display", "block");
  } // You can't style <math> nodes, so we wrap the node in a span.
  // NOTE: The span class is not typed to have <math> nodes as children, and
  // we don't want to make the children type more generic since the children
  // of span are expected to have more fields in `buildHtml` contexts.


  const wrapperClass = forMathmlOnly ? "katex" : "katex-mathml"; // $FlowFixMe

  return buildCommon.makeSpan([wrapperClass], [math]);
}
;// CONCATENATED MODULE: ./src/buildTree.js







const optionsFromSettings = function (settings) {
  return new src_Options({
    style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};

const displayWrap = function (node, settings) {
  if (settings.displayMode) {
    const classes = ["katex-display"];

    if (settings.leqno) {
      classes.push("leqno");
    }

    if (settings.fleqn) {
      classes.push("fleqn");
    }

    node = buildCommon.makeSpan(classes, [node]);
  }

  return node;
};

const buildTree = function (tree, expression, settings) {
  const options = optionsFromSettings(settings);
  let katexNode;

  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options, settings.displayMode, true);
  } else if (settings.output === "html") {
    const htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    const mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
    const htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
  }

  return displayWrap(katexNode, settings);
};
const buildHTMLTree = function (tree, expression, settings) {
  const options = optionsFromSettings(settings);
  const htmlNode = buildHTML(tree, options);
  const katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};
/* harmony default export */ var src_buildTree = ((/* unused pure expression or super */ null && (0)));
;// CONCATENATED MODULE: ./src/stretchy.js
/**
 * This file provides support to buildMathML.js and buildHTML.js
 * for stretchy wide elements rendered from SVG files
 * and other CSS trickery.
 */





const stretchyCodePoint = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23df",
  overbrace: "\u23de",
  overgroup: "\u23e0",
  undergroup: "\u23e1",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21d2",
  xRightarrow: "\u21d2",
  overleftharpoon: "\u21bc",
  xleftharpoonup: "\u21bc",
  overrightharpoon: "\u21c0",
  xrightharpoonup: "\u21c0",
  xLeftarrow: "\u21d0",
  xLeftrightarrow: "\u21d4",
  xhookleftarrow: "\u21a9",
  xhookrightarrow: "\u21aa",
  xmapsto: "\u21a6",
  xrightharpoondown: "\u21c1",
  xleftharpoondown: "\u21bd",
  xrightleftharpoons: "\u21cc",
  xleftrightharpoons: "\u21cb",
  xtwoheadleftarrow: "\u219e",
  xtwoheadrightarrow: "\u21a0",
  xlongequal: "=",
  xtofrom: "\u21c4",
  xrightleftarrows: "\u21c4",
  xrightequilibrium: "\u21cc",
  // Not a perfect match.
  xleftequilibrium: "\u21cb",
  // None better available.
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};

const mathMLnode = function (label) {
  const node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, '')])]);
  node.setAttribute("stretchy", "true");
  return node;
}; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.
// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)
// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)
// Licensed under the SIL Open Font License, Version 1.1.
// See \nhttp://scripts.sil.org/OFL
// Very Long SVGs
//    Many of the KaTeX stretchy wide elements use a long SVG image and an
//    overflow: hidden tactic to achieve a stretchy image while avoiding
//    distortion of arrowheads or brace corners.
//    The SVG typically contains a very long (400 em) arrow.
//    The SVG is in a container span that has overflow: hidden, so the span
//    acts like a window that exposes only part of the  SVG.
//    The SVG always has a longer, thinner aspect ratio than the container span.
//    After the SVG fills 100% of the height of the container span,
//    there is a long arrow shaft left over. That left-over shaft is not shown.
//    Instead, it is sliced off because the span's CSS has overflow: hidden.
//    Thus, the reader sees an arrow that matches the subject matter width
//    without distortion.
//    Some functions, such as \cancel, need to vary their aspect ratio. These
//    functions do not get the overflow SVG treatment.
// Second Brush Stroke
//    Low resolution monitors struggle to display images in fine detail.
//    So browsers apply anti-aliasing. A long straight arrow shaft therefore
//    will sometimes appear as if it has a blurred edge.
//    To mitigate this, these SVG files contain a second "brush-stroke" on the
//    arrow shafts. That is, a second long thin rectangular SVG path has been
//    written directly on top of each arrow shaft. This reinforcement causes
//    some of the screen pixels to display as black instead of the anti-aliased
//    gray pixel that a  single path would generate. So we get arrow shafts
//    whose edges appear to be sharper.
// In the katexImagesData object just below, the dimensions all
// correspond to path geometry inside the relevant SVG.
// For example, \overrightarrow uses the same arrowhead as glyph U+2192
// from the KaTeX Main font. The scaling factor is 1000.
// That is, inside the font, that arrowhead is 522 units tall, which
// corresponds to 0.522 em inside the document.


const katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3.0, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3.0, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3.0, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};

const groupLength = function (arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};

const svgSpan = function (group, options) {
  // Create a span with inline SVG for the element.
  function buildSvgSpan_() {
    let viewBoxWidth = 400000; // default

    const label = group.label.slice(1);

    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
      // Each type in the `if` statement corresponds to one of the ParseNode
      // types below. This narrowing is required to access `grp.base`.
      // $FlowFixMe
      const grp = group; // There are four SVG images available for each function.
      // Choose a taller image when there are more characters.

      const numChars = groupLength(grp.base);
      let viewBoxHeight;
      let pathName;
      let height;

      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          height = 0.34;
          pathName = "tilde4";
        }
      } else {
        const imgIndex = [1, 1, 2, 2, 3, 3][numChars];

        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }

      const path = new PathNode(pathName);
      const svgNode = new SvgNode([path], {
        "width": "100%",
        "height": makeEm(height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options),
        minWidth: 0,
        height
      };
    } else {
      const spans = [];
      const data = katexImagesData[label];
      const [paths, minWidth, viewBoxHeight] = data;
      const height = viewBoxHeight / 1000;
      const numSvgChildren = paths.length;
      let widthClasses;
      let aligns;

      if (numSvgChildren === 1) {
        // $FlowFixMe: All these cases must be of the 4-tuple type.
        const align1 = data[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }

      for (let i = 0; i < numSvgChildren; i++) {
        const path = new PathNode(paths[i]);
        const svgNode = new SvgNode([path], {
          "width": "400em",
          "height": makeEm(height),
          "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
          "preserveAspectRatio": aligns[i] + " slice"
        });
        const span = buildCommon.makeSvgSpan([widthClasses[i]], [svgNode], options);

        if (numSvgChildren === 1) {
          return {
            span,
            minWidth,
            height
          };
        } else {
          span.style.height = makeEm(height);
          spans.push(span);
        }
      }

      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options),
        minWidth,
        height
      };
    }
  } // buildSvgSpan_()


  const {
    span,
    minWidth,
    height
  } = buildSvgSpan_(); // Note that we are returning span.depth = 0.
  // Any adjustments relative to the baseline must be done in buildHTML.

  span.height = height;
  span.style.height = makeEm(height);

  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }

  return span;
};

const encloseSpan = function (inner, label, topPad, bottomPad, options) {
  // Return an image span for \cancel, \bcancel, \xcancel, \fbox, or \angl
  let img;
  const totalHeight = inner.height + inner.depth + topPad + bottomPad;

  if (/fbox|color|angl/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options);

    if (label === "fbox") {
      const color = options.color && options.getColor();

      if (color) {
        img.style.borderColor = color;
      }
    }
  } else {
    // \cancel, \bcancel, or \xcancel
    // Since \cancel's SVG is inline and it omits the viewBox attribute,
    // its stroke-width will not vary with span area.
    const lines = [];

    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }

    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }

    const svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options);
  }

  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};

/* harmony default export */ var stretchy = ({
  encloseSpan,
  mathMLnode,
  svgSpan
});
;// CONCATENATED MODULE: ./src/parseNode.js


/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
  } // $FlowFixMe, >=0.125


  return node;
}
/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */

function assertSymbolNodeType(node) {
  const typedNode = checkSymbolNodeType(node);

  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
  }

  return typedNode;
}
/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */

function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
    // $FlowFixMe
    return node;
  }

  return null;
}
;// CONCATENATED MODULE: ./src/functions/accent.js










// NOTE: Unlike most `htmlBuilder`s, this one handles not only "accent", but
// also "supsub" since an accent can affect super/subscripting.
const htmlBuilder = (grp, options) => {
  // Accents are handled in the TeXbook pg. 443, rule 12.
  let base;
  let group;
  let supSubGroup;

  if (grp && grp.type === "supsub") {
    // If our base is a character box, and we have superscripts and
    // subscripts, the supsub will defer to us. In particular, we want
    // to attach the superscripts and subscripts to the inner body (so
    // that the position of the superscripts and subscripts won't be
    // affected by the height of the accent). We accomplish this by
    // sticking the base of the accent into the base of the supsub, and
    // rendering that, while keeping track of where the accent is.
    // The real accent group is the base of the supsub group
    group = assertNodeType(grp.base, "accent"); // The character box is the base of the accent group

    base = group.base; // Stick the character box into the base of the supsub group

    grp.base = base; // Rerender the supsub group with its new base, and store that
    // result.

    supSubGroup = assertSpan(buildGroup(grp, options)); // reset original base

    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base = group.base;
  } // Build the base group


  const body = buildGroup(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?

  const mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line "If the
  // nucleus is not a single character, let s = 0; otherwise set s to the
  // kern amount for the nucleus followed by the \skewchar of its font."
  // Note that our skew metrics are just the kern between each character
  // and the skewchar.

  let skew = 0;

  if (mustShift) {
    // If the base is a character box, then we want the skew of the
    // innermost character. To do that, we find the innermost character:
    const baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it

    const baseGroup = buildGroup(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.

    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we
    // removed with getBaseElem might contain things like \color which
    // we can't get rid of.
    // TODO(emily): Find a better way to get the skew
  }

  const accentBelow = group.label === "\\c"; // calculate the amount of space between the body and the accent

  let clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight); // Build the accent

  let accentBody;

  if (!group.isStretchy) {
    let accent;
    let width;

    if (group.label === "\\vec") {
      // Before version 0.9, \vec used the combining font glyph U+20D7.
      // But browsers, especially Safari, are not consistent in how they
      // render combining characters when not preceded by a character.
      // So now we use an SVG.
      // If Safari reforms, we should consider reverting to the glyph.
      accent = buildCommon.staticSvg("vec", options);
      width = buildCommon.svgData.vec[1];
    } else {
      accent = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options, "textord");
      accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to
      // shift the accent over to a place we don't want.

      accent.italic = 0;
      width = accent.width;

      if (accentBelow) {
        clearance += accent.depth;
      }
    }

    accentBody = buildCommon.makeSpan(["accent-body"], [accent]); // "Full" accents expand the width of the resulting symbol to be
    // at least the width of the accent, and overlap directly onto the
    // character without any vertical offset.

    const accentFull = group.label === "\\textcircled";

    if (accentFull) {
      accentBody.classes.push('accent-full');
      clearance = body.height;
    } // Shift the accent over by the skew.


    let left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`
    // so that the accent doesn't contribute to the bounding box.
    // We need to shift the character by its width (effectively half
    // its width) to compensate.

    if (!accentFull) {
      left -= width / 2;
    }

    accentBody.style.left = makeEm(left); // \textcircled uses the \bigcirc glyph, so it needs some
    // vertical adjustment to match LaTeX.

    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }

    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options);
  } else {
    accentBody = stretchy.svgSpan(group, options);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew) + ")",
          marginLeft: makeEm(2 * skew)
        } : undefined
      }]
    }, options);
  }

  const accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);

  if (supSubGroup) {
    // Here, we replace the "base" child of the supsub with our newly
    // generated accent.
    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the
    // accent, we manually recalculate height.

    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.

    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};

const mathmlBuilder = (group, options) => {
  const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
  node.setAttribute("accent", "true");
  return node;
};

const NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(accent => "\\" + accent).join("|")); // Accents

defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);
    const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy: isStretchy,
      isShifty: isShifty,
      base: base
    };
  },
  htmlBuilder,
  mathmlBuilder
}); // Text-mode accents

defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const base = args[0];
    let mode = context.parser.mode;

    if (mode === "math") {
      context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
      mode = "text";
    }

    return {
      type: "accent",
      mode: mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base: base
    };
  },
  htmlBuilder,
  mathmlBuilder
});
;// CONCATENATED MODULE: ./src/functions/accentunder.js
// Horizontal overlap functions






defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    let {
      parser,
      funcName
    } = _ref;
    const base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base
    };
  },
  htmlBuilder: (group, options) => {
    // Treat under accents much like underlines.
    const innerGroup = buildGroup(group.base, options);
    const accentBody = stretchy.svgSpan(group, options);
    const kern = group.label === "\\utilde" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns

    const vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
  },
  mathmlBuilder: (group, options) => {
    const accentNode = stretchy.mathMLnode(group.label);
    const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
;// CONCATENATED MODULE: ./src/functions/arrow.js







// Helper function
const paddedNode = group => {
  const node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node.setAttribute("width", "+0.6em");
  node.setAttribute("lspace", "0.3em");
  return node;
}; // Stretchy arrows with an optional argument


defineFunction({
  type: "xArrow",
  names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom", // The next 3 functions are here to support the mhchem extension.
  // Direct use of these functions is discouraged and may break someday.
  "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium", // The next 3 functions are here only to support the {CD} environment.
  "\\\\cdrightarrow", "\\\\cdleftarrow", "\\\\cdlongequal"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },

  handler(_ref, args, optArgs) {
    let {
      parser,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },

  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(group, options) {
    const style = options.style; // Build the argument groups in the appropriate style.
    // Ref: amsmath.dtx:   \hbox{$\scriptstyle\mkern#3mu{#6}\mkern#4mu$}%
    // Some groups can return document fragments.  Handle those by wrapping
    // them in a span.

    let newOptions = options.havingStyle(style.sup());
    const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
    const arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    let lowerGroup;

    if (group.below) {
      // Build the lower group
      newOptions = options.havingStyle(style.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }

    const arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.
    // The point we want on the math axis is at 0.5 * arrowBody.height.

    const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\if0#2\else\mkern#2mu\fi

    let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu

    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth; // shift up if depth encroaches
    } // Generate the vlist


    let vlist;

    if (lowerGroup) {
      const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options);
    } // $FlowFixMe: Replace this with passing "svg-align" into makeVList.


    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
  },

  mathmlBuilder(group, options) {
    const arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    let node;

    if (group.body) {
      const upperNode = paddedNode(buildMathML_buildGroup(group.body, options));

      if (group.below) {
        const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
        node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
      node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
    } else {
      // This should never happen.
      // Parser.js throws an error if there is no argument.
      node = paddedNode();
      node = new mathMLTree.MathNode("mover", [arrowNode, node]);
    }

    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/mclass.js






const mclass_makeSpan = buildCommon.makeSpan;

function mclass_htmlBuilder(group, options) {
  const elements = buildExpression(group.body, options, true);
  return mclass_makeSpan([group.mclass], elements, options);
}

function mclass_mathmlBuilder(group, options) {
  let node;
  const inner = buildMathML_buildExpression(group.body, options);

  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node = inner[0];
      node.type = "mi";
    } else {
      node = new mathMLTree.MathNode("mi", inner);
    }
  } else {
    if (group.isCharacterBox) {
      node = inner[0];
      node.type = "mo";
    } else {
      node = new mathMLTree.MathNode("mo", inner);
    } // Set spacing based on what is the most likely adjacent atom type.
    // See TeXbook p170.


    if (group.mclass === "mbin") {
      node.attributes.lspace = "0.22em"; // medium space

      node.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0.17em"; // thinspace
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0em";
    } else if (group.mclass === "minner") {
      node.attributes.lspace = "0.0556em"; // 1 mu is the most likely option

      node.attributes.width = "+0.1111em";
    } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.
    // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo

  }

  return node;
} // Math class commands except \mathop


defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },

  handler(_ref, args) {
    let {
      parser,
      funcName
    } = _ref;
    const body = args[0];
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: "m" + funcName.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(body),
      isCharacterBox: utils.isCharacterBox(body)
    };
  },

  htmlBuilder: mclass_htmlBuilder,
  mathmlBuilder: mclass_mathmlBuilder
});
const binrelClass = arg => {
  // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
  // (by rendering separately and with {}s before and after, and measuring
  // the change in spacing).  We'll do roughly the same by detecting the
  // atom type directly.
  const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;

  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
}; // \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
// This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.

defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },

  handler(_ref2, args) {
    let {
      parser
    } = _ref2;
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }

}); // Build a relation or stacked op by placing one symbol on top of another

defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },

  handler(_ref3, args) {
    let {
      parser,
      funcName
    } = _ref3;
    const baseArg = args[1];
    const shiftedArg = args[0];
    let mclass;

    if (funcName !== "\\stackrel") {
      // LaTeX applies \binrel spacing to \overset and \underset.
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel"; // for \stackrel
    }

    const baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    const supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils.isCharacterBox(supsub)
    };
  },

  htmlBuilder: mclass_htmlBuilder,
  mathmlBuilder: mclass_mathmlBuilder
});
;// CONCATENATED MODULE: ./src/functions/pmb.js






// \pmb is a simulation of bold font.
// The version of \pmb in ambsy.sty works by typesetting three copies
// with small offsets. We use CSS text-shadow.
// It's a hack. Not as good as a real bold font. Better than nothing.
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },

  handler(_ref, args) {
    let {
      parser
    } = _ref;
    return {
      type: "pmb",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[0])
    };
  },

  htmlBuilder(group, options) {
    const elements = buildExpression(group.body, options, true);
    const node = buildCommon.makeSpan([group.mclass], elements, options);
    node.style.textShadow = "0.02em 0.01em 0.04px";
    return node;
  },

  mathmlBuilder(group, style) {
    const inner = buildMathML_buildExpression(group.body, style); // Wrap with an <mstyle> element.

    const node = new mathMLTree.MathNode("mstyle", inner);
    node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
    return node;
  }

});
;// CONCATENATED MODULE: ./src/environments/cd.js








const cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};

const newCell = () => {
  // Create an empty cell, to be filled below with parse nodes.
  // The parseTree from this module must be constructed like the
  // one created by parseArray(), so an empty CD cell must
  // be a ParseNode<"styling">. And CD is always displaystyle.
  // So these values are fixed and flow can do implicit typing.
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};

const isStartOfArrow = node => {
  return node.type === "textord" && node.text === "@";
};

const isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};

function cdArrow(arrowChar, labels, parser) {
  // Return a parse tree of an arrow and its labels.
  // This acts in a way similar to a macro expansion.
  const funcName = cdArrowFunctionName[arrowChar];

  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);

    case "\\uparrow":
    case "\\downarrow":
      {
        const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
        const bareArrow = {
          type: "atom",
          text: funcName,
          mode: "math",
          family: "rel"
        };
        const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
        const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
        const arrowGroup = {
          type: "ordgroup",
          mode: "math",
          body: [leftLabel, sizedArrow, rightLabel]
        };
        return parser.callFunction("\\\\cdparent", [arrowGroup], []);
      }

    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);

    case "\\Vert":
      {
        const arrow = {
          type: "textord",
          text: "\\Vert",
          mode: "math"
        };
        return parser.callFunction("\\Big", [arrow], []);
      }

    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}

function parseCD(parser) {
  // Get the array's parse nodes with \\ temporarily mapped to \cr.
  const parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();

  while (true) {
    // eslint-disable-line no-constant-condition
    // Get the parse nodes for the next row.
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    const next = parser.fetch().text;

    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop(); // final row ended in \\
      }

      break;
    } else {
      throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }

  let row = [];
  const body = [row]; // Loop thru the parse nodes. Collect them into cells and arrows.

  for (let i = 0; i < parsedRows.length; i++) {
    // Start a new row.
    const rowNodes = parsedRows[i]; // Create the first cell.

    let cell = newCell();

    for (let j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        // If a parseNode is not an arrow, it goes into a cell.
        cell.body.push(rowNodes[j]);
      } else {
        // Parse node j is an "@", the start of an arrow.
        // Before starting on the arrow, push the cell into `row`.
        row.push(cell); // Now collect parseNodes into an arrow.
        // The character after "@" defines the arrow type.

        j += 1;
        const arrowChar = assertSymbolNodeType(rowNodes[j]).text; // Create two empty label nodes. We may or may not use them.

        const labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }; // Process the arrow.

        if ("=|.".indexOf(arrowChar) > -1) {// Three "arrows", ``@=`, `@|`, and `@.`, do not take labels.
          // Do nothing here.
        } else if ("<>AV".indexOf(arrowChar) > -1) {
          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take
          // two optional labels. E.g. the right-point arrow syntax is
          // really:  @>{optional label}>{optional label}>
          // Collect parseNodes into labels.
          for (let labelNum = 0; labelNum < 2; labelNum++) {
            let inLabel = true;

            for (let k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }

              if (isStartOfArrow(rowNodes[k])) {
                throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
              }

              labels[labelNum].body.push(rowNodes[k]);
            }

            if (inLabel) {
              // isLabelEnd never returned a true.
              throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
            }
          }
        } else {
          throw new src_ParseError("Expected one of \"<>AV=|.\" after @", rowNodes[j]);
        } // Now join the arrow to its labels.


        const arrow = cdArrow(arrowChar, labels, parser); // Wrap the arrow in  ParseNode<"styling">.
        // This is done to match parseArray() behavior.

        const wrappedArrow = {
          type: "styling",
          body: [arrow],
          mode: "math",
          style: "display" // CD is always displaystyle.

        };
        row.push(wrappedArrow); // In CD's syntax, cells are implicit. That is, everything that
        // is not an arrow gets collected into a cell. So create an empty
        // cell now. It will collect upcoming parseNodes.

        cell = newCell();
      }
    }

    if (i % 2 === 0) {
      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell
      // The last cell is not yet pushed into `row`, so:
      row.push(cell);
    } else {
      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow
      // Remove the empty cell that was placed at the beginning of `row`.
      row.shift();
    }

    row = [];
    body.push(row);
  } // End row group


  parser.gullet.endGroup(); // End array group defining \\

  parser.gullet.endGroup(); // define column separation.

  const cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25 // So pre and post each get half an \enskip, i.e. 0.25em.

  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
} // The functions below are not available for general use.
// They are here only for internal use by the {CD} environment in placing labels
// next to vertical arrows.
// We don't need any such functions for horizontal arrows because we can reuse
// the functionality that already exists for extensible arrows.

defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },

  handler(_ref, args) {
    let {
      parser,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },

  htmlBuilder(group, options) {
    const newOptions = options.havingStyle(options.style.sup());
    const label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
    label.classes.push("cd-label-" + group.side);
    label.style.bottom = makeEm(0.8 - label.depth); // Zero out label height & depth, so vertical align of arrow is set
    // by the arrow height, not by the label.

    label.height = 0;
    label.depth = 0;
    return label;
  },

  mathmlBuilder(group, options) {
    let label = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
    label = new mathMLTree.MathNode("mpadded", [label]);
    label.setAttribute("width", "0");

    if (group.side === "left") {
      label.setAttribute("lspace", "-1width");
    } // We have to guess at vertical alignment. We know the arrow is 1.8em tall,
    // But we don't know the height or depth of the label.


    label.setAttribute("voffset", "0.7em");
    label = new mathMLTree.MathNode("mstyle", [label]);
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    return label;
  }

});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },

  handler(_ref2, args) {
    let {
      parser
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },

  htmlBuilder(group, options) {
    // Wrap the vertical arrow and its labels.
    // The parent gets position: relative. The child gets position: absolute.
    // So CSS can locate the label correctly.
    const parent = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },

  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
  }

});
;// CONCATENATED MODULE: ./src/functions/char.js


 // \@char is an internal function that takes a grouped decimal argument like
// {123} and converts into symbol with code 123.  It is used by the *macro*
// \char defined in macros.js.

defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },

  handler(_ref, args) {
    let {
      parser
    } = _ref;
    const arg = assertNodeType(args[0], "ordgroup");
    const group = arg.body;
    let number = "";

    for (let i = 0; i < group.length; i++) {
      const node = assertNodeType(group[i], "textord");
      number += node.text;
    }

    let code = parseInt(number);
    let text;

    if (isNaN(code)) {
      throw new src_ParseError("\\@char has non-numeric argument " + number); // If we drop IE support, the following code could be replaced with
      // text = String.fromCodePoint(code)
    } else if (code < 0 || code >= 0x10ffff) {
      throw new src_ParseError("\\@char with invalid code point " + number);
    } else if (code <= 0xffff) {
      text = String.fromCharCode(code);
    } else {
      // Astral code point; split into surrogate halves
      code -= 0x10000;
      text = String.fromCharCode((code >> 10) + 0xd800, (code & 0x3ff) + 0xdc00);
    }

    return {
      type: "textord",
      mode: parser.mode,
      text: text
    };
  }

});
;// CONCATENATED MODULE: ./src/functions/color.js







const color_htmlBuilder = (group, options) => {
  const elements = buildExpression(group.body, options.withColor(group.color), false); // \color isn't supposed to affect the type of the elements it contains.
  // To accomplish this, we wrap the results in a fragment, so the inner
  // elements will be able to directly interact with their neighbors. For
  // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`

  return buildCommon.makeFragment(elements);
};

const color_mathmlBuilder = (group, options) => {
  const inner = buildMathML_buildExpression(group.body, options.withColor(group.color));
  const node = new mathMLTree.MathNode("mstyle", inner);
  node.setAttribute("mathcolor", group.color);
  return node;
};

defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },

  handler(_ref, args) {
    let {
      parser
    } = _ref;
    const color = assertNodeType(args[0], "color-token").color;
    const body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color,
      body: ordargument(body)
    };
  },

  htmlBuilder: color_htmlBuilder,
  mathmlBuilder: color_mathmlBuilder
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },

  handler(_ref2, args) {
    let {
      parser,
      breakOnTokenText
    } = _ref2;
    const color = assertNodeType(args[0], "color-token").color; // Set macro \current@color in current namespace to store the current
    // color, mimicking the behavior of color.sty.
    // This is currently used just to correctly color a \right
    // that follows a \color command.

    parser.gullet.macros.set("\\current@color", color); // Parse out the implicit body that should be colored.

    const body = parser.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser.mode,
      color,
      body
    };
  },

  htmlBuilder: color_htmlBuilder,
  mathmlBuilder: color_mathmlBuilder
});
;// CONCATENATED MODULE: ./src/functions/cr.js
// Row breaks within tabular environments, and line breaks at top level




 // \DeclareRobustCommand\\{...\@xnewline}

defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },

  handler(_ref, args, optArgs) {
    let {
      parser
    } = _ref;
    const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    const newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline " + "does nothing in display mode");
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    };
  },

  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(group, options) {
    const span = buildCommon.makeSpan(["mspace"], [], options);

    if (group.newLine) {
      span.classes.push("newline");

      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options));
      }
    }

    return span;
  },

  mathmlBuilder(group, options) {
    const node = new mathMLTree.MathNode("mspace");

    if (group.newLine) {
      node.setAttribute("linebreak", "newline");

      if (group.size) {
        node.setAttribute("height", makeEm(calculateSize(group.size, options)));
      }
    }

    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/def.js



const globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};

const checkControlSequence = tok => {
  const name = tok.text;

  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new src_ParseError("Expected a control sequence", tok);
  }

  return name;
};

const getRHS = parser => {
  let tok = parser.gullet.popToken();

  if (tok.text === "=") {
    // consume optional equals
    tok = parser.gullet.popToken();

    if (tok.text === " ") {
      // consume one optional space
      tok = parser.gullet.popToken();
    }
  }

  return tok;
};

const letCommand = (parser, name, tok, global) => {
  let macro = parser.gullet.macros.get(tok.text);

  if (macro == null) {
    // don't expand it later even if a macro with the same name is defined
    // e.g., \let\foo=\frac \def\frac{\relax} \frac12
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }

  parser.gullet.macros.set(name, macro, global);
}; // <assignment> -> <non-macro assignment>|<macro assignment>
// <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
// <macro assignment> -> <definition>|<prefix><macro assignment>
// <prefix> -> \global|\long|\outer


defineFunction({
  type: "internal",
  names: ["\\global", "\\long", "\\\\globallong" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },

  handler(_ref) {
    let {
      parser,
      funcName
    } = _ref;
    parser.consumeSpaces();
    const token = parser.fetch();

    if (globalMap[token.text]) {
      // KaTeX doesn't have \par, so ignore \long
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }

      return assertNodeType(parser.parseFunction(), "internal");
    }

    throw new src_ParseError("Invalid token after macro prefix", token);
  }

}); // Basic support for macro definitions: \def, \gdef, \edef, \xdef
// <definition> -> <def><control sequence><definition text>
// <def> -> \def|\gdef|\edef|\xdef
// <definition text> -> <parameter text><left brace><balanced text><right brace>

defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },

  handler(_ref2) {
    let {
      parser,
      funcName
    } = _ref2;
    let tok = parser.gullet.popToken();
    const name = tok.text;

    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new src_ParseError("Expected a control sequence", tok);
    }

    let numArgs = 0;
    let insert;
    const delimiters = [[]]; // <parameter text> contains no braces

    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();

      if (tok.text === "#") {
        // If the very last character of the <parameter text> is #, so that
        // this # is immediately followed by {, TeX will behave as if the {
        // had been inserted at the right end of both the parameter text
        // and the replacement text.
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters[numArgs].push("{");
          break;
        } // A parameter, the first appearance of # must be followed by 1,
        // the next by 2, and so on; up to nine #’s are allowed


        tok = parser.gullet.popToken();

        if (!/^[1-9]$/.test(tok.text)) {
          throw new src_ParseError("Invalid argument number \"" + tok.text + "\"");
        }

        if (parseInt(tok.text) !== numArgs + 1) {
          throw new src_ParseError("Argument number \"" + tok.text + "\" out of order");
        }

        numArgs++;
        delimiters.push([]);
      } else if (tok.text === "EOF") {
        throw new src_ParseError("Expected a macro definition");
      } else {
        delimiters[numArgs].push(tok.text);
      }
    } // replacement text, enclosed in '{' and '}' and properly nested


    let {
      tokens
    } = parser.gullet.consumeArg();

    if (insert) {
      tokens.unshift(insert);
    }

    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      tokens.reverse(); // to fit in with stack order
    } // Final arg is the expansion of the macro


    parser.gullet.macros.set(name, {
      tokens,
      numArgs,
      delimiters
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser.mode
    };
  }

}); // <simple assignment> -> <let assignment>
// <let assignment> -> \futurelet<control sequence><token><token>
//     | \let<control sequence><equals><one optional space><token>
// <equals> -> <optional spaces>|<optional spaces>=

defineFunction({
  type: "internal",
  names: ["\\let", "\\\\globallet" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },

  handler(_ref3) {
    let {
      parser,
      funcName
    } = _ref3;
    const name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    const tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser.mode
    };
  }

}); // ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf

defineFunction({
  type: "internal",
  names: ["\\futurelet", "\\\\globalfuture" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },

  handler(_ref4) {
    let {
      parser,
      funcName
    } = _ref4;
    const name = checkControlSequence(parser.gullet.popToken());
    const middle = parser.gullet.popToken();
    const tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser.mode
    };
  }

});
;// CONCATENATED MODULE: ./src/delimiter.js
/**
 * This file deals with creating delimiters of various sizes. The TeXbook
 * discusses these routines on page 441-442, in the "Another subroutine sets box
 * x to a specified variable delimiter" paragraph.
 *
 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
 * normal font, but in either text, script, or scriptscript style.
 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
 * smaller pieces that are stacked on top of one another.
 *
 * The functions take a parameter `center`, which determines if the delimiter
 * should be centered around the axis.
 *
 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
 * one of the given sizes. This is used for things like `\bigl`.
 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
 * delimiter which surrounds an expression of a given height an depth. It is
 * used in `\left` and `\right`.
 */











/**
 * Get the metrics for a given symbol and font, after transformation (i.e.
 * after following replacement from symbols.js)
 */
const getMetrics = function (symbol, font, mode) {
  const replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
  const metrics = getCharacterMetrics(replace || symbol, font, mode);

  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }

  return metrics;
};
/**
 * Puts a delimiter span in a given style, and adds appropriate height, depth,
 * and maxFontSizes.
 */


const styleWrap = function (delim, toStyle, options, classes) {
  const newOptions = options.havingBaseStyle(toStyle);
  const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
  const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};

const centerSpan = function (span, options, style) {
  const newOptions = options.havingBaseStyle(style);
  const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift);
  span.height -= shift;
  span.depth += shift;
};
/**
 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
 * font, but is restyled to either be in textstyle, scriptstyle, or
 * scriptscriptstyle.
 */


const makeSmallDelim = function (delim, style, center, options, mode, classes) {
  const text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
  const span = styleWrap(text, style, options, classes);

  if (center) {
    centerSpan(span, options, style);
  }

  return span;
};
/**
 * Builds a symbol in the given font size (note size is an integer)
 */


const mathrmSize = function (value, size, mode, options) {
  return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
};
/**
 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
 * Size3, or Size4 fonts. It is always rendered in textstyle.
 */


const makeLargeDelim = function (delim, size, center, options, mode, classes) {
  const inner = mathrmSize(delim, size, mode, options);
  const span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), src_Style.TEXT, options, classes);

  if (center) {
    centerSpan(span, options, src_Style.TEXT);
  }

  return span;
};
/**
 * Make a span from a font glyph with the given offset and in the given font.
 * This is used in makeStackedDelim to make the stacking pieces for the delimiter.
 */


const makeGlyphSpan = function (symbol, font, mode) {
  let sizeClass; // Apply the correct CSS class to choose the right font.

  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else
    /* if (font === "Size4-Regular") */
    {
      sizeClass = "delim-size4";
    }

  const corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element
  // in the appropriate tag that VList uses.

  return {
    type: "elem",
    elem: corner
  };
};

const makeInner = function (ch, height, options) {
  // Create a span with inline SVG for the inner part of a tall stacked delimiter.
  const width = fontMetricsData['Size4-Regular'][ch.charCodeAt(0)] ? fontMetricsData['Size4-Regular'][ch.charCodeAt(0)][4] : fontMetricsData['Size1-Regular'][ch.charCodeAt(0)][4];
  const path = new PathNode("inner", innerPath(ch, Math.round(1000 * height)));
  const svgNode = new SvgNode([path], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1000 * width + " " + Math.round(1000 * height),
    "preserveAspectRatio": "xMinYMin"
  });
  const span = buildCommon.makeSvgSpan([], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return {
    type: "elem",
    elem: span
  };
}; // Helpers for makeStackedDelim


const lapInEms = 0.008;
const lap = {
  type: "kern",
  size: -1 * lapInEms
};
const verts = ["|", "\\lvert", "\\rvert", "\\vert"];
const doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
/**
 * Make a stacked delimiter out of a given delimiter, with the total height at
 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
 */

const makeStackedDelim = function (delim, heightTotal, center, options, mode, classes) {
  // There are four parts, the top, an optional middle, a repeated part, and a
  // bottom.
  let top;
  let middle;
  let repeat;
  let bottom;
  let svgLabel = "";
  let viewBoxWidth = 0;
  top = repeat = bottom = delim;
  middle = null; // Also keep track of what font the delimiters are in

  let font = "Size1-Regular"; // We set the parts and font based on the symbol. Note that we use
  // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
  // repeats of the arrows

  if (delim === "\\uparrow") {
    repeat = bottom = "\u23d0";
  } else if (delim === "\\Uparrow") {
    repeat = bottom = "\u2016";
  } else if (delim === "\\downarrow") {
    top = repeat = "\u23d0";
  } else if (delim === "\\Downarrow") {
    top = repeat = "\u2016";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat = "\u23d0";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat = "\u2016";
    bottom = "\\Downarrow";
  } else if (utils.contains(verts, delim)) {
    repeat = "\u2223";
    svgLabel = "vert";
    viewBoxWidth = 333;
  } else if (utils.contains(doubleVerts, delim)) {
    repeat = "\u2225";
    svgLabel = "doublevert";
    viewBoxWidth = 556;
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "\u23a1";
    repeat = "\u23a2";
    bottom = "\u23a3";
    font = "Size4-Regular";
    svgLabel = "lbrack";
    viewBoxWidth = 667;
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "\u23a4";
    repeat = "\u23a5";
    bottom = "\u23a6";
    font = "Size4-Regular";
    svgLabel = "rbrack";
    viewBoxWidth = 667;
  } else if (delim === "\\lfloor" || delim === "\u230a") {
    repeat = top = "\u23a2";
    bottom = "\u23a3";
    font = "Size4-Regular";
    svgLabel = "lfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\lceil" || delim === "\u2308") {
    top = "\u23a1";
    repeat = bottom = "\u23a2";
    font = "Size4-Regular";
    svgLabel = "lceil";
    viewBoxWidth = 667;
  } else if (delim === "\\rfloor" || delim === "\u230b") {
    repeat = top = "\u23a5";
    bottom = "\u23a6";
    font = "Size4-Regular";
    svgLabel = "rfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\rceil" || delim === "\u2309") {
    top = "\u23a4";
    repeat = bottom = "\u23a5";
    font = "Size4-Regular";
    svgLabel = "rceil";
    viewBoxWidth = 667;
  } else if (delim === "(" || delim === "\\lparen") {
    top = "\u239b";
    repeat = "\u239c";
    bottom = "\u239d";
    font = "Size4-Regular";
    svgLabel = "lparen";
    viewBoxWidth = 875;
  } else if (delim === ")" || delim === "\\rparen") {
    top = "\u239e";
    repeat = "\u239f";
    bottom = "\u23a0";
    font = "Size4-Regular";
    svgLabel = "rparen";
    viewBoxWidth = 875;
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "\u23a7";
    middle = "\u23a8";
    bottom = "\u23a9";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "\u23ab";
    middle = "\u23ac";
    bottom = "\u23ad";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "\u27ee") {
    top = "\u23a7";
    bottom = "\u23a9";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "\u27ef") {
    top = "\u23ab";
    bottom = "\u23ad";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "\u23b0") {
    top = "\u23a7";
    bottom = "\u23ad";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "\u23b1") {
    top = "\u23ab";
    bottom = "\u23a9";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } // Get the metrics of the four sections


  const topMetrics = getMetrics(top, font, mode);
  const topHeightTotal = topMetrics.height + topMetrics.depth;
  const repeatMetrics = getMetrics(repeat, font, mode);
  const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  const bottomMetrics = getMetrics(bottom, font, mode);
  const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  let middleHeightTotal = 0;
  let middleFactor = 1;

  if (middle !== null) {
    const middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2; // repeat symmetrically above and below middle
  } // Calculate the minimal height that the delimiter can have.
  // It is at least the size of the top, bottom, and optional middle combined.


  const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need

  const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols

  const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note
  // that in this context, "center" means that the delimiter should be
  // centered around the axis in the current style, while normally it is
  // centered around the axis in textstyle.

  let axisHeight = options.fontMetrics().axisHeight;

  if (center) {
    axisHeight *= options.sizeMultiplier;
  } // Calculate the depth


  const depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist
  // Keep a list of the pieces of the stacked delimiter

  const stack = [];

  if (svgLabel.length > 0) {
    // Instead of stacking glyphs, create a single SVG.
    // This evades browser problems with imprecise positioning of spans.
    const midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
    const viewBoxHeight = Math.round(realHeightTotal * 1000);
    const pathStr = tallDelim(svgLabel, Math.round(midHeight * 1000));
    const path = new PathNode(svgLabel, pathStr);
    const width = (viewBoxWidth / 1000).toFixed(3) + "em";
    const height = (viewBoxHeight / 1000).toFixed(3) + "em";
    const svg = new SvgNode([path], {
      "width": width,
      "height": height,
      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
    });
    const wrapper = buildCommon.makeSvgSpan([], [svg], options);
    wrapper.height = viewBoxHeight / 1000;
    wrapper.style.width = width;
    wrapper.style.height = height;
    stack.push({
      type: "elem",
      elem: wrapper
    });
  } else {
    // Stack glyphs
    // Start by adding the bottom symbol
    stack.push(makeGlyphSpan(bottom, font, mode));
    stack.push(lap); // overlap

    if (middle === null) {
      // The middle section will be an SVG. Make it an extra 0.016em tall.
      // We'll overlap by 0.008em at top and bottom.
      const innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
      stack.push(makeInner(repeat, innerHeight, options));
    } else {
      // When there is a middle bit, we need the middle part and two repeated
      // sections
      const innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
      stack.push(makeInner(repeat, innerHeight, options)); // Now insert the middle of the brace.

      stack.push(lap);
      stack.push(makeGlyphSpan(middle, font, mode));
      stack.push(lap);
      stack.push(makeInner(repeat, innerHeight, options));
    } // Add the top symbol


    stack.push(lap);
    stack.push(makeGlyphSpan(top, font, mode));
  } // Finally, build the vlist


  const newOptions = options.havingBaseStyle(src_Style.TEXT);
  const inner = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), src_Style.TEXT, options, classes);
}; // All surds have 0.08em padding above the vinculum inside the SVG.
// That keeps browser span height rounding error from pinching the line.


const vbPad = 80; // padding above the surd, measured inside the viewBox.

const emPad = 0.08; // padding, in ems, measured in the document.

const sqrtSvg = function (sqrtName, height, viewBoxHeight, extraVinculum, options) {
  const path = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
  const pathNode = new PathNode(sqrtName, path);
  const svg = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": makeEm(height),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
};
/**
 * Make a sqrt image of the given height,
 */


const makeSqrtImage = function (height, options) {
  // Define a newOptions that removes the effect of size changes such as \Huge.
  // We don't pick different a height surd for \Huge. For it, we scale up.
  const newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.

  const delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  let sizeMultiplier = newOptions.sizeMultiplier; // default
  // The standard sqrt SVGs each have a 0.04em thick vinculum.
  // If Settings.minRuleThickness is larger than that, we add extraVinculum.

  const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.

  let span;
  let spanHeight = 0;
  let texHeight = 0;
  let viewBoxHeight = 0;
  let advanceWidth; // We create viewBoxes with 80 units of "padding" above each surd.
  // Then browser rounding error on the parent span height will not
  // encroach on the ink of the vinculum. But that padding is not
  // included in the TeX-like `height` used for calculation of
  // vertical alignment. So texHeight = span.height < span.style.height.

  if (delim.type === "small") {
    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.
    // 1000 unit normal glyph height.
    viewBoxHeight = 1000 + 1000 * extraVinculum + vbPad;

    if (height < 1.0) {
      sizeMultiplier = 1.0; // mimic a \textfont radical
    } else if (height < 1.4) {
      sizeMultiplier = 0.7; // mimic a \scriptfont radical
    }

    spanHeight = (1.0 + extraVinculum + emPad) / sizeMultiplier;
    texHeight = (1.00 + extraVinculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier; // from the font.
  } else if (delim.type === "large") {
    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.
    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "1.02em";
    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.
  } else {
    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.
    // We'll use a single SVG to accomplish the same thing.
    spanHeight = height + extraVinculum + emPad;
    texHeight = height + extraVinculum;
    viewBoxHeight = Math.floor(1000 * height + extraVinculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }

  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
  };
}; // There are three kinds of delimiters, delimiters that stack when they become
// too large


const stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"]; // delimiters that always stack

const stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1"]; // and delimiters that never stack

const stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"]; // Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.

const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];
/**
 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
 */

const makeSizedDelim = function (delim, size, options, mode, classes) {
  // < and > turn into \langle and \rangle in delimiters
  if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
    delim = "\\rangle";
  } // Sized delimiters are never centered.


  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
    return makeLargeDelim(delim, size, false, options, mode, classes);
  } else if (utils.contains(stackAlwaysDelimiters, delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
  } else {
    throw new src_ParseError("Illegal delimiter: '" + delim + "'");
  }
};
/**
 * There are three different sequences of delimiter sizes that the delimiters
 * follow depending on the kind of delimiter. This is used when creating custom
 * sized delimiters to decide whether to create a small, large, or stacked
 * delimiter.
 *
 * In real TeX, these sequences aren't explicitly defined, but are instead
 * defined inside the font metrics. Since there are only three sequences that
 * are possible for the delimiters that TeX defines, it is easier to just encode
 * them explicitly here.
 */


// Delimiters that never stack try small delimiters and large delimiters only
const stackNeverDelimiterSequence = [{
  type: "small",
  style: src_Style.SCRIPTSCRIPT
}, {
  type: "small",
  style: src_Style.SCRIPT
}, {
  type: "small",
  style: src_Style.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}]; // Delimiters that always stack try the small delimiters first, then stack

const stackAlwaysDelimiterSequence = [{
  type: "small",
  style: src_Style.SCRIPTSCRIPT
}, {
  type: "small",
  style: src_Style.SCRIPT
}, {
  type: "small",
  style: src_Style.TEXT
}, {
  type: "stack"
}]; // Delimiters that stack when large try the small and then large delimiters, and
// stack afterwards

const stackLargeDelimiterSequence = [{
  type: "small",
  style: src_Style.SCRIPTSCRIPT
}, {
  type: "small",
  style: src_Style.SCRIPT
}, {
  type: "small",
  style: src_Style.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
/**
 * Get the font used in a delimiter based on what kind of delimiter it is.
 * TODO(#963) Use more specific font family return type once that is introduced.
 */

const delimTypeToFont = function (type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
/**
 * Traverse a sequence of types of delimiters to decide what kind of delimiter
 * should be used to create a delimiter of the given height+depth.
 */


const traverseSequence = function (delim, height, sequence, options) {
  // Here, we choose the index we should start at in the sequences. In smaller
  // sizes (which correspond to larger numbers in style.size) we start earlier
  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
  const start = Math.min(2, 3 - options.style.size);

  for (let i = start; i < sequence.length; i++) {
    if (sequence[i].type === "stack") {
      // This is always the last delimiter, so we just break the loop now.
      break;
    }

    const metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
    let heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we
    // account for the style change size.

    if (sequence[i].type === "small") {
      const newOptions = options.havingBaseStyle(sequence[i].style);
      heightDepth *= newOptions.sizeMultiplier;
    } // Check if the delimiter at this size works for the given height.


    if (heightDepth > height) {
      return sequence[i];
    }
  } // If we reached the end of the sequence, return the last sequence element.


  return sequence[sequence.length - 1];
};
/**
 * Make a delimiter of a given height+depth, with optional centering. Here, we
 * traverse the sequences, and create a delimiter that the sequence tells us to.
 */


const makeCustomSizedDelim = function (delim, height, center, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
    delim = "\\rangle";
  } // Decide what sequence to use


  let sequence;

  if (utils.contains(stackNeverDelimiters, delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (utils.contains(stackLargeDelimiters, delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  } // Look through the sequence


  const delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.
  // Depending on the sequence element we decided on, call the
  // appropriate function.

  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
  } else
    /* if (delimType.type === "stack") */
    {
      return makeStackedDelim(delim, height, center, options, mode, classes);
    }
};
/**
 * Make a delimiter for use with `\left` and `\right`, given a height and depth
 * of an expression that the delimiters surround.
 */


const makeLeftRightDelim = function (delim, height, depth, options, mode, classes) {
  // We always center \left/\right delimiters, so the axis is always shifted
  const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right

  const delimiterFactor = 901;
  const delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;
  const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  const totalHeight = Math.max( // In real TeX, calculations are done using integral values which are
  // 65536 per pt, or 655360 per em. So, the division here truncates in
  // TeX but doesn't here, producing different results. If we wanted to
  // exactly match TeX's calculation, we could do
  //   Math.floor(655360 * maxDistFromAxis / 500) *
  //    delimiterFactor / 655360
  // (To see the difference, compare
  //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
  // in TeX and KaTeX)
  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total
  // height

  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
};

/* harmony default export */ var delimiter = ({
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight: sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
});
;// CONCATENATED MODULE: ./src/functions/delimsizing.js










// Extra data needed for the delimiter handler down below
const delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
const delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27e8", "\\rangle", "\u27e9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];

// Delimiter functions
function checkDelimiter(delim, context) {
  const symDelim = checkSymbolNodeType(delim);

  if (symDelim && utils.contains(delimiters, symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
  } else {
    throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
  }
}

defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    if (group.delim === ".") {
      // Empty delimiters still count as elements, even though they don't
      // show anything.
      return buildCommon.makeSpan([group.mclass]);
    } // Use delimiter.sizedDelim to generate the delimiter.


    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
  },
  mathmlBuilder: group => {
    const children = [];

    if (group.delim !== ".") {
      children.push(makeText(group.delim, group.mode));
    }

    const node = new mathMLTree.MathNode("mo", children);

    if (group.mclass === "mopen" || group.mclass === "mclose") {
      // Only some of the delimsizing functions act as fences, and they
      // return "mopen" or "mclose" mclass.
      node.setAttribute("fence", "true");
    } else {
      // Explicitly disable fencing if it's not a fence, to override the
      // defaults.
      node.setAttribute("fence", "false");
    }

    node.setAttribute("stretchy", "true");
    const size = makeEm(delimiter.sizeToMaxHeight[group.size]);
    node.setAttribute("minsize", size);
    node.setAttribute("maxsize", size);
    return node;
  }
});

function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}

defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    // \left case below triggers parsing of \right in
    //   `const right = parser.parseFunction();`
    // uses this return value.
    const color = context.parser.gullet.macros.get("\\current@color");

    if (color && typeof color !== "string") {
      throw new src_ParseError("\\current@color set to non-string in \\right");
    }

    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text,
      color // undefined if not set via \color

    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);
    const parser = context.parser; // Parse out the implicit body

    ++parser.leftrightDepth; // parseExpression stops before '\\right'

    const body = parser.parseExpression(false);
    --parser.leftrightDepth; // Check the next token

    parser.expect("\\right", false);
    const right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim,
      rightColor: right.color
    };
  },
  htmlBuilder: (group, options) => {
    assertParsed(group); // Build the inner expression

    const inner = buildExpression(group.body, options, true, ["mopen", "mclose"]);
    let innerHeight = 0;
    let innerDepth = 0;
    let hadMiddle = false; // Calculate its height and depth

    for (let i = 0; i < inner.length; i++) {
      // Property `isMiddle` not defined on `span`. See comment in
      // "middle"'s htmlBuilder.
      // $FlowFixMe
      if (inner[i].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner[i].height, innerHeight);
        innerDepth = Math.max(inner[i].depth, innerDepth);
      }
    } // The size of delimiters is the same, regardless of what style we are
    // in. Thus, to correctly calculate the size of delimiter we need around
    // a group, we scale down the inner size based on the size.


    innerHeight *= options.sizeMultiplier;
    innerDepth *= options.sizeMultiplier;
    let leftDelim;

    if (group.left === ".") {
      // Empty delimiters in \left and \right make null delimiter spaces.
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      // Otherwise, use leftRightDelim to generate the correct sized
      // delimiter.
      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
    } // Add it to the beginning of the expression


    inner.unshift(leftDelim); // Handle middle delimiters

    if (hadMiddle) {
      for (let i = 1; i < inner.length; i++) {
        const middleDelim = inner[i]; // Property `isMiddle` not defined on `span`. See comment in
        // "middle"'s htmlBuilder.
        // $FlowFixMe

        const isMiddle = middleDelim.isMiddle;

        if (isMiddle) {
          // Apply the options that were active when \middle was called
          inner[i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }

    let rightDelim; // Same for the right delimiter, but using color specified by \color

    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    } // Add it to the end of the expression.


    inner.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner, options);
  },
  mathmlBuilder: (group, options) => {
    assertParsed(group);
    const inner = buildMathML_buildExpression(group.body, options);

    if (group.left !== ".") {
      const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner.unshift(leftNode);
    }

    if (group.right !== ".") {
      const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");

      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }

      inner.push(rightNode);
    }

    return makeRow(inner);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    if (!context.parser.leftrightDepth) {
      throw new src_ParseError("\\middle without preceding \\left", delim);
    }

    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    let middleDelim;

    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options, []);
    } else {
      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
      const isMiddle = {
        delim: group.delim,
        options
      }; // Property `isMiddle` not defined on `span`. It is only used in
      // this file above.
      // TODO: Fix this violation of the `span` type and possibly rename
      // things since `isMiddle` sounds like a boolean, but is a struct.
      // $FlowFixMe

      middleDelim.isMiddle = isMiddle;
    }

    return middleDelim;
  },
  mathmlBuilder: (group, options) => {
    // A Firefox \middle will stretch a character vertically only if it
    // is in the fence part of the operator dictionary at:
    // https://www.w3.org/TR/MathML3/appendixc.html.
    // So we need to avoid U+2223 and use plain "|" instead.
    const textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    const middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true"); // MathML gives 5/18em spacing to each <mo> element.
    // \middle should get delimiter spacing instead.

    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
;// CONCATENATED MODULE: ./src/functions/enclose.js












const enclose_htmlBuilder = (group, options) => {
  // \cancel, \bcancel, \xcancel, \sout, \fbox, \colorbox, \fcolorbox, \phase
  // Some groups can return document fragments.  Handle those by wrapping
  // them in a span.
  const inner = buildCommon.wrapFragment(buildGroup(group.body, options), options);
  const label = group.label.slice(1);
  let scale = options.sizeMultiplier;
  let img;
  let imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different
  // depending on whether the subject is wider than it is tall, or vice versa.
  // We don't know the width of a group, so as a proxy, we test if
  // the subject is a single character. This captures most of the
  // subjects that should get the "tall" treatment.

  const isSingleChar = utils.isCharacterBox(group.body);

  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options.fontMetrics().xHeight;
  } else if (label === "phase") {
    // Set a couple of dimensions from the steinmetz package.
    const lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options);
    const clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options); // Prevent size changes like \Huge from affecting line thickness

    const newOptions = options.havingBaseSizing();
    scale = scale / newOptions.sizeMultiplier;
    const angleHeight = inner.height + inner.depth + lineWeight + clearance; // Reserve a left pad for the angle.

    inner.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight); // Create an SVG

    const viewBoxHeight = Math.floor(1000 * angleHeight * scale);
    const path = phasePath(viewBoxHeight);
    const svgNode = new SvgNode([new PathNode("phase", path)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1000),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    }); // Wrap it in a span with overflow: hidden.

    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
    img.style.height = makeEm(angleHeight);
    imgShift = inner.depth + lineWeight + clearance;
  } else {
    // Add horizontal padding
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner.classes.push("cancel-pad");
      }
    } else if (label === "angl") {
      inner.classes.push("anglpad");
    } else {
      inner.classes.push("boxpad");
    } // Add vertical padding


    let topPad = 0;
    let bottomPad = 0;
    let ruleThickness = 0; // ref: cancel package: \advance\totalheight2\p@ % "+2"

    if (/box/.test(label)) {
      ruleThickness = Math.max(options.fontMetrics().fboxrule, // default
      options.minRuleThickness // User override.
      );
      topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label === "angl") {
      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      topPad = 4 * ruleThickness; // gap = 3 × line, plus the line itself.

      bottomPad = Math.max(0, 0.25 - inner.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }

    img = stretchy.encloseSpan(inner, label, topPad, bottomPad, options);

    if (/fbox|boxed|fcolorbox/.test(label)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }

    imgShift = inner.depth + bottomPad;

    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;

      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }

  let vlist;

  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [// Put the color background behind inner;
      {
        type: "elem",
        elem: img,
        shift: imgShift
      }, {
        type: "elem",
        elem: inner,
        shift: 0
      }]
    }, options);
  } else {
    const classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [// Write the \cancel stroke on top of inner.
      {
        type: "elem",
        elem: inner,
        shift: 0
      }, {
        type: "elem",
        elem: img,
        shift: imgShift,
        wrapperClasses: classes
      }]
    }, options);
  }

  if (/cancel/.test(label)) {
    // The cancel package documentation says that cancel lines add their height
    // to the expression, but tests show that isn't how it actually works.
    vlist.height = inner.height;
    vlist.depth = inner.depth;
  }

  if (/cancel/.test(label) && !isSingleChar) {
    // cancel does not create horiz space for its line extension.
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options);
  }
};

const enclose_mathmlBuilder = (group, options) => {
  let fboxsep = 0;
  const node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);

  switch (group.label) {
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      break;

    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      break;

    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      break;

    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      break;

    case "\\fbox":
      node.setAttribute("notation", "box");
      break;

    case "\\angl":
      node.setAttribute("notation", "actuarial");
      break;

    case "\\fcolorbox":
    case "\\colorbox":
      // <menclose> doesn't have a good notation option. So use <mpadded>
      // instead. Set some attributes that come included with <menclose>.
      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
      node.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node.setAttribute("lspace", fboxsep + "pt"); //

      node.setAttribute("voffset", fboxsep + "pt");

      if (group.label === "\\fcolorbox") {
        const thk = Math.max(options.fontMetrics().fboxrule, // default
        options.minRuleThickness // user override
        );
        node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }

      break;

    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }

  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }

  return node;
};

defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },

  handler(_ref, args, optArgs) {
    let {
      parser,
      funcName
    } = _ref;
    const color = assertNodeType(args[0], "color-token").color;
    const body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },

  htmlBuilder: enclose_htmlBuilder,
  mathmlBuilder: enclose_mathmlBuilder
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },

  handler(_ref2, args, optArgs) {
    let {
      parser,
      funcName
    } = _ref2;
    const borderColor = assertNodeType(args[0], "color-token").color;
    const backgroundColor = assertNodeType(args[1], "color-token").color;
    const body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },

  htmlBuilder: enclose_htmlBuilder,
  mathmlBuilder: enclose_mathmlBuilder
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },

  handler(_ref3, args) {
    let {
      parser
    } = _ref3;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }

});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },

  handler(_ref4, args) {
    let {
      parser,
      funcName
    } = _ref4;
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },

  htmlBuilder: enclose_htmlBuilder,
  mathmlBuilder: enclose_mathmlBuilder
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },

  handler(_ref5, args) {
    let {
      parser
    } = _ref5;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\angl",
      body: args[0]
    };
  }

});
;// CONCATENATED MODULE: ./src/defineEnvironment.js


/**
 * All registered environments.
 * `environments.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `environments.js`.
 */
const _environments = {};
function defineEnvironment(_ref) {
  let {
    type,
    names,
    props,
    handler,
    htmlBuilder,
    mathmlBuilder
  } = _ref;
  // Set default values of environments.
  const data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };

  for (let i = 0; i < names.length; ++i) {
    // TODO: The value type of _environments should be a type union of all
    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is
    // an existential type.
    _environments[names[i]] = data;
  }

  if (htmlBuilder) {
    _htmlGroupBuilders[type] = htmlBuilder;
  }

  if (mathmlBuilder) {
    _mathmlGroupBuilders[type] = mathmlBuilder;
  }
}
;// CONCATENATED MODULE: ./src/defineMacro.js


/**
 * All registered global/built-in macros.
 * `macros.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `macros.js`.
 */
const _macros = {}; // This function might one day accept an additional argument and do more things.

function defineMacro(name, body) {
  _macros[name] = body;
}
;// CONCATENATED MODULE: ./src/SourceLocation.js
/**
 * Lexing or parsing positional information for error reporting.
 * This object is immutable.
 */
class SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(lexer, start, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start;
    this.end = end;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */


  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }

}
;// CONCATENATED MODULE: ./src/Token.js

/**
 * Interface required to break circular dependency between Token, Lexer, and
 * ParseError.
 */

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information is optional, so it is OK to construct synthetic
 * tokens if appropriate. Not providing available position information may
 * lead to degraded error reporting, though.
 */
class Token {
  // don't expand the token
  // used in \noexpand
  constructor(text, // the text of this token
  loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */


  range(endToken, // last token of the range, inclusive
  text // the text of the newly constructed token
  ) {
    return new Token(text, SourceLocation.range(this, endToken));
  }

}
;// CONCATENATED MODULE: ./src/environments/array.js
















// Helper functions
function getHLines(parser) {
  // Return an array. The array length = number of hlines.
  // Each element in the array tells if the line is dashed.
  const hlineInfo = [];
  parser.consumeSpaces();
  let nxt = parser.fetch().text;

  if (nxt === "\\relax") {
    // \relax is an artifact of the \cr macro below
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }

  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }

  return hlineInfo;
}

const validateAmsEnvironmentContext = context => {
  const settings = context.parser.settings;

  if (!settings.displayMode) {
    throw new src_ParseError("{" + context.envName + "} can be used only in" + " display mode.");
  }
}; // autoTag (an argument to parseArray) can be one of three values:
// * undefined: Regular (not-top-level) array; no tags on each row
// * true: Automatic equation numbering, overridable by \tag
// * false: Tags allowed on each row, but no automatic numbering
// This function *doesn't* work with the "split" environment name.


function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  } // return undefined;

}
/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.  If given an optional argument style
 * ("text", "display", etc.), then each cell is cast into that style.
 */


function parseArray(parser, _ref, style) {
  let {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    autoTag,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser.gullet.beginGroup();

  if (!singleRow) {
    // \cr is equivalent to \\ without the optional size argument (see below)
    // TODO: provide helpful error when \cr is used outside array environment
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  } // Get current arraystretch if it's not set by the environment


  if (!arraystretch) {
    const stretch = parser.gullet.expandMacroAsText("\\arraystretch");

    if (stretch == null) {
      // Default \arraystretch from lttab.dtx
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);

      if (!arraystretch || arraystretch < 0) {
        throw new src_ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  } // Start group for first cell


  parser.gullet.beginGroup();
  let row = [];
  const body = [row];
  const rowGaps = [];
  const hLinesBeforeRow = [];
  const tags = autoTag != null ? [] : undefined; // amsmath uses \global\@eqnswtrue and \global\@eqnswfalse to represent
  // whether this row should have an equation number.  Simulate this with
  // a \@eqnsw macro set to 1 or 0.

  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }

  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", undefined, true);
      } else {
        tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }

  beginRow(); // Test for \hline at the top of the array.

  hLinesBeforeRow.push(getHLines(parser));

  while (true) {
    // eslint-disable-line no-constant-condition
    // Parse each cell in its own group (namespace)
    let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell
    };

    if (style) {
      cell = {
        type: "styling",
        mode: parser.mode,
        style,
        body: [cell]
      };
    }

    row.push(cell);
    const next = parser.fetch().text;

    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          // {equation} or {split}
          throw new src_ParseError("Too many tab characters: &", parser.nextToken);
        } else {
          // {array} environment
          parser.settings.reportNonstrict("textEnv", "Too few columns " + "specified in the {array} column argument.");
        }
      }

      parser.consume();
    } else if (next === "\\end") {
      endRow(); // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
      // the last line is empty.  However, AMS environments keep the
      // empty row if it's the only one.
      // NOTE: Currently, `cell` is the last item added into `row`.

      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }

      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }

      break;
    } else if (next === "\\\\") {
      parser.consume();
      let size; // \def\Let@{\let\\\math@cr}
      // \def\math@cr{...\math@cr@}
      // \def\math@cr@{\new@ifnextchar[\math@cr@@{\math@cr@@[\z@]}}
      // \def\math@cr@@[#1]{...\math@cr@@@...}
      // \def\math@cr@@@{\cr}

      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }

      rowGaps.push(size ? size.value : null);
      endRow(); // check for \hline(s) following the row separator

      hLinesBeforeRow.push(getHLines(parser));
      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
    }
  } // End cell group


  parser.gullet.endGroup(); // End array group defining \cr

  parser.gullet.endGroup();
  return {
    type: "array",
    mode: parser.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    tags,
    leqno
  };
} // Decides on a style for cells in an array according to whether the given
// environment name starts with the letter 'd'.


function dCellStyle(envName) {
  if (envName.slice(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}

const array_htmlBuilder = function (group, options) {
  let r;
  let c;
  const nr = group.body.length;
  const hLinesBeforeRow = group.hLinesBeforeRow;
  let nc = 0;
  let body = new Array(nr);
  const hlines = [];
  const ruleThickness = Math.max( // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
  options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.
  ); // Horizontal spacing

  const pt = 1 / options.fontMetrics().ptPerEm;
  let arraycolsep = 5 * pt; // default value, i.e. \arraycolsep in article.cls

  if (group.colSeparationType && group.colSeparationType === "small") {
    // We're in a {smallmatrix}. Default column space is \thickspace,
    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.
    // But that needs adjustment because LaTeX applies \scriptstyle to the
    // entire array, including the colspace, but this function applies
    // \scriptstyle only inside each element.
    const localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
  } // Vertical spacing


  const baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options) : 12 * pt; // see size10.clo
  // Default \jot from ltmath.dtx
  // TODO(edemaine): allow overriding \jot via \setlength (#687)

  const jot = 3 * pt;
  const arrayskip = group.arraystretch * baselineskip;
  const arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and

  const arstrutDepth = 0.3 * arrayskip; // \@arstrutbox in lttab.dtx

  let totalHeight = 0; // Set a position for \hline(s) at the top of the array, if any.

  function setHLinePos(hlinesInGap) {
    for (let i = 0; i < hlinesInGap.length; ++i) {
      if (i > 0) {
        totalHeight += 0.25;
      }

      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i]
      });
    }
  }

  setHLinePos(hLinesBeforeRow[0]);

  for (r = 0; r < group.body.length; ++r) {
    const inrow = group.body[r];
    let height = arstrutHeight; // \@array adds an \@arstrut

    let depth = arstrutDepth; // to each tow (via the template)

    if (nc < inrow.length) {
      nc = inrow.length;
    }

    const outrow = new Array(inrow.length);

    for (c = 0; c < inrow.length; ++c) {
      const elt = buildGroup(inrow[c], options);

      if (depth < elt.depth) {
        depth = elt.depth;
      }

      if (height < elt.height) {
        height = elt.height;
      }

      outrow[c] = elt;
    }

    const rowGap = group.rowGaps[r];
    let gap = 0;

    if (rowGap) {
      gap = calculateSize(rowGap, options);

      if (gap > 0) {
        // \@argarraycr
        gap += arstrutDepth;

        if (depth < gap) {
          depth = gap; // \@xargarraycr
        }

        gap = 0;
      }
    } // In AMS multiline environments such as aligned and gathered, rows
    // correspond to lines that have additional \jot added to the
    // \baselineskip via \openup.


    if (group.addJot) {
      depth += jot;
    }

    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap; // \@yargarraycr

    body[r] = outrow; // Set a position for \hline(s), if any.

    setHLinePos(hLinesBeforeRow[r + 1]);
  }

  const offset = totalHeight / 2 + options.fontMetrics().axisHeight;
  const colDescriptions = group.cols || [];
  const cols = [];
  let colSep;
  let colDescrNum;
  const tagSpans = [];

  if (group.tags && group.tags.some(tag => tag)) {
    // An environment with manual tags and/or automatic equation numbers.
    // Create node(s), the latter of which trigger CSS counter increment.
    for (r = 0; r < nr; ++r) {
      const rw = body[r];
      const shift = rw.pos - offset;
      const tag = group.tags[r];
      let tagSpan;

      if (tag === true) {
        // automatic numbering
        tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
      } else if (tag === false) {
        // \nonumber/\notag or starred environment
        tagSpan = buildCommon.makeSpan([], [], options);
      } else {
        // manual \tag
        tagSpan = buildCommon.makeSpan([], buildExpression(tag, options, true), options);
      }

      tagSpan.depth = rw.depth;
      tagSpan.height = rw.height;
      tagSpans.push({
        type: "elem",
        elem: tagSpan,
        shift
      });
    }
  }

  for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column
  // descriptions, so trailing separators don't get lost.
  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
    let colDescr = colDescriptions[colDescrNum] || {};
    let firstSeparator = true;

    while (colDescr.type === "separator") {
      // If there is more than one separator in a row, add a space
      // between them.
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }

      if (colDescr.separator === "|" || colDescr.separator === ":") {
        const lineType = colDescr.separator === "|" ? "solid" : "dashed";
        const separator = buildCommon.makeSpan(["vertical-separator"], [], options);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
        const shift = totalHeight - offset;

        if (shift) {
          separator.style.verticalAlign = makeEm(-shift);
        }

        cols.push(separator);
      } else {
        throw new src_ParseError("Invalid separator type: " + colDescr.separator);
      }

      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }

    if (c >= nc) {
      continue;
    }

    let sepwidth;

    if (c > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);

      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }

    let col = [];

    for (r = 0; r < nr; ++r) {
      const row = body[r];
      const elem = row[c];

      if (!elem) {
        continue;
      }

      const shift = row.pos - offset;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem: elem,
        shift: shift
      });
    }

    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);

    if (c < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);

      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }

  body = buildCommon.makeSpan(["mtable"], cols); // Add \hline(s), if any.

  if (hlines.length > 0) {
    const line = buildCommon.makeLineSpan("hline", options, ruleThickness);
    const dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
    const vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];

    while (hlines.length > 0) {
      const hline = hlines.pop();
      const lineShift = hline.pos - offset;

      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }

    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options);
  }

  if (tagSpans.length === 0) {
    return buildCommon.makeSpan(["mord"], [body], options);
  } else {
    let eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: tagSpans
    }, options);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};

const alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};

const array_mathmlBuilder = function (group, options) {
  const tbl = [];
  const glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  const tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);

  for (let i = 0; i < group.body.length; i++) {
    const rw = group.body[i];
    const row = [];

    for (let j = 0; j < rw.length; j++) {
      row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j], options)]));
    }

    if (group.tags && group.tags[i]) {
      row.unshift(glue);
      row.push(glue);

      if (group.leqno) {
        row.unshift(tag);
      } else {
        row.push(tag);
      }
    }

    tbl.push(new mathMLTree.MathNode("mtr", row));
  }

  let table = new mathMLTree.MathNode("mtable", tbl); // Set column alignment, row spacing, column spacing, and
  // array lines by setting attributes on the table element.
  // Set the row spacing. In MathML, we specify a gap distance.
  // We do not use rowGap[] because MathML automatically increases
  // cell height with the height/depth of the element content.
  // LaTeX \arraystretch multiplies the row baseline-to-baseline distance.
  // We simulate this by adding (arraystretch - 1)em to the gap. This
  // does a reasonable job of adjusting arrays containing 1 em tall content.
  // The 0.16 and 0.09 values are found empirically. They produce an array
  // similar to LaTeX and in which content does not interfere with \hlines.

  const gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}
  : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table.setAttribute("rowspacing", makeEm(gap)); // MathML table lines go only between cells.
  // To place a line on an edge we'll use <menclose>, if necessary.

  let menclose = "";
  let align = "";

  if (group.cols && group.cols.length > 0) {
    // Find column alignment, column spacing, and  vertical lines.
    const cols = group.cols;
    let columnLines = "";
    let prevTypeWasAlign = false;
    let iStart = 0;
    let iEnd = cols.length;

    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }

    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }

    for (let i = iStart; i < iEnd; i++) {
      if (cols[i].type === "align") {
        align += alignMap[cols[i].align];

        if (prevTypeWasAlign) {
          columnLines += "none ";
        }

        prevTypeWasAlign = true;
      } else if (cols[i].type === "separator") {
        // MathML accepts only single lines between cells.
        // So we read only the first of consecutive separators.
        if (prevTypeWasAlign) {
          columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }

    table.setAttribute("columnalign", align.trim());

    if (/[sd]/.test(columnLines)) {
      table.setAttribute("columnlines", columnLines.trim());
    }
  } // Set column spacing.


  if (group.colSeparationType === "align") {
    const cols = group.cols || [];
    let spacing = "";

    for (let i = 1; i < cols.length; i++) {
      spacing += i % 2 ? "0em " : "1em ";
    }

    table.setAttribute("columnspacing", spacing.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table.setAttribute("columnspacing", "0.5em");
  } else {
    table.setAttribute("columnspacing", "1em");
  } // Address \hline and \hdashline


  let rowLines = "";
  const hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";

  for (let i = 1; i < hlines.length - 1; i++) {
    rowLines += hlines[i].length === 0 ? "none " // MathML accepts only a single line between rows. Read one element.
    : hlines[i][0] ? "dashed " : "solid ";
  }

  if (/[sd]/.test(rowLines)) {
    table.setAttribute("rowlines", rowLines.trim());
  }

  if (menclose !== "") {
    table = new mathMLTree.MathNode("menclose", [table]);
    table.setAttribute("notation", menclose.trim());
  }

  if (group.arraystretch && group.arraystretch < 1) {
    // A small array. Wrap in scriptstyle so row gap is not too large.
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }

  return table;
}; // Convenience function for align, align*, aligned, alignat, alignat*, alignedat.


const alignedHandler = function (context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }

  const cols = [];
  const separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
  const isSplit = context.envName === "split";
  const res = parseArray(context.parser, {
    cols,
    addJot: true,
    autoTag: isSplit ? undefined : getAutoTag(context.envName),
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: isSplit ? 2 : undefined,
    leqno: context.parser.settings.leqno
  }, "display"); // Determining number of columns.
  // 1. If the first argument is given, we use it as a number of columns,
  //    and makes sure that each row doesn't exceed that number.
  // 2. Otherwise, just count number of columns = maximum number
  //    of cells in each row ("aligned" mode -- isAligned will be true).
  //
  // At the same time, prepend empty group {} at beginning of every second
  // cell in each row (starting with second cell) so that operators become
  // binary.  This behavior is implemented in amsmath's \start@aligned.

  let numMaths;
  let numCols = 0;
  const emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };

  if (args[0] && args[0].type === "ordgroup") {
    let arg0 = "";

    for (let i = 0; i < args[0].body.length; i++) {
      const textord = assertNodeType(args[0].body[i], "textord");
      arg0 += textord.text;
    }

    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }

  const isAligned = !numCols;
  res.body.forEach(function (row) {
    for (let i = 1; i < row.length; i += 2) {
      // Modify ordgroup node within styling node
      const styling = assertNodeType(row[i], "styling");
      const ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }

    if (!isAligned) {
      // Case 1
      const curMaths = row.length / 2;

      if (numMaths < curMaths) {
        throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      // Case 2
      numCols = row.length;
    }
  }); // Adjusting alignment.
  // In aligned mode, we add one \qquad between columns;
  // otherwise we add nothing.

  for (let i = 0; i < numCols; ++i) {
    let align = "r";
    let pregap = 0;

    if (i % 2 === 1) {
      align = "l";
    } else if (i > 0 && isAligned) {
      // "aligned" mode.
      pregap = 1; // add one \quad
    }

    cols[i] = {
      type: "align",
      align: align,
      pregap: pregap,
      postgap: 0
    };
  }

  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
}; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
// {darray} is an {array} environment where cells are set in \displaystyle,
// as defined in nccmath.sty.


defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },

  handler(context, args) {
    // Since no types are specified above, the two possibilities are
    // - The argument is wrapped in {} or [], in which case Parser's
    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
    // - The argument is a bare symbol node.
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function (nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;

      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }

      throw new src_ParseError("Unknown column alignment: " + ca, nde);
    });
    const res = {
      cols,
      hskipBeforeAndAfter: true,
      // \@preamble in lttab.dtx
      maxNumCols: cols.length
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },

  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // The matrix environments of amsmath builds on the array environment
// of LaTeX, which is discussed above.
// The mathtools package adds starred versions of the same environments.
// These have an optional argument to choose left|center|right justification.

defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },

  handler(context) {
    const delimiters = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")]; // \hskip -\arraycolsep in amsmath

    let colAlign = "c";
    const payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };

    if (context.envName.charAt(context.envName.length - 1) === "*") {
      // It's one of the mathtools starred functions.
      // Parse the optional alignment argument.
      const parser = context.parser;
      parser.consumeSpaces();

      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;

        if ("lcr".indexOf(colAlign) === -1) {
          throw new src_ParseError("Expected l or c or r", parser.nextToken);
        }

        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }

    const res = parseArray(context.parser, payload, dCellStyle(context.envName)); // Populate cols with the correct number of column alignment specs.

    const numCols = Math.max(0, ...res.body.map(row => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters[0],
      right: delimiters[1],
      rightColor: undefined // \right uninfluenced by \color in array

    } : res;
  },

  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },

  handler(context) {
    const payload = {
      arraystretch: 0.5
    };
    const res = parseArray(context.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },

  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },

  handler(context, args) {
    // Parsing of {subarray} is similar to {array}
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function (nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text; // {subarray} only recognizes "l" & "c"

      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }

      throw new src_ParseError("Unknown column alignment: " + ca, nde);
    });

    if (cols.length > 1) {
      throw new src_ParseError("{subarray} can contain only one column");
    }

    let res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context.parser, res, "script");

    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new src_ParseError("{subarray} can contain only one column");
    }

    return res;
  },

  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // A cases environment (in amsmath.sty) is almost equivalent to
// \def\arraystretch{1.2}%
// \left\{\begin{array}{@{}l@{\quad}l@{}} … \end{array}\right.
// {dcases} is a {cases} environment where cells are set in \displaystyle,
// as defined in mathtools.sty.
// {rcases} is another mathtools environment. It's brace is on the right side.

defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },

  handler(context) {
    const payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1.0
        /* 1em quad */

      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    const res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: undefined
    };
  },

  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // In the align environment, one uses ampersands, &, to specify number of
// columns in each row, and to locate spacing between each column.
// align gets automatic numbering. align* and aligned do not.
// The alignedat environment can be used in math mode.
// Note that we assume \nomallineskiplimit to be zero,
// so that \strut@ is the same as \strut.

defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // A gathered environment is like an array environment with one centered
// column, but where rows are considered lines so get \jot line spacing
// and contents are set in \displaystyle.

defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },

  handler(context) {
    if (utils.contains(["gather", "gather*"], context.envName)) {
      validateAmsEnvironmentContext(context);
    }

    const res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },

  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // alignat environment is like an align environment, but one must explicitly
// specify maximum number of columns in each row, and can adjust spacing between
// each columns.

defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },

  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },

  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },

  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },

  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber"); // Catch \hline outside array environment

defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },

  handler(context, args) {
    throw new src_ParseError(context.funcName + " valid only within array environment");
  }

});
;// CONCATENATED MODULE: ./src/environments.js

const environments = _environments;
/* harmony default export */ var src_environments = (environments); // All environment definitions should be imported below


;// CONCATENATED MODULE: ./src/functions/environment.js



 // Environment delimiters. HTML/MathML rendering is defined in the corresponding
// defineEnvironment definitions.

defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },

  handler(_ref, args) {
    let {
      parser,
      funcName
    } = _ref;
    const nameGroup = args[0];

    if (nameGroup.type !== "ordgroup") {
      throw new src_ParseError("Invalid environment name", nameGroup);
    }

    let envName = "";

    for (let i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }

    if (funcName === "\\begin") {
      // begin...end is similar to left...right
      if (!src_environments.hasOwnProperty(envName)) {
        throw new src_ParseError("No such environment: " + envName, nameGroup);
      } // Build the environment object. Arguments and other information will
      // be made available to the begin and end methods using properties.


      const env = src_environments[envName];
      const {
        args,
        optArgs
      } = parser.parseArguments("\\begin{" + envName + "}", env);
      const context = {
        mode: parser.mode,
        envName,
        parser
      };
      const result = env.handler(context, args, optArgs);
      parser.expect("\\end", false);
      const endNameToken = parser.nextToken;
      const end = assertNodeType(parser.parseFunction(), "environment");

      if (end.name !== envName) {
        throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      } // $FlowFixMe, "environment" handler returns an environment ParseNode


      return result;
    }

    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }

});
;// CONCATENATED MODULE: ./src/functions/font.js
// TODO(kevinb): implement \\sl and \\sc






const font_htmlBuilder = (group, options) => {
  const font = group.font;
  const newOptions = options.withFont(font);
  return buildGroup(group.body, newOptions);
};

const font_mathmlBuilder = (group, options) => {
  const font = group.font;
  const newOptions = options.withFont(font);
  return buildMathML_buildGroup(group.body, newOptions);
};

const fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [// styles, except \boldsymbol defined below
  "\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal", "\\mathsfit", // families
  "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt", // aliases, except \bm defined below
  "\\Bbb", "\\bold", "\\frak"],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    let {
      parser,
      funcName
    } = _ref;
    const body = normalizeArgument(args[0]);
    let func = funcName;

    if (func in fontAliases) {
      func = fontAliases[func];
    }

    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: font_htmlBuilder,
  mathmlBuilder: font_mathmlBuilder
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    let {
      parser
    } = _ref2;
    const body = args[0];
    const isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \boldsymbol uses \binrel spacing to inherit the
    // argument's bin|rel|ord status

    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox
    };
  }
}); // Old font changing functions

defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    let {
      parser,
      funcName,
      breakOnTokenText
    } = _ref3;
    const {
      mode
    } = parser;
    const body = parser.parseExpression(true, breakOnTokenText);
    const style = "math" + funcName.slice(1);
    return {
      type: "font",
      mode: mode,
      font: style,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  htmlBuilder: font_htmlBuilder,
  mathmlBuilder: font_mathmlBuilder
});
;// CONCATENATED MODULE: ./src/functions/genfrac.js











const adjustStyle = (size, originalStyle) => {
  // Figure out what style this fraction should be in based on the
  // function used
  let style = originalStyle;

  if (size === "display") {
    // Get display style as a default.
    // If incoming style is sub/sup, use style.text() to get correct size.
    style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
  } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
    // We're in a \tfrac but incoming style is displaystyle, so:
    style = src_Style.TEXT;
  } else if (size === "script") {
    style = src_Style.SCRIPT;
  } else if (size === "scriptscript") {
    style = src_Style.SCRIPTSCRIPT;
  }

  return style;
};

const genfrac_htmlBuilder = (group, options) => {
  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
  const style = adjustStyle(group.size, options.style);
  const nstyle = style.fracNum();
  const dstyle = style.fracDen();
  let newOptions;
  newOptions = options.havingStyle(nstyle);
  const numerm = buildGroup(group.numer, newOptions, options);

  if (group.continued) {
    // \cfrac inserts a \strut into the numerator.
    // Get \strut dimensions from TeXbook page 353.
    const hStrut = 8.5 / options.fontMetrics().ptPerEm;
    const dStrut = 3.5 / options.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }

  newOptions = options.havingStyle(dstyle);
  const denomm = buildGroup(group.denom, newOptions, options);
  let rule;
  let ruleWidth;
  let ruleSpacing;

  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options);
      rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options);
    }

    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options.fontMetrics().defaultRuleThickness;
  } // Rule 15b


  let numShift;
  let clearance;
  let denomShift;

  if (style.size === src_Style.DISPLAY.size || group.size === "display") {
    numShift = options.fontMetrics().num1;

    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }

    denomShift = options.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }

    denomShift = options.fontMetrics().denom2;
  }

  let frac;

  if (!rule) {
    // Rule 15c
    const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);

    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }

    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } else {
    // Rule 15d
    const axisHeight = options.fontMetrics().axisHeight;

    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }

    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }

    const midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } // Since we manually change the style sometimes (with \dfrac or \tfrac),
  // account for the possible size change here.


  newOptions = options.havingStyle(style);
  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e

  let delimSize;

  if (style.size === src_Style.DISPLAY.size) {
    delimSize = options.fontMetrics().delim1;
  } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
    delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options.fontMetrics().delim2;
  }

  let leftDelim;
  let rightDelim;

  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, ["mopen"]);
  } else {
    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
  }

  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]); // zero width for \cfrac
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, ["mclose"]);
  } else {
    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
  }

  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
};

const genfrac_mathmlBuilder = (group, options) => {
  let node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);

  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    const ruleWidth = calculateSize(group.barSize, options);
    node.setAttribute("linethickness", makeEm(ruleWidth));
  }

  const style = adjustStyle(group.size, options.style);

  if (style.size !== options.style.size) {
    node = new mathMLTree.MathNode("mstyle", [node]);
    const isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
    node.setAttribute("displaystyle", isDisplay);
    node.setAttribute("scriptlevel", "0");
  }

  if (group.leftDelim != null || group.rightDelim != null) {
    const withDelims = [];

    if (group.leftDelim != null) {
      const leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }

    withDelims.push(node);

    if (group.rightDelim != null) {
      const rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }

    return makeRow(withDelims);
  }

  return node;
};

defineFunction({
  type: "genfrac",
  names: ["\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac", // can’t be entered directly
  "\\\\bracefrac", "\\\\brackfrac" // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    let {
      parser,
      funcName
    } = _ref;
    const numer = args[0];
    const denom = args[1];
    let hasBarLine;
    let leftDelim = null;
    let rightDelim = null;
    let size = "auto";

    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;

      case "\\\\atopfrac":
        hasBarLine = false;
        break;

      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;

      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;

      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;

      default:
        throw new Error("Unrecognized genfrac command");
    }

    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size = "display";
        break;

      case "\\tfrac":
      case "\\tbinom":
        size = "text";
        break;
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size,
      barSize: null
    };
  },
  htmlBuilder: genfrac_htmlBuilder,
  mathmlBuilder: genfrac_mathmlBuilder
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    let {
      parser,
      funcName
    } = _ref2;
    const numer = args[0];
    const denom = args[1];
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
}); // Infix generalized fractions -- these are not rendered directly, but replaced
// immediately by one of the variants above.

defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },

  handler(_ref3) {
    let {
      parser,
      funcName,
      token
    } = _ref3;
    let replaceWith;

    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;

      case "\\choose":
        replaceWith = "\\binom";
        break;

      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;

      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;

      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;

      default:
        throw new Error("Unrecognized infix genfrac command");
    }

    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }

});
const stylArray = ["display", "text", "script", "scriptscript"];

const delimFromValue = function (delimString) {
  let delim = null;

  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }

  return delim;
};

defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },

  handler(_ref4, args) {
    let {
      parser
    } = _ref4;
    const numer = args[4];
    const denom = args[5]; // Look into the parse nodes to get the desired delimiters.

    const leftNode = normalizeArgument(args[0]);
    const leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    const rightNode = normalizeArgument(args[1]);
    const rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    const barNode = assertNodeType(args[2], "size");
    let hasBarLine;
    let barSize = null;

    if (barNode.isBlank) {
      // \genfrac acts differently than \above.
      // \genfrac treats an empty size group as a signal to use a
      // standard bar size. \above would see size = 0 and omit the bar.
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    } // Find out if we want displaystyle, textstyle, etc.


    let size = "auto";
    let styl = args[3];

    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        const textOrd = assertNodeType(styl.body[0], "textord");
        size = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size = stylArray[Number(styl.text)];
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size
    };
  },

  htmlBuilder: genfrac_htmlBuilder,
  mathmlBuilder: genfrac_mathmlBuilder
}); // \above is an infix fraction that also defines a fraction bar size.

defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },

  handler(_ref5, args) {
    let {
      parser,
      funcName,
      token
    } = _ref5;
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token
    };
  }

});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    let {
      parser,
      funcName
    } = _ref6;
    const numer = args[0];
    const barSize = assert(assertNodeType(args[1], "infix").size);
    const denom = args[2];
    const hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: genfrac_htmlBuilder,
  mathmlBuilder: genfrac_mathmlBuilder
});
;// CONCATENATED MODULE: ./src/functions/horizBrace.js








// NOTE: Unlike most `htmlBuilder`s, this one handles not only "horizBrace", but
// also "supsub" since an over/underbrace can affect super/subscripting.
const horizBrace_htmlBuilder = (grp, options) => {
  const style = options.style; // Pull out the `ParseNode<"horizBrace">` if `grp` is a "supsub" node.

  let supSubGroup;
  let group;

  if (grp.type === "supsub") {
    // Ref: LaTeX source2e: }}}}\limits}
    // i.e. LaTeX treats the brace similar to an op and passes it
    // with \limits, so we need to assign supsub style.
    supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  } // Build the base group


  const body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY)); // Create the stretchy element

  const braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        ┏━━━━━━━━┓
  // This first vlist contains the content and the brace:   equation

  let vlist;

  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }

  if (supSubGroup) {
    // To write the supsub, wrap the first vlist in another vlist:
    // They can't all go in the same vlist, because the note might be
    // wider than the equation. We want the equation to control the
    // brace width.
    //      note          long note           long note
    //   ┏━━━━━━━━┓   or    ┏━━━┓     not    ┏━━━━━━━━━┓
    //    equation           eqn                 eqn
    const vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);

    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options);
    }
  }

  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
};

const horizBrace_mathmlBuilder = (group, options) => {
  const accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
}; // Horizontal stretchy braces


defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },

  handler(_ref, args) {
    let {
      parser,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },

  htmlBuilder: horizBrace_htmlBuilder,
  mathmlBuilder: horizBrace_mathmlBuilder
});
;// CONCATENATED MODULE: ./src/functions/href.js






defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    let {
      parser
    } = _ref;
    const body = args[1];
    const href = assertNodeType(args[0], "url").url;

    if (!parser.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\href");
    }

    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    const elements = buildExpression(group.body, options, false);
    return buildCommon.makeAnchor(group.href, [], elements, options);
  },
  mathmlBuilder: (group, options) => {
    let math = buildExpressionRow(group.body, options);

    if (!(math instanceof MathNode)) {
      math = new MathNode("mrow", [math]);
    }

    math.setAttribute("href", group.href);
    return math;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    let {
      parser
    } = _ref2;
    const href = assertNodeType(args[0], "url").url;

    if (!parser.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\url");
    }

    const chars = [];

    for (let i = 0; i < href.length; i++) {
      let c = href[i];

      if (c === "~") {
        c = "\\textasciitilde";
      }

      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }

    const body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});
;// CONCATENATED MODULE: ./src/functions/hbox.js




 // \hbox is provided for compatibility with LaTeX \vcenter.
// In LaTeX, \vcenter can act only on a box, as in
// \vcenter{\hbox{$\frac{a+b}{\dfrac{c}{d}}$}}
// This function by itself doesn't do anything but prevent a soft line break.

defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },

  handler(_ref, args) {
    let {
      parser
    } = _ref;
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },

  htmlBuilder(group, options) {
    const elements = buildExpression(group.body, options, false);
    return buildCommon.makeFragment(elements);
  },

  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
  }

});
;// CONCATENATED MODULE: ./src/functions/html.js






defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    let {
      parser,
      funcName,
      token
    } = _ref;
    const value = assertNodeType(args[0], "raw").string;
    const body = args[1];

    if (parser.settings.strict) {
      parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }

    let trustContext;
    const attributes = {};

    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value;
        trustContext = {
          command: "\\htmlClass",
          class: value
        };
        break;

      case "\\htmlId":
        attributes.id = value;
        trustContext = {
          command: "\\htmlId",
          id: value
        };
        break;

      case "\\htmlStyle":
        attributes.style = value;
        trustContext = {
          command: "\\htmlStyle",
          style: value
        };
        break;

      case "\\htmlData":
        {
          const data = value.split(",");

          for (let i = 0; i < data.length; i++) {
            const keyVal = data[i].split("=");

            if (keyVal.length !== 2) {
              throw new src_ParseError("Error parsing key-value for \\htmlData");
            }

            attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
          }

          trustContext = {
            command: "\\htmlData",
            attributes
          };
          break;
        }

      default:
        throw new Error("Unrecognized html command");
    }

    if (!parser.settings.isTrusted(trustContext)) {
      return parser.formatUnsupportedCmd(funcName);
    }

    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    const elements = buildExpression(group.body, options, false);
    const classes = ["enclosing"];

    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }

    const span = buildCommon.makeSpan(classes, elements, options);

    for (const attr in group.attributes) {
      if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
        span.setAttribute(attr, group.attributes[attr]);
      }
    }

    return span;
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.body, options);
  }
});
;// CONCATENATED MODULE: ./src/functions/htmlmathml.js




defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    let {
      parser
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options) => {
    const elements = buildExpression(group.html, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.mathml, options);
  }
});
;// CONCATENATED MODULE: ./src/functions/includegraphics.js







const sizeData = function (str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    // str is a number with no unit specified.
    // default unit is bp, per graphix package.
    return {
      number: +str,
      unit: "bp"
    };
  } else {
    const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);

    if (!match) {
      throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }

    const data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };

    if (!validUnit(data)) {
      throw new src_ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }

    return data;
  }
};

defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    let {
      parser
    } = _ref;
    let width = {
      number: 0,
      unit: "em"
    };
    let height = {
      number: 0.9,
      unit: "em"
    }; // sorta character sized.

    let totalheight = {
      number: 0,
      unit: "em"
    };
    let alt = "";

    if (optArgs[0]) {
      const attributeStr = assertNodeType(optArgs[0], "raw").string; // Parser.js does not parse key/value pairs. We get a string.

      const attributes = attributeStr.split(",");

      for (let i = 0; i < attributes.length; i++) {
        const keyVal = attributes[i].split("=");

        if (keyVal.length === 2) {
          const str = keyVal[1].trim();

          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break;

            case "width":
              width = sizeData(str);
              break;

            case "height":
              height = sizeData(str);
              break;

            case "totalheight":
              totalheight = sizeData(str);
              break;

            default:
              throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }

    const src = assertNodeType(args[0], "url").url;

    if (alt === "") {
      // No alt given. Use the file name. Strip away the path.
      alt = src;
      alt = alt.replace(/^.*[\\/]/, '');
      alt = alt.substring(0, alt.lastIndexOf('.'));
    }

    if (!parser.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser.formatUnsupportedCmd("\\includegraphics");
    }

    return {
      type: "includegraphics",
      mode: parser.mode,
      alt: alt,
      width: width,
      height: height,
      totalheight: totalheight,
      src: src
    };
  },
  htmlBuilder: (group, options) => {
    const height = calculateSize(group.height, options);
    let depth = 0;

    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
    }

    let width = 0;

    if (group.width.number > 0) {
      width = calculateSize(group.width, options);
    }

    const style = {
      height: makeEm(height + depth)
    };

    if (width > 0) {
      style.width = makeEm(width);
    }

    if (depth > 0) {
      style.verticalAlign = makeEm(-depth);
    }

    const node = new Img(group.src, group.alt, style);
    node.height = height;
    node.depth = depth;
    return node;
  },
  mathmlBuilder: (group, options) => {
    const node = new mathMLTree.MathNode("mglyph", []);
    node.setAttribute("alt", group.alt);
    const height = calculateSize(group.height, options);
    let depth = 0;

    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
      node.setAttribute("valign", makeEm(-depth));
    }

    node.setAttribute("height", makeEm(height + depth));

    if (group.width.number > 0) {
      const width = calculateSize(group.width, options);
      node.setAttribute("width", makeEm(width));
    }

    node.setAttribute("src", group.src);
    return node;
  }
});
;// CONCATENATED MODULE: ./src/functions/kern.js
// Horizontal spacing commands




 // TODO: \hskip and \mskip should support plus and minus in lengths

defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },

  handler(_ref, args) {
    let {
      parser,
      funcName
    } = _ref;
    const size = assertNodeType(args[0], "size");

    if (parser.settings.strict) {
      const mathFunction = funcName[1] === 'm'; // \mkern, \mskip

      const muUnit = size.value.unit === 'mu';

      if (mathFunction) {
        if (!muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
        }

        if (parser.mode !== "math") {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        // !mathFunction
        if (muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }

    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },

  htmlBuilder(group, options) {
    return buildCommon.makeGlue(group.dimension, options);
  },

  mathmlBuilder(group, options) {
    const dimension = calculateSize(group.dimension, options);
    return new mathMLTree.SpaceNode(dimension);
  }

});
;// CONCATENATED MODULE: ./src/functions/lap.js
// Horizontal overlap functions






defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    let {
      parser,
      funcName
    } = _ref;
    const body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options) => {
    // mathllap, mathrlap, mathclap
    let inner;

    if (group.alignment === "clap") {
      // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/
      inner = buildCommon.makeSpan([], [buildGroup(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span

      inner = buildCommon.makeSpan(["inner"], [inner], options);
    } else {
      inner = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
    }

    const fix = buildCommon.makeSpan(["fix"], []);
    let node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the
    // two items involved in the lap.
    // Next, use a strut to set the height of the HTML bounding box.
    // Otherwise, a tall argument may be misplaced.
    // This code resolved issue #1153

    const strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node.height + node.depth);

    if (node.depth) {
      strut.style.verticalAlign = makeEm(-node.depth);
    }

    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.
    // This code resolves issue #1234

    node = buildCommon.makeSpan(["thinbox"], [node], options);
    return buildCommon.makeSpan(["mord", "vbox"], [node], options);
  },
  mathmlBuilder: (group, options) => {
    // mathllap, mathrlap, mathclap
    const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);

    if (group.alignment !== "rlap") {
      const offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
    }

    node.setAttribute("width", "0px");
    return node;
  }
});
;// CONCATENATED MODULE: ./src/functions/math.js

 // Switching from text mode back to math mode

defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },

  handler(_ref, args) {
    let {
      funcName,
      parser
    } = _ref;
    const outerMode = parser.mode;
    parser.switchMode("math");
    const close = funcName === "\\(" ? "\\)" : "$";
    const body = parser.parseExpression(false, close);
    parser.expect(close);
    parser.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser.mode,
      style: "text",
      body
    };
  }

}); // Check for extra closing math delimiters

defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },

  handler(context, args) {
    throw new src_ParseError("Mismatched " + context.funcName);
  }

});
;// CONCATENATED MODULE: ./src/functions/mathchoice.js






const chooseMathStyle = (group, options) => {
  switch (options.style.size) {
    case src_Style.DISPLAY.size:
      return group.display;

    case src_Style.TEXT.size:
      return group.text;

    case src_Style.SCRIPT.size:
      return group.script;

    case src_Style.SCRIPTSCRIPT.size:
      return group.scriptscript;

    default:
      return group.text;
  }
};

defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    let {
      parser
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options) => {
    const body = chooseMathStyle(group, options);
    const elements = buildExpression(body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    const body = chooseMathStyle(group, options);
    return buildExpressionRow(body, options);
  }
});
;// CONCATENATED MODULE: ./src/functions/utils/assembleSupSub.js



 // For an operator with limits, assemble the base, sup, and sub into a span.

const assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
  base = buildCommon.makeSpan([], [base]);
  const subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
  let sub;
  let sup; // We manually have to handle the superscripts and subscripts. This,
  // aside from the kern calculations, is copied from supsub.

  if (supGroup) {
    const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
    sup = {
      elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }

  if (subGroup) {
    const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
    sub = {
      elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
    };
  } // Build the final group as a vlist of the possible subscript, base,
  // and possible superscript.


  let finalGroup;

  if (sup && sub) {
    const bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub.kern
      }, {
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup.kern
      }, {
        type: "elem",
        elem: sup.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else if (sub) {
    const top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note
    // that we are supposed to shift the limits by 1/2 of the slant,
    // but since we are centering the limits adding a full slant of
    // margin will shift by 1/2 that.

    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub.kern
      }, {
        type: "elem",
        elem: base
      }]
    }, options);
  } else if (sup) {
    const bottom = base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup.kern
      }, {
        type: "elem",
        elem: sup.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else {
    // This case probably shouldn't occur (this would mean the
    // supsub was sending us a group with no superscript or
    // subscript) but be safe.
    return base;
  }

  const parts = [finalGroup];

  if (sub && slant !== 0 && !subIsSingleCharacter) {
    // A negative margin-left was applied to the lower limit.
    // Avoid an overlap by placing a spacer on the left on the group.
    const spacer = buildCommon.makeSpan(["mspace"], [], options);
    spacer.style.marginRight = makeEm(slant);
    parts.unshift(spacer);
  }

  return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
};
;// CONCATENATED MODULE: ./src/functions/op.js
// Limits, symbols











// Most operators have a large successor symbol, but these don't.
const noSuccessor = ["\\smallint"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only "op", but also
// "supsub" since some of them (like \int) can affect super/subscripting.

const op_htmlBuilder = (grp, options) => {
  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
  let supGroup;
  let subGroup;
  let hasLimits = false;
  let group;

  if (grp.type === "supsub") {
    // If we have limits, supsub will pass us its group to handle. Pull
    // out the superscript and subscript and set the group to the op in
    // its base.
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }

  const style = options.style;
  let large = false;

  if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
    // Most symbol operators get larger in displaystyle (rule 13)
    large = true;
  }

  let base;

  if (group.symbol) {
    // If this is a symbol, create the symbol.
    const fontName = large ? "Size2-Regular" : "Size1-Regular";
    let stash = "";

    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      // No font glyphs yet, so use a glyph w/o the oval.
      // TODO: When font glyphs are available, delete this code.
      stash = group.name.slice(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }

    base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);

    if (stash.length > 0) {
      // We're in \oiint or \oiiint. Overlay the oval.
      // TODO: When font glyphs are available, delete this code.
      const italic = base.italic;
      const oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
      base = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options);
      group.name = "\\" + stash;
      base.classes.unshift("mop"); // $FlowFixMe

      base.italic = italic;
    }
  } else if (group.body) {
    // If this is a list, compose that list.
    const inner = buildExpression(group.body, options, true);

    if (inner.length === 1 && inner[0] instanceof SymbolNode) {
      base = inner[0];
      base.classes[0] = "mop"; // replace old mclass
    } else {
      base = buildCommon.makeSpan(["mop"], inner, options);
    }
  } else {
    // Otherwise, this is a text operator. Build the text from the
    // operator's name.
    const output = [];

    for (let i = 1; i < group.name.length; i++) {
      output.push(buildCommon.mathsym(group.name[i], group.mode, options));
    }

    base = buildCommon.makeSpan(["mop"], output, options);
  } // If content of op is a single symbol, shift it vertically.


  let baseShift = 0;
  let slant = 0;

  if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    // We suppress the shift of the base of \overset and \underset. Otherwise,
    // shift the symbol so its center lies on the axis (rule 13). It
    // appears that our fonts have the centers of the symbols already
    // almost on the axis, so these numbers are very small. Note we
    // don't actually apply this here, but instead it is used either in
    // the vlist creation or separately when there are no limits.
    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.
    // $FlowFixMe

    slant = base.italic;
  }

  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
  } else {
    if (baseShift) {
      base.style.position = "relative";
      base.style.top = makeEm(baseShift);
    }

    return base;
  }
};

const op_mathmlBuilder = (group, options) => {
  let node;

  if (group.symbol) {
    // This is a symbol. Just add the symbol.
    node = new MathNode("mo", [makeText(group.name, group.mode)]);

    if (utils.contains(noSuccessor, group.name)) {
      node.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    // This is an operator with children. Add them.
    node = new MathNode("mo", buildMathML_buildExpression(group.body, options));
  } else {
    // This is a text operator. Add all of the characters from the
    // operator's name.
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.
    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4

    const operator = new MathNode("mo", [makeText("\u2061", "text")]);

    if (group.parentIsSupSub) {
      node = new MathNode("mrow", [node, operator]);
    } else {
      node = newDocumentFragment([node, operator]);
    }
  }

  return node;
};

const singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22c0": "\\bigwedge",
  "\u22c1": "\\bigvee",
  "\u22c2": "\\bigcap",
  "\u22c3": "\\bigcup",
  "\u2a00": "\\bigodot",
  "\u2a01": "\\bigoplus",
  "\u2a02": "\\bigotimes",
  "\u2a04": "\\biguplus",
  "\u2a06": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22c0", "\u22c1", "\u22c2", "\u22c3", "\u2a00", "\u2a01", "\u2a02", "\u2a04", "\u2a06"],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    let {
      parser,
      funcName
    } = _ref;
    let fName = funcName;

    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }

    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
}); // Note: calling defineFunction with a type that's already been defined only
// works because the same htmlBuilder and mathmlBuilder are being used.

defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    let {
      parser
    } = _ref2;
    const body = args[0];
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
}); // There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

const singleCharIntegrals = {
  "\u222b": "\\int",
  "\u222c": "\\iint",
  "\u222d": "\\iiint",
  "\u222e": "\\oint",
  "\u222f": "\\oiint",
  "\u2230": "\\oiiint"
}; // No limits, not symbols

defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },

  handler(_ref3) {
    let {
      parser,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },

  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
}); // Limits, not symbols

defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },

  handler(_ref4) {
    let {
      parser,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },

  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
}); // No limits, symbols

defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222b", "\u222c", "\u222d", "\u222e", "\u222f", "\u2230"],
  props: {
    numArgs: 0
  },

  handler(_ref5) {
    let {
      parser,
      funcName
    } = _ref5;
    let fName = funcName;

    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }

    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },

  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
});
;// CONCATENATED MODULE: ./src/functions/operatorname.js









// NOTE: Unlike most `htmlBuilder`s, this one handles not only
// "operatorname", but also  "supsub" since \operatorname* can
// affect super/subscripting.
const operatorname_htmlBuilder = (grp, options) => {
  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
  let supGroup;
  let subGroup;
  let hasLimits = false;
  let group;

  if (grp.type === "supsub") {
    // If we have limits, supsub will pass us its group to handle. Pull
    // out the superscript and subscript and set the group to the op in
    // its base.
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }

  let base;

  if (group.body.length > 0) {
    const body = group.body.map(child => {
      // $FlowFixMe: Check if the node has a string `text` property.
      const childText = child.text;

      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child.mode,
          text: childText
        };
      } else {
        return child;
      }
    }); // Consolidate function names into symbol characters.

    const expression = buildExpression(body, options.withFont("mathrm"), true);

    for (let i = 0; i < expression.length; i++) {
      const child = expression[i];

      if (child instanceof SymbolNode) {
        // Per amsopn package,
        // change minus to hyphen and \ast to asterisk
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }

    base = buildCommon.makeSpan(["mop"], expression, options);
  } else {
    base = buildCommon.makeSpan(["mop"], [], options);
  }

  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
  } else {
    return base;
  }
};

const operatorname_mathmlBuilder = (group, options) => {
  // The steps taken here are similar to the html version.
  let expression = buildMathML_buildExpression(group.body, options.withFont("mathrm")); // Is expression a string or has it something like a fraction?

  let isAllString = true; // default

  for (let i = 0; i < expression.length; i++) {
    const node = expression[i];

    if (node instanceof mathMLTree.SpaceNode) {// Do nothing
    } else if (node instanceof mathMLTree.MathNode) {
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.

        case "mo":
          {
            const child = node.children[0];

            if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            } else {
              isAllString = false;
            }

            break;
          }

        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }

  if (isAllString) {
    // Write a single TextNode instead of multiple nested tags.
    const word = expression.map(node => node.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }

  const identifier = new mathMLTree.MathNode("mi", expression);
  identifier.setAttribute("mathvariant", "normal"); // \u2061 is the same as &ApplyFunction;
  // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp

  const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);

  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
}; // \operatorname
// amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@


defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    let {
      parser,
      funcName
    } = _ref;
    const body = args[0];
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: operatorname_htmlBuilder,
  mathmlBuilder: operatorname_mathmlBuilder
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
;// CONCATENATED MODULE: ./src/functions/ordgroup.js




defineFunctionBuilders({
  type: "ordgroup",

  htmlBuilder(group, options) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression(group.body, options, false));
    }

    return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
  },

  mathmlBuilder(group, options) {
    return buildExpressionRow(group.body, options, true);
  }

});
;// CONCATENATED MODULE: ./src/functions/overline.js





defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },

  handler(_ref, args) {
    let {
      parser
    } = _ref;
    const body = args[0];
    return {
      type: "overline",
      mode: parser.mode,
      body
    };
  },

  htmlBuilder(group, options) {
    // Overlines are handled in the TeXbook pg 443, Rule 9.
    // Build the inner group in the cramped style.
    const innerGroup = buildGroup(group.body, options.havingCrampedStyle()); // Create the line above the body

    const line = buildCommon.makeLineSpan("overline-line", options); // Generate the vlist, with the appropriate kerns

    const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    const vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
  },

  mathmlBuilder(group, options) {
    const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");
    const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
    node.setAttribute("accent", "true");
    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/phantom.js





defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    let {
      parser
    } = _ref;
    const body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    const elements = buildExpression(group.body, options.withPhantom(), false); // \phantom isn't supposed to affect the elements it contains.
    // See "color" for more details.

    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    const inner = buildMathML_buildExpression(group.body, options);
    return new mathMLTree.MathNode("mphantom", inner);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    let {
      parser
    } = _ref2;
    const body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    let node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
    node.height = 0;
    node.depth = 0;

    if (node.children) {
      for (let i = 0; i < node.children.length; i++) {
        node.children[i].height = 0;
        node.children[i].depth = 0;
      }
    } // See smash for comment re: use of makeVList


    node = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options); // For spacing, TeX treats \smash as a math group (same spacing as ord).

    return buildCommon.makeSpan(["mord"], [node], options);
  },
  mathmlBuilder: (group, options) => {
    const inner = buildMathML_buildExpression(ordargument(group.body), options);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    let {
      parser
    } = _ref3;
    const body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    const inner = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
    const fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
  },
  mathmlBuilder: (group, options) => {
    const inner = buildMathML_buildExpression(ordargument(group.body), options);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});
;// CONCATENATED MODULE: ./src/functions/raisebox.js






 // Box manipulation

defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },

  handler(_ref, args) {
    let {
      parser
    } = _ref;
    const amount = assertNodeType(args[0], "size").value;
    const body = args[1];
    return {
      type: "raisebox",
      mode: parser.mode,
      dy: amount,
      body
    };
  },

  htmlBuilder(group, options) {
    const body = buildGroup(group.body, options);
    const dy = calculateSize(group.dy, options);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },

  mathmlBuilder(group, options) {
    const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
    const dy = group.dy.number + group.dy.unit;
    node.setAttribute("voffset", dy);
    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/relax.js

defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },

  handler(_ref) {
    let {
      parser
    } = _ref;
    return {
      type: "internal",
      mode: parser.mode
    };
  }

});
;// CONCATENATED MODULE: ./src/functions/rule.js





defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["size", "size", "size"]
  },

  handler(_ref, args, optArgs) {
    let {
      parser
    } = _ref;
    const shift = optArgs[0];
    const width = assertNodeType(args[0], "size");
    const height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },

  htmlBuilder(group, options) {
    // Make an empty span for the rule
    const rule = buildCommon.makeSpan(["mord", "rule"], [], options); // Calculate the shift, width, and height of the rule, and account for units

    const width = calculateSize(group.width, options);
    const height = calculateSize(group.height, options);
    const shift = group.shift ? calculateSize(group.shift, options) : 0; // Style the rule to the right size

    rule.style.borderRightWidth = makeEm(width);
    rule.style.borderTopWidth = makeEm(height);
    rule.style.bottom = makeEm(shift); // Record the height and width

    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift; // Font size is the number large enough that the browser will
    // reserve at least `absHeight` space above the baseline.
    // The 1.125 factor was empirically determined

    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
    return rule;
  },

  mathmlBuilder(group, options) {
    const width = calculateSize(group.width, options);
    const height = calculateSize(group.height, options);
    const shift = group.shift ? calculateSize(group.shift, options) : 0;
    const color = options.color && options.getColor() || "black";
    const rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color);
    rule.setAttribute("width", makeEm(width));
    rule.setAttribute("height", makeEm(height));
    const wrapper = new mathMLTree.MathNode("mpadded", [rule]);

    if (shift >= 0) {
      wrapper.setAttribute("height", makeEm(shift));
    } else {
      wrapper.setAttribute("height", makeEm(shift));
      wrapper.setAttribute("depth", makeEm(-shift));
    }

    wrapper.setAttribute("voffset", makeEm(shift));
    return wrapper;
  }

});
;// CONCATENATED MODULE: ./src/functions/sizing.js






function sizingGroup(value, options, baseOptions) {
  const inner = buildExpression(value, options, false);
  const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize
  // manually. Handle nested size changes.

  for (let i = 0; i < inner.length; i++) {
    const pos = inner[i].classes.indexOf("sizing");

    if (pos < 0) {
      Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
    } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
      // This is a nested size change: e.g., inner[i] is the "b" in
      // `\Huge a \small b`. Override the old size (the `reset-` class)
      // but not the new size.
      inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
    }

    inner[i].height *= multiplier;
    inner[i].depth *= multiplier;
  }

  return buildCommon.makeFragment(inner);
}
const sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
const sizing_htmlBuilder = (group, options) => {
  // Handle sizing operators like \Huge. Real TeX doesn't actually allow
  // these functions inside of math expressions, so we do some special
  // handling.
  const newOptions = options.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    let {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    const body = parser.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder: sizing_htmlBuilder,
  mathmlBuilder: (group, options) => {
    const newOptions = options.havingSize(group.size);
    const inner = buildMathML_buildExpression(group.body, newOptions);
    const node = new mathMLTree.MathNode("mstyle", inner); // TODO(emily): This doesn't produce the correct size for nested size
    // changes, because we don't keep state of what style we're currently
    // in, so we can't reset the size to normal before changing it.  Now
    // that we're passing an options parameter we should be able to fix
    // this.

    node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node;
  }
});
;// CONCATENATED MODULE: ./src/functions/smash.js
// smash, with optional [tb], as in AMS






defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    let {
      parser
    } = _ref;
    let smashHeight = false;
    let smashDepth = false;
    const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");

    if (tbArg) {
      // Optional [tb] argument is engaged.
      // ref: amsmath: \renewcommand{\smash}[1][tb]{%
      //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
      let letter = "";

      for (let i = 0; i < tbArg.body.length; ++i) {
        const node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.

        letter = node.text;

        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }

    const body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options) => {
    const node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);

    if (!group.smashHeight && !group.smashDepth) {
      return node;
    }

    if (group.smashHeight) {
      node.height = 0; // In order to influence makeVList, we have to reset the children.

      if (node.children) {
        for (let i = 0; i < node.children.length; i++) {
          node.children[i].height = 0;
        }
      }
    }

    if (group.smashDepth) {
      node.depth = 0;

      if (node.children) {
        for (let i = 0; i < node.children.length; i++) {
          node.children[i].depth = 0;
        }
      }
    } // At this point, we've reset the TeX-like height and depth values.
    // But the span still has an HTML line height.
    // makeVList applies "display: table-cell", which prevents the browser
    // from acting on that line height. So we'll call makeVList now.


    const smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options); // For spacing, TeX treats \hphantom as a math group (same spacing as ord).

    return buildCommon.makeSpan(["mord"], [smashedNode], options);
  },
  mathmlBuilder: (group, options) => {
    const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);

    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }

    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }

    return node;
  }
});
;// CONCATENATED MODULE: ./src/functions/sqrt.js








defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },

  handler(_ref, args, optArgs) {
    let {
      parser
    } = _ref;
    const index = optArgs[0];
    const body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },

  htmlBuilder(group, options) {
    // Square roots are handled in the TeXbook pg. 443, Rule 11.
    // First, we do the same steps as in overline to build the inner group
    // and line
    let inner = buildGroup(group.body, options.havingCrampedStyle());

    if (inner.height === 0) {
      // Render a small surd.
      inner.height = options.fontMetrics().xHeight;
    } // Some groups can return document fragments.  Handle those by wrapping
    // them in a span.


    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \surd delimiter

    const metrics = options.fontMetrics();
    const theta = metrics.defaultRuleThickness;
    let phi = theta;

    if (options.style.id < src_Style.TEXT.id) {
      phi = options.fontMetrics().xHeight;
    } // Calculate the clearance between the body and line


    let lineClearance = theta + phi / 4;
    const minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size

    const {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter.sqrtImage(minDelimiterHeight, options);
    const delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size

    if (delimDepth > inner.height + inner.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
    } // Shift the sqrt image


    const imgShift = img.height - inner.height - lineClearance - ruleWidth;
    inner.style.paddingLeft = makeEm(advanceWidth); // Overlay the image and the argument.

    const body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options);

    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
    } else {
      // Handle the optional root index
      // The index is always in scriptscript style
      const newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
      const rootm = buildGroup(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX
      // source, in the definition of `\r@@t`.

      const toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly

      const rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options); // Add a class surrounding it so we can add on the appropriate
      // kerning

      const rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
    }
  },

  mathmlBuilder(group, options) {
    const {
      body,
      index
    } = group;
    return index ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
  }

});
;// CONCATENATED MODULE: ./src/functions/styling.js





const styling_styleMap = {
  "display": src_Style.DISPLAY,
  "text": src_Style.TEXT,
  "script": src_Style.SCRIPT,
  "scriptscript": src_Style.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },

  handler(_ref, args) {
    let {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    // parse out the implicit body
    const body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.
    // here and in buildHTML and de-dupe the enumeration of all the styles).
    // $FlowFixMe: The names above exactly match the styles.

    const style = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style,
      body
    };
  },

  htmlBuilder(group, options) {
    // Style changes are handled in the TeXbook on pg. 442, Rule 3.
    const newStyle = styling_styleMap[group.style];
    const newOptions = options.havingStyle(newStyle).withFont('');
    return sizingGroup(group.body, newOptions, options);
  },

  mathmlBuilder(group, options) {
    // Figure out what style we're changing to.
    const newStyle = styling_styleMap[group.style];
    const newOptions = options.havingStyle(newStyle);
    const inner = buildMathML_buildExpression(group.body, newOptions);
    const node = new mathMLTree.MathNode("mstyle", inner);
    const styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    const attr = styleAttributes[group.style];
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);
    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/supsub.js














/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * Sometimes, groups perform special rules when they have superscripts or
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */
const htmlBuilderDelegate = function (group, options) {
  const base = group.base;

  if (!base) {
    return null;
  } else if (base.type === "op") {
    // Operators handle supsubs differently when they have limits
    // (e.g. `\displaystyle\sum_2^3`)
    const delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);
    return delegate ? op_htmlBuilder : null;
  } else if (base.type === "operatorname") {
    const delegate = base.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base.limits);
    return delegate ? operatorname_htmlBuilder : null;
  } else if (base.type === "accent") {
    return utils.isCharacterBox(base.base) ? htmlBuilder : null;
  } else if (base.type === "horizBrace") {
    const isSup = !group.sub;
    return isSup === base.isOver ? horizBrace_htmlBuilder : null;
  } else {
    return null;
  }
}; // Super scripts and subscripts, whose precise placement can depend on other
// functions that precede them.


defineFunctionBuilders({
  type: "supsub",

  htmlBuilder(group, options) {
    // Superscript and subscripts are handled in the TeXbook on page
    // 445-446, rules 18(a-f).
    // Here is where we defer to the inner group if it should handle
    // superscripts and subscripts itself.
    const builderDelegate = htmlBuilderDelegate(group, options);

    if (builderDelegate) {
      return builderDelegate(group, options);
    }

    const {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    const base = buildGroup(valueBase, options);
    let supm;
    let subm;
    const metrics = options.fontMetrics(); // Rule 18a

    let supShift = 0;
    let subShift = 0;
    const isCharacterBox = valueBase && utils.isCharacterBox(valueBase);

    if (valueSup) {
      const newOptions = options.havingStyle(options.style.sup());
      supm = buildGroup(valueSup, newOptions, options);

      if (!isCharacterBox) {
        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }

    if (valueSub) {
      const newOptions = options.havingStyle(options.style.sub());
      subm = buildGroup(valueSub, newOptions, options);

      if (!isCharacterBox) {
        subShift = base.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    } // Rule 18c


    let minSupShift;

    if (options.style === src_Style.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    } // scriptspace is a font-size-independent size, so scale it
    // appropriately for use as the marginRight.


    const multiplier = options.sizeMultiplier;
    const marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    let marginLeft = null;

    if (subm) {
      // Subscripts shouldn't be shifted by the base's italic correction.
      // Account for that by shifting the subscript back the appropriate
      // amount. Note we only do this when the base is a single symbol.
      const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");

      if (base instanceof SymbolNode || isOiint) {
        // $FlowFixMe
        marginLeft = makeEm(-base.italic);
      }
    }

    let supsub;

    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      const ruleWidth = metrics.defaultRuleThickness; // Rule 18e

      const maxWidth = 4 * ruleWidth;

      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);

        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }

      const vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options);
    } else if (subm) {
      // Rule 18b
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      const vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: vlistElem
      }, options);
    } else if (supm) {
      // Rule 18c, d
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options);
    } else {
      throw new Error("supsub must have either sup or sub.");
    } // Wrap the supsub vlist in a span.msupsub to reset text-align.


    const mclass = getTypeOfDomTree(base, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
  },

  mathmlBuilder(group, options) {
    // Is the inner group a relevant horizonal brace?
    let isBrace = false;
    let isOver;
    let isSup;

    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;

      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }

    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }

    const children = [buildMathML_buildGroup(group.base, options)];

    if (group.sub) {
      children.push(buildMathML_buildGroup(group.sub, options));
    }

    if (group.sup) {
      children.push(buildMathML_buildGroup(group.sup, options));
    }

    let nodeType;

    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      const base = group.base;

      if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      const base = group.base;

      if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      const base = group.base;

      if (base && base.type === "op" && base.limits && options.style === src_Style.DISPLAY) {
        nodeType = "munderover";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || base.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }

    return new mathMLTree.MathNode(nodeType, children);
  }

});
;// CONCATENATED MODULE: ./src/functions/symbolsOp.js



 // Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.

defineFunctionBuilders({
  type: "atom",

  htmlBuilder(group, options) {
    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
  },

  mathmlBuilder(group, options) {
    const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);

    if (group.family === "bin") {
      const variant = getVariant(group, options);

      if (variant === "bold-italic") {
        node.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      // Delims built here should not stretch vertically.
      // See delimsizing.js for stretchy delims.
      node.setAttribute("stretchy", "false");
    }

    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/symbolsOrd.js




// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
// src/symbols.js.
const defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",

  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
  },

  mathmlBuilder(group, options) {
    const node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
    const variant = getVariant(group, options) || "italic";

    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }

    return node;
  }

});
defineFunctionBuilders({
  type: "textord",

  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
  },

  mathmlBuilder(group, options) {
    const text = makeText(group.text, group.mode, options);
    const variant = getVariant(group, options) || "normal";
    let node;

    if (group.mode === 'text') {
      node = new mathMLTree.MathNode("mtext", [text]);
    } else if (/[0-9]/.test(group.text)) {
      node = new mathMLTree.MathNode("mn", [text]);
    } else if (group.text === "\\prime") {
      node = new mathMLTree.MathNode("mo", [text]);
    } else {
      node = new mathMLTree.MathNode("mi", [text]);
    }

    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }

    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/symbolsSpacing.js



 // A map of CSS-based spacing functions to their CSS class.

const cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}; // A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.

const regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
}; // ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.

defineFunctionBuilders({
  type: "spacing",

  htmlBuilder(group, options) {
    if (regularSpace.hasOwnProperty(group.text)) {
      const className = regularSpace[group.text].className || ""; // Spaces are generated by adding an actual space. Each of these
      // things has an entry in the symbols table, so these will be turned
      // into appropriate outputs.

      if (group.mode === "text") {
        const ord = buildCommon.makeOrd(group, options, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      // Spaces based on just a CSS class.
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
    } else {
      throw new src_ParseError("Unknown type of space \"" + group.text + "\"");
    }
  },

  mathmlBuilder(group, options) {
    let node;

    if (regularSpace.hasOwnProperty(group.text)) {
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      // CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new src_ParseError("Unknown type of space \"" + group.text + "\"");
    }

    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/tag.js




const pad = () => {
  const padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};

defineFunctionBuilders({
  type: "tag",

  mathmlBuilder(group, options) {
    const table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
    table.setAttribute("width", "100%");
    return table; // TODO: Left-aligned tags.
    // Currently, the group and options passed here do not contain
    // enough info to set tag alignment. `leqno` is in Settings but it is
    // not passed to Options. On the HTML side, leqno is
    // set by a CSS class applied in buildTree.js. That would have worked
    // in MathML if browsers supported <mlabeledtr>. Since they don't, we
    // need to rewrite the way this function is called.
  }

});
;// CONCATENATED MODULE: ./src/functions/text.js



 // Non-mathy text, possibly in a font

const textFontFamilies = {
  "\\text": undefined,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
const textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
const textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};

const optionsWithFont = (group, options) => {
  const font = group.font; // Checks if the argument is a font family or a font style.

  if (!font) {
    return options;
  } else if (textFontFamilies[font]) {
    return options.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options.withTextFontWeight(textFontWeights[font]);
  } else if (font === "\\emph") {
    return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
  }

  return options.withTextFontShape(textFontShapes[font]);
};

defineFunction({
  type: "text",
  names: [// Font families
  "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", // Font weights
  "\\textbf", "\\textmd", // Font Shapes
  "\\textit", "\\textup", "\\emph"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },

  handler(_ref, args) {
    let {
      parser,
      funcName
    } = _ref;
    const body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },

  htmlBuilder(group, options) {
    const newOptions = optionsWithFont(group, options);
    const inner = buildExpression(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner, newOptions);
  },

  mathmlBuilder(group, options) {
    const newOptions = optionsWithFont(group, options);
    return buildExpressionRow(group.body, newOptions);
  }

});
;// CONCATENATED MODULE: ./src/functions/underline.js





defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },

  handler(_ref, args) {
    let {
      parser
    } = _ref;
    return {
      type: "underline",
      mode: parser.mode,
      body: args[0]
    };
  },

  htmlBuilder(group, options) {
    // Underlines are handled in the TeXbook pg 443, Rule 10.
    // Build the inner group.
    const innerGroup = buildGroup(group.body, options); // Create the line to go below the body

    const line = buildCommon.makeLineSpan("underline-line", options); // Generate the vlist, with the appropriate kerns

    const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    const vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
  },

  mathmlBuilder(group, options) {
    const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");
    const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
    node.setAttribute("accentunder", "true");
    return node;
  }

});
;// CONCATENATED MODULE: ./src/functions/vcenter.js




 // \vcenter:  Vertically center the argument group on the math axis.

defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: false
  },

  handler(_ref, args) {
    let {
      parser
    } = _ref;
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },

  htmlBuilder(group, options) {
    const body = buildGroup(group.body, options);
    const axisHeight = options.fontMetrics().axisHeight;
    const dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },

  mathmlBuilder(group, options) {
    // There is no way to do this in MathML.
    // Write a class as a breadcrumb in case some post-processor wants
    // to perform a vcenter adjustment.
    return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
  }

});
;// CONCATENATED MODULE: ./src/functions/verb.js




defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },

  handler(context, args, optArgs) {
    // \verb and \verb* are dealt with directly in Parser.js.
    // If we end up here, it's because of a failure to match the two delimiters
    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
    // terminated by end of line (or file).
    throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
  },

  htmlBuilder(group, options) {
    const text = makeVerb(group);
    const body = []; // \verb enters text mode and therefore is sized like \textstyle

    const newOptions = options.havingStyle(options.style.text());

    for (let i = 0; i < text.length; i++) {
      let c = text[i];

      if (c === '~') {
        c = '\\textasciitilde';
      }

      body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }

    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
  },

  mathmlBuilder(group, options) {
    const text = new mathMLTree.TextNode(makeVerb(group));
    const node = new mathMLTree.MathNode("mtext", [text]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }

});
/**
 * Converts verb group into body string.
 *
 * \verb* replaces each space with an open box \u2423
 * \verb replaces each space with a no-break space \xA0
 */

const makeVerb = group => group.body.replace(/ /g, group.star ? '\u2423' : '\xA0');
;// CONCATENATED MODULE: ./src/functions.js
/** Include this to ensure that all functions are defined. */

const functions = _functions;
/* harmony default export */ var src_functions = (functions); // TODO(kevinb): have functions return an object and call defineFunction with
// that object in this file instead of relying on side-effects.















































;// CONCATENATED MODULE: ./src/Lexer.js
/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */




/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first group
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - matches a backslash followed by one or more whitespace characters
 * - matches a backslash followed by one or more letters then whitespace
 * - matches a backslash followed by any BMP character
 * Capturing groups:
 *   [1] regular whitespace
 *   [2] backslash followed by whitespace
 *   [3] anything else, which may include:
 *     [4] left character of \verb*
 *     [5] left character of \verb
 *     [6] backslash followed by word, excluding any trailing whitespace
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
const spaceRegexString = "[ \r\n\t]";
const controlWordRegexString = "\\\\[a-zA-Z@]+";
const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
const controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
const controlSpaceRegexString = "\\\\(\n|[ \r\t]+\n?)[ \r\t]*";
const combiningDiacriticalMarkString = "[\u0300-\u036f]";
const combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
const tokenRegexString = "(" + spaceRegexString + "+)|" + ( // whitespace
controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + ( // single codepoint
combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + ( // surrogate pair
combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4" + // \verb*
"|\\\\verb([^*a-zA-Z]).*?\\5" + ( // \verb unstarred
"|" + controlWordWhitespaceRegexString) + ( // \macroName + spaces
"|" + controlSymbolRegexString + ")"); // \\, \', etc.

/** Main Lexer class */

class Lexer {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    // Separate accents from characters
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, 'g');
    this.catcodes = {
      "%": 14,
      // comment character
      "~": 13 // active character

    };
  }

  setCatcode(char, code) {
    this.catcodes[char] = code;
  }
  /**
   * This function lexes a single token.
   */


  lex() {
    const input = this.input;
    const pos = this.tokenRegex.lastIndex;

    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }

    const match = this.tokenRegex.exec(input);

    if (match === null || match.index !== pos) {
      throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }

    const text = match[6] || match[3] || (match[2] ? "\\ " : " ");

    if (this.catcodes[text] === 14) {
      // comment character
      const nlIndex = input.indexOf('\n', this.tokenRegex.lastIndex);

      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length; // EOF

        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would " + "fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }

      return this.lex();
    }

    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }

}
;// CONCATENATED MODULE: ./src/Namespace.js
/**
 * A `Namespace` refers to a space of nameable things like macros or lengths,
 * which can be `set` either globally or local to a nested group, using an
 * undo stack similar to how TeX implements this functionality.
 * Performance-wise, `get` and local `set` take constant time, while global
 * `set` takes time proportional to the depth of group nesting.
 */

class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }

    if (globalMacros === void 0) {
      globalMacros = {};
    }

    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */


  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */


  endGroup() {
    if (this.undefStack.length === 0) {
      throw new src_ParseError("Unbalanced namespace destruction: attempt " + "to pop global namespace; please report this as a bug");
    }

    const undefs = this.undefStack.pop();

    for (const undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] == null) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */


  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */


  has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */


  get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */


  set(name, value, global) {
    if (global === void 0) {
      global = false;
    }

    if (global) {
      // Global set is equivalent to setting in all groups.  Simulate this
      // by destroying any undos currently scheduled for this name,
      // and adding an undo with the *new* value (in case it later gets
      // locally reset within this environment).
      for (let i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }

      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      // Undo this set at end of this group (possibly to `undefined`),
      // unless an undo is already in place, in which case that older
      // value is the correct one.
      const top = this.undefStack[this.undefStack.length - 1];

      if (top && !top.hasOwnProperty(name)) {
        top[name] = this.current[name];
      }
    }

    if (value == null) {
      delete this.current[name];
    } else {
      this.current[name] = value;
    }
  }

}
;// CONCATENATED MODULE: ./src/macros.js
/**
 * Predefined macros for KaTeX.
 * This can be used to define some commands in terms of others.
 */
// Export global macros object from defineMacro

const macros = _macros;
/* harmony default export */ var src_macros = (macros);





 //////////////////////////////////////////////////////////////////////
// macro tools

defineMacro("\\noexpand", function (context) {
  // The expansion is the token itself; but that token is interpreted
  // as if its meaning were ‘\relax’ if it is a control sequence that
  // would ordinarily be expanded by TeX’s expansion rules.
  const t = context.popToken();

  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }

  return {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function (context) {
  // TeX first reads the token that comes immediately after \expandafter,
  // without expanding it; let’s call this token t. Then TeX reads the
  // token that comes after t (and possibly more tokens, if that token
  // has an argument), replacing it by its expansion. Finally TeX puts
  // t back in front of that expansion.
  const t = context.popToken();
  context.expandOnce(true); // expand only an expandable token

  return {
    tokens: [t],
    numArgs: 0
  };
}); // LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
// TeX source: \long\def\@firstoftwo#1#2{#1}

defineMacro("\\@firstoftwo", function (context) {
  const args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
}); // LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
// TeX source: \long\def\@secondoftwo#1#2{#2}

defineMacro("\\@secondoftwo", function (context) {
  const args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
}); // LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
// symbol that isn't a space, consuming any spaces but not consuming the
// first nonspace character.  If that nonspace character matches #1, then
// the macro expands to #2; otherwise, it expands to #3.

defineMacro("\\@ifnextchar", function (context) {
  const args = context.consumeArgs(3); // symbol, if, else

  context.consumeSpaces();
  const nextToken = context.future();

  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
}); // LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
// If it is `*`, then it consumes the symbol, and the macro expands to #1;
// otherwise, the macro expands to #2 (without consuming the symbol).
// TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}

defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"); // LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode

defineMacro("\\TextOrMath", function (context) {
  const args = context.consumeArgs(2);

  if (context.mode === 'text') {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
}); // Lookup table for parsing numbers in base 8 through 16

const digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
}; // TeX \char makes a literal character (catcode 12) using the following forms:
// (see The TeXBook, p. 43)
//   \char123  -- decimal
//   \char'123 -- octal
//   \char"123 -- hex
//   \char`x   -- character that can be written (i.e. isn't active)
//   \char`\x  -- character that cannot be written (e.g. %)
// These all refer to characters from the font, so we turn them into special
// calls to a function \@char dealt with in the Parser.

defineMacro("\\char", function (context) {
  let token = context.popToken();
  let base;
  let number = '';

  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();

    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new src_ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }

  if (base) {
    // Parse a number in the given base, starting with first `token`.
    number = digitToNumber[token.text];

    if (number == null || number >= base) {
      throw new src_ParseError("Invalid base-" + base + " digit " + token.text);
    }

    let digit;

    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
      number *= base;
      number += digit;
      context.popToken();
    }
  }

  return "\\@char{" + number + "}";
}); // \newcommand{\macro}[args]{definition}
// \renewcommand{\macro}[args]{definition}
// TODO: Optional arguments: \newcommand{\macro}[args][default]{definition}

const newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
  let arg = context.consumeArg().tokens;

  if (arg.length !== 1) {
    throw new src_ParseError("\\newcommand's first argument must be a macro name");
  }

  const name = arg[0].text;
  const exists = context.isDefined(name);

  if (exists && !existsOK) {
    throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }

  if (!exists && !nonexistsOK) {
    throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " " + "does not yet exist; use \\newcommand");
  }

  let numArgs = 0;
  arg = context.consumeArg().tokens;

  if (arg.length === 1 && arg[0].text === "[") {
    let argText = '';
    let token = context.expandNextToken();

    while (token.text !== "]" && token.text !== "EOF") {
      // TODO: Should properly expand arg, e.g., ignore {}s
      argText += token.text;
      token = context.expandNextToken();
    }

    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new src_ParseError("Invalid number of arguments: " + argText);
    }

    numArgs = parseInt(argText);
    arg = context.consumeArg().tokens;
  }

  if (!(exists && skipIfExists)) {
    // Final arg is the expansion of the macro
    context.macros.set(name, {
      tokens: arg,
      numArgs
    });
  }

  return '';
};

defineMacro("\\newcommand", context => newcommand(context, false, true, false));
defineMacro("\\renewcommand", context => newcommand(context, true, false, false));
defineMacro("\\providecommand", context => newcommand(context, true, true, true)); // terminal (console) tools

defineMacro("\\message", context => {
  const arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console

  console.log(arg.reverse().map(token => token.text).join(""));
  return '';
});
defineMacro("\\errmessage", context => {
  const arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console

  console.error(arg.reverse().map(token => token.text).join(""));
  return '';
});
defineMacro("\\show", context => {
  const tok = context.popToken();
  const name = tok.text; // eslint-disable-next-line no-console

  console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
  return '';
}); //////////////////////////////////////////////////////////////////////
// Grouping
// \let\bgroup={ \let\egroup=}

defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}"); // Symbols from latex.ltx:
// \def~{\nobreakspace{}}
// \def\lq{`}
// \def\rq{'}
// \def \aa {\r a}
// \def \AA {\r A}

defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.
// \DeclareTextCommandDefault{\textcopyright}{\textcircled{c}}
// \DeclareTextCommandDefault{\textregistered}{\textcircled{%
//      \check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont R}}
// \DeclareRobustCommand{\copyright}{%
//    \ifmmode{\nfss@text{\textcopyright}}\else\textcopyright\fi}

defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}"); // Characters omitted from Unicode range 1D400–1D7FF

defineMacro("\u212C", "\\mathscr{B}"); // script

defineMacro("\u2130", "\\mathscr{E}");
defineMacro("\u2131", "\\mathscr{F}");
defineMacro("\u210B", "\\mathscr{H}");
defineMacro("\u2110", "\\mathscr{I}");
defineMacro("\u2112", "\\mathscr{L}");
defineMacro("\u2133", "\\mathscr{M}");
defineMacro("\u211B", "\\mathscr{R}");
defineMacro("\u212D", "\\mathfrak{C}"); // Fraktur

defineMacro("\u210C", "\\mathfrak{H}");
defineMacro("\u2128", "\\mathfrak{Z}"); // Define \Bbbk with a macro that works in both HTML and MathML.

defineMacro("\\Bbbk", "\\Bbb{k}"); // Unicode middle dot
// The KaTeX fonts do not contain U+00B7. Instead, \cdotp displays
// the dot at U+22C5 and gives it punct spacing.

defineMacro("\u00b7", "\\cdotp"); // \llap and \rlap render their contents in text mode

defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}"); // \mathstrut from the TeXbook, p 360

defineMacro("\\mathstrut", "\\vphantom{(}"); // \underbar from TeXbook p 353

defineMacro("\\underbar", "\\underline{\\text{#1}}"); // \not is defined by base/fontmath.ltx via
// \DeclareMathSymbol{\not}{\mathrel}{symbols}{"36}
// It's thus treated like a \mathrel, but defined by a symbol that has zero
// width but extends to the right.  We use \rlap to get that spacing.
// For MathML we write U+0338 here. buildMathML.js will then do the overlay.

defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'); // Negated symbols from base/fontmath.ltx:
// \def\neq{\not=} \let\ne=\neq
// \DeclareRobustCommand
//   \notin{\mathrel{\m@th\mathpalette\c@ncel\in}}
// \def\c@ncel#1#2{\m@th\ooalign{$\hfil#1\mkern1mu/\hfil$\crcr$#1#2$}}

defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
defineMacro("\\ne", "\\neq");
defineMacro("\u2260", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}" + "{\\mathrel{\\char`∉}}");
defineMacro("\u2209", "\\notin"); // Unicode stacked relations

defineMacro("\u2258", "\\html@mathml{" + "\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}" + "}{\\mathrel{\\char`\u2258}}");
defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}" + "{\\mathrel{\\char`\u225B}}");
defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}" + "{\\mathrel{\\char`\u225D}}");
defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}" + "{\\mathrel{\\char`\u225E}}");
defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"); // Misc Unicode

defineMacro("\u27C2", "\\perp");
defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("\u220C", "\\notni");
defineMacro("\u231C", "\\ulcorner");
defineMacro("\u231D", "\\urcorner");
defineMacro("\u231E", "\\llcorner");
defineMacro("\u231F", "\\lrcorner");
defineMacro("\u00A9", "\\copyright");
defineMacro("\u00AE", "\\textregistered");
defineMacro("\uFE0F", "\\textregistered"); // The KaTeX fonts have corners at codepoints that don't match Unicode.
// For MathML purposes, use the Unicode code point.

defineMacro("\\ulcorner", "\\html@mathml{\\@ulcorner}{\\mathop{\\char\"231c}}");
defineMacro("\\urcorner", "\\html@mathml{\\@urcorner}{\\mathop{\\char\"231d}}");
defineMacro("\\llcorner", "\\html@mathml{\\@llcorner}{\\mathop{\\char\"231e}}");
defineMacro("\\lrcorner", "\\html@mathml{\\@lrcorner}{\\mathop{\\char\"231f}}"); //////////////////////////////////////////////////////////////////////
// LaTeX_2ε
// \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
// \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
// We'll call \varvdots, which gets a glyph from symbols.js.
// The zero-width rule gets us an equivalent to the vertical 6pt kern.

defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22ee", "\\vdots"); //////////////////////////////////////////////////////////////////////
// amsmath.sty
// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
// Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
// but they are equivalent to \mathit{\Letter}.

defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}"); //\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}

defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"); // \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
// \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}

defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}" + "\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"); // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}}

defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}"); // \def\iff{\DOTSB\;\Longleftrightarrow\;}
// \def\implies{\DOTSB\;\Longrightarrow\;}
// \def\impliedby{\DOTSB\;\Longleftarrow\;}

defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"); // \def\dddot#1{{\mathop{#1}\limits^{\vbox to-1.4\ex@{\kern-\tw@\ex@
//  \hbox{\normalfont ...}\vss}}}}
// We use \overset which avoids the vertical shift of \mathop.

defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}"); // AMSMath's automatic \dots, based on \mdots@@ macro.

const dotsByToken = {
  ',': '\\dotsc',
  '\\not': '\\dotsb',
  // \keybin@ checks for the following:
  '+': '\\dotsb',
  '=': '\\dotsb',
  '<': '\\dotsb',
  '>': '\\dotsb',
  '-': '\\dotsb',
  '*': '\\dotsb',
  ':': '\\dotsb',
  // Symbols whose definition starts with \DOTSB:
  '\\DOTSB': '\\dotsb',
  '\\coprod': '\\dotsb',
  '\\bigvee': '\\dotsb',
  '\\bigwedge': '\\dotsb',
  '\\biguplus': '\\dotsb',
  '\\bigcap': '\\dotsb',
  '\\bigcup': '\\dotsb',
  '\\prod': '\\dotsb',
  '\\sum': '\\dotsb',
  '\\bigotimes': '\\dotsb',
  '\\bigoplus': '\\dotsb',
  '\\bigodot': '\\dotsb',
  '\\bigsqcup': '\\dotsb',
  '\\And': '\\dotsb',
  '\\longrightarrow': '\\dotsb',
  '\\Longrightarrow': '\\dotsb',
  '\\longleftarrow': '\\dotsb',
  '\\Longleftarrow': '\\dotsb',
  '\\longleftrightarrow': '\\dotsb',
  '\\Longleftrightarrow': '\\dotsb',
  '\\mapsto': '\\dotsb',
  '\\longmapsto': '\\dotsb',
  '\\hookrightarrow': '\\dotsb',
  '\\doteq': '\\dotsb',
  // Symbols whose definition starts with \mathbin:
  '\\mathbin': '\\dotsb',
  // Symbols whose definition starts with \mathrel:
  '\\mathrel': '\\dotsb',
  '\\relbar': '\\dotsb',
  '\\Relbar': '\\dotsb',
  '\\xrightarrow': '\\dotsb',
  '\\xleftarrow': '\\dotsb',
  // Symbols whose definition starts with \DOTSI:
  '\\DOTSI': '\\dotsi',
  '\\int': '\\dotsi',
  '\\oint': '\\dotsi',
  '\\iint': '\\dotsi',
  '\\iiint': '\\dotsi',
  '\\iiiint': '\\dotsi',
  '\\idotsint': '\\dotsi',
  // Symbols whose definition starts with \DOTSX:
  '\\DOTSX': '\\dotsx'
};
defineMacro("\\dots", function (context) {
  // TODO: If used in text mode, should expand to \textellipsis.
  // However, in KaTeX, \textellipsis and \ldots behave the same
  // (in text mode), and it's unlikely we'd see any of the math commands
  // that affect the behavior of \dots when in text mode.  So fine for now
  // (until we support \ifmmode ... \else ... \fi).
  let thedots = '\\dotso';
  const next = context.expandAfterFuture().text;

  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === '\\not') {
    thedots = '\\dotsb';
  } else if (next in src_symbols.math) {
    if (utils.contains(['bin', 'rel'], src_symbols.math[next].group)) {
      thedots = '\\dotsb';
    }
  }

  return thedots;
});
const spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ')': true,
  ']': true,
  '\\rbrack': true,
  '\\}': true,
  '\\rbrace': true,
  '\\rangle': true,
  '\\rceil': true,
  '\\rfloor': true,
  '\\rgroup': true,
  '\\rmoustache': true,
  '\\right': true,
  '\\bigr': true,
  '\\biggr': true,
  '\\Bigr': true,
  '\\Biggr': true,
  // \extra@ also tests for the following:
  '$': true,
  // \extrap@ checks for the following:
  ';': true,
  '.': true,
  ',': true
};
defineMacro("\\dotso", function (context) {
  const next = context.future().text;

  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function (context) {
  const next = context.future().text; // \dotsc uses \extra@ but not \extrap@, instead specially checking for
  // ';' and '.', but doesn't check for ','.

  if (next in spaceAfterDots && next !== ',') {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function (context) {
  const next = context.future().text;

  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots"); // amsmath doesn't actually define \dotsx, but \dots followed by a macro
// starting with \DOTSX implies \dotso, and then \extra@ detects this case
// and forces the added `\,`.

defineMacro("\\dotsx", "\\ldots\\,"); // \let\DOTSI\relax
// \let\DOTSB\relax
// \let\DOTSX\relax

defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax"); // Spacing, based on amsmath.sty's override of LaTeX defaults
// \DeclareRobustCommand{\tmspace}[3]{%
//   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}

defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"); // \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip

defineMacro("\\,", "\\tmspace+{3mu}{.1667em}"); // \let\thinspace\,

defineMacro("\\thinspace", "\\,"); // \def\>{\mskip\medmuskip}
// \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
// TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu

defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}"); // \let\medspace\:

defineMacro("\\medspace", "\\:"); // \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip = 5mu plus 5mu

defineMacro("\\;", "\\tmspace+{5mu}{.2777em}"); // \let\thickspace\;

defineMacro("\\thickspace", "\\;"); // \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip

defineMacro("\\!", "\\tmspace-{3mu}{.1667em}"); // \let\negthinspace\!

defineMacro("\\negthinspace", "\\!"); // \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
// TODO: math mode should use \medmuskip

defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}"); // \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip

defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}"); // \def\enspace{\kern.5em }

defineMacro("\\enspace", "\\kern.5em "); // \def\enskip{\hskip.5em\relax}

defineMacro("\\enskip", "\\hskip.5em\\relax"); // \def\quad{\hskip1em\relax}

defineMacro("\\quad", "\\hskip1em\\relax"); // \def\qquad{\hskip2em\relax}

defineMacro("\\qquad", "\\hskip2em\\relax"); // \tag@in@display form of \tag

defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", context => {
  if (context.macros.get("\\df@tag")) {
    throw new src_ParseError("Multiple \\tag");
  }

  return "\\gdef\\df@tag{\\text{#1}}";
}); // \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
//   {\operator@font mod}\penalty900
//   \mkern5mu\nonscript\mskip-\medmuskip}
// \newcommand{\pod}[1]{\allowbreak
//   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
// \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
// \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
//   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
// TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu

defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}" + "\\mathbin{\\rm mod}" + "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" + "{\\rm mod}\\,\\,#1"); //////////////////////////////////////////////////////////////////////
// LaTeX source2e
// \expandafter\let\expandafter\@normalcr
//     \csname\expandafter\@gobble\string\\ \endcsname
// \DeclareRobustCommand\newline{\@normalcr\relax}

defineMacro("\\newline", "\\\\\\relax"); // \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
// TODO: Doesn't normally work in math mode because \@ fails.  KaTeX doesn't
// support \@ yet, so that's omitted, and we add \text so that the result
// doesn't look funny in math mode.

defineMacro("\\TeX", "\\textrm{\\html@mathml{" + "T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX" + "}{TeX}}"); // \DeclareRobustCommand{\LaTeX}{L\kern-.36em%
//         {\sbox\z@ T%
//          \vbox to\ht\z@{\hbox{\check@mathfonts
//                               \fontsize\sf@size\z@
//                               \math@fontsfalse\selectfont
//                               A}%
//                         \vss}%
//         }%
//         \kern-.15em%
//         \TeX}
// This code aligns the top of the A with the T (from the perspective of TeX's
// boxes, though visually the A appears to extend above slightly).
// We compute the corresponding \raisebox when A is rendered in \normalsize
// \scriptstyle, which has a scale factor of 0.7 (see Options.js).

const latexRaiseA = makeEm(fontMetricsData['Main-Regular']["T".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular']["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"); // New KaTeX logo based on tweaking LaTeX logo

defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"); // \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
// \def\@hspace#1{\hskip  #1\relax}
// \def\@hspacer#1{\vrule \@width\z@\nobreak
//                 \hskip #1\hskip \z@skip}

defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"); //////////////////////////////////////////////////////////////////////
// mathtools.sty
//\providecommand\ordinarycolon{:}

defineMacro("\\ordinarycolon", ":"); //\def\vcentcolon{\mathrel{\mathop\ordinarycolon}}
//TODO(edemaine): Not yet centered. Fix via \raisebox or #726

defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"); // \providecommand*\dblcolon{\vcentcolon\mathrel{\mkern-.9mu}\vcentcolon}

defineMacro("\\dblcolon", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}" + "{\\mathop{\\char\"2237}}"); // \providecommand*\coloneqq{\vcentcolon\mathrel{\mkern-1.2mu}=}

defineMacro("\\coloneqq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2254}}"); // ≔
// \providecommand*\Coloneqq{\dblcolon\mathrel{\mkern-1.2mu}=}

defineMacro("\\Coloneqq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2237\\char\"3d}}"); // \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

defineMacro("\\coloneq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"3a\\char\"2212}}"); // \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

defineMacro("\\Coloneq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"2237\\char\"2212}}"); // \providecommand*\eqqcolon{=\mathrel{\mkern-1.2mu}\vcentcolon}

defineMacro("\\eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2255}}"); // ≕
// \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}

defineMacro("\\Eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"3d\\char\"2237}}"); // \providecommand*\eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\vcentcolon}

defineMacro("\\eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2239}}"); // \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}

defineMacro("\\Eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"2212\\char\"2237}}"); // \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}

defineMacro("\\colonapprox", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"3a\\char\"2248}}"); // \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}

defineMacro("\\Colonapprox", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"2237\\char\"2248}}"); // \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}

defineMacro("\\colonsim", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"3a\\char\"223c}}"); // \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}

defineMacro("\\Colonsim", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"2237\\char\"223c}}"); // Some Unicode characters are implemented with macros to mathtools functions.

defineMacro("\u2237", "\\dblcolon"); // ::

defineMacro("\u2239", "\\eqcolon"); // -:

defineMacro("\u2254", "\\coloneqq"); // :=

defineMacro("\u2255", "\\eqqcolon"); // =:

defineMacro("\u2A74", "\\Coloneqq"); // ::=
//////////////////////////////////////////////////////////////////////
// colonequals.sty
// Alternate names for mathtools's macros:

defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon"); // \colonapprox name is same in mathtools and colonequals.

defineMacro("\\coloncolonapprox", "\\Colonapprox"); // \colonsim name is same in mathtools and colonequals.

defineMacro("\\coloncolonsim", "\\Colonsim"); // Additional macros, implemented by analogy with mathtools definitions:

defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"); // Present in newtxmath, pxfonts and txfonts

defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"); //////////////////////////////////////////////////////////////////////
// From amsopn.sty

defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"); //////////////////////////////////////////////////////////////////////
// MathML alternates for KaTeX glyphs in the Unicode private area

defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}"); //////////////////////////////////////////////////////////////////////
// stmaryrd and semantic
// The stmaryrd and semantic packages render the next four items by calling a
// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.

defineMacro("\\llbracket", "\\html@mathml{" + "\\mathopen{[\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u27e6}}");
defineMacro("\\rrbracket", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu]}}" + "{\\mathclose{\\char`\u27e7}}");
defineMacro("\u27e6", "\\llbracket"); // blackboard bold [

defineMacro("\u27e7", "\\rrbracket"); // blackboard bold ]

defineMacro("\\lBrace", "\\html@mathml{" + "\\mathopen{\\{\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u2983}}");
defineMacro("\\rBrace", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu\\}}}" + "{\\mathclose{\\char`\u2984}}");
defineMacro("\u2983", "\\lBrace"); // blackboard bold {

defineMacro("\u2984", "\\rBrace"); // blackboard bold }
// TODO: Create variable sized versions of the last two items. I believe that
// will require new font glyphs.
// The stmaryrd function `\minuso` provides a "Plimsoll" symbol that
// superimposes the characters \circ and \mathminus. Used in chemistry.

defineMacro("\\minuso", "\\mathbin{\\html@mathml{" + "{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}" + "{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}" + "{\\char`⦵}}");
defineMacro("⦵", "\\minuso"); //////////////////////////////////////////////////////////////////////
// texvc.sty
// The texvc package contains macros available in mediawiki pages.
// We omit the functions deprecated at
// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
// We also omit texvc's \O, which conflicts with \text{\O}

defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta"); // TODO: defineMacro("\\varcoppa", "\\\mbox{\\coppa}");

defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}"); //////////////////////////////////////////////////////////////////////
// statmath.sty
// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"); //////////////////////////////////////////////////////////////////////
// braket.sty
// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf

defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");

const braketHelper = one => context => {
  const left = context.consumeArg().tokens;
  const middle = context.consumeArg().tokens;
  const middleDouble = context.consumeArg().tokens;
  const right = context.consumeArg().tokens;
  const oldMiddle = context.macros.get("|");
  const oldMiddleDouble = context.macros.get("\\|");
  context.macros.beginGroup();

  const midMacro = double => context => {
    if (one) {
      // Only modify the first instance of | or \|
      context.macros.set("|", oldMiddle);

      if (middleDouble.length) {
        context.macros.set("\\|", oldMiddleDouble);
      }
    }

    let doubled = double;

    if (!double && middleDouble.length) {
      // Mimic \@ifnextchar
      const nextToken = context.future();

      if (nextToken.text === "|") {
        context.popToken();
        doubled = true;
      }
    }

    return {
      tokens: doubled ? middleDouble : middle,
      numArgs: 0
    };
  };

  context.macros.set("|", midMacro(false));

  if (middleDouble.length) {
    context.macros.set("\\|", midMacro(true));
  }

  const arg = context.consumeArg().tokens;
  const expanded = context.expandTokens([...right, ...arg, ...left // reversed
  ]);
  context.macros.endGroup();
  return {
    tokens: expanded.reverse(),
    numArgs: 0
  };
};

defineMacro("\\bra@ket", braketHelper(false));
defineMacro("\\bra@set", braketHelper(true));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}" + "{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}" + "{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"); // has no support for special || or \|
//////////////////////////////////////////////////////////////////////
// actuarialangle.dtx

defineMacro("\\angln", "{\\angl n}"); // Custom Khan Academy colors, should be moved to an optional package

defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
;// CONCATENATED MODULE: ./src/MacroExpander.js
/**
 * This file contains the “gullet” where macros are expanded
 * until only non-macro tokens remain.
 */







// List of commands that act like macros but aren't defined as a macro,
// function, or symbol.  Used in `isDefined`.
const implicitCommands = {
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true // Parser.js

};
class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input); // Make new global namespace

    this.macros = new Namespace(src_macros, settings.macros);
    this.mode = mode;
    this.stack = []; // contains tokens in REVERSE order
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */


  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */


  switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */


  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */


  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */


  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */


  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }

    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */


  popToken() {
    this.future(); // ensure non-empty stack

    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */


  pushToken(token) {
    this.stack.push(token);
  }
  /**
   * Append an array of tokens to the token stack.
   */


  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */


  scanArgument(isOptional) {
    let start;
    let end;
    let tokens;

    if (isOptional) {
      this.consumeSpaces(); // \@ifnextchar gobbles any space following it

      if (this.future().text !== "[") {
        return null;
      }

      start = this.popToken(); // don't include [ in tokens

      ({
        tokens,
        end
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start,
        end
      } = this.consumeArg());
    } // indicate the end of an argument


    this.pushToken(new Token("EOF", end.loc));
    this.pushTokens(tokens);
    return start.range(end, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */


  consumeSpaces() {
    for (;;) {
      const token = this.future();

      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */


  consumeArg(delims) {
    // The argument for a delimited parameter is the shortest (possibly
    // empty) sequence of tokens with properly nested {...} groups that is
    // followed ... by this particular list of non-parameter tokens.
    // The argument for an undelimited parameter is the next nonblank
    // token, unless that token is ‘{’, when the argument will be the
    // entire {...} group that follows.
    const tokens = [];
    const isDelimited = delims && delims.length > 0;

    if (!isDelimited) {
      // Ignore spaces between arguments.  As the TeXbook says:
      // "After you have said ‘\def\row#1#2{...}’, you are allowed to
      //  put spaces between the arguments (e.g., ‘\row x n’), because
      //  TeX doesn’t use single spaces as undelimited arguments."
      this.consumeSpaces();
    }

    const start = this.future();
    let tok;
    let depth = 0;
    let match = 0;

    do {
      tok = this.popToken();
      tokens.push(tok);

      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;

        if (depth === -1) {
          throw new src_ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new src_ParseError("Unexpected end of input in a macro argument" + ", expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
      }

      if (delims && isDelimited) {
        if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
          ++match;

          if (match === delims.length) {
            // don't include delims in tokens
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited); // If the argument found ... has the form ‘{<nested tokens>}’,
    // ... the outermost braces enclosing the argument are removed


    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }

    tokens.reverse(); // to fit in with stack order

    return {
      tokens,
      start,
      end: tok
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */


  consumeArgs(numArgs, delimiters) {
    if (delimiters) {
      if (delimiters.length !== numArgs + 1) {
        throw new src_ParseError("The length of delimiters doesn't match the number of args!");
      }

      const delims = delimiters[0];

      for (let i = 0; i < delims.length; i++) {
        const tok = this.popToken();

        if (delims[i] !== tok.text) {
          throw new src_ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }

    const args = [];

    for (let i = 0; i < numArgs; i++) {
      args.push(this.consumeArg(delimiters && delimiters[i + 1]).tokens);
    }

    return args;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */


  countExpansion(amount) {
    this.expansionCount += amount;

    if (this.expansionCount > this.settings.maxExpand) {
      throw new src_ParseError("Too many expansions: infinite loop or " + "need to increase maxExpand setting");
    }
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */


  expandOnce(expandableOnly) {
    const topToken = this.popToken();
    const name = topToken.text;
    const expansion = !topToken.noexpand ? this._getExpansion(name) : null;

    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new src_ParseError("Undefined control sequence: " + name);
      }

      this.pushToken(topToken);
      return false;
    }

    this.countExpansion(1);
    let tokens = expansion.tokens;
    const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);

    if (expansion.numArgs) {
      // paste arguments in place of the placeholders
      tokens = tokens.slice(); // make a shallow copy

      for (let i = tokens.length - 1; i >= 0; --i) {
        let tok = tokens[i];

        if (tok.text === "#") {
          if (i === 0) {
            throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
          }

          tok = tokens[--i]; // next token on stack

          if (tok.text === "#") {
            // ## → #
            tokens.splice(i + 1, 1); // drop first #
          } else if (/^[1-9]$/.test(tok.text)) {
            // replace the placeholder with the indicated argument
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new src_ParseError("Not a valid argument number", tok);
          }
        }
      }
    } // Concatenate expansion onto top of stack.


    this.pushTokens(tokens);
    return tokens.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */


  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */


  expandNextToken() {
    for (;;) {
      if (this.expandOnce() === false) {
        // fully expanded
        const token = this.stack.pop(); // the token after \noexpand is interpreted as if its meaning
        // were ‘\relax’

        if (token.treatAsRelax) {
          token.text = "\\relax";
        }

        return token;
      }
    } // Flow unable to figure out that this pathway is impossible.
    // https://github.com/facebook/flow/issues/4808


    throw new Error(); // eslint-disable-line no-unreachable
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */


  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */


  expandTokens(tokens) {
    const output = [];
    const oldStackLength = this.stack.length;
    this.pushTokens(tokens);

    while (this.stack.length > oldStackLength) {
      // Expand only expandable tokens
      if (this.expandOnce(true) === false) {
        // fully expanded
        const token = this.stack.pop();

        if (token.treatAsRelax) {
          // the expansion of \noexpand is the token itself
          token.noexpand = false;
          token.treatAsRelax = false;
        }

        output.push(token);
      }
    } // Count all of these tokens as additional expansions, to prevent
    // exponential blowup from linearly many \edef's.


    this.countExpansion(output.length);
    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */


  expandMacroAsText(name) {
    const tokens = this.expandMacro(name);

    if (tokens) {
      return tokens.map(token => token.text).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */


  _getExpansion(name) {
    const definition = this.macros.get(name);

    if (definition == null) {
      // mainly checking for undefined here
      return definition;
    } // If a single character has an associated catcode other than 13
    // (active character), then don't expand it.


    if (name.length === 1) {
      const catcode = this.lexer.catcodes[name];

      if (catcode != null && catcode !== 13) {
        return;
      }
    }

    const expansion = typeof definition === "function" ? definition(this) : definition;

    if (typeof expansion === "string") {
      let numArgs = 0;

      if (expansion.indexOf("#") !== -1) {
        const stripped = expansion.replace(/##/g, "");

        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }

      const bodyLexer = new Lexer(expansion, this.settings);
      const tokens = [];
      let tok = bodyLexer.lex();

      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }

      tokens.reverse(); // to fit in with stack using push and pop

      const expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }

    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */


  isDefined(name) {
    return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  }
  /**
   * Determine whether a command is expandable.
   */


  isExpandable(name) {
    const macro = this.macros.get(name);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
  }

}
;// CONCATENATED MODULE: ./src/unicodeSupOrSub.js
// Helpers for Parser.js handling of Unicode (sub|super)script characters.
const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
const uSubsAndSups = Object.freeze({
  '₊': '+',
  '₋': '-',
  '₌': '=',
  '₍': '(',
  '₎': ')',
  '₀': '0',
  '₁': '1',
  '₂': '2',
  '₃': '3',
  '₄': '4',
  '₅': '5',
  '₆': '6',
  '₇': '7',
  '₈': '8',
  '₉': '9',
  '\u2090': 'a',
  '\u2091': 'e',
  '\u2095': 'h',
  '\u1D62': 'i',
  '\u2C7C': 'j',
  '\u2096': 'k',
  '\u2097': 'l',
  '\u2098': 'm',
  '\u2099': 'n',
  '\u2092': 'o',
  '\u209A': 'p',
  '\u1D63': 'r',
  '\u209B': 's',
  '\u209C': 't',
  '\u1D64': 'u',
  '\u1D65': 'v',
  '\u2093': 'x',
  '\u1D66': 'β',
  '\u1D67': 'γ',
  '\u1D68': 'ρ',
  '\u1D69': '\u03d5',
  '\u1D6A': 'χ',
  '⁺': '+',
  '⁻': '-',
  '⁼': '=',
  '⁽': '(',
  '⁾': ')',
  '⁰': '0',
  '¹': '1',
  '²': '2',
  '³': '3',
  '⁴': '4',
  '⁵': '5',
  '⁶': '6',
  '⁷': '7',
  '⁸': '8',
  '⁹': '9',
  '\u1D2C': 'A',
  '\u1D2E': 'B',
  '\u1D30': 'D',
  '\u1D31': 'E',
  '\u1D33': 'G',
  '\u1D34': 'H',
  '\u1D35': 'I',
  '\u1D36': 'J',
  '\u1D37': 'K',
  '\u1D38': 'L',
  '\u1D39': 'M',
  '\u1D3A': 'N',
  '\u1D3C': 'O',
  '\u1D3E': 'P',
  '\u1D3F': 'R',
  '\u1D40': 'T',
  '\u1D41': 'U',
  '\u2C7D': 'V',
  '\u1D42': 'W',
  '\u1D43': 'a',
  '\u1D47': 'b',
  '\u1D9C': 'c',
  '\u1D48': 'd',
  '\u1D49': 'e',
  '\u1DA0': 'f',
  '\u1D4D': 'g',
  '\u02B0': 'h',
  '\u2071': 'i',
  '\u02B2': 'j',
  '\u1D4F': 'k',
  '\u02E1': 'l',
  '\u1D50': 'm',
  '\u207F': 'n',
  '\u1D52': 'o',
  '\u1D56': 'p',
  '\u02B3': 'r',
  '\u02E2': 's',
  '\u1D57': 't',
  '\u1D58': 'u',
  '\u1D5B': 'v',
  '\u02B7': 'w',
  '\u02E3': 'x',
  '\u02B8': 'y',
  '\u1DBB': 'z',
  '\u1D5D': 'β',
  '\u1D5E': 'γ',
  '\u1D5F': 'δ',
  '\u1D60': '\u03d5',
  '\u1D61': 'χ',
  '\u1DBF': 'θ'
});
;// CONCATENATED MODULE: ./src/Parser.js
/* eslint no-constant-condition:0 */










 // Pre-evaluate both modules as unicodeSymbols require String.normalize()

const unicodeAccents = {
  "́": {
    "text": "\\'",
    "math": "\\acute"
  },
  "̀": {
    "text": "\\`",
    "math": "\\grave"
  },
  "̈": {
    "text": "\\\"",
    "math": "\\ddot"
  },
  "̃": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "̄": {
    "text": "\\=",
    "math": "\\bar"
  },
  "̆": {
    "text": "\\u",
    "math": "\\breve"
  },
  "̌": {
    "text": "\\v",
    "math": "\\check"
  },
  "̂": {
    "text": "\\^",
    "math": "\\hat"
  },
  "̇": {
    "text": "\\.",
    "math": "\\dot"
  },
  "̊": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "̋": {
    "text": "\\H"
  },
  "̧": {
    "text": "\\c"
  }
};
const unicodeSymbols = {
  "á": "á",
  "à": "à",
  "ä": "ä",
  "ǟ": "ǟ",
  "ã": "ã",
  "ā": "ā",
  "ă": "ă",
  "ắ": "ắ",
  "ằ": "ằ",
  "ẵ": "ẵ",
  "ǎ": "ǎ",
  "â": "â",
  "ấ": "ấ",
  "ầ": "ầ",
  "ẫ": "ẫ",
  "ȧ": "ȧ",
  "ǡ": "ǡ",
  "å": "å",
  "ǻ": "ǻ",
  "ḃ": "ḃ",
  "ć": "ć",
  "ḉ": "ḉ",
  "č": "č",
  "ĉ": "ĉ",
  "ċ": "ċ",
  "ç": "ç",
  "ď": "ď",
  "ḋ": "ḋ",
  "ḑ": "ḑ",
  "é": "é",
  "è": "è",
  "ë": "ë",
  "ẽ": "ẽ",
  "ē": "ē",
  "ḗ": "ḗ",
  "ḕ": "ḕ",
  "ĕ": "ĕ",
  "ḝ": "ḝ",
  "ě": "ě",
  "ê": "ê",
  "ế": "ế",
  "ề": "ề",
  "ễ": "ễ",
  "ė": "ė",
  "ȩ": "ȩ",
  "ḟ": "ḟ",
  "ǵ": "ǵ",
  "ḡ": "ḡ",
  "ğ": "ğ",
  "ǧ": "ǧ",
  "ĝ": "ĝ",
  "ġ": "ġ",
  "ģ": "ģ",
  "ḧ": "ḧ",
  "ȟ": "ȟ",
  "ĥ": "ĥ",
  "ḣ": "ḣ",
  "ḩ": "ḩ",
  "í": "í",
  "ì": "ì",
  "ï": "ï",
  "ḯ": "ḯ",
  "ĩ": "ĩ",
  "ī": "ī",
  "ĭ": "ĭ",
  "ǐ": "ǐ",
  "î": "î",
  "ǰ": "ǰ",
  "ĵ": "ĵ",
  "ḱ": "ḱ",
  "ǩ": "ǩ",
  "ķ": "ķ",
  "ĺ": "ĺ",
  "ľ": "ľ",
  "ļ": "ļ",
  "ḿ": "ḿ",
  "ṁ": "ṁ",
  "ń": "ń",
  "ǹ": "ǹ",
  "ñ": "ñ",
  "ň": "ň",
  "ṅ": "ṅ",
  "ņ": "ņ",
  "ó": "ó",
  "ò": "ò",
  "ö": "ö",
  "ȫ": "ȫ",
  "õ": "õ",
  "ṍ": "ṍ",
  "ṏ": "ṏ",
  "ȭ": "ȭ",
  "ō": "ō",
  "ṓ": "ṓ",
  "ṑ": "ṑ",
  "ŏ": "ŏ",
  "ǒ": "ǒ",
  "ô": "ô",
  "ố": "ố",
  "ồ": "ồ",
  "ỗ": "ỗ",
  "ȯ": "ȯ",
  "ȱ": "ȱ",
  "ő": "ő",
  "ṕ": "ṕ",
  "ṗ": "ṗ",
  "ŕ": "ŕ",
  "ř": "ř",
  "ṙ": "ṙ",
  "ŗ": "ŗ",
  "ś": "ś",
  "ṥ": "ṥ",
  "š": "š",
  "ṧ": "ṧ",
  "ŝ": "ŝ",
  "ṡ": "ṡ",
  "ş": "ş",
  "ẗ": "ẗ",
  "ť": "ť",
  "ṫ": "ṫ",
  "ţ": "ţ",
  "ú": "ú",
  "ù": "ù",
  "ü": "ü",
  "ǘ": "ǘ",
  "ǜ": "ǜ",
  "ǖ": "ǖ",
  "ǚ": "ǚ",
  "ũ": "ũ",
  "ṹ": "ṹ",
  "ū": "ū",
  "ṻ": "ṻ",
  "ŭ": "ŭ",
  "ǔ": "ǔ",
  "û": "û",
  "ů": "ů",
  "ű": "ű",
  "ṽ": "ṽ",
  "ẃ": "ẃ",
  "ẁ": "ẁ",
  "ẅ": "ẅ",
  "ŵ": "ŵ",
  "ẇ": "ẇ",
  "ẘ": "ẘ",
  "ẍ": "ẍ",
  "ẋ": "ẋ",
  "ý": "ý",
  "ỳ": "ỳ",
  "ÿ": "ÿ",
  "ỹ": "ỹ",
  "ȳ": "ȳ",
  "ŷ": "ŷ",
  "ẏ": "ẏ",
  "ẙ": "ẙ",
  "ź": "ź",
  "ž": "ž",
  "ẑ": "ẑ",
  "ż": "ż",
  "Á": "Á",
  "À": "À",
  "Ä": "Ä",
  "Ǟ": "Ǟ",
  "Ã": "Ã",
  "Ā": "Ā",
  "Ă": "Ă",
  "Ắ": "Ắ",
  "Ằ": "Ằ",
  "Ẵ": "Ẵ",
  "Ǎ": "Ǎ",
  "Â": "Â",
  "Ấ": "Ấ",
  "Ầ": "Ầ",
  "Ẫ": "Ẫ",
  "Ȧ": "Ȧ",
  "Ǡ": "Ǡ",
  "Å": "Å",
  "Ǻ": "Ǻ",
  "Ḃ": "Ḃ",
  "Ć": "Ć",
  "Ḉ": "Ḉ",
  "Č": "Č",
  "Ĉ": "Ĉ",
  "Ċ": "Ċ",
  "Ç": "Ç",
  "Ď": "Ď",
  "Ḋ": "Ḋ",
  "Ḑ": "Ḑ",
  "É": "É",
  "È": "È",
  "Ë": "Ë",
  "Ẽ": "Ẽ",
  "Ē": "Ē",
  "Ḗ": "Ḗ",
  "Ḕ": "Ḕ",
  "Ĕ": "Ĕ",
  "Ḝ": "Ḝ",
  "Ě": "Ě",
  "Ê": "Ê",
  "Ế": "Ế",
  "Ề": "Ề",
  "Ễ": "Ễ",
  "Ė": "Ė",
  "Ȩ": "Ȩ",
  "Ḟ": "Ḟ",
  "Ǵ": "Ǵ",
  "Ḡ": "Ḡ",
  "Ğ": "Ğ",
  "Ǧ": "Ǧ",
  "Ĝ": "Ĝ",
  "Ġ": "Ġ",
  "Ģ": "Ģ",
  "Ḧ": "Ḧ",
  "Ȟ": "Ȟ",
  "Ĥ": "Ĥ",
  "Ḣ": "Ḣ",
  "Ḩ": "Ḩ",
  "Í": "Í",
  "Ì": "Ì",
  "Ï": "Ï",
  "Ḯ": "Ḯ",
  "Ĩ": "Ĩ",
  "Ī": "Ī",
  "Ĭ": "Ĭ",
  "Ǐ": "Ǐ",
  "Î": "Î",
  "İ": "İ",
  "Ĵ": "Ĵ",
  "Ḱ": "Ḱ",
  "Ǩ": "Ǩ",
  "Ķ": "Ķ",
  "Ĺ": "Ĺ",
  "Ľ": "Ľ",
  "Ļ": "Ļ",
  "Ḿ": "Ḿ",
  "Ṁ": "Ṁ",
  "Ń": "Ń",
  "Ǹ": "Ǹ",
  "Ñ": "Ñ",
  "Ň": "Ň",
  "Ṅ": "Ṅ",
  "Ņ": "Ņ",
  "Ó": "Ó",
  "Ò": "Ò",
  "Ö": "Ö",
  "Ȫ": "Ȫ",
  "Õ": "Õ",
  "Ṍ": "Ṍ",
  "Ṏ": "Ṏ",
  "Ȭ": "Ȭ",
  "Ō": "Ō",
  "Ṓ": "Ṓ",
  "Ṑ": "Ṑ",
  "Ŏ": "Ŏ",
  "Ǒ": "Ǒ",
  "Ô": "Ô",
  "Ố": "Ố",
  "Ồ": "Ồ",
  "Ỗ": "Ỗ",
  "Ȯ": "Ȯ",
  "Ȱ": "Ȱ",
  "Ő": "Ő",
  "Ṕ": "Ṕ",
  "Ṗ": "Ṗ",
  "Ŕ": "Ŕ",
  "Ř": "Ř",
  "Ṙ": "Ṙ",
  "Ŗ": "Ŗ",
  "Ś": "Ś",
  "Ṥ": "Ṥ",
  "Š": "Š",
  "Ṧ": "Ṧ",
  "Ŝ": "Ŝ",
  "Ṡ": "Ṡ",
  "Ş": "Ş",
  "Ť": "Ť",
  "Ṫ": "Ṫ",
  "Ţ": "Ţ",
  "Ú": "Ú",
  "Ù": "Ù",
  "Ü": "Ü",
  "Ǘ": "Ǘ",
  "Ǜ": "Ǜ",
  "Ǖ": "Ǖ",
  "Ǚ": "Ǚ",
  "Ũ": "Ũ",
  "Ṹ": "Ṹ",
  "Ū": "Ū",
  "Ṻ": "Ṻ",
  "Ŭ": "Ŭ",
  "Ǔ": "Ǔ",
  "Û": "Û",
  "Ů": "Ů",
  "Ű": "Ű",
  "Ṽ": "Ṽ",
  "Ẃ": "Ẃ",
  "Ẁ": "Ẁ",
  "Ẅ": "Ẅ",
  "Ŵ": "Ŵ",
  "Ẇ": "Ẇ",
  "Ẍ": "Ẍ",
  "Ẋ": "Ẋ",
  "Ý": "Ý",
  "Ỳ": "Ỳ",
  "Ÿ": "Ÿ",
  "Ỹ": "Ỹ",
  "Ȳ": "Ȳ",
  "Ŷ": "Ŷ",
  "Ẏ": "Ẏ",
  "Ź": "Ź",
  "Ž": "Ž",
  "Ẑ": "Ẑ",
  "Ż": "Ż",
  "ά": "ά",
  "ὰ": "ὰ",
  "ᾱ": "ᾱ",
  "ᾰ": "ᾰ",
  "έ": "έ",
  "ὲ": "ὲ",
  "ή": "ή",
  "ὴ": "ὴ",
  "ί": "ί",
  "ὶ": "ὶ",
  "ϊ": "ϊ",
  "ΐ": "ΐ",
  "ῒ": "ῒ",
  "ῑ": "ῑ",
  "ῐ": "ῐ",
  "ό": "ό",
  "ὸ": "ὸ",
  "ύ": "ύ",
  "ὺ": "ὺ",
  "ϋ": "ϋ",
  "ΰ": "ΰ",
  "ῢ": "ῢ",
  "ῡ": "ῡ",
  "ῠ": "ῠ",
  "ώ": "ώ",
  "ὼ": "ὼ",
  "Ύ": "Ύ",
  "Ὺ": "Ὺ",
  "Ϋ": "Ϋ",
  "Ῡ": "Ῡ",
  "Ῠ": "Ῠ",
  "Ώ": "Ώ",
  "Ὼ": "Ὼ"
};

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The functions return ParseNodes.
 */
class Parser {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    // Start in math mode
    this.mode = "math"; // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)

    this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing

    this.settings = settings; // Count leftright depth (for \middle errors)

    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */


  expect(text, consume) {
    if (consume === void 0) {
      consume = true;
    }

    if (this.fetch().text !== text) {
      throw new src_ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
    }

    if (consume) {
      this.consume();
    }
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */


  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */


  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }

    return this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */


  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */


  parse() {
    if (!this.settings.globalGroup) {
      // Create a group namespace for the math expression.
      // (LaTeX creates a new group for every $...$, $$...$$, \[...\].)
      this.gullet.beginGroup();
    } // Use old \color behavior (same as LaTeX's \textcolor) if requested.
    // We do this within the group for the math expression, so it doesn't
    // pollute settings.macros.


    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }

    try {
      // Try to parse the input
      const parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end

      this.expect("EOF"); // End the group namespace for the expression

      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }

      return parse; // Close any leftover groups in case of a parse error.
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */


  subparse(tokens) {
    // Save the next token from the current job.
    const oldToken = this.nextToken;
    this.consume(); // Run the new job, terminating it with an excess '}'

    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    const parse = this.parseExpression(false);
    this.expect("}"); // Restore the next token from the current job.

    this.nextToken = oldToken;
    return parse;
  }

  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(breakOnInfix, breakOnTokenText) {
    const body = []; // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)

    while (true) {
      // Ignore spaces in math mode
      if (this.mode === "math") {
        this.consumeSpaces();
      }

      const lex = this.fetch();

      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }

      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }

      if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
        break;
      }

      const atom = this.parseAtom(breakOnTokenText);

      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }

      body.push(atom);
    }

    if (this.mode === "text") {
      this.formLigatures(body);
    }

    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */


  handleInfixNodes(body) {
    let overIndex = -1;
    let funcName;

    for (let i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new src_ParseError("only one infix operator per group", body[i].token);
        }

        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }

    if (overIndex !== -1 && funcName) {
      let numerNode;
      let denomNode;
      const numerBody = body.slice(0, overIndex);
      const denomBody = body.slice(overIndex + 1);

      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }

      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }

      let node;

      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }

      return [node];
    } else {
      return body;
    }
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */


  handleSupSubscript(name // For error reporting.
  ) {
    const symbolToken = this.fetch();
    const symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces(); // ignore spaces before sup/subscript argument

    const group = this.parseGroup(name);

    if (!group) {
      throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
    }

    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */


  formatUnsupportedCmd(text) {
    const textordArray = [];

    for (let i = 0; i < text.length; i++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text[i]
      });
    }

    const textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    const colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */


  parseAtom(breakOnTokenText) {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    const base = this.parseGroup("atom", breakOnTokenText); // In text mode, we don't have superscripts or subscripts

    if (this.mode === "text") {
      return base;
    } // Note that base may be empty (i.e. null) at this point.


    let superscript;
    let subscript;

    while (true) {
      // Guaranteed in math mode, so eat any spaces first.
      this.consumeSpaces(); // Lex the first token

      const lex = this.fetch();

      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        // We got a limit control
        if (base && base.type === "op") {
          const limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new src_ParseError("Limit controls must follow a math operator", lex);
        }

        this.consume();
      } else if (lex.text === "^") {
        // We got a superscript start
        if (superscript) {
          throw new src_ParseError("Double superscript", lex);
        }

        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        // We got a subscript start
        if (subscript) {
          throw new src_ParseError("Double subscript", lex);
        }

        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        // We got a prime
        if (superscript) {
          throw new src_ParseError("Double superscript", lex);
        }

        const prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }; // Many primes can be grouped together, so we handle this here

        const primes = [prime];
        this.consume(); // Keep lexing tokens until we get something that's not a prime

        while (this.fetch().text === "'") {
          // For each one, add another prime to the list
          primes.push(prime);
          this.consume();
        } // If there's a superscript following the primes, combine that
        // superscript in with the primes.


        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        } // Put everything into an ordgroup as the superscript


        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else if (uSubsAndSups[lex.text]) {
        // A Unicode subscript or superscript character.
        // We treat these similarly to the unicode-math package.
        // So we render a string of Unicode (sub|super)scripts the
        // same as a (sub|super)script of regular characters.
        const isSub = unicodeSubRegEx.test(lex.text);
        const subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume(); // Continue fetching tokens to fill out the string.

        while (true) {
          const token = this.fetch().text;

          if (!uSubsAndSups[token]) {
            break;
          }

          if (unicodeSubRegEx.test(token) !== isSub) {
            break;
          }

          subsupTokens.unshift(new Token(uSubsAndSups[token]));
          this.consume();
        } // Now create a (sub|super)script.


        const body = this.subparse(subsupTokens);

        if (isSub) {
          subscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        } else {
          superscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        }
      } else {
        // If it wasn't ^, _, or ', stop parsing super/subscripts
        break;
      }
    } // Base must be set if superscript or subscript are set per logic above,
    // but need to check here for type check to pass.


    if (superscript || subscript) {
      // If we got either a superscript or subscript, create a supsub
      return {
        type: "supsub",
        mode: this.mode,
        base: base,
        sup: superscript,
        sub: subscript
      };
    } else {
      // Otherwise return the original body
      return base;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */


  parseFunction(breakOnTokenText, name // For determining its context
  ) {
    const token = this.fetch();
    const func = token.text;
    const funcData = src_functions[func];

    if (!funcData) {
      return null;
    }

    this.consume(); // consume command token

    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
    }

    const {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */


  callFunction(name, args, optArgs, token, breakOnTokenText) {
    const context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    const func = src_functions[name];

    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new src_ParseError("No function handler for " + name);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */


  parseArguments(func, // Should look like "\name" or "\begin{name}".
  funcData) {
    const totalArgs = funcData.numArgs + funcData.numOptionalArgs;

    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }

    const args = [];
    const optArgs = [];

    for (let i = 0; i < totalArgs; i++) {
      let argType = funcData.argTypes && funcData.argTypes[i];
      const isOptional = i < funcData.numOptionalArgs;

      if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
      funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
        argType = "primitive";
      }

      const arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);

      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        // should be unreachable
        throw new src_ParseError("Null argument, please report this as a bug");
      }
    }

    return {
      args,
      optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */


  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);

      case "size":
        return this.parseSizeGroup(optional);

      case "url":
        return this.parseUrlGroup(optional);

      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);

      case "hbox":
        {
          // hbox argument type wraps the argument in the equivalent of
          // \hbox, which is like \text but switching to \textstyle size.
          const group = this.parseArgumentGroup(optional, "text");
          return group != null ? {
            type: "styling",
            mode: group.mode,
            body: [group],
            style: "text" // simulate \textstyle

          } : null;
        }

      case "raw":
        {
          const token = this.parseStringGroup("raw", optional);
          return token != null ? {
            type: "raw",
            mode: "text",
            string: token.text
          } : null;
        }

      case "primitive":
        {
          if (optional) {
            throw new src_ParseError("A primitive argument cannot be optional");
          }

          const group = this.parseGroup(name);

          if (group == null) {
            throw new src_ParseError("Expected group as " + name, this.fetch());
          }

          return group;
        }

      case "original":
      case null:
      case undefined:
        return this.parseArgumentGroup(optional);

      default:
        throw new src_ParseError("Unknown group type as " + name, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */


  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */


  parseStringGroup(modeName, // Used to describe the mode in error messages.
  optional) {
    const argToken = this.gullet.scanArgument(optional);

    if (argToken == null) {
      return null;
    }

    let str = "";
    let nextToken;

    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }

    this.consume(); // consume the end of the argument

    argToken.text = str;
    return argToken;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */


  parseRegexGroup(regex, modeName // Used to describe the mode in error messages.
  ) {
    const firstToken = this.fetch();
    let lastToken = firstToken;
    let str = "";
    let nextToken;

    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }

    if (str === "") {
      throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }

    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */


  parseColorGroup(optional) {
    const res = this.parseStringGroup("color", optional);

    if (res == null) {
      return null;
    }

    const match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);

    if (!match) {
      throw new src_ParseError("Invalid color: '" + res.text + "'", res);
    }

    let color = match[0];

    if (/^[0-9a-f]{6}$/i.test(color)) {
      // We allow a 6-digit HTML color spec without a leading "#".
      // This follows the xcolor package's HTML color model.
      // Predefined color names are all missed by this RegEx pattern.
      color = "#" + color;
    }

    return {
      type: "color-token",
      mode: this.mode,
      color
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */


  parseSizeGroup(optional) {
    let res;
    let isBlank = false; // don't expand before parseStringGroup

    this.gullet.consumeSpaces();

    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }

    if (!res) {
      return null;
    }

    if (!optional && res.text.length === 0) {
      // Because we've tested for what is !optional, this block won't
      // affect \kern, \hspace, etc. It will capture the mandatory arguments
      // to \genfrac and \above.
      res.text = "0pt"; // Enable \above{}

      isBlank = true; // This is here specifically for \genfrac
    }

    const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);

    if (!match) {
      throw new src_ParseError("Invalid size: '" + res.text + "'", res);
    }

    const data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };

    if (!validUnit(data)) {
      throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
    }

    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */


  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13); // active character

    this.gullet.lexer.setCatcode("~", 12); // other character

    const res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14); // comment character

    this.gullet.lexer.setCatcode("~", 13); // active character

    if (res == null) {
      return null;
    } // hyperref package allows backslashes alone in href, but doesn't
    // generate valid links in such cases; we interpret this as
    // "undefined" behaviour, and keep them as-is. Some browser will
    // replace backslashes with forward slashes.


    const url = res.text.replace(/\\([#$%&~_^{}])/g, '$1');
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }
  /**
   * Parses an argument with the mode specified.
   */


  parseArgumentGroup(optional, mode) {
    const argToken = this.gullet.scanArgument(optional);

    if (argToken == null) {
      return null;
    }

    const outerMode = this.mode;

    if (mode) {
      // Switch to specified mode
      this.switchMode(mode);
    }

    this.gullet.beginGroup();
    const expression = this.parseExpression(false, "EOF"); // TODO: find an alternative way to denote the end

    this.expect("EOF"); // expect the end of the argument

    this.gullet.endGroup();
    const result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };

    if (mode) {
      // Switch mode back
      this.switchMode(outerMode);
    }

    return result;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */


  parseGroup(name, // For error reporting.
  breakOnTokenText) {
    const firstToken = this.fetch();
    const text = firstToken.text;
    let result; // Try to parse an open brace or \begingroup

    if (text === "{" || text === "\\begingroup") {
      this.consume();
      const groupEnd = text === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup(); // If we get a brace, parse an expression

      const expression = this.parseExpression(false, groupEnd);
      const lastToken = this.fetch();
      this.expect(groupEnd); // Check that we got a matching closing brace

      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text === "\\begingroup" || undefined
      };
    } else {
      // If there exists a function with this name, parse the function.
      // Otherwise, just return a nucleus
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();

      if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
        if (this.settings.throwOnError) {
          throw new src_ParseError("Undefined control sequence: " + text, firstToken);
        }

        result = this.formatUnsupportedCmd(text);
        this.consume();
      }
    }

    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */


  formLigatures(group) {
    let n = group.length - 1;

    for (let i = 0; i < n; ++i) {
      const a = group[i]; // $FlowFixMe: Not every node type has a `text` property.

      const v = a.text;

      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }

      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */


  parseSymbol() {
    const nucleus = this.fetch();
    let text = nucleus.text;

    if (/^\\verb[^a-zA-Z]/.test(text)) {
      this.consume();
      let arg = text.slice(5);
      const star = arg.charAt(0) === "*";

      if (star) {
        arg = arg.slice(1);
      } // Lexer's tokenRegex is constructed to always have matching
      // first/last characters.


      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }

      arg = arg.slice(1, -1); // remove first and last char

      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    } // At this point, we should have a symbol, possibly with accents.
    // First expand any accented base symbol according to unicodeSymbols.


    if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {
      // This behavior is not strict (XeTeX-compatible) in math mode.
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", "Accented Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
      }

      text = unicodeSymbols[text[0]] + text.slice(1);
    } // Strip off any combining characters


    const match = combiningDiacriticalMarksEndRegex.exec(text);

    if (match) {
      text = text.substring(0, match.index);

      if (text === 'i') {
        text = '\u0131'; // dotless i, in math and text mode
      } else if (text === 'j') {
        text = '\u0237'; // dotless j, in math and text mode
      }
    } // Recognize base symbol


    let symbol;

    if (src_symbols[this.mode][text]) {
      if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", "Latin-1/Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
      }

      const group = src_symbols[this.mode][text].group;
      const loc = SourceLocation.range(nucleus);
      let s;

      if (ATOMS.hasOwnProperty(group)) {
        // $FlowFixMe
        const family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text
        };
      } else {
        // $FlowFixMe
        s = {
          type: group,
          mode: this.mode,
          loc,
          text
        };
      } // $FlowFixMe


      symbol = s;
    } else if (text.charCodeAt(0) >= 0x80) {
      // no symbol for e.g. ^
      if (this.settings.strict) {
        if (!supportedCodepoint(text.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", "Unrecognized Unicode character \"" + text[0] + "\"" + (" (" + text.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", "Unicode text character \"" + text[0] + "\" used in math mode", nucleus);
        }
      } // All nonmathematical Unicode characters are rendered as if they
      // are in text mode (wrapped in \text) because that's what it
      // takes to render them in LaTeX.  Setting `mode: this.mode` is
      // another natural choice (the user requested math mode), but
      // this makes it more difficult for getCharacterMetrics() to
      // distinguish Unicode characters without metrics and those for
      // which we want to simulate the letter M.


      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text
      };
    } else {
      return null; // EOF, ^, _, {, }, etc.
    }

    this.consume(); // Transform combining characters into accents

    if (match) {
      for (let i = 0; i < match[0].length; i++) {
        const accent = match[0][i];

        if (!unicodeAccents[accent]) {
          throw new src_ParseError("Unknown accent ' " + accent + "'", nucleus);
        }

        const command = unicodeAccents[accent][this.mode] || unicodeAccents[accent].text;

        if (!command) {
          throw new src_ParseError("Accent " + accent + " unsupported in " + this.mode + " mode", nucleus);
        }

        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          // $FlowFixMe
          base: symbol
        };
      }
    } // $FlowFixMe


    return symbol;
  }

}
Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
;// CONCATENATED MODULE: ./src/parseTree.js
/**
 * Provides a single function for parsing an expression using a Parser
 * TODO(emily): Remove this
 */




/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
const parseTree = function (toParse, settings) {
  if (!(typeof toParse === 'string' || toParse instanceof String)) {
    throw new TypeError('KaTeX can only parse string typed expression');
  }

  const parser = new Parser(toParse, settings); // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors

  delete parser.gullet.macros.current["\\df@tag"];
  let tree = parser.parse(); // Prevent a color definition from persisting between calls to katex.render().

  delete parser.gullet.macros.current["\\current@color"];
  delete parser.gullet.macros.current["\\color"]; // If the input used \tag, it will set the \df@tag macro to the tag.
  // In this case, we separately parse the tag and wrap the tree.

  if (parser.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new src_ParseError("\\tag works only in display equations");
    }

    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser.subparse([new Token("\\df@tag")])
    }];
  }

  return tree;
};

/* harmony default export */ var src_parseTree = (parseTree);
;// CONCATENATED MODULE: ./katex.js
/* eslint no-console:0 */

/**
 * This is the main entry point for KaTeX. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from KaTeX are
 * errors in the expression, or errors in javascript handling.
 */











/**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
let render = function (expression, baseNode, options) {
  baseNode.textContent = "";
  const node = renderToDomTree(expression, options).toNode();
  baseNode.appendChild(node);
}; // KaTeX's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.


if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your " + "website has a suitable doctype.");

    render = function () {
      throw new src_ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
/**
 * Parse and build an expression, and return the markup for that.
 */


const renderToString = function (expression, options) {
  const markup = renderToDomTree(expression, options).toMarkup();
  return markup;
};
/**
 * Parse an expression and return the parse tree.
 */


const generateParseTree = function (expression, options) {
  const settings = new Settings(options);
  return src_parseTree(expression, settings);
};
/**
 * If the given error is a KaTeX ParseError and options.throwOnError is false,
 * renders the invalid LaTeX as a span with hover title giving the KaTeX
 * error message.  Otherwise, simply throws the error.
 */


const renderError = function (error, expression, options) {
  if (options.throwOnError || !(error instanceof src_ParseError)) {
    throw error;
  }

  const node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node.setAttribute("title", error.toString());
  node.setAttribute("style", "color:" + options.errorColor);
  return node;
};
/**
 * Generates and returns the katex build tree. This is used for advanced
 * use cases (like rendering to custom output).
 */


const renderToDomTree = function (expression, options) {
  const settings = new Settings(options);

  try {
    const tree = src_parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
/**
 * Generates and returns the katex build tree, with just HTML (no MathML).
 * This is used for advanced use cases (like rendering to custom output).
 */


const renderToHTMLTree = function (expression, options) {
  const settings = new Settings(options);

  try {
    const tree = src_parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};

const version = "0.16.21";
const __domTree = {
  Span: Span,
  Anchor: Anchor,
  SymbolNode: SymbolNode,
  SvgNode: SvgNode,
  PathNode: PathNode,
  LineNode: LineNode
}; // ESM exports

 // CJS exports and ESM default export

/* harmony default export */ var katex = ({
  /**
   * Current KaTeX version
   */
  version,

  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render,

  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString,

  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: src_ParseError,

  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: SETTINGS_SCHEMA,

  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,

  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: renderToDomTree,

  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: renderToHTMLTree,

  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,

  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,

  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: defineFunction,

  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,

  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree
});
;// CONCATENATED MODULE: ./katex.webpack.js
/**
 * This is the webpack entry point for KaTeX. As ECMAScript, flow[1] and jest[2]
 * doesn't support CSS modules natively, a separate entry point is used and
 * it is not flowtyped.
 *
 * [1] https://gist.github.com/lambdahands/d19e0da96285b749f0ef
 * [2] https://facebook.github.io/jest/docs/en/webpack.html
 */


/* harmony default export */ var katex_webpack = (katex);
__nested_webpack_exports__ = __nested_webpack_exports__["default"];
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./MarkUp.ts":
/*!*******************!*\
  !*** ./MarkUp.ts ***!
  \*******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interpret = void 0;
const index_1 = __webpack_require__(/*! ts-parso/index */ "./node_modules/ts-parso/index.ts");
const katex_1 = __importDefault(__webpack_require__(/*! katex */ "./node_modules/katex/dist/katex.js"));
const token_desc_list = [
    {
        name: "HASH",
        description: /#/,
        precedence: 12,
    },
    {
        name: "STAR",
        description: /\*/,
        precedence: 13,
    },
    {
        name: "UNDER",
        description: /_/,
        precedence: 13,
    },
    {
        name: "GT",
        description: />/,
        precedence: 13,
    },
    {
        name: "TAB",
        description: /\t/,
        precedence: 10,
    },
    {
        name: "NUM_DOT",
        description: /\d+\./,
        precedence: 13,
    },
    {
        name: "DASH",
        description: /-/,
        precedence: 13,
    },
    {
        name: "LBRACKET",
        description: /\[/,
        precedence: 13,
    },
    {
        name: "RBRACKET",
        description: /\]/,
        precedence: 13,
    },
    {
        name: "LPAREN",
        description: /\(/,
        precedence: 13,
    },
    {
        name: "RPAREN",
        description: /\)/,
        precedence: 13,
    },
    {
        name: "ESCAPE_SEQ",
        description: /\\/,
        precedence: 14,
    },
    {
        name: "STR",
        description: /[^*_`\n\$\[\]\(\)\\]+/,
        precedence: 0,
    },
    {
        name: "CODE_BLOCK",
        description: /\`[^`]+\`/,
        precedence: 13,
    },
    {
        name: "KATEX",
        description: /\$[^\$]+\$/,
        precedence: 3,
    },
    {
        name: "ESCAPE_DOLLAR",
        description: /\\\$/,
        precedence: 15,
    },
    {
        name: "BR",
        description: /\n/,
        precedence: 10,
    },
];
const gram = [
    {
        type: "Rule",
        name: "HorizontalRule",
        pattern: [["DASH", "DASH", "DASH"]],
        callback: (r) => {
            return document.createElement("hr");
        },
    },
    {
        type: "Rule",
        name: "Head1",
        pattern: [["HASH", "STR", "BR"]],
        callback: (r) => {
            const strToken = r.match[1];
            if (strToken.type === "Token") {
                const ret_elem = document.createElement("h1");
                ret_elem.textContent = strToken.match;
                return ret_elem;
                // return `<h1>${strToken.match}</h1>`;
            }
            else {
                throw new Error("HEAD1: Expecting a STR, when we instead got an extended rule.");
            }
        },
    },
    {
        type: "Rule",
        name: "Head2",
        pattern: [["HASH", "HASH", "STR", "BR"]],
        callback: (r) => {
            const strToken = r.match[2];
            if (strToken.type === "Token") {
                const ret_elem = document.createElement("h2");
                ret_elem.textContent = strToken.match;
                return ret_elem;
                // return `<h2>${strToken.match}</h2>`;
            }
            else {
                throw new Error("HEAD2: Expecting a STR, when we instead got an extended rule.");
            }
        },
    },
    {
        type: "Rule",
        name: "Head3",
        pattern: [["HASH", "HASH", "HASH", "STR", "BR"]],
        callback: (r) => {
            const strToken = r.match[3];
            if (strToken.type === "Token") {
                const ret_elem = document.createElement("h3");
                ret_elem.textContent = strToken.match;
                return ret_elem;
                // return `<h3>${strToken.match}</h3>`;
            }
            else {
                throw new Error("HEAD3: Expecting a STR, when we instead got an extended rule.");
            }
        },
    },
    {
        type: "Rule",
        name: "Indent",
        pattern: [["TAB"]],
        callback: (r) => {
            const ret_elem = document.createElement("div");
            return ret_elem;
        },
    },
    {
        type: "Rule",
        name: "BlockQuote",
        // TODO: Add better nesting handling
        pattern: [
            ["GT", "BreakFreeText", "BR"],
            ["GT", "BlockQuote"],
        ],
        callback: (r, context) => {
            const subProgRule = r.match[1];
            if (subProgRule.type === "Rule") {
                const ret_elem = document.createElement("blockquote");
                ret_elem.textContent = `${subProgRule.callback(context)}`;
                return ret_elem;
                // return `<blockquote>${subProgRule.callback(context)}</blockquote>`;
            }
            throw new Error("Error in 'BlockQuote', subProg is not a rule");
        },
    },
    {
        type: "Rule",
        name: "OrderedListElem",
        pattern: [["NUM_DOT", "Text", "BR"]],
        callback: (r, context) => {
            const textToken = r.match[1];
            if (textToken.type === "Rule") {
                const ret_elem = document.createElement("li");
                ret_elem.textContent = `${textToken.callback(context)}`;
                return ret_elem;
                // return `<li>${textToken.callback(context)}</li>`;
            }
            else {
                throw new Error("OrderedListElem: Expecting a Text, when we instead got a Token.");
            }
        },
    },
    {
        type: "Rule",
        name: "UnorderedListElem",
        pattern: [["DASH", "Text", "BR"]],
        callback: (r, context) => {
            const textToken = r.match[1];
            if (textToken.type === "Rule") {
                const ret_elem = document.createElement("ul");
                ret_elem.textContent = `${textToken.callback(context)}`;
                return ret_elem;
                // return `<li>${textToken.callback(context)}</li>`;
            }
            else {
                throw new Error("UnorderedListElem: Expecting a Text, when we instead got a Token.");
            }
        },
    },
    // {
    //   type: "Rule",
    //   name: "BlockQuote",
    //   pattern: [["GT", "Prog"]],
    //   callback: () => {},
    // },
    {
        type: "Rule",
        name: "Bold",
        pattern: [
            ["STAR", "STAR", "STR", "STAR", "STAR"],
            ["UNDER", "UNDER", "STR", "UNDER", "UNDER"],
        ],
        callback: (r) => {
            const strToken = r.match[2];
            if (strToken.type === "Token") {
                // Return a bold element
                const ret_elem = document.createElement("b");
                ret_elem.textContent = strToken.match;
                return ret_elem;
                // return `<b>${strToken.match}</b>`;
            }
            else {
                throw new Error("Bold: Expecting a STR, when we instead got an extended rule.");
            }
        },
    },
    {
        type: "Rule",
        name: "Link",
        pattern: [["LBRACKET", "STR", "RBRACKET", "LPAREN", "STR", "RPAREN"]],
        callback: (r) => {
            const strNameToken = r.match[1];
            const strHrefToken = r.match[4];
            if (strNameToken.type === "Token" && strHrefToken.type === "Token") {
                const ret_elem = document.createElement("a");
                ret_elem.href = strHrefToken.match;
                ret_elem.textContent = strNameToken.match;
                return ret_elem;
                // return `<a href="${strHrefToken.match}">${strNameToken.match}</a>`;
            }
            else {
                throw new Error("Link Element: Expecting a STR, when we instead got an extended rule.");
            }
        },
    },
    {
        type: "Rule",
        name: "Italic",
        pattern: [
            ["STAR", "STR", "STAR"],
            ["UNDER", "STR", "UNDER"],
        ],
        callback: (r) => {
            const strToken = r.match[1];
            if (strToken.type === "Token") {
                const ret_elem = document.createElement("em");
                ret_elem.textContent = strToken.match;
                return ret_elem;
                // return `<em>${strToken.match}</em>`;
            }
            else {
                throw new Error("Italic: Expecting a STR, when we instead got an extended rule.");
            }
        },
    },
    {
        type: "Rule",
        name: "BreakFreeText",
        pattern: [
            ["ESCAPE_SEQ", "STAR"],
            ["ESCAPE_SEQ", "ESCAPE_SEQ"],
            ["ESCAPE_SEQ", "HASH"],
            ["ESCAPE_SEQ", "UNDER"],
            ["ESCAPE_SEQ", "BACKTICK"],
            ["ESCAPE_SEQ", "LBRACKET"],
            ["ESCAPE_SEQ", "RBRACKET"],
            ["ESCAPE_SEQ", "LPAREN"],
            ["ESCAPE_SEQ", "RPAREN"],
            ["ESCAPE_DOLLAR"],
            ["KATEX"],
            ["STR"],
            ["Italic"],
            ["Bold"],
            ["CODE_BLOCK"],
            ["Link"],
            // ["EMPTY"],
        ],
        callback: (r, context) => {
            const ret_anchor = document.createElement("div");
            for (const rule of r.match) {
                if (rule.type === "Token") {
                    // We are a token, we should be a STR or ESCAPED
                    if (rule.name === "ESCAPE_DOLLAR") {
                        const ret_elem = document.createElement("p");
                        ret_elem.textContent = "$";
                        ret_anchor.appendChild(ret_elem);
                        // return "$";
                    }
                    else if (rule.name === "ESCAPE_SEQ") {
                        if (r.match[1].type === "Token") {
                            // Should always hold
                            const ret_elem = document.createElement("p");
                            ret_elem.textContent = r.match[1].match;
                            ret_anchor.appendChild(ret_elem);
                            // return r.match[1].match;
                        }
                    }
                    else if (rule.name === "KATEX") {
                        const katexSlice = rule.match;
                        console.log(katex_1.default);
                        console.log(katexSlice);
                        // @ts-ignore: Unreachable code error
                        window.katex = katex_1.default;
                        const katexVal = katexSlice.slice(1, katexSlice.length - 1);
                        const katex_root_node = document.createElement("div");
                        katex_1.default.render(katexVal, katex_root_node);
                        ret_anchor.appendChild(katex_root_node);
                        console.log(`Rendering Latex for: ${katexVal}`);
                        console.log(katexVal.length);
                    }
                    else if (rule.name === "CODE_BLOCK") {
                        const ret_elem = document.createElement("code");
                        ret_elem.textContent = rule.match.slice(1, rule.match.length - 1);
                        ret_anchor.appendChild(ret_elem);
                        // const codeSlice = rule.match.slice(1, rule.match.length - 1);
                        // outputs += `<code>${codeSlice}</code>`;
                    }
                    else if (rule.name === "STR") {
                        const ret_elem = document.createElement("p");
                        ret_elem.textContent = rule.match;
                        ret_anchor.appendChild(ret_elem);
                        continue;
                    }
                    else {
                        throw new Error(`We should only be a STR, but instead were a '${rule.name}'`);
                    }
                }
                else if (rule.type === "Rule") {
                    const currentOutput = rule.callback(context);
                    ret_anchor.appendChild(currentOutput);
                }
            }
            return ret_anchor;
        },
    },
    {
        type: "Rule",
        name: "Text",
        pattern: [["BreakFreeText", "Text"], ["EMPTY"]],
        callback: (r, context) => {
            const ret_anchor = document.createElement("div");
            for (const rule of r.match) {
                if (rule.type === "Rule") {
                    const currentOutput = rule.callback(context);
                    ret_anchor.appendChild(currentOutput);
                }
            }
            return ret_anchor;
        },
    },
    {
        type: "Rule",
        name: "NonEmptyText",
        pattern: [["BreakFreeText", "Text"]],
        callback: (r, context) => {
            const ret_anchor = document.createElement("div");
            for (const rule of r.match) {
                if (rule.type === "Rule") {
                    const currentOutput = rule.callback(context);
                    ret_anchor.appendChild(currentOutput);
                }
            }
            return ret_anchor;
        },
    },
    {
        type: "Rule",
        name: "Prog",
        pattern: [
            ["HorizontalRule", "Prog"],
            ["Head1", "Prog"],
            ["Head2", "Prog"],
            ["Head3", "Prog"],
            ["Indent", "Prog"],
            ["BlockQuote", "Prog"],
            ["OrderedListElem", "Prog"],
            ["UnorderedListElem", "Prog"],
            ["NonEmptyText", "Prog"],
            ["BR", "Prog"],
            ["EMPTY"], // IMPORTANT THAT THIS BE HERE
            // TODO: Make more flexible so Empty need not be the last rule
        ],
        callback: (r, context) => {
            const ret_anchor = document.createElement("div");
            const openItems = context.openItems;
            let previousBR = context.previousBR;
            for (const rule of r.match) {
                if (rule.type === "Rule") {
                    // const ruleOutput =
                    if (rule.name === "OrderedListElem") {
                        // If the next item is a an ordered list element
                        if (openItems[0] === "OrderedListElem") {
                            // If we are in the middle of an ordered list
                            ret_anchor.appendChild(rule.callback({ openItems: openItems, previousBR: previousBR }));
                        }
                        else {
                            if (openItems[0] === "UnorderedListElem") {
                                // The other one was open!
                                const ulElem = document.createElement("ul");
                                ret_anchor.appendChild(ulElem);
                                openItems.pop();
                            }
                            // We are just starting an ordered list
                            openItems.push("OrderedListElem");
                            const olElem = document.createElement("ol");
                            ret_anchor.appendChild(olElem);
                            ret_anchor.appendChild(rule.callback({ openItems: openItems, previousBR: previousBR }));
                        }
                    }
                    else if (rule.name === "UnorderedListElem") {
                        // If the next item is a an un-ordered list element
                        if (openItems[0] === "UnorderedListElem") {
                            // If we are in the middle of an un-ordered list
                            ret_anchor.appendChild(rule.callback({ openItems: openItems, previousBR: previousBR }));
                        }
                        else {
                            if (openItems[0] === "OrderedListElem") {
                                // The other one was open!
                                const olElem = document.createElement("ol");
                                ret_anchor.appendChild(olElem);
                                openItems.pop();
                            }
                            // We are just starting an un-ordered list
                            openItems.push("UnorderedListElem");
                            const ulElem = document.createElement("ul");
                            ret_anchor.appendChild(ulElem);
                            ret_anchor.appendChild(rule.callback({ openItems: openItems, previousBR: previousBR }));
                        }
                    }
                    else if (rule.name === "Prog") {
                        // We could be in between
                        ret_anchor.appendChild(rule.callback({ openItems: openItems, previousBR: previousBR }));
                    }
                    else {
                        // We are in the middle of neither
                        // Check if we have possibly switched off one to the other
                        switch (openItems[0]) {
                            case "UnorderedListElem":
                                openItems.pop();
                                const ret_elem = document.createElement("ul");
                                ret_anchor.appendChild(ret_elem);
                                ret_anchor.appendChild(rule.callback({ openItems: openItems, previousBR: previousBR }));
                                break;
                            case "OrderedListElem":
                                openItems.pop();
                                const ret_elem2 = document.createElement("ol");
                                ret_anchor.appendChild(ret_elem2);
                                ret_anchor.appendChild(rule.callback({ openItems: openItems, previousBR: previousBR }));
                                break;
                            default:
                                ret_anchor.appendChild(rule.callback({ openItems: openItems, previousBR: previousBR }));
                                break;
                        }
                    }
                }
                else if (rule.type === "Token" && rule.name === "BR") {
                    // We are a BR
                    if (previousBR === true) {
                        // Add a break
                        const brElem = document.createElement("br");
                        ret_anchor.appendChild(brElem);
                        previousBR = false;
                        continue;
                    }
                    else {
                        // We have not seen a previous BR, so set flag
                        previousBR = true;
                        continue;
                    }
                }
                else {
                    throw new Error(`ERROR: Prog should never encounter a raw token, but did: '${rule.name}'`);
                }
            }
            return ret_anchor;
        },
    },
];
const Interpret = (str) => {
    const tokens = (0, index_1.Tokenize)(str, token_desc_list);
    const progRule = gram.find((val) => val.name === "Prog");
    if (progRule) {
        const ruleRes = (0, index_1.Parser)(4, tokens, gram, progRule);
        if (ruleRes && ruleRes.type === "Rule") {
            return ruleRes.callback({ openItems: [] });
        }
        else {
            throw new Error("Return of parser failed");
        }
    }
    else {
        throw new Error("Could not interpret markup");
    }
};
exports.Interpret = Interpret;


/***/ }),

/***/ "./node_modules/ts-parso/Parser.ts":
/*!*****************************************!*\
  !*** ./node_modules/ts-parso/Parser.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parser = void 0;
/**
 * Gets the name of all rules in a grammar
 * @param g the grammar to get the rules names from
 */
const rule_names = (g) => {
    return g.map((rule) => rule.name);
};
/**
 * Gets a specific grammar rule for from a grammar
 * where the rule name is provided
 * @param g the grammar to get the rule from
 * @param r the name of the rule to find
 * @throws If the rule name r is not in grammar g
 */
const get_rule = (g, r) => {
    const gr = g.find((val) => val.name === r);
    if (gr) {
        return gr;
    }
    throw new Error(`Rule '${r}' does not exist in grammar ${g}`);
};
/**
 * A LL(k) parser for a specific grammar rules pattern
 * @param k the number of lookahead tokens for this parser
 * @param ts the stream of tokens to parse
 * @param g the grammar to use for parsing
 * @param r the top-level grammar rule to attempt to parse
 * @param p the specific pattern to attempt to parse
 * @param final whether or not this parser should consume all remaining tokens
 */
const LL_pattern = (k, ts, g, r, p, final) => {
    /** We are attempting to force match pattern "p" with tokens "ts"
        We have to match "k" tokens, and then if they all match,
        consume the rest of the pattern.
        
        If we finish our match before "k" tokens,
        then we can fully consume that as the pattern is applicable
  
        If we have matched as we reach "k" tokens,
        then continue going. (If we fail later, the grammar is not LL(k)
        which will not be our fault)
    */
    const ruleNames = rule_names(g);
    const running_rule = {
        type: "Rule",
        name: r.name,
        callback: (context) => r.callback(running_rule, context),
        match: [],
    };
    // Checking the first "k" tokens
    let tokenInd = 0;
    for (let patternInd = 0; patternInd < p.length && tokenInd < ts.length; patternInd++) {
        const tokI = ts[tokenInd];
        const patternI = p[patternInd];
        if (patternI === "EMPTY") {
            const emptyMatch = {
                type: "Token",
                name: "EMPTY",
                match: "",
            };
            running_rule.match.push(emptyMatch);
            return [running_rule, 0];
        }
        if (tokI.name === patternI) {
            // This match at point 'i'
            const tokenMatch = {
                type: "Token",
                name: tokI.name,
                match: tokI.match,
            };
            running_rule.match.push(tokenMatch);
            tokenInd++;
        }
        else if (ruleNames.includes(patternI)) {
            // pattern[i] is a separate rule, recurse down to match
            // If our pattern is the last in the list, it should consume all
            const consumeAll = final && patternInd === p.length - 1;
            const patRule = get_rule(g, patternI);
            const matchedRule = LL_rule(k, ts.slice(tokenInd), g, patRule, consumeAll);
            if (matchedRule) {
                // We did not have an undefined traversal.
                // Add the matches
                running_rule.match.push(matchedRule[0]);
                tokenInd += matchedRule[1];
            }
            else {
                if (tokenInd < k) {
                    // Matched rule was undefined, and this is the first "k"
                    // tokens, so we have to bail out
                    return undefined;
                }
                else {
                    throw new Error("We made it 'k' tokens, but it failed afterwards");
                }
            }
        }
        else {
            if (tokenInd < k) {
                // So we didn't consume "k" tokens and failed,
                // so this is not a true error, just a bail out
                return undefined;
            }
            else {
                throw new Error("We made it 'k' tokens, but it failed afterwards");
            }
        }
    }
    // We have consumed all the way we need to
    return [running_rule, tokenInd];
};
/**
 * A LL(k) parser for a specific grammar rule
 * @param k the number of lookahead tokens for this parser
 * @param ts the stream of tokens to parse
 * @param g the grammar to use for parsing
 * @param r the top-level grammar rule to attempt to parse
 * @param final whether or not this parser should consume all remaining tokens
 */
const LL_rule = (k, ts, g, r, final) => {
    // While we still have tokens to consume, try the rules patterns
    for (const pattern of r.pattern) {
        // For each possible pattern
        // Try to apply that pattern,
        const patternReturn = LL_pattern(k, ts, g, r, pattern, final);
        if (patternReturn) {
            const [patternTry, ind] = patternReturn;
            // If we have validly reached this point,
            // the entire pattern has been consumed!
            if (final && ind < ts.length) {
                // If this is supposed to consume all, but it didnt
                continue;
                // This cannot be the pattern, so continue
            }
            return [patternTry, ind];
        }
    }
    if (final) {
        throw new Error("All patterns exhausted, and none validly parsed");
    }
    return undefined;
};
/**
 * Parses the token stream with an LL(k) parser
 * using the provided Grammer and a top-level grammar rule
 * that the token stream must conform to.
 * @param k the number of the LL(k) parser
 * @param tokStream the stream of tokens to parse
 * @param langGrammar the grammar to use for parsing
 * @param topLevelRule the top-level rule that the token stream must conform to
 */
const Parser = (k, tokStream, langGrammar, topLevelRule) => {
    const ruleOut = LL_rule(k, tokStream, langGrammar, topLevelRule, true);
    if (ruleOut) {
        return ruleOut[0];
    }
    throw new Error("Failed to parser!");
};
exports.Parser = Parser;


/***/ }),

/***/ "./node_modules/ts-parso/Tokenizer.ts":
/*!********************************************!*\
  !*** ./node_modules/ts-parso/Tokenizer.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tokenize = void 0;
/**
 * Very similar to Tokenize, but we presumed that the
 * token description list "tds" is sorted based on
 * token precedence
 * @param str the string to tokenize
 * @param tds the list of token descriptions
 */
const Tokenize_prime = (str, tds) => {
    if (str.length === 0) {
        // End of input
        return [];
    }
    const goodMatches = tds
        .map((desc) => {
        return {
            name: desc.name,
            match: str.match(desc.description),
        };
    })
        .filter((val) => val.match && val.match.index === 0);
    if (!goodMatches) {
        throw new Error(`We could not tokenize, error with string '${str}'`);
    }
    const optimalMatch = goodMatches[0];
    if (optimalMatch && optimalMatch.match) {
        const best_token = {
            type: "Token",
            name: optimalMatch.name,
            match: optimalMatch.match[0],
        };
        return [
            best_token,
            ...Tokenize_prime(str.slice(best_token.match.length), tds),
        ];
    }
    throw new Error("Error tokenizing");
};
/**
 * Tokenizes a string "str" using tokens as described
 * in the list of token descriptions "tds"
 * @param str the string to tokenize
 * @param tds the list of token descriptions
 */
const Tokenize = (str, tds) => {
    const tokens = Tokenize_prime(str, tds.sort((a, b) => b.precedence - a.precedence));
    return tokens;
};
exports.Tokenize = Tokenize;


/***/ }),

/***/ "./node_modules/ts-parso/index.ts":
/*!****************************************!*\
  !*** ./node_modules/ts-parso/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tokenize = exports.Parser = void 0;
var Parser_1 = __webpack_require__(/*! ./Parser */ "./node_modules/ts-parso/Parser.ts");
Object.defineProperty(exports, "Parser", ({ enumerable: true, get: function () { return Parser_1.Parser; } }));
var Tokenizer_1 = __webpack_require__(/*! ./Tokenizer */ "./node_modules/ts-parso/Tokenizer.ts");
Object.defineProperty(exports, "Tokenize", ({ enumerable: true, get: function () { return Tokenizer_1.Tokenize; } }));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!*************************!*\
  !*** ./MarkUpInterp.ts ***!
  \*************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const MarkUp_1 = __webpack_require__(/*! ./MarkUp */ "./MarkUp.ts");
let interpretShown = false;
const rootElem = document.querySelector("#root");
const textBoxElem = document.querySelector("#textBox");
const toggleDisplay = () => {
    interpretShown = !interpretShown;
    if (!rootElem || !textBoxElem)
        return;
    rootElem.hidden = !interpretShown;
    textBoxElem.hidden = interpretShown;
    if (interpretShown === true) {
        if (textBoxElem.value) {
            const output = (0, MarkUp_1.Interpret)(textBoxElem.value + "\n\n");
            rootElem.appendChild(output);
        }
    }
    else {
        textBoxElem.focus();
    }
};
document === null || document === void 0 ? void 0 : document.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && e.shiftKey) {
        toggleDisplay();
        e.preventDefault();
    }
    else if (e.key === "Tab") {
        if (textBoxElem) {
            textBoxElem.value += "\t";
            e.preventDefault();
        }
    }
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPLE1BQU07QUFDMUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmLG1OQUFtTjs7QUFFbk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6Qzs7QUFFQSxvQkFBb0IsMEJBQTBCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQkFBcUI7O0FBRXJCLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLFlBQVksUUFBUSxPQUFPLFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxnREFBZ0Q7O0FBRWhELDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osa0JBQWtCLDBCQUEwQjtBQUM1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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUErQyxlQUFlOztBQUV0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRCw0Q0FBNEMsT0FBTztBQUNuRCw0Q0FBNEM7QUFDNUMsMENBQTBDLE9BQU87QUFDakQsNENBQTRDLE9BQU87QUFDbkQsNENBQTRDO0FBQzVDLHlD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEMsb0NBQW9DOztBQUVwQztBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUdBO0FBQ0EsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNEQUFzRDtBQUNyRzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVTtBQUNWLFVBQVU7QUFDVixXQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxDQUFTO0FBQzNHLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtB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QyxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7Ozs7O0FBT0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQSxNQUFNO0FBQ047QUFDQSx5Q0FBeUM7QUFDekMsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDOztBQUUzQztBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUcsWUFBWSxHQUFHLEdBQUc7QUFDckIsa0NBQWtDLEVBQUUsVUFBVSxHQUFHOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7Ozs7Ozs7QUFPRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7Ozs7Ozs7QUFTRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEIsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBLG9DQUFvQzs7QUFFcEM7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYLDRDQUE0QztBQUM1QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EseUJBQXlCLGVBQWUsRUFBRSxlQUFlO0FBQ3pEO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7O0FBRUEsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVOzs7QUFHViwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osNEJBQTRCOztBQUU1Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7OztBQUdEO0FBQ0EsSUFBSSxLQUFLO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7Ozs7Ozs7O0FBUUQ7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBLHNCQUFzQixLQUFLLEtBQUs7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDs7Ozs7QUFLQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3Qiw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsVUFBVTtBQUNWLHFDQUFxQzs7O0FBR3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTSxtQ0FBbUMsUUFBUTs7O0FBR2pEO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0pBQWtKO0FBQ2xKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUJBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixJQUFJO0FBQ0o7OztBQUdBLDRFQUE0RTs7QUFFNUUsOEdBQThHOztBQUU5RyxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSixrREFBa0Q7QUFDbEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLGtCQUFrQjs7QUFFbEIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBLHlHQUF5Rzs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsTUFBTTtBQUNOLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0Esc0dBQXNHLG1CQUFtQixnSEFBZ0g7O0FBRXpPLHNTQUFzUzs7QUFFdFMscUdBQXFHO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEs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QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBLEdBQUc7QUFDSCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFD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QUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7Ozs7Ozs7Ozs7QUFZRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQyxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNB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O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7Ozs7Ozs7QUFPRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGlCQUFpQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQzs7Ozs7Ozs7QUFRRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDBEQUEwRCxFQUFFOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFOztBQUVyRTs7QUFFQSxzQkFBc0IsdUJBQXVCO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7Ozs7O0FBT0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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QUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDLEdBQUcsb0NBQW9DO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7Ozs7Ozs7O0FBVUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjs7QUFFQSxvQkFBb0IsdUJB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LENBQUM7QUFDRCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUFlRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOzs7O0FBSUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELENBQUM7Ozs7QUFJRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFT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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxELDZGQUE2RjtBQUM3RixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtB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QUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw4REFBOEQsS0FBSztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVB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QUFFLENBQUM7S0FDckI7QUFDSCxDQUFDLENBQUM7QUFFRixRQUFRLGFBQVIsUUFBUSx1QkFBUixRQUFRLENBQUUsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBZ0IsRUFBRSxFQUFFO0lBQ3pELElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxPQUFPLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRTtRQUNuQyxhQUFhLEVBQUUsQ0FBQztRQUNoQixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7S0FDcEI7U0FBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssS0FBSyxFQUFFO1FBQzFCLElBQUksV0FBVyxFQUFFO1lBQ2YsV0FBVyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUM7WUFDMUIsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBQ3BCO0tBQ0Y7QUFDSCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmt1cC8uL25vZGVfbW9kdWxlcy9rYXRleC9kaXN0L2thdGV4LmpzIiwid2VicGFjazovL21hcmt1cC8uL01hcmtVcC50cyIsIndlYnBhY2s6Ly9tYXJrdXAvLi9ub2RlX21vZHVsZXMvdHMtcGFyc28vUGFyc2VyLnRzIiwid2VicGFjazovL21hcmt1cC8uL25vZGVfbW9kdWxlcy90cy1wYXJzby9Ub2tlbml6ZXIudHMiLCJ3ZWJwYWNrOi8vbWFya3VwLy4vbm9kZV9tb2R1bGVzL3RzLXBhcnNvL2luZGV4LnRzIiwid2VicGFjazovL21hcmt1cC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9tYXJrdXAvLi9NYXJrVXBJbnRlcnAudHMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wia2F0ZXhcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wia2F0ZXhcIl0gPSBmYWN0b3J5KCk7XG59KSgodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIHNjb3BlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfcmVxdWlyZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfVxuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwiZGVmYXVsdFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8ga2F0ZXhfd2VicGFjazsgfVxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9QYXJzZUVycm9yLmpzXG5cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgS2FUZVhcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKi9cbmNsYXNzIFBhcnNlRXJyb3Ige1xuICAvLyBFcnJvciBzdGFydCBwb3NpdGlvbiBiYXNlZCBvbiBwYXNzZWQtaW4gVG9rZW4gb3IgUGFyc2VOb2RlLlxuICAvLyBMZW5ndGggb2YgYWZmZWN0ZWQgdGV4dCBiYXNlZCBvbiBwYXNzZWQtaW4gVG9rZW4gb3IgUGFyc2VOb2RlLlxuICAvLyBUaGUgdW5kZXJseWluZyBlcnJvciBtZXNzYWdlIHdpdGhvdXQgYW55IGNvbnRleHQgYWRkZWQuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIC8vIFRoZSBlcnJvciBtZXNzYWdlXG4gIHRva2VuIC8vIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgKSB7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMucG9zaXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5sZW5ndGggPSB2b2lkIDA7XG4gICAgdGhpcy5yYXdNZXNzYWdlID0gdm9pZCAwO1xuICAgIGxldCBlcnJvciA9IFwiS2FUZVggcGFyc2UgZXJyb3I6IFwiICsgbWVzc2FnZTtcbiAgICBsZXQgc3RhcnQ7XG4gICAgbGV0IGVuZDtcbiAgICBjb25zdCBsb2MgPSB0b2tlbiAmJiB0b2tlbi5sb2M7XG5cbiAgICBpZiAobG9jICYmIGxvYy5zdGFydCA8PSBsb2MuZW5kKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRoZSBpbnB1dCBhbmQgYSBwb3NpdGlvbiwgbWFrZSB0aGUgZXJyb3IgYSBiaXQgZmFuY2llclxuICAgICAgLy8gR2V0IHRoZSBpbnB1dFxuICAgICAgY29uc3QgaW5wdXQgPSBsb2MubGV4ZXIuaW5wdXQ7IC8vIFByZXBlbmQgc29tZSBpbmZvcm1hdGlvblxuXG4gICAgICBzdGFydCA9IGxvYy5zdGFydDtcbiAgICAgIGVuZCA9IGxvYy5lbmQ7XG5cbiAgICAgIGlmIChzdGFydCA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGVycm9yICs9IFwiIGF0IGVuZCBvZiBpbnB1dDogXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciArPSBcIiBhdCBwb3NpdGlvbiBcIiArIChzdGFydCArIDEpICsgXCI6IFwiO1xuICAgICAgfSAvLyBVbmRlcmxpbmUgdG9rZW4gaW4gcXVlc3Rpb24gdXNpbmcgY29tYmluaW5nIHVuZGVyc2NvcmVzXG5cblxuICAgICAgY29uc3QgdW5kZXJsaW5lZCA9IGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLnJlcGxhY2UoL1teXS9nLCBcIiQmXFx1MDMzMlwiKTsgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcblxuICAgICAgbGV0IGxlZnQ7XG5cbiAgICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICAgIGxlZnQgPSBcIuKAplwiICsgaW5wdXQuc2xpY2Uoc3RhcnQgLSAxNSwgc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IGlucHV0LnNsaWNlKDAsIHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJpZ2h0O1xuXG4gICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQsIGVuZCArIDE1KSArIFwi4oCmXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gICAgfSAvLyBTb21lIGhhY2tlcnkgdG8gbWFrZSBQYXJzZUVycm9yIGEgcHJvdG90eXBlIG9mIEVycm9yXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg0NjA3NTNcbiAgICAvLyAkRmxvd0ZpeE1lXG5cblxuICAgIGNvbnN0IHNlbGYgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIHNlbGYubmFtZSA9IFwiUGFyc2VFcnJvclwiOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBzZWxmLl9fcHJvdG9fXyA9IFBhcnNlRXJyb3IucHJvdG90eXBlO1xuICAgIHNlbGYucG9zaXRpb24gPSBzdGFydDtcblxuICAgIGlmIChzdGFydCAhPSBudWxsICYmIGVuZCAhPSBudWxsKSB7XG4gICAgICBzZWxmLmxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuICAgIH1cblxuICAgIHNlbGYucmF3TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxufSAvLyAkRmxvd0ZpeE1lIE1vcmUgaGFja2VyeVxuXG5cblBhcnNlRXJyb3IucHJvdG90eXBlLl9fcHJvdG9fXyA9IEVycm9yLnByb3RvdHlwZTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19QYXJzZUVycm9yID0gKFBhcnNlRXJyb3IpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIGxpc3Qgb2YgdXRpbGl0eSBmdW5jdGlvbnMgd2hpY2ggYXJlIHVzZWZ1bCBpbiBvdGhlclxuICogZmlsZXMuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhIGxpc3RcbiAqL1xuY29uc3QgY29udGFpbnMgPSBmdW5jdGlvbiAobGlzdCwgZWxlbSkge1xuICByZXR1cm4gbGlzdC5pbmRleE9mKGVsZW0pICE9PSAtMTtcbn07XG4vKipcbiAqIFByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlIGlmIGEgc2V0dGluZyBpcyB1bmRlZmluZWRcbiAqIE5PVEU6IENvdWxkbid0IHVzZSBgVGAgYXMgdGhlIG91dHB1dCB0eXBlIGR1ZSB0byBmYWNlYm9vay9mbG93IzUwMjIuXG4gKi9cblxuXG5jb25zdCBkZWZsdCA9IGZ1bmN0aW9uIChzZXR0aW5nLCBkZWZhdWx0SWZVbmRlZmluZWQpIHtcbiAgcmV0dXJuIHNldHRpbmcgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRJZlVuZGVmaW5lZCA6IHNldHRpbmc7XG59OyAvLyBoeXBoZW5hdGUgYW5kIGVzY2FwZSBhZGFwdGVkIGZyb20gRmFjZWJvb2sncyBSZWFjdCB1bmRlciBBcGFjaGUgMiBsaWNlbnNlXG5cblxuY29uc3QgdXBwZXJjYXNlID0gLyhbQS1aXSkvZztcblxuY29uc3QgaHlwaGVuYXRlID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UodXBwZXJjYXNlLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpO1xufTtcblxuY29uc3QgRVNDQVBFX0xPT0tVUCA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiXFxcIlwiOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImI3gyNztcIlxufTtcbmNvbnN0IEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqL1xuXG5mdW5jdGlvbiB1dGlsc19lc2NhcGUodGV4dCkge1xuICByZXR1cm4gU3RyaW5nKHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBtYXRjaCA9PiBFU0NBUEVfTE9PS1VQW21hdGNoXSk7XG59XG4vKipcbiAqIFNvbWV0aW1lcyB3ZSB3YW50IHRvIHB1bGwgb3V0IHRoZSBpbm5lcm1vc3QgZWxlbWVudCBvZiBhIGdyb3VwLiBJbiBtb3N0XG4gKiBjYXNlcywgdGhpcyB3aWxsIGp1c3QgYmUgdGhlIGdyb3VwIGl0c2VsZiwgYnV0IHdoZW4gb3JkZ3JvdXBzIGFuZCBjb2xvcnMgaGF2ZVxuICogYSBzaW5nbGUgZWxlbWVudCwgd2Ugd2FudCB0byBwdWxsIHRoYXQgb3V0LlxuICovXG5cblxuY29uc3QgZ2V0QmFzZUVsZW0gPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgaWYgKGdyb3VwLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHlbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiY29sb3JcIikge1xuICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHlbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiZm9udFwiKSB7XG4gICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBncm91cDtcbiAgfVxufTtcbi8qKlxuICogVGVYYm9vayBhbGdvcml0aG1zIG9mdGVuIHJlZmVyZW5jZSBcImNoYXJhY3RlciBib3hlc1wiLCB3aGljaCBhcmUgc2ltcGx5IGdyb3Vwc1xuICogd2l0aCBhIHNpbmdsZSBjaGFyYWN0ZXIgaW4gdGhlbS4gVG8gZGVjaWRlIGlmIHNvbWV0aGluZyBpcyBhIGNoYXJhY3RlciBib3gsXG4gKiB3ZSBmaW5kIGl0cyBpbm5lcm1vc3QgZ3JvdXAsIGFuZCBzZWUgaWYgaXQgaXMgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICovXG5cblxuY29uc3QgaXNDaGFyYWN0ZXJCb3ggPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgY29uc3QgYmFzZUVsZW0gPSBnZXRCYXNlRWxlbShncm91cCk7IC8vIFRoZXNlIGFyZSBhbGwgdGhleSB0eXBlcyBvZiBncm91cHMgd2hpY2ggaG9sZCBzaW5nbGUgY2hhcmFjdGVyc1xuXG4gIHJldHVybiBiYXNlRWxlbS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBiYXNlRWxlbS50eXBlID09PSBcInRleHRvcmRcIiB8fCBiYXNlRWxlbS50eXBlID09PSBcImF0b21cIjtcbn07XG5cbmNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub24tbnVsbCwgYnV0IGdvdCAnICsgU3RyaW5nKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBSZXR1cm4gdGhlIHByb3RvY29sIG9mIGEgVVJMLCBvciBcIl9yZWxhdGl2ZVwiIGlmIHRoZSBVUkwgZG9lcyBub3Qgc3BlY2lmeSBhXG4gKiBwcm90b2NvbCAoYW5kIHRodXMgaXMgcmVsYXRpdmUpLCBvciBgbnVsbGAgaWYgVVJMIGhhcyBpbnZhbGlkIHByb3RvY29sXG4gKiAoc28gc2hvdWxkIGJlIG91dHJpZ2h0IHJlamVjdGVkKS5cbiAqL1xuXG5jb25zdCBwcm90b2NvbEZyb21VcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gIC8vIENoZWNrIGZvciBwb3NzaWJsZSBsZWFkaW5nIHByb3RvY29sLlxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgLy8gKFUrMjApIG9yIEMwIGNvbnRyb2wgKFUrMDAtVSsxRikgY2hhcmFjdGVycy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgY29uc3QgcHJvdG9jb2wgPSAvXltcXHgwMC1cXHgyMF0qKFteXFxcXC8jP10qPykoOnwmIzAqNTh8JiN4MCozYXwmY29sb24pL2kuZXhlYyh1cmwpO1xuXG4gIGlmICghcHJvdG9jb2wpIHtcbiAgICByZXR1cm4gXCJfcmVsYXRpdmVcIjtcbiAgfSAvLyBSZWplY3Qgd2VpcmQgY29sb25zXG5cblxuICBpZiAocHJvdG9jb2xbMl0gIT09IFwiOlwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gUmVqZWN0IGludmFsaWQgY2hhcmFjdGVycyBpbiBzY2hlbWUgYWNjb3JkaW5nIHRvXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMVxuXG5cbiAgaWYgKCEvXlthLXpBLVpdW2EtekEtWjAtOStcXC0uXSokLy50ZXN0KHByb3RvY29sWzFdKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIExvd2VyY2FzZSB0aGUgcHJvdG9jb2xcblxuXG4gIHJldHVybiBwcm90b2NvbFsxXS50b0xvd2VyQ2FzZSgpO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHV0aWxzID0gKHtcbiAgY29udGFpbnMsXG4gIGRlZmx0LFxuICBlc2NhcGU6IHV0aWxzX2VzY2FwZSxcbiAgaHlwaGVuYXRlLFxuICBnZXRCYXNlRWxlbSxcbiAgaXNDaGFyYWN0ZXJCb3gsXG4gIHByb3RvY29sRnJvbVVybFxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvU2V0dGluZ3MuanNcbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgbW9kdWxlIGZvciBzdG9yaW5nIHNldHRpbmdzIHBhc3NlZCBpbnRvIEthVGVYLiBJdCBjb3JyZWN0bHkgaGFuZGxlc1xuICogZGVmYXVsdCBzZXR0aW5ncy5cbiAqL1xuXG5cblxuLy8gVE9ETzogYXV0b21hdGljYWxseSBnZW5lcmF0ZSBkb2N1bWVudGF0aW9uXG4vLyBUT0RPOiBjaGVjayBhbGwgcHJvcGVydGllcyBvbiBTZXR0aW5ncyBleGlzdFxuLy8gVE9ETzogY2hlY2sgdGhlIHR5cGUgb2YgYSBwcm9wZXJ0eSBvbiBTZXR0aW5ncyBtYXRjaGVzXG5jb25zdCBTRVRUSU5HU19TQ0hFTUEgPSB7XG4gIGRpc3BsYXlNb2RlOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUmVuZGVyIG1hdGggaW4gZGlzcGxheSBtb2RlLCB3aGljaCBwdXRzIHRoZSBtYXRoIGluIFwiICsgXCJkaXNwbGF5IHN0eWxlIChzbyBcXFxcaW50IGFuZCBcXFxcc3VtIGFyZSBsYXJnZSwgZm9yIGV4YW1wbGUpLCBhbmQgXCIgKyBcImNlbnRlcnMgdGhlIG1hdGggb24gdGhlIHBhZ2Ugb24gaXRzIG93biBsaW5lLlwiLFxuICAgIGNsaTogXCItZCwgLS1kaXNwbGF5LW1vZGVcIlxuICB9LFxuICBvdXRwdXQ6IHtcbiAgICB0eXBlOiB7XG4gICAgICBlbnVtOiBbXCJodG1sQW5kTWF0aG1sXCIsIFwiaHRtbFwiLCBcIm1hdGhtbFwiXVxuICAgIH0sXG4gICAgZGVzY3JpcHRpb246IFwiRGV0ZXJtaW5lcyB0aGUgbWFya3VwIGxhbmd1YWdlIG9mIHRoZSBvdXRwdXQuXCIsXG4gICAgY2xpOiBcIi1GLCAtLWZvcm1hdCA8dHlwZT5cIlxuICB9LFxuICBsZXFubzoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlJlbmRlciBkaXNwbGF5IG1hdGggaW4gbGVxbm8gc3R5bGUgKGxlZnQtanVzdGlmaWVkIHRhZ3MpLlwiXG4gIH0sXG4gIGZsZXFuOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUmVuZGVyIGRpc3BsYXkgbWF0aCBmbHVzaCBsZWZ0LlwiXG4gIH0sXG4gIHRocm93T25FcnJvcjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgY2xpOiBcIi10LCAtLW5vLXRocm93LW9uLWVycm9yXCIsXG4gICAgY2xpRGVzY3JpcHRpb246IFwiUmVuZGVyIGVycm9ycyAoaW4gdGhlIGNvbG9yIGdpdmVuIGJ5IC0tZXJyb3ItY29sb3IpIGluc1wiICsgXCJ0ZWFkIG9mIHRocm93aW5nIGEgUGFyc2VFcnJvciBleGNlcHRpb24gd2hlbiBlbmNvdW50ZXJpbmcgYW4gZXJyb3IuXCJcbiAgfSxcbiAgZXJyb3JDb2xvcjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZGVmYXVsdDogXCIjY2MwMDAwXCIsXG4gICAgY2xpOiBcIi1jLCAtLWVycm9yLWNvbG9yIDxjb2xvcj5cIixcbiAgICBjbGlEZXNjcmlwdGlvbjogXCJBIGNvbG9yIHN0cmluZyBnaXZlbiBpbiB0aGUgZm9ybWF0ICdyZ2InIG9yICdycmdnYmInIFwiICsgXCIobm8gIykuIFRoaXMgb3B0aW9uIGRldGVybWluZXMgdGhlIGNvbG9yIG9mIGVycm9ycyByZW5kZXJlZCBieSB0aGUgXCIgKyBcIi10IG9wdGlvbi5cIixcbiAgICBjbGlQcm9jZXNzb3I6IGNvbG9yID0+IFwiI1wiICsgY29sb3JcbiAgfSxcbiAgbWFjcm9zOiB7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBjbGk6IFwiLW0sIC0tbWFjcm8gPGRlZj5cIixcbiAgICBjbGlEZXNjcmlwdGlvbjogXCJEZWZpbmUgY3VzdG9tIG1hY3JvIG9mIHRoZSBmb3JtICdcXFxcZm9vOmV4cGFuc2lvbicgKHVzZSBcIiArIFwibXVsdGlwbGUgLW0gYXJndW1lbnRzIGZvciBtdWx0aXBsZSBtYWNyb3MpLlwiLFxuICAgIGNsaURlZmF1bHQ6IFtdLFxuICAgIGNsaVByb2Nlc3NvcjogKGRlZiwgZGVmcykgPT4ge1xuICAgICAgZGVmcy5wdXNoKGRlZik7XG4gICAgICByZXR1cm4gZGVmcztcbiAgICB9XG4gIH0sXG4gIG1pblJ1bGVUaGlja25lc3M6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlNwZWNpZmllcyBhIG1pbmltdW0gdGhpY2tuZXNzLCBpbiBlbXMsIGZvciBmcmFjdGlvbiBsaW5lcyxcIiArIFwiIGBcXFxcc3FydGAgdG9wIGxpbmVzLCBge2FycmF5fWAgdmVydGljYWwgbGluZXMsIGBcXFxcaGxpbmVgLCBcIiArIFwiYFxcXFxoZGFzaGxpbmVgLCBgXFxcXHVuZGVybGluZWAsIGBcXFxcb3ZlcmxpbmVgLCBhbmQgdGhlIGJvcmRlcnMgb2YgXCIgKyBcImBcXFxcZmJveGAsIGBcXFxcYm94ZWRgLCBhbmQgYFxcXFxmY29sb3Jib3hgLlwiLFxuICAgIHByb2Nlc3NvcjogdCA9PiBNYXRoLm1heCgwLCB0KSxcbiAgICBjbGk6IFwiLS1taW4tcnVsZS10aGlja25lc3MgPHNpemU+XCIsXG4gICAgY2xpUHJvY2Vzc29yOiBwYXJzZUZsb2F0XG4gIH0sXG4gIGNvbG9ySXNUZXh0Q29sb3I6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJNYWtlcyBcXFxcY29sb3IgYmVoYXZlIGxpa2UgTGFUZVgncyAyLWFyZ3VtZW50IFxcXFx0ZXh0Y29sb3IsIFwiICsgXCJpbnN0ZWFkIG9mIExhVGVYJ3Mgb25lLWFyZ3VtZW50IFxcXFxjb2xvciBtb2RlIGNoYW5nZS5cIixcbiAgICBjbGk6IFwiLWIsIC0tY29sb3ItaXMtdGV4dC1jb2xvclwiXG4gIH0sXG4gIHN0cmljdDoge1xuICAgIHR5cGU6IFt7XG4gICAgICBlbnVtOiBbXCJ3YXJuXCIsIFwiaWdub3JlXCIsIFwiZXJyb3JcIl1cbiAgICB9LCBcImJvb2xlYW5cIiwgXCJmdW5jdGlvblwiXSxcbiAgICBkZXNjcmlwdGlvbjogXCJUdXJuIG9uIHN0cmljdCAvIExhVGVYIGZhaXRoZnVsbmVzcyBtb2RlLCB3aGljaCB0aHJvd3MgYW4gXCIgKyBcImVycm9yIGlmIHRoZSBpbnB1dCB1c2VzIGZlYXR1cmVzIHRoYXQgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgTGFUZVguXCIsXG4gICAgY2xpOiBcIi1TLCAtLXN0cmljdFwiLFxuICAgIGNsaURlZmF1bHQ6IGZhbHNlXG4gIH0sXG4gIHRydXN0OiB7XG4gICAgdHlwZTogW1wiYm9vbGVhblwiLCBcImZ1bmN0aW9uXCJdLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRydXN0IHRoZSBpbnB1dCwgZW5hYmxpbmcgYWxsIEhUTUwgZmVhdHVyZXMgc3VjaCBhcyBcXFxcdXJsLlwiLFxuICAgIGNsaTogXCItVCwgLS10cnVzdFwiXG4gIH0sXG4gIG1heFNpemU6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IEluZmluaXR5LFxuICAgIGRlc2NyaXB0aW9uOiBcIklmIG5vbi16ZXJvLCBhbGwgdXNlci1zcGVjaWZpZWQgc2l6ZXMsIGUuZy4gaW4gXCIgKyBcIlxcXFxydWxlezUwMGVtfXs1MDBlbX0sIHdpbGwgYmUgY2FwcGVkIHRvIG1heFNpemUgZW1zLiBPdGhlcndpc2UsIFwiICsgXCJlbGVtZW50cyBhbmQgc3BhY2VzIGNhbiBiZSBhcmJpdHJhcmlseSBsYXJnZVwiLFxuICAgIHByb2Nlc3NvcjogcyA9PiBNYXRoLm1heCgwLCBzKSxcbiAgICBjbGk6IFwiLXMsIC0tbWF4LXNpemUgPG4+XCIsXG4gICAgY2xpUHJvY2Vzc29yOiBwYXJzZUludFxuICB9LFxuICBtYXhFeHBhbmQ6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEwMDAsXG4gICAgZGVzY3JpcHRpb246IFwiTGltaXQgdGhlIG51bWJlciBvZiBtYWNybyBleHBhbnNpb25zIHRvIHRoZSBzcGVjaWZpZWQgXCIgKyBcIm51bWJlciwgdG8gcHJldmVudCBlLmcuIGluZmluaXRlIG1hY3JvIGxvb3BzLiBJZiBzZXQgdG8gSW5maW5pdHksIFwiICsgXCJ0aGUgbWFjcm8gZXhwYW5kZXIgd2lsbCB0cnkgdG8gZnVsbHkgZXhwYW5kIGFzIGluIExhVGVYLlwiLFxuICAgIHByb2Nlc3NvcjogbiA9PiBNYXRoLm1heCgwLCBuKSxcbiAgICBjbGk6IFwiLWUsIC0tbWF4LWV4cGFuZCA8bj5cIixcbiAgICBjbGlQcm9jZXNzb3I6IG4gPT4gbiA9PT0gXCJJbmZpbml0eVwiID8gSW5maW5pdHkgOiBwYXJzZUludChuKVxuICB9LFxuICBnbG9iYWxHcm91cDoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGNsaTogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLmRlZmF1bHQpIHtcbiAgICByZXR1cm4gc2NoZW1hLmRlZmF1bHQ7XG4gIH1cblxuICBjb25zdCB0eXBlID0gc2NoZW1hLnR5cGU7XG4gIGNvbnN0IGRlZmF1bHRUeXBlID0gQXJyYXkuaXNBcnJheSh0eXBlKSA/IHR5cGVbMF0gOiB0eXBlO1xuXG4gIGlmICh0eXBlb2YgZGVmYXVsdFR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRUeXBlLmVudW1bMF07XG4gIH1cblxuICBzd2l0Y2ggKGRlZmF1bHRUeXBlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiAwO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiB7fTtcbiAgfVxufVxuLyoqXG4gKiBUaGUgbWFpbiBTZXR0aW5ncyBvYmplY3RcbiAqXG4gKiBUaGUgY3VycmVudCBvcHRpb25zIHN0b3JlZCBhcmU6XG4gKiAgLSBkaXNwbGF5TW9kZTogV2hldGhlciB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgdHlwZXNldCBhcyBpbmxpbmUgbWF0aFxuICogICAgICAgICAgICAgICAgIChmYWxzZSwgdGhlIGRlZmF1bHQpLCBtZWFuaW5nIHRoYXQgdGhlIG1hdGggc3RhcnRzIGluXG4gKiAgICAgICAgICAgICAgICAgXFx0ZXh0c3R5bGUgYW5kIGlzIHBsYWNlZCBpbiBhbiBpbmxpbmUtYmxvY2spOyBvciBhcyBkaXNwbGF5XG4gKiAgICAgICAgICAgICAgICAgbWF0aCAodHJ1ZSksIG1lYW5pbmcgdGhhdCB0aGUgbWF0aCBzdGFydHMgaW4gXFxkaXNwbGF5c3R5bGVcbiAqICAgICAgICAgICAgICAgICBhbmQgaXMgcGxhY2VkIGluIGEgYmxvY2sgd2l0aCB2ZXJ0aWNhbCBtYXJnaW4uXG4gKi9cblxuXG5jbGFzcyBTZXR0aW5ncyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRpc3BsYXlNb2RlID0gdm9pZCAwO1xuICAgIHRoaXMub3V0cHV0ID0gdm9pZCAwO1xuICAgIHRoaXMubGVxbm8gPSB2b2lkIDA7XG4gICAgdGhpcy5mbGVxbiA9IHZvaWQgMDtcbiAgICB0aGlzLnRocm93T25FcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9yQ29sb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5tYWNyb3MgPSB2b2lkIDA7XG4gICAgdGhpcy5taW5SdWxlVGhpY2tuZXNzID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3JJc1RleHRDb2xvciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmljdCA9IHZvaWQgMDtcbiAgICB0aGlzLnRydXN0ID0gdm9pZCAwO1xuICAgIHRoaXMubWF4U2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEV4cGFuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmdsb2JhbEdyb3VwID0gdm9pZCAwO1xuICAgIC8vIGFsbG93IG51bGwgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgZm9yIChjb25zdCBwcm9wIGluIFNFVFRJTkdTX1NDSEVNQSkge1xuICAgICAgaWYgKFNFVFRJTkdTX1NDSEVNQS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IFNFVFRJTkdTX1NDSEVNQVtwcm9wXTsgLy8gVE9ETzogdmFsaWRhdGUgb3B0aW9uc1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF0gIT09IHVuZGVmaW5lZCA/IHNjaGVtYS5wcm9jZXNzb3IgPyBzY2hlbWEucHJvY2Vzc29yKG9wdGlvbnNbcHJvcF0pIDogb3B0aW9uc1twcm9wXSA6IGdldERlZmF1bHRWYWx1ZShzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVwb3J0IG5vbnN0cmljdCAobm9uLUxhVGVYLWNvbXBhdGlibGUpIGlucHV0LlxuICAgKiBDYW4gc2FmZWx5IG5vdCBiZSBjYWxsZWQgaWYgYHRoaXMuc3RyaWN0YCBpcyBmYWxzZSBpbiBKYXZhU2NyaXB0LlxuICAgKi9cblxuXG4gIHJlcG9ydE5vbnN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbikge1xuICAgIGxldCBzdHJpY3QgPSB0aGlzLnN0cmljdDtcblxuICAgIGlmICh0eXBlb2Ygc3RyaWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIEFsbG93IHJldHVybiB2YWx1ZSBvZiBzdHJpY3QgZnVuY3Rpb24gdG8gYmUgYm9vbGVhbiBvciBzdHJpbmdcbiAgICAgIC8vIChvciBudWxsL3VuZGVmaW5lZCwgbWVhbmluZyBubyBmdXJ0aGVyIHByb2Nlc3NpbmcpLlxuICAgICAgc3RyaWN0ID0gc3RyaWN0KGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoIXN0cmljdCB8fCBzdHJpY3QgPT09IFwiaWdub3JlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gdHJ1ZSB8fCBzdHJpY3QgPT09IFwiZXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ2Vycm9yJzogXCIgKyAoZXJyb3JNc2cgKyBcIiBbXCIgKyBlcnJvckNvZGUgKyBcIl1cIiksIHRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gXCJ3YXJuXCIpIHtcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcIkxhVGVYLWluY29tcGF0aWJsZSBpbnB1dCBhbmQgc3RyaWN0IG1vZGUgaXMgc2V0IHRvICd3YXJuJzogXCIgKyAoZXJyb3JNc2cgKyBcIiBbXCIgKyBlcnJvckNvZGUgKyBcIl1cIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3b24ndCBoYXBwZW4gaW4gdHlwZS1zYWZlIGNvZGVcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcIkxhVGVYLWluY29tcGF0aWJsZSBpbnB1dCBhbmQgc3RyaWN0IG1vZGUgaXMgc2V0IHRvIFwiICsgKFwidW5yZWNvZ25pemVkICdcIiArIHN0cmljdCArIFwiJzogXCIgKyBlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRvIGFwcGx5IHN0cmljdCAoTGFUZVgtYWRoZXJpbmcpIGJlaGF2aW9yIGZvciB1bnVzdWFsXG4gICAqIGlucHV0IChsaWtlIGBcXFxcYCkuICBVbmxpa2UgYG5vbnN0cmljdGAsIHdpbGwgbm90IHRocm93IGFuIGVycm9yO1xuICAgKiBpbnN0ZWFkLCBcImVycm9yXCIgdHJhbnNsYXRlcyB0byBhIHJldHVybiB2YWx1ZSBvZiBgdHJ1ZWAsIHdoaWxlIFwiaWdub3JlXCJcbiAgICogdHJhbnNsYXRlcyB0byBhIHJldHVybiB2YWx1ZSBvZiBgZmFsc2VgLiAgTWF5IHN0aWxsIHByaW50IGEgd2FybmluZzpcbiAgICogXCJ3YXJuXCIgcHJpbnRzIGEgd2FybmluZyBhbmQgcmV0dXJucyBgZmFsc2VgLlxuICAgKiBUaGlzIGlzIGZvciB0aGUgc2Vjb25kIGNhdGVnb3J5IG9mIGBlcnJvckNvZGVgcyBsaXN0ZWQgaW4gdGhlIFJFQURNRS5cbiAgICovXG5cblxuICB1c2VTdHJpY3RCZWhhdmlvcihlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbikge1xuICAgIGxldCBzdHJpY3QgPSB0aGlzLnN0cmljdDtcblxuICAgIGlmICh0eXBlb2Ygc3RyaWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIEFsbG93IHJldHVybiB2YWx1ZSBvZiBzdHJpY3QgZnVuY3Rpb24gdG8gYmUgYm9vbGVhbiBvciBzdHJpbmdcbiAgICAgIC8vIChvciBudWxsL3VuZGVmaW5lZCwgbWVhbmluZyBubyBmdXJ0aGVyIHByb2Nlc3NpbmcpLlxuICAgICAgLy8gQnV0IGNhdGNoIGFueSBleGNlcHRpb25zIHRocm93biBieSBmdW5jdGlvbiwgdHJlYXRpbmcgdGhlbVxuICAgICAgLy8gbGlrZSBcImVycm9yXCIuXG4gICAgICB0cnkge1xuICAgICAgICBzdHJpY3QgPSBzdHJpY3QoZXJyb3JDb2RlLCBlcnJvck1zZywgdG9rZW4pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc3RyaWN0ID0gXCJlcnJvclwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3RyaWN0IHx8IHN0cmljdCA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSB0cnVlIHx8IHN0cmljdCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gXCJ3YXJuXCIpIHtcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcIkxhVGVYLWluY29tcGF0aWJsZSBpbnB1dCBhbmQgc3RyaWN0IG1vZGUgaXMgc2V0IHRvICd3YXJuJzogXCIgKyAoZXJyb3JNc2cgKyBcIiBbXCIgKyBlcnJvckNvZGUgKyBcIl1cIikpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3b24ndCBoYXBwZW4gaW4gdHlwZS1zYWZlIGNvZGVcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcIkxhVGVYLWluY29tcGF0aWJsZSBpbnB1dCBhbmQgc3RyaWN0IG1vZGUgaXMgc2V0IHRvIFwiICsgKFwidW5yZWNvZ25pemVkICdcIiArIHN0cmljdCArIFwiJzogXCIgKyBlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRvIHRlc3QgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGlucHV0LCBhbmQgcmV0dXJuXG4gICAqIGB0cnVlYCAodHJ1c3RlZCkgb3IgYGZhbHNlYCAodW50cnVzdGVkKS4gIFRoZSBzb2xlIGFyZ3VtZW50IGBjb250ZXh0YFxuICAgKiBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggYGNvbW1hbmRgIGZpZWxkIHNwZWNpZnlpbmcgdGhlIHJlbGV2YW50IExhVGVYXG4gICAqIGNvbW1hbmQgKGFzIGEgc3RyaW5nIHN0YXJ0aW5nIHdpdGggYFxcYCksIGFuZCBhbnkgb3RoZXIgYXJndW1lbnRzLCBldGMuXG4gICAqIElmIGBjb250ZXh0YCBoYXMgYSBgdXJsYCBmaWVsZCwgYSBgcHJvdG9jb2xgIGZpZWxkIHdpbGwgYXV0b21hdGljYWxseVxuICAgKiBnZXQgYWRkZWQgYnkgdGhpcyBmdW5jdGlvbiAoY2hhbmdpbmcgdGhlIHNwZWNpZmllZCBvYmplY3QpLlxuICAgKi9cblxuXG4gIGlzVHJ1c3RlZChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQudXJsICYmICFjb250ZXh0LnByb3RvY29sKSB7XG4gICAgICBjb25zdCBwcm90b2NvbCA9IHV0aWxzLnByb3RvY29sRnJvbVVybChjb250ZXh0LnVybCk7XG5cbiAgICAgIGlmIChwcm90b2NvbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIH1cblxuICAgIGNvbnN0IHRydXN0ID0gdHlwZW9mIHRoaXMudHJ1c3QgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMudHJ1c3QoY29udGV4dCkgOiB0aGlzLnRydXN0O1xuICAgIHJldHVybiBCb29sZWFuKHRydXN0KTtcbiAgfVxuXG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvU3R5bGUuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCBjbGFzc2VzIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBzdHlsZXNcbiAqIHVzZWQgaW4gVGVYLiBJdCBwcm92aWRlcyBhIGdlbmVyaWMgYFN0eWxlYCBjbGFzcywgd2hpY2ggaG9sZHMgaW5mb3JtYXRpb25cbiAqIGFib3V0IGEgc3BlY2lmaWMgc3R5bGUuIEl0IHRoZW4gcHJvdmlkZXMgaW5zdGFuY2VzIG9mIGFsbCB0aGUgZGlmZmVyZW50IGtpbmRzXG4gKiBvZiBzdHlsZXMgcG9zc2libGUsIGFuZCBwcm92aWRlcyBmdW5jdGlvbnMgdG8gbW92ZSBiZXR3ZWVuIHRoZW0gYW5kIGdldFxuICogaW5mb3JtYXRpb24gYWJvdXQgdGhlbS5cbiAqL1xuXG4vKipcbiAqIFRoZSBtYWluIHN0eWxlIGNsYXNzLiBDb250YWlucyBhIHVuaXF1ZSBpZCBmb3IgdGhlIHN0eWxlLCBhIHNpemUgKHdoaWNoIGlzXG4gKiB0aGUgc2FtZSBmb3IgY3JhbXBlZCBhbmQgdW5jcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSksIGFuZCBhIGNyYW1wZWQgZmxhZy5cbiAqL1xuY2xhc3MgU3R5bGUge1xuICBjb25zdHJ1Y3RvcihpZCwgc2l6ZSwgY3JhbXBlZCkge1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMuY3JhbXBlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNyYW1wZWQgPSBjcmFtcGVkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgc3VwZXJzY3JpcHQgZ2l2ZW4gYSBiYXNlIGluIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKi9cblxuXG4gIHN1cCgpIHtcbiAgICByZXR1cm4gc3R5bGVzW3N1cFt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdWJzY3JpcHQgZ2l2ZW4gYSBiYXNlIGluIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKi9cblxuXG4gIHN1YigpIHtcbiAgICByZXR1cm4gc3R5bGVzW3N1Ylt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgb2YgYSBmcmFjdGlvbiBudW1lcmF0b3IgZ2l2ZW4gdGhlIGZyYWN0aW9uIGluIHRoZSBjdXJyZW50XG4gICAqIHN0eWxlLlxuICAgKi9cblxuXG4gIGZyYWNOdW0oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjTnVtW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIGZyYWN0aW9uIGRlbm9taW5hdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICAgKiBzdHlsZS5cbiAgICovXG5cblxuICBmcmFjRGVuKCkge1xuICAgIHJldHVybiBzdHlsZXNbZnJhY0Rlblt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3JhbXBlZCB2ZXJzaW9uIG9mIGEgc3R5bGUgKGluIHBhcnRpY3VsYXIsIGNyYW1waW5nIGEgY3JhbXBlZCBzdHlsZVxuICAgKiBkb2Vzbid0IGNoYW5nZSB0aGUgc3R5bGUpLlxuICAgKi9cblxuXG4gIGNyYW1wKCkge1xuICAgIHJldHVybiBzdHlsZXNbY3JhbXBbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB0ZXh0IG9yIGRpc3BsYXkgdmVyc2lvbiBvZiB0aGlzIHN0eWxlLlxuICAgKi9cblxuXG4gIHRleHQoKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tTdHlsZV90ZXh0W3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgdGhpcyBzdHlsZSBpcyB0aWdodGx5IHNwYWNlZCAoc2NyaXB0c3R5bGUvc2NyaXB0c2NyaXB0c3R5bGUpXG4gICAqL1xuXG5cbiAgaXNUaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplID49IDI7XG4gIH1cblxufSAvLyBFeHBvcnQgYW4gaW50ZXJmYWNlIGZvciB0eXBlIGNoZWNraW5nLCBidXQgZG9uJ3QgZXhwb3NlIHRoZSBpbXBsZW1lbnRhdGlvbi5cbi8vIFRoaXMgd2F5LCBubyBtb3JlIHN0eWxlcyBjYW4gYmUgZ2VuZXJhdGVkLlxuXG5cbi8vIElEcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xuY29uc3QgRCA9IDA7XG5jb25zdCBEYyA9IDE7XG5jb25zdCBUID0gMjtcbmNvbnN0IFRjID0gMztcbmNvbnN0IFMgPSA0O1xuY29uc3QgU2MgPSA1O1xuY29uc3QgU1MgPSA2O1xuY29uc3QgU1NjID0gNzsgLy8gSW5zdGFuY2VzIG9mIHRoZSBkaWZmZXJlbnQgc3R5bGVzXG5cbmNvbnN0IHN0eWxlcyA9IFtuZXcgU3R5bGUoRCwgMCwgZmFsc2UpLCBuZXcgU3R5bGUoRGMsIDAsIHRydWUpLCBuZXcgU3R5bGUoVCwgMSwgZmFsc2UpLCBuZXcgU3R5bGUoVGMsIDEsIHRydWUpLCBuZXcgU3R5bGUoUywgMiwgZmFsc2UpLCBuZXcgU3R5bGUoU2MsIDIsIHRydWUpLCBuZXcgU3R5bGUoU1MsIDMsIGZhbHNlKSwgbmV3IFN0eWxlKFNTYywgMywgdHJ1ZSldOyAvLyBMb29rdXAgdGFibGVzIGZvciBzd2l0Y2hpbmcgZnJvbSBvbmUgc3R5bGUgdG8gYW5vdGhlclxuXG5jb25zdCBzdXAgPSBbUywgU2MsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbmNvbnN0IHN1YiA9IFtTYywgU2MsIFNjLCBTYywgU1NjLCBTU2MsIFNTYywgU1NjXTtcbmNvbnN0IGZyYWNOdW0gPSBbVCwgVGMsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbmNvbnN0IGZyYWNEZW4gPSBbVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjLCBTU2MsIFNTY107XG5jb25zdCBjcmFtcCA9IFtEYywgRGMsIFRjLCBUYywgU2MsIFNjLCBTU2MsIFNTY107XG5jb25zdCBTdHlsZV90ZXh0ID0gW0QsIERjLCBULCBUYywgVCwgVGMsIFQsIFRjXTsgLy8gV2Ugb25seSBleHBvcnQgc29tZSBvZiB0aGUgc3R5bGVzLlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfU3R5bGUgPSAoe1xuICBESVNQTEFZOiBzdHlsZXNbRF0sXG4gIFRFWFQ6IHN0eWxlc1tUXSxcbiAgU0NSSVBUOiBzdHlsZXNbU10sXG4gIFNDUklQVFNDUklQVDogc3R5bGVzW1NTXVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdW5pY29kZVNjcmlwdHMuanNcbi8qXG4gKiBUaGlzIGZpbGUgZGVmaW5lcyB0aGUgVW5pY29kZSBzY3JpcHRzIGFuZCBzY3JpcHQgZmFtaWxpZXMgdGhhdCB3ZVxuICogc3VwcG9ydC4gVG8gYWRkIG5ldyBzY3JpcHRzIG9yIGZhbWlsaWVzLCBqdXN0IGFkZCBhIG5ldyBlbnRyeSB0byB0aGVcbiAqIHNjcmlwdERhdGEgYXJyYXkgYmVsb3cuIEFkZGluZyBzY3JpcHRzIHRvIHRoZSBzY3JpcHREYXRhIGFycmF5IGFsbG93c1xuICogY2hhcmFjdGVycyBmcm9tIHRoYXQgc2NyaXB0IHRvIGFwcGVhciBpbiBcXHRleHR7fSBlbnZpcm9ubWVudHMuXG4gKi9cblxuLyoqXG4gKiBFYWNoIHNjcmlwdCBvciBzY3JpcHQgZmFtaWx5IGhhcyBhIG5hbWUgYW5kIGFuIGFycmF5IG9mIGJsb2Nrcy5cbiAqIEVhY2ggYmxvY2sgaXMgYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgd2hpY2ggc3BlY2lmeSB0aGUgc3RhcnQgYW5kXG4gKiBlbmQgcG9pbnRzIChpbmNsdXNpdmUpIG9mIGEgYmxvY2sgb2YgVW5pY29kZSBjb2RlcG9pbnRzLlxuICovXG5cbi8qKlxuICogVW5pY29kZSBibG9jayBkYXRhIGZvciB0aGUgZmFtaWxpZXMgb2Ygc2NyaXB0cyB3ZSBzdXBwb3J0IGluIFxcdGV4dHt9LlxuICogU2NyaXB0cyBvbmx5IG5lZWQgdG8gYXBwZWFyIGhlcmUgaWYgdGhleSBkbyBub3QgaGF2ZSBmb250IG1ldHJpY3MuXG4gKi9cbmNvbnN0IHNjcmlwdERhdGEgPSBbe1xuICAvLyBMYXRpbiBjaGFyYWN0ZXJzIGJleW9uZCB0aGUgTGF0aW4tMSBjaGFyYWN0ZXJzIHdlIGhhdmUgbWV0cmljcyBmb3IuXG4gIC8vIE5lZWRlZCBmb3IgQ3plY2gsIEh1bmdhcmlhbiBhbmQgVHVya2lzaCB0ZXh0LCBmb3IgZXhhbXBsZS5cbiAgbmFtZTogJ2xhdGluJyxcbiAgYmxvY2tzOiBbWzB4MDEwMCwgMHgwMjRmXSwgLy8gTGF0aW4gRXh0ZW5kZWQtQSBhbmQgTGF0aW4gRXh0ZW5kZWQtQlxuICBbMHgwMzAwLCAweDAzNmZdIC8vIENvbWJpbmluZyBEaWFjcml0aWNhbCBtYXJrc1xuICBdXG59LCB7XG4gIC8vIFRoZSBDeXJpbGxpYyBzY3JpcHQgdXNlZCBieSBSdXNzaWFuIGFuZCByZWxhdGVkIGxhbmd1YWdlcy5cbiAgLy8gQSBDeXJpbGxpYyBzdWJzZXQgdXNlZCB0byBiZSBzdXBwb3J0ZWQgYXMgZXhwbGljaXRseSBkZWZpbmVkXG4gIC8vIHN5bWJvbHMgaW4gc3ltYm9scy5qc1xuICBuYW1lOiAnY3lyaWxsaWMnLFxuICBibG9ja3M6IFtbMHgwNDAwLCAweDA0ZmZdXVxufSwge1xuICAvLyBBcm1lbmlhblxuICBuYW1lOiAnYXJtZW5pYW4nLFxuICBibG9ja3M6IFtbMHgwNTMwLCAweDA1OEZdXVxufSwge1xuICAvLyBUaGUgQnJhaG1pYyBzY3JpcHRzIG9mIFNvdXRoIGFuZCBTb3V0aGVhc3QgQXNpYVxuICAvLyBEZXZhbmFnYXJpICgwOTAw4oCTMDk3RilcbiAgLy8gQmVuZ2FsaSAoMDk4MOKAkzA5RkYpXG4gIC8vIEd1cm11a2hpICgwQTAw4oCTMEE3RilcbiAgLy8gR3VqYXJhdGkgKDBBODDigJMwQUZGKVxuICAvLyBPcml5YSAoMEIwMOKAkzBCN0YpXG4gIC8vIFRhbWlsICgwQjgw4oCTMEJGRilcbiAgLy8gVGVsdWd1ICgwQzAw4oCTMEM3RilcbiAgLy8gS2FubmFkYSAoMEM4MOKAkzBDRkYpXG4gIC8vIE1hbGF5YWxhbSAoMEQwMOKAkzBEN0YpXG4gIC8vIFNpbmhhbGEgKDBEODDigJMwREZGKVxuICAvLyBUaGFpICgwRTAw4oCTMEU3RilcbiAgLy8gTGFvICgwRTgw4oCTMEVGRilcbiAgLy8gVGliZXRhbiAoMEYwMOKAkzBGRkYpXG4gIC8vIE15YW5tYXIgKDEwMDDigJMxMDlGKVxuICBuYW1lOiAnYnJhaG1pYycsXG4gIGJsb2NrczogW1sweDA5MDAsIDB4MTA5Rl1dXG59LCB7XG4gIG5hbWU6ICdnZW9yZ2lhbicsXG4gIGJsb2NrczogW1sweDEwQTAsIDB4MTBmZl1dXG59LCB7XG4gIC8vIENoaW5lc2UgYW5kIEphcGFuZXNlLlxuICAvLyBUaGUgXCJrXCIgaW4gY2prIGlzIGZvciBLb3JlYW4sIGJ1dCB3ZSd2ZSBzZXBhcmF0ZWQgS29yZWFuIG91dFxuICBuYW1lOiBcImNqa1wiLFxuICBibG9ja3M6IFtbMHgzMDAwLCAweDMwRkZdLCAvLyBDSksgc3ltYm9scyBhbmQgcHVuY3R1YXRpb24sIEhpcmFnYW5hLCBLYXRha2FuYVxuICBbMHg0RTAwLCAweDlGQUZdLCAvLyBDSksgaWRlb2dyYW1zXG4gIFsweEZGMDAsIDB4RkY2MF0gLy8gRnVsbHdpZHRoIHB1bmN0dWF0aW9uXG4gIC8vIFRPRE86IGFkZCBoYWxmd2lkdGggS2F0YWthbmEgYW5kIFJvbWFuamkgZ2x5cGhzXG4gIF1cbn0sIHtcbiAgLy8gS29yZWFuXG4gIG5hbWU6ICdoYW5ndWwnLFxuICBibG9ja3M6IFtbMHhBQzAwLCAweEQ3QUZdXVxufV07XG4vKipcbiAqIEdpdmVuIGEgY29kZXBvaW50LCByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIHNjcmlwdCBvciBzY3JpcHQgZmFtaWx5XG4gKiBpdCBpcyBmcm9tLCBvciBudWxsIGlmIGl0IGlzIG5vdCBwYXJ0IG9mIGEga25vd24gYmxvY2tcbiAqL1xuXG5mdW5jdGlvbiBzY3JpcHRGcm9tQ29kZXBvaW50KGNvZGVwb2ludCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNjcmlwdERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzY3JpcHQgPSBzY3JpcHREYXRhW2ldO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY3JpcHQuYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBibG9jayA9IHNjcmlwdC5ibG9ja3NbaV07XG5cbiAgICAgIGlmIChjb2RlcG9pbnQgPj0gYmxvY2tbMF0gJiYgY29kZXBvaW50IDw9IGJsb2NrWzFdKSB7XG4gICAgICAgIHJldHVybiBzY3JpcHQubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbGwgdGhlIHN1cHBvcnRlZCBibG9ja3MgaW4gYSBzaW5nbGUgYXJyYXkuXG4gKiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiB0byBtYWtlIHN1cHBvcnRlZENvZGVwb2ludCgpIGZhc3QuXG4gKi9cblxuY29uc3QgYWxsQmxvY2tzID0gW107XG5zY3JpcHREYXRhLmZvckVhY2gocyA9PiBzLmJsb2Nrcy5mb3JFYWNoKGIgPT4gYWxsQmxvY2tzLnB1c2goLi4uYikpKTtcbi8qKlxuICogR2l2ZW4gYSBjb2RlcG9pbnQsIHJldHVybiB0cnVlIGlmIGl0IGZhbGxzIHdpdGhpbiBvbmUgb2YgdGhlXG4gKiBzY3JpcHRzIG9yIHNjcmlwdCBmYW1pbGllcyBkZWZpbmVkIGFib3ZlIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogTWljcm8gYmVuY2htYXJrcyBzaG93cyB0aGF0IHRoaXMgaXMgZmFzdGVyIHRoYW5cbiAqIC9bXFx1MzAwMC1cXHUzMEZGXFx1NEUwMC1cXHU5RkFGXFx1RkYwMC1cXHVGRjYwXFx1QUMwMC1cXHVEN0FGXFx1MDkwMC1cXHUxMDlGXS8udGVzdCgpXG4gKiBpbiBGaXJlZm94LCBDaHJvbWUgYW5kIE5vZGUuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydGVkQ29kZXBvaW50KGNvZGVwb2ludCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEJsb2Nrcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChjb2RlcG9pbnQgPj0gYWxsQmxvY2tzW2ldICYmIGNvZGVwb2ludCA8PSBhbGxCbG9ja3NbaSArIDFdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3ZnR2VvbWV0cnkuanNcbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgdG8gZG9tVHJlZS5qcyBhbmQgZGVsaW1pdGVyLmpzLlxuICogSXQncyBhIHN0b3JlaG91c2Ugb2YgcGF0aCBnZW9tZXRyeSBmb3IgU1ZHIGltYWdlcy5cbiAqL1xuLy8gSW4gYWxsIHBhdGhzIGJlbG93LCB0aGUgdmlld0JveC10by1lbSBzY2FsZSBpcyAxMDAwOjEuXG5jb25zdCBoTGluZVBhZCA9IDgwOyAvLyBwYWRkaW5nIGFib3ZlIGEgc3FydCB2aW5jdWx1bS4gUHJldmVudHMgaW1hZ2UgY3JvcHBpbmcuXG4vLyBUaGUgdmluY3VsdW0gb2YgYSBcXHNxcnQgY2FuIGJlIG1hZGUgdGhpY2tlciBieSBhIEthVGVYIHJlbmRlcmluZyBvcHRpb24uXG4vLyBUaGluayBvZiB2YXJpYWJsZSBleHRyYVZpbmN1bHVtIGFzIHR3byBkZXRvdXJzIGluIHRoZSBTVkcgcGF0aC5cbi8vIFRoZSBkZXRvdXIgYmVnaW5zIGF0IHRoZSBsb3dlciBsZWZ0IG9mIHRoZSBhcmVhIGxhYmVsZWQgZXh0cmFWaW5jdWx1bSBiZWxvdy5cbi8vIFRoZSBkZXRvdXIgcHJvY2VlZHMgb25lIGV4dHJhVmluY3VsdW0gZGlzdGFuY2UgdXAgYW5kIHNsaWdodGx5IHRvIHRoZSByaWdodCxcbi8vIGRpc3BsYWNpbmcgdGhlIHJhZGl1c2VkIGNvcm5lciBiZXR3ZWVuIHN1cmQgYW5kIHZpbmN1bHVtLiBUaGUgcmFkaXVzIGlzXG4vLyB0cmF2ZXJzZWQgYXMgdXN1YWwsIHRoZW4gdGhlIGRldG91ciByZXN1bWVzLiBJdCBnb2VzIHJpZ2h0LCB0byB0aGUgZW5kIG9mXG4vLyB0aGUgdmVyeSBsb25nIHZpbmN1bHVtLCB0aGVuIGRvd24gb25lIGV4dHJhVmluY3VsdW0gZGlzdGFuY2UsXG4vLyBhZnRlciB3aGljaCBpdCByZXN1bWVzIHJlZ3VsYXIgcGF0aCBnZW9tZXRyeSBmb3IgdGhlIHJhZGljYWwuXG5cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aW5jdWx1bVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgL1xuICAgICAgICAgL+KWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKGkGV4dHJhVmluY3VsdW1cbiAgICAgICAgLyDilojilojilojilojilojilojilojilojilojilojilojilojilojilojilojilojilojilojilojilojilojihpAwLjA0ZW0gKDQwIHVuaXQpIHN0ZCB2aW5jdWx1bSB0aGlja25lc3NcbiAgICAgICAvIC9cbiAgICAgIC8gL1xuICAgICAvIC9cXFxuICAgIC8gLyBzdXJkXG4qL1xuXG5jb25zdCBzcXJ0TWFpbiA9IGZ1bmN0aW9uIChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzcXJ0TWFpbiBwYXRoIGdlb21ldHJ5IGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVggTWFpblxuICByZXR1cm4gXCJNOTUsXCIgKyAoNjIyICsgZXh0cmFWaW5jdWx1bSArIGhMaW5lUGFkKSArIFwiXFxuYy0yLjcsMCwtNy4xNywtMi43LC0xMy41LC04Yy01LjgsLTUuMywtOS41LC0xMCwtOS41LC0xNFxcbmMwLC0yLDAuMywtMy4zLDEsLTRjMS4zLC0yLjcsMjMuODMsLTIwLjcsNjcuNSwtNTRcXG5jNDQuMiwtMzMuMyw2NS44LC01MC4zLDY2LjUsLTUxYzEuMywtMS4zLDMsLTIsNSwtMmM0LjcsMCw4LjcsMy4zLDEyLDEwXFxuczE3MywzNzgsMTczLDM3OGMwLjcsMCwzNS4zLC03MSwxMDQsLTIxM2M2OC43LC0xNDIsMTM3LjUsLTI4NSwyMDYuNSwtNDI5XFxuYzY5LC0xNDQsMTA0LjUsLTIxNy43LDEwNi41LC0yMjFcXG5sXCIgKyBleHRyYVZpbmN1bHVtIC8gMi4wNzUgKyBcIiAtXCIgKyBleHRyYVZpbmN1bHVtICsgXCJcXG5jNS4zLC05LjMsMTIsLTE0LDIwLC0xNFxcbkg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiSDg0NS4yNzI0XFxucy0yMjUuMjcyLDQ2NywtMjI1LjI3Miw0NjdzLTIzNSw0ODYsLTIzNSw0ODZjLTIuNyw0LjcsLTksNywtMTksN1xcbmMtNiwwLC0xMCwtMSwtMTIsLTNzLTE5NCwtNDIyLC0xOTQsLTQyMnMtNjUsNDcsLTY1LDQ3elxcbk1cIiArICg4MzQgKyBleHRyYVZpbmN1bHVtKSArIFwiIFwiICsgaExpbmVQYWQgKyBcImg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiaC00MDAwMDB6XCI7XG59O1xuXG5jb25zdCBzcXJ0U2l6ZTEgPSBmdW5jdGlvbiAoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpIHtcbiAgLy8gc2l6ZTEgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWF9TaXplMS1SZWd1bGFyXG4gIHJldHVybiBcIk0yNjMsXCIgKyAoNjAxICsgZXh0cmFWaW5jdWx1bSArIGhMaW5lUGFkKSArIFwiYzAuNywwLDE4LDM5LjcsNTIsMTE5XFxuYzM0LDc5LjMsNjguMTY3LDE1OC43LDEwMi41LDIzOGMzNC4zLDc5LjMsNTEuOCwxMTkuMyw1Mi41LDEyMFxcbmMzNDAsLTcwNC43LDUxMC43LC0xMDYwLjMsNTEyLC0xMDY3XFxubFwiICsgZXh0cmFWaW5jdWx1bSAvIDIuMDg0ICsgXCIgLVwiICsgZXh0cmFWaW5jdWx1bSArIFwiXFxuYzQuNywtNy4zLDExLC0xMSwxOSwtMTFcXG5INDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiSDEwMTIuM1xcbnMtMjcxLjMsNTY3LC0yNzEuMyw1NjdjLTM4LjcsODAuNywtODQsMTc1LC0xMzYsMjgzYy01MiwxMDgsLTg5LjE2NywxODUuMywtMTExLjUsMjMyXFxuYy0yMi4zLDQ2LjcsLTMzLjgsNzAuMywtMzQuNSw3MWMtNC43LDQuNywtMTIuMyw3LC0yMyw3cy0xMiwtMSwtMTIsLTFcXG5zLTEwOSwtMjUzLC0xMDksLTI1M2MtNzIuNywtMTY4LC0xMDkuMywtMjUyLC0xMTAsLTI1MmMtMTAuNyw4LC0yMiwxNi43LC0zNCwyNlxcbmMtMjIsMTcuMywtMzMuMywyNiwtMzQsMjZzLTI2LC0yNiwtMjYsLTI2czc2LC01OSw3NiwtNTlzNzYsLTYwLDc2LC02MHpcXG5NXCIgKyAoMTAwMSArIGV4dHJhVmluY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbmNvbnN0IHNxcnRTaXplMiA9IGZ1bmN0aW9uIChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzaXplMiBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYX1NpemUyLVJlZ3VsYXJcbiAgcmV0dXJuIFwiTTk4MyBcIiArICgxMCArIGV4dHJhVmluY3VsdW0gKyBoTGluZVBhZCkgKyBcIlxcbmxcIiArIGV4dHJhVmluY3VsdW0gLyAzLjEzICsgXCIgLVwiICsgZXh0cmFWaW5jdWx1bSArIFwiXFxuYzQsLTYuNywxMCwtMTAsMTgsLTEwIEg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiXFxuSDEwMTMuMXMtODMuNCwyNjgsLTI2NC4xLDg0MGMtMTgwLjcsNTcyLC0yNzcsODc2LjMsLTI4OSw5MTNjLTQuNyw0LjcsLTEyLjcsNywtMjQsN1xcbnMtMTIsMCwtMTIsMGMtMS4zLC0zLjMsLTMuNywtMTEuNywtNywtMjVjLTM1LjMsLTEyNS4zLC0xMDYuNywtMzczLjMsLTIxNCwtNzQ0XFxuYy0xMCwxMiwtMjEsMjUsLTMzLDM5cy0zMiwzOSwtMzIsMzljLTYsLTUuMywtMTUsLTE0LC0yNywtMjZzMjUsLTMwLDI1LC0zMFxcbmMyNi43LC0zMi43LDUyLC02Myw3NiwtOTFzNTIsLTYwLDUyLC02MHMyMDgsNzIyLDIwOCw3MjJcXG5jNTYsLTE3NS4zLDEyNi4zLC0zOTcuMywyMTEsLTY2NmM4NC43LC0yNjguNywxNTMuOCwtNDg4LjIsMjA3LjUsLTY1OC41XFxuYzUzLjcsLTE3MC4zLDg0LjUsLTI2Ni44LDkyLjUsLTI4OS41elxcbk1cIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJoNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcImgtNDAwMDAwelwiO1xufTtcblxuY29uc3Qgc3FydFNpemUzID0gZnVuY3Rpb24gKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKSB7XG4gIC8vIHNpemUzIGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTMtUmVndWxhclxuICByZXR1cm4gXCJNNDI0LFwiICsgKDIzOTggKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQpICsgXCJcXG5jLTEuMywtMC43LC0zOC41LC0xNzIsLTExMS41LC01MTRjLTczLC0zNDIsLTEwOS44LC01MTMuMywtMTEwLjUsLTUxNFxcbmMwLC0yLC0xMC43LDE0LjMsLTMyLDQ5Yy00LjcsNy4zLC05LjgsMTUuNywtMTUuNSwyNWMtNS43LDkuMywtOS44LDE2LC0xMi41LDIwXFxucy01LDcsLTUsN2MtNCwtMy4zLC04LjMsLTcuNywtMTMsLTEzcy0xMywtMTMsLTEzLC0xM3M3NiwtMTIyLDc2LC0xMjJzNzcsLTEyMSw3NywtMTIxXFxuczIwOSw5NjgsMjA5LDk2OGMwLC0yLDg0LjcsLTM2MS43LDI1NCwtMTA3OWMxNjkuMywtNzE3LjMsMjU0LjcsLTEwNzcuNywyNTYsLTEwODFcXG5sXCIgKyBleHRyYVZpbmN1bHVtIC8gNC4yMjMgKyBcIiAtXCIgKyBleHRyYVZpbmN1bHVtICsgXCJjNCwtNi43LDEwLC0xMCwxOCwtMTAgSDQwMDAwMFxcbnZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJIMTAxNC42XFxucy04Ny4zLDM3OC43LC0yNzIuNiwxMTY2Yy0xODUuMyw3ODcuMywtMjc5LjMsMTE4Mi4zLC0yODIsMTE4NVxcbmMtMiw2LC0xMCw5LC0yNCw5XFxuYy04LDAsLTEyLC0wLjcsLTEyLC0yeiBNXCIgKyAoMTAwMSArIGV4dHJhVmluY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiXFxuaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbmNvbnN0IHNxcnRTaXplNCA9IGZ1bmN0aW9uIChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzaXplNCBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgcmV0dXJuIFwiTTQ3MyxcIiArICgyNzEzICsgZXh0cmFWaW5jdWx1bSArIGhMaW5lUGFkKSArIFwiXFxuYzMzOS4zLC0xNzk5LjMsNTA5LjMsLTI3MDAsNTEwLC0yNzAyIGxcIiArIGV4dHJhVmluY3VsdW0gLyA1LjI5OCArIFwiIC1cIiArIGV4dHJhVmluY3VsdW0gKyBcIlxcbmMzLjMsLTcuMyw5LjMsLTExLDE4LC0xMSBINDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcIkgxMDE3LjdcXG5zLTkwLjUsNDc4LC0yNzYuMiwxNDY2Yy0xODUuNyw5ODgsLTI3OS41LDE0ODMsLTI4MS41LDE0ODVjLTIsNiwtMTAsOSwtMjQsOVxcbmMtOCwwLC0xMiwtMC43LC0xMiwtMmMwLC0xLjMsLTUuMywtMzIsLTE2LC05MmMtNTAuNywtMjkzLjMsLTExOS43LC02OTMuMywtMjA3LC0xMjAwXFxuYzAsLTEuMywtNS4zLDguNywtMTYsMzBjLTEwLjcsMjEuMywtMjEuMyw0Mi43LC0zMiw2NHMtMTYsMzMsLTE2LDMzcy0yNiwtMjYsLTI2LC0yNlxcbnM3NiwtMTUzLDc2LC0xNTNzNzcsLTE1MSw3NywtMTUxYzAuNywwLjcsMzUuNywyMDIsMTA1LDYwNGM2Ny4zLDQwMC43LDEwMiw2MDIuNywxMDQsXFxuNjA2ek1cIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJoNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcIkgxMDE3Ljd6XCI7XG59O1xuXG5jb25zdCBwaGFzZVBhdGggPSBmdW5jdGlvbiAoeSkge1xuICBjb25zdCB4ID0geSAvIDI7IC8vIHggY29vcmRpbmF0ZSBhdCB0b3Agb2YgYW5nbGVcblxuICByZXR1cm4gXCJNNDAwMDAwIFwiICsgeSArIFwiIEgwIExcIiArIHggKyBcIiAwIGw2NSA0NSBMMTQ1IFwiICsgKHkgLSA4MCkgKyBcIiBINDAwMDAwelwiO1xufTtcblxuY29uc3Qgc3FydFRhbGwgPSBmdW5jdGlvbiAoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQsIHZpZXdCb3hIZWlnaHQpIHtcbiAgLy8gc3FydFRhbGwgaXMgZnJvbSBnbHlwaCBVMjNCNyBpbiB0aGUgZm9udCBLYVRlWF9TaXplNC1SZWd1bGFyXG4gIC8vIE9uZSBwYXRoIGVkZ2UgaGFzIGEgdmFyaWFibGUgbGVuZ3RoLiBJdCBydW5zIHZlcnRpY2FsbHkgZnJvbSB0aGUgdmluY3VsdW1cbiAgLy8gdG8gYSBwb2ludCBuZWFyICgxNCB1bml0cykgdGhlIGJvdHRvbSBvZiB0aGUgc3VyZC4gVGhlIHZpbmN1bHVtXG4gIC8vIGlzIG5vcm1hbGx5IDQwIHVuaXRzIHRoaWNrLiBTbyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIGluIHF1ZXN0aW9uIGlzOlxuICBjb25zdCB2ZXJ0U2VnbWVudCA9IHZpZXdCb3hIZWlnaHQgLSA1NCAtIGhMaW5lUGFkIC0gZXh0cmFWaW5jdWx1bTtcbiAgcmV0dXJuIFwiTTcwMiBcIiArIChleHRyYVZpbmN1bHVtICsgaExpbmVQYWQpICsgXCJINDAwMDAwXCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiXFxuSDc0MnZcIiArIHZlcnRTZWdtZW50ICsgXCJsLTQgNC00IDRjLS42NjcuNyAtMiAxLjUtNCAyLjVzLTQuMTY3IDEuODMzLTYuNSAyLjUtNS41IDEtOS41IDFcXG5oLTEybC0yOC04NGMtMTYuNjY3LTUyLTk2LjY2NyAtMjk0LjMzMy0yNDAtNzI3bC0yMTIgLTY0MyAtODUgMTcwXFxuYy00LTMuMzMzLTguMzMzLTcuNjY3LTEzIC0xM2wtMTMtMTNsNzctMTU1IDc3LTE1NmM2NiAxOTkuMzMzIDEzOSA0MTkuNjY3XFxuMjE5IDY2MSBsMjE4IDY2MXpNNzAyIFwiICsgaExpbmVQYWQgKyBcIkg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiSDc0MnpcIjtcbn07XG5cbmNvbnN0IHNxcnRQYXRoID0gZnVuY3Rpb24gKHNpemUsIGV4dHJhVmluY3VsdW0sIHZpZXdCb3hIZWlnaHQpIHtcbiAgZXh0cmFWaW5jdWx1bSA9IDEwMDAgKiBleHRyYVZpbmN1bHVtOyAvLyBDb252ZXJ0IGZyb20gZG9jdW1lbnQgZW1zIHRvIHZpZXdCb3guXG5cbiAgbGV0IHBhdGggPSBcIlwiO1xuXG4gIHN3aXRjaCAoc2l6ZSkge1xuICAgIGNhc2UgXCJzcXJ0TWFpblwiOlxuICAgICAgcGF0aCA9IHNxcnRNYWluKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRTaXplMVwiOlxuICAgICAgcGF0aCA9IHNxcnRTaXplMShleHRyYVZpbmN1bHVtLCBoTGluZVBhZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXJ0U2l6ZTJcIjpcbiAgICAgIHBhdGggPSBzcXJ0U2l6ZTIoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3FydFNpemUzXCI6XG4gICAgICBwYXRoID0gc3FydFNpemUzKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRTaXplNFwiOlxuICAgICAgcGF0aCA9IHNxcnRTaXplNChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXJ0VGFsbFwiOlxuICAgICAgcGF0aCA9IHNxcnRUYWxsKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkLCB2aWV3Qm94SGVpZ2h0KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufTtcbmNvbnN0IGlubmVyUGF0aCA9IGZ1bmN0aW9uIChuYW1lLCBoZWlnaHQpIHtcbiAgLy8gVGhlIGlubmVyIHBhcnQgb2Ygc3RyZXRjaHkgdGFsbCBkZWxpbWl0ZXJzXG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgXCJcXHUyMzljXCI6XG4gICAgICByZXR1cm4gXCJNMjkxIDAgSDQxNyBWXCIgKyBoZWlnaHQgKyBcIiBIMjkxeiBNMjkxIDAgSDQxNyBWXCIgKyBoZWlnaHQgKyBcIiBIMjkxelwiO1xuXG4gICAgY2FzZSBcIlxcdTIyMjNcIjpcbiAgICAgIHJldHVybiBcIk0xNDUgMCBIMTg4IFZcIiArIGhlaWdodCArIFwiIEgxNDV6IE0xNDUgMCBIMTg4IFZcIiArIGhlaWdodCArIFwiIEgxNDV6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjIyNVwiOlxuICAgICAgcmV0dXJuIFwiTTE0NSAwIEgxODggVlwiICsgaGVpZ2h0ICsgXCIgSDE0NXogTTE0NSAwIEgxODggVlwiICsgaGVpZ2h0ICsgXCIgSDE0NXpcIiArIChcIk0zNjcgMCBINDEwIFZcIiArIGhlaWdodCArIFwiIEgzNjd6IE0zNjcgMCBINDEwIFZcIiArIGhlaWdodCArIFwiIEgzNjd6XCIpO1xuXG4gICAgY2FzZSBcIlxcdTIzOWZcIjpcbiAgICAgIHJldHVybiBcIk00NTcgMCBINTgzIFZcIiArIGhlaWdodCArIFwiIEg0NTd6IE00NTcgMCBINTgzIFZcIiArIGhlaWdodCArIFwiIEg0NTd6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjNhMlwiOlxuICAgICAgcmV0dXJuIFwiTTMxOSAwIEg0MDMgVlwiICsgaGVpZ2h0ICsgXCIgSDMxOXogTTMxOSAwIEg0MDMgVlwiICsgaGVpZ2h0ICsgXCIgSDMxOXpcIjtcblxuICAgIGNhc2UgXCJcXHUyM2E1XCI6XG4gICAgICByZXR1cm4gXCJNMjYzIDAgSDM0NyBWXCIgKyBoZWlnaHQgKyBcIiBIMjYzeiBNMjYzIDAgSDM0NyBWXCIgKyBoZWlnaHQgKyBcIiBIMjYzelwiO1xuXG4gICAgY2FzZSBcIlxcdTIzYWFcIjpcbiAgICAgIHJldHVybiBcIk0zODQgMCBINTA0IFZcIiArIGhlaWdodCArIFwiIEgzODR6IE0zODQgMCBINTA0IFZcIiArIGhlaWdodCArIFwiIEgzODR6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjNkMFwiOlxuICAgICAgcmV0dXJuIFwiTTMxMiAwIEgzNTUgVlwiICsgaGVpZ2h0ICsgXCIgSDMxMnogTTMxMiAwIEgzNTUgVlwiICsgaGVpZ2h0ICsgXCIgSDMxMnpcIjtcblxuICAgIGNhc2UgXCJcXHUyMDE2XCI6XG4gICAgICByZXR1cm4gXCJNMjU3IDAgSDMwMCBWXCIgKyBoZWlnaHQgKyBcIiBIMjU3eiBNMjU3IDAgSDMwMCBWXCIgKyBoZWlnaHQgKyBcIiBIMjU3elwiICsgKFwiTTQ3OCAwIEg1MjEgVlwiICsgaGVpZ2h0ICsgXCIgSDQ3OHogTTQ3OCAwIEg1MjEgVlwiICsgaGVpZ2h0ICsgXCIgSDQ3OHpcIik7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH1cbn07XG5jb25zdCBwYXRoID0ge1xuICAvLyBUaGUgZG91YmxlbGVmdGFycm93IGdlb21ldHJ5IGlzIGZyb20gZ2x5cGggVSsyMUQwIGluIHRoZSBmb250IEthVGVYIE1haW5cbiAgZG91YmxlbGVmdGFycm93OiBcIk0yNjIgMTU3XFxubDEwLTEwYzM0LTM2IDYyLjctNzcgODYtMTIzIDMuMy04IDUtMTMuMyA1LTE2IDAtNS4zLTYuNy04LTIwLTgtNy4zXFxuIDAtMTIuMi41LTE0LjUgMS41LTIuMyAxLTQuOCA0LjUtNy41IDEwLjUtNDkuMyA5Ny4zLTEyMS43IDE2OS4zLTIxNyAyMTYtMjhcXG4gMTQtNTcuMyAyNS04OCAzMy02LjcgMi0xMSAzLjgtMTMgNS41LTIgMS43LTMgNC4yLTMgNy41czEgNS44IDMgNy41XFxuYzIgMS43IDYuMyAzLjUgMTMgNS41IDY4IDE3LjMgMTI4LjIgNDcuOCAxODAuNSA5MS41IDUyLjMgNDMuNyA5My44IDk2LjIgMTI0LjVcXG4gMTU3LjUgOS4zIDggMTUuMyAxMi4zIDE4IDEzaDZjMTItLjcgMTgtNCAxOC0xMCAwLTItMS43LTctNS0xNS0yMy4zLTQ2LTUyLTg3XFxuLTg2LTEyM2wtMTAtMTBoMzk5NzM4di00MEgyMThjMzI4IDAgMCAwIDAgMGwtMTAtOGMtMjYuNy0yMC02NS43LTQzLTExNy02OSAyLjdcXG4tMiA2LTMuNyAxMC01IDM2LjctMTYgNzIuMy0zNy4zIDEwNy02NGwxMC04aDM5OTc4MnYtNDB6XFxubTggMHY0MGgzOTk3MzB2LTQwem0wIDE5NHY0MGgzOTk3MzB2LTQwelwiLFxuICAvLyBkb3VibGVyaWdodGFycm93IGlzIGZyb20gZ2x5cGggVSsyMUQyIGluIGZvbnQgS2FUZVggTWFpblxuICBkb3VibGVyaWdodGFycm93OiBcIk0zOTk3MzggMzkybFxcbi0xMCAxMGMtMzQgMzYtNjIuNyA3Ny04NiAxMjMtMy4zIDgtNSAxMy4zLTUgMTYgMCA1LjMgNi43IDggMjAgOCA3LjMgMCAxMi4yLS41XFxuIDE0LjUtMS41IDIuMy0xIDQuOC00LjUgNy41LTEwLjUgNDkuMy05Ny4zIDEyMS43LTE2OS4zIDIxNy0yMTYgMjgtMTQgNTcuMy0yNSA4OFxcbi0zMyA2LjctMiAxMS0zLjggMTMtNS41IDItMS43IDMtNC4yIDMtNy41cy0xLTUuOC0zLTcuNWMtMi0xLjctNi4zLTMuNS0xMy01LjUtNjhcXG4tMTcuMy0xMjguMi00Ny44LTE4MC41LTkxLjUtNTIuMy00My43LTkzLjgtOTYuMi0xMjQuNS0xNTcuNS05LjMtOC0xNS4zLTEyLjMtMThcXG4tMTNoLTZjLTEyIC43LTE4IDQtMTggMTAgMCAyIDEuNyA3IDUgMTUgMjMuMyA0NiA1MiA4NyA4NiAxMjNsMTAgMTBIMHY0MGgzOTk3ODJcXG5jLTMyOCAwIDAgMCAwIDBsMTAgOGMyNi43IDIwIDY1LjcgNDMgMTE3IDY5LTIuNyAyLTYgMy43LTEwIDUtMzYuNyAxNi03Mi4zIDM3LjNcXG4tMTA3IDY0bC0xMCA4SDB2NDB6TTAgMTU3djQwaDM5OTczMHYtNDB6bTAgMTk0djQwaDM5OTczMHYtNDB6XCIsXG4gIC8vIGxlZnRhcnJvdyBpcyBmcm9tIGdseXBoIFUrMjE5MCBpbiBmb250IEthVGVYIE1haW5cbiAgbGVmdGFycm93OiBcIk00MDAwMDAgMjQxSDExMGwzLTNjNjguNy01Mi43IDExMy43LTEyMFxcbiAxMzUtMjAyIDQtMTQuNyA2LTIzIDYtMjUgMC03LjMtNy0xMS0yMS0xMS04IDAtMTMuMi44LTE1LjUgMi41LTIuMyAxLjctNC4yIDUuOFxcbi01LjUgMTIuNS0xLjMgNC43LTIuNyAxMC4zLTQgMTctMTIgNDguNy0zNC44IDkyLTY4LjUgMTMwUzY1LjMgMjI4LjMgMTggMjQ3XFxuYy0xMCA0LTE2IDcuNy0xOCAxMSAwIDguNyA2IDE0LjMgMTggMTcgNDcuMyAxOC43IDg3LjggNDcgMTIxLjUgODVTMTk2IDQ0MS4zIDIwOFxcbiA0OTBjLjcgMiAxLjMgNSAyIDlzMS4yIDYuNyAxLjUgOGMuMyAxLjMgMSAzLjMgMiA2czIuMiA0LjUgMy41IDUuNWMxLjMgMSAzLjNcXG4gMS44IDYgMi41czYgMSAxMCAxYzE0IDAgMjEtMy43IDIxLTExIDAtMi0yLTEwLjMtNi0yNS0yMC03OS4zLTY1LTE0Ni43LTEzNS0yMDJcXG4gbC0zLTNoMzk5ODkwek0xMDAgMjQxdjQwaDM5OTkwMHYtNDB6XCIsXG4gIC8vIG92ZXJicmFjZSBpcyBmcm9tIGdseXBocyBVKzIzQTkvMjNBOC8yM0E3IGluIGZvbnQgS2FUZVhfU2l6ZTQtUmVndWxhclxuICBsZWZ0YnJhY2U6IFwiTTYgNTQ4bC02LTZ2LTM1bDYtMTFjNTYtMTA0IDEzNS4zLTE4MS4zIDIzOC0yMzIgNTcuMy0yOC43IDExN1xcbi00NSAxNzktNTBoMzk5NTc3djEyMEg0MDNjLTQzLjMgNy04MSAxNS0xMTMgMjYtMTAwLjcgMzMtMTc5LjcgOTEtMjM3IDE3NC0yLjdcXG4gNS02IDktMTAgMTMtLjcgMS03LjMgMS0yMCAxSDZ6XCIsXG4gIGxlZnRicmFjZXVuZGVyOiBcIk0wIDZsNi02aDE3YzEyLjY4OCAwIDE5LjMxMy4zIDIwIDEgNCA0IDcuMzEzIDguMyAxMCAxM1xcbiAzNS4zMTMgNTEuMyA4MC44MTMgOTMuOCAxMzYuNSAxMjcuNSA1NS42ODggMzMuNyAxMTcuMTg4IDU1LjggMTg0LjUgNjYuNS42ODhcXG4gMCAyIC4zIDQgMSAxOC42ODggMi43IDc2IDQuMyAxNzIgNWgzOTk0NTB2MTIwSDQyOWwtNi0xYy0xMjQuNjg4LTgtMjM1LTYxLjdcXG4tMzMxLTE2MUM2MC42ODcgMTM4LjcgMzIuMzEyIDk5LjMgNyA1NEwwIDQxVjZ6XCIsXG4gIC8vIG92ZXJncm91cCBpcyBmcm9tIHRoZSBNblN5bWJvbCBwYWNrYWdlIChwdWJsaWMgZG9tYWluKVxuICBsZWZ0Z3JvdXA6IFwiTTQwMDAwMCA4MFxcbkg0MzVDNjQgODAgMTY4LjMgMjI5LjQgMjEgMjYwYy01LjkgMS4yLTE4IDAtMTggMC0yIDAtMy0xLTMtM3YtMzhDNzYgNjEgMjU3IDBcXG4gNDM1IDBoMzk5NTY1elwiLFxuICBsZWZ0Z3JvdXB1bmRlcjogXCJNNDAwMDAwIDI2Mlxcbkg0MzVDNjQgMjYyIDE2OC4zIDExMi42IDIxIDgyYy01LjktMS4yLTE4IDAtMTggMC0yIDAtMyAxLTMgM3YzOGM3NiAxNTggMjU3IDIxOVxcbiA0MzUgMjE5aDM5OTU2NXpcIixcbiAgLy8gSGFycG9vbnMgYXJlIGZyb20gZ2x5cGggVSsyMUJEIGluIGZvbnQgS2FUZVggTWFpblxuICBsZWZ0aGFycG9vbjogXCJNMCAyNjdjLjcgNS4zIDMgMTAgNyAxNGgzOTk5OTN2LTQwSDkzYzMuM1xcbi0zLjMgMTAuMi05LjUgMjAuNS0xOC41czE3LjgtMTUuOCAyMi41LTIwLjVjNTAuNy01MiA4OC0xMTAuMyAxMTItMTc1IDQtMTEuMyA1XFxuLTE4LjMgMy0yMS0xLjMtNC03LjMtNi0xOC02LTggMC0xMyAuNy0xNSAycy00LjcgNi43LTggMTZjLTQyIDk4LjctMTA3LjMgMTc0LjdcXG4tMTk2IDIyOC02LjcgNC43LTEwLjcgOC0xMiAxMC0xLjMgMi0yIDUuNy0yIDExem0xMDAtMjZ2NDBoMzk5OTAwdi00MHpcIixcbiAgbGVmdGhhcnBvb25wbHVzOiBcIk0wIDI2N2MuNyA1LjMgMyAxMCA3IDE0aDM5OTk5M3YtNDBIOTNjMy4zLTMuMyAxMC4yLTkuNVxcbiAyMC41LTE4LjVzMTcuOC0xNS44IDIyLjUtMjAuNWM1MC43LTUyIDg4LTExMC4zIDExMi0xNzUgNC0xMS4zIDUtMTguMyAzLTIxLTEuM1xcbi00LTcuMy02LTE4LTYtOCAwLTEzIC43LTE1IDJzLTQuNyA2LjctOCAxNmMtNDIgOTguNy0xMDcuMyAxNzQuNy0xOTYgMjI4LTYuNyA0LjdcXG4tMTAuNyA4LTEyIDEwLTEuMyAyLTIgNS43LTIgMTF6bTEwMC0yNnY0MGgzOTk5MDB2LTQwek0wIDQzNXY0MGg0MDAwMDB2LTQwelxcbm0wIDB2NDBoNDAwMDAwdi00MHpcIixcbiAgbGVmdGhhcnBvb25kb3duOiBcIk03IDI0MWMtNCA0LTYuMzMzIDguNjY3LTcgMTQgMCA1LjMzMy42NjcgOSAyIDExczUuMzMzXFxuIDUuMzMzIDEyIDEwYzkwLjY2NyA1NCAxNTYgMTMwIDE5NiAyMjggMy4zMzMgMTAuNjY3IDYuMzMzIDE2LjMzMyA5IDE3IDIgLjY2NyA1XFxuIDEgOSAxaDVjMTAuNjY3IDAgMTYuNjY3LTIgMTgtNiAyLTIuNjY3IDEtOS42NjctMy0yMS0zMi04Ny4zMzMtODIuNjY3LTE1Ny42NjdcXG4tMTUyLTIxMWwtMy0zaDM5OTkwN3YtNDB6TTkzIDI4MSBINDAwMDAwIHYtNDBMNyAyNDF6XCIsXG4gIGxlZnRoYXJwb29uZG93bnBsdXM6IFwiTTcgNDM1Yy00IDQtNi4zIDguNy03IDE0IDAgNS4zLjcgOSAyIDExczUuMyA1LjMgMTJcXG4gMTBjOTAuNyA1NCAxNTYgMTMwIDE5NiAyMjggMy4zIDEwLjcgNi4zIDE2LjMgOSAxNyAyIC43IDUgMSA5IDFoNWMxMC43IDAgMTYuN1xcbi0yIDE4LTYgMi0yLjcgMS05LjctMy0yMS0zMi04Ny4zLTgyLjctMTU3LjctMTUyLTIxMWwtMy0zaDM5OTkwN3YtNDBIN3ptOTMgMFxcbnY0MGgzOTk5MDB2LTQwek0wIDI0MXY0MGgzOTk5MDB2LTQwem0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gaG9vayBpcyBmcm9tIGdseXBoIFUrMjFBOSBpbiBmb250IEthVGVYIE1haW5cbiAgbGVmdGhvb2s6IFwiTTQwMDAwMCAyODEgSDEwM3MtMzMtMTEuMi02MS0zMy41UzAgMTk3LjMgMCAxNjRzMTQuMi02MS4yIDQyLjVcXG4tODMuNUM3MC44IDU4LjIgMTA0IDQ3IDE0MiA0NyBjMTYuNyAwIDI1IDYuNyAyNSAyMCAwIDEyLTguNyAxOC43LTI2IDIwLTQwIDMuM1xcbi02OC43IDE1LjctODYgMzctMTAgMTItMTUgMjUuMy0xNSA0MCAwIDIyLjcgOS44IDQwLjcgMjkuNSA1NCAxOS43IDEzLjMgNDMuNSAyMVxcbiA3MS41IDIzaDM5OTg1OXpNMTAzIDI4MXYtNDBoMzk5ODk3djQwelwiLFxuICBsZWZ0bGluZXNlZ21lbnQ6IFwiTTQwIDI4MSBWNDI4IEgwIFY5NCBINDAgVjI0MSBINDAwMDAwIHY0MHpcXG5NNDAgMjgxIFY0MjggSDAgVjk0IEg0MCBWMjQxIEg0MDAwMDAgdjQwelwiLFxuICBsZWZ0bWFwc3RvOiBcIk00MCAyODEgVjQ0OEgwVjc0SDQwVjI0MUg0MDAwMDB2NDB6XFxuTTQwIDI4MSBWNDQ4SDBWNzRINDBWMjQxSDQwMDAwMHY0MHpcIixcbiAgLy8gdG9mcm9tIGlzIGZyb20gZ2x5cGggVSsyMUM0IGluIGZvbnQgS2FUZVggQU1TIFJlZ3VsYXJcbiAgbGVmdFRvRnJvbTogXCJNMCAxNDdoNDAwMDAwdjQwSDB6bTAgMjE0YzY4IDQwIDExNS43IDk1LjcgMTQzIDE2N2gyMmMxNS4zIDAgMjNcXG4tLjMgMjMtMSAwLTEuMy01LjMtMTMuNy0xNi0zNy0xOC0zNS4zLTQxLjMtNjktNzAtMTAxbC03LThoMzk5OTA1di00MEg5NWw3LThcXG5jMjguNy0zMiA1Mi02NS43IDcwLTEwMSAxMC43LTIzLjMgMTYtMzUuNyAxNi0zNyAwLS43LTcuNy0xLTIzLTFoLTIyQzExNS43IDI2NS4zXFxuIDY4IDMyMSAwIDM2MXptMC0xNzR2LTQwaDM5OTkwMHY0MHptMTAwIDE1NHY0MGgzOTk5MDB2LTQwelwiLFxuICBsb25nZXF1YWw6IFwiTTAgNTAgaDQwMDAwMCB2NDBIMHogbTAgMTk0aDQwMDAwdjQwSDB6XFxuTTAgNTAgaDQwMDAwMCB2NDBIMHogbTAgMTk0aDQwMDAwdjQwSDB6XCIsXG4gIG1pZGJyYWNlOiBcIk0yMDA0MjggMzM0XFxuYy0xMDAuNy04LjMtMTk1LjMtNDQtMjgwLTEwOC01NS4zLTQyLTEwMS43LTkzLTEzOS0xNTNsLTktMTRjLTIuNyA0LTUuNyA4LjctOSAxNFxcbi01My4zIDg2LjctMTIzLjcgMTUzLTIxMSAxOTktNjYuNyAzNi0xMzcuMyA1Ni4zLTIxMiA2MkgwVjIxNGgxOTk1NjhjMTc4LjMtMTEuN1xcbiAzMTEuNy03OC4zIDQwMy0yMDEgNi04IDkuNy0xMiAxMS0xMiAuNy0uNyA2LjctMSAxOC0xczE3LjMuMyAxOCAxYzEuMyAwIDUgNCAxMVxcbiAxMiA0NC43IDU5LjMgMTAxLjMgMTA2LjMgMTcwIDE0MXMxNDUuMyA1NC4zIDIyOSA2MGgxOTk1NzJ2MTIwelwiLFxuICBtaWRicmFjZXVuZGVyOiBcIk0xOTk1NzIgMjE0XFxuYzEwMC43IDguMyAxOTUuMyA0NCAyODAgMTA4IDU1LjMgNDIgMTAxLjcgOTMgMTM5IDE1M2w5IDE0YzIuNy00IDUuNy04LjcgOS0xNFxcbiA1My4zLTg2LjcgMTIzLjctMTUzIDIxMS0xOTkgNjYuNy0zNiAxMzcuMy01Ni4zIDIxMi02MmgxOTk1Njh2MTIwSDIwMDQzMmMtMTc4LjNcXG4gMTEuNy0zMTEuNyA3OC4zLTQwMyAyMDEtNiA4LTkuNyAxMi0xMSAxMi0uNy43LTYuNyAxLTE4IDFzLTE3LjMtLjMtMTgtMWMtMS4zIDBcXG4tNS00LTExLTEyLTQ0LjctNTkuMy0xMDEuMy0xMDYuMy0xNzAtMTQxcy0xNDUuMy01NC4zLTIyOS02MEgwVjIxNHpcIixcbiAgb2lpbnRTaXplMTogXCJNNTEyLjYgNzEuNmMyNzIuNiAwIDMyMC4zIDEwNi44IDMyMC4zIDE3OC4yIDAgNzAuOC00Ny43IDE3Ny42XFxuLTMyMC4zIDE3Ny42UzE5My4xIDMyMC42IDE5My4xIDI0OS44YzAtNzEuNCA0Ni45LTE3OC4yIDMxOS41LTE3OC4yelxcbm0zNjguMSAxNzguMmMwLTg2LjQtNjAuOS0yMTUuNC0zNjguMS0yMTUuNC0zMDYuNCAwLTM2Ny4zIDEyOS0zNjcuMyAyMTUuNCAwIDg1LjhcXG42MC45IDIxNC44IDM2Ny4zIDIxNC44IDMwNy4yIDAgMzY4LjEtMTI5IDM2OC4xLTIxNC44elwiLFxuICBvaWludFNpemUyOiBcIk03NTcuOCAxMDAuMWMzODQuNyAwIDQ1MS4xIDEzNy42IDQ1MS4xIDIzMCAwIDkxLjMtNjYuNCAyMjguOFxcbi00NTEuMSAyMjguOC0zODYuMyAwLTQ1Mi43LTEzNy41LTQ1Mi43LTIyOC44IDAtOTIuNCA2Ni40LTIzMCA0NTIuNy0yMzB6XFxubTUwMi40IDIzMGMwLTExMS4yLTgyLjQtMjc3LjItNTAyLjQtMjc3LjJzLTUwNCAxNjYtNTA0IDI3Ny4yXFxuYzAgMTEwIDg0IDI3NiA1MDQgMjc2czUwMi40LTE2NiA1MDIuNC0yNzZ6XCIsXG4gIG9paWludFNpemUxOiBcIk02ODEuNCA3MS42YzQwOC45IDAgNDgwLjUgMTA2LjggNDgwLjUgMTc4LjIgMCA3MC44LTcxLjYgMTc3LjZcXG4tNDgwLjUgMTc3LjZTMjAyLjEgMzIwLjYgMjAyLjEgMjQ5LjhjMC03MS40IDcwLjUtMTc4LjIgNDc5LjMtMTc4LjJ6XFxubTUyNS44IDE3OC4yYzAtODYuNC04Ni44LTIxNS40LTUyNS43LTIxNS40LTQzNy45IDAtNTI0LjcgMTI5LTUyNC43IDIxNS40IDBcXG44NS44IDg2LjggMjE0LjggNTI0LjcgMjE0LjggNDM4LjkgMCA1MjUuNy0xMjkgNTI1LjctMjE0Ljh6XCIsXG4gIG9paWludFNpemUyOiBcIk0xMDIxLjIgNTNjNjAzLjYgMCA3MDcuOCAxNjUuOCA3MDcuOCAyNzcuMiAwIDExMC0xMDQuMiAyNzUuOFxcbi03MDcuOCAyNzUuOC02MDYgMC03MTAuMi0xNjUuOC03MTAuMi0yNzUuOEMzMTEgMjE4LjggNDE1LjIgNTMgMTAyMS4yIDUzelxcbm03NzAuNCAyNzcuMWMwLTEzMS4yLTEyNi40LTMyNy42LTc3MC41LTMyNy42UzI0OC40IDE5OC45IDI0OC40IDMzMC4xXFxuYzAgMTMwIDEyOC44IDMyNi40IDc3Mi43IDMyNi40czc3MC41LTE5Ni40IDc3MC41LTMyNi40elwiLFxuICByaWdodGFycm93OiBcIk0wIDI0MXY0MGgzOTk4OTFjLTQ3LjMgMzUuMy04NCA3OC0xMTAgMTI4XFxuLTE2LjcgMzItMjcuNyA2My43LTMzIDk1IDAgMS4zLS4yIDIuNy0uNSA0LS4zIDEuMy0uNSAyLjMtLjUgMyAwIDcuMyA2LjcgMTEgMjBcXG4gMTEgOCAwIDEzLjItLjggMTUuNS0yLjUgMi4zLTEuNyA0LjItNS41IDUuNS0xMS41IDItMTMuMyA1LjctMjcgMTEtNDEgMTQuNy00NC43XFxuIDM5LTg0LjUgNzMtMTE5LjVzNzMuNy02MC4yIDExOS03NS41YzYtMiA5LTUuNyA5LTExcy0zLTktOS0xMWMtNDUuMy0xNS4zLTg1XFxuLTQwLjUtMTE5LTc1LjVzLTU4LjMtNzQuOC03My0xMTkuNWMtNC43LTE0LTguMy0yNy4zLTExLTQwLTEuMy02LjctMy4yLTEwLjgtNS41XFxuLTEyLjUtMi4zLTEuNy03LjUtMi41LTE1LjUtMi41LTE0IDAtMjEgMy43LTIxIDExIDAgMiAyIDEwLjMgNiAyNSAyMC43IDgzLjMgNjdcXG4gMTUxLjcgMTM5IDIwNXptMCAwdjQwaDM5OTkwMHYtNDB6XCIsXG4gIHJpZ2h0YnJhY2U6IFwiTTQwMDAwMCA1NDJsXFxuLTYgNmgtMTdjLTEyLjcgMC0xOS4zLS4zLTIwLTEtNC00LTcuMy04LjMtMTAtMTMtMzUuMy01MS4zLTgwLjgtOTMuOC0xMzYuNS0xMjcuNVxcbnMtMTE3LjItNTUuOC0xODQuNS02Ni41Yy0uNyAwLTItLjMtNC0xLTE4LjctMi43LTc2LTQuMy0xNzItNUgwVjIxNGgzOTk1NzFsNiAxXFxuYzEyNC43IDggMjM1IDYxLjcgMzMxIDE2MSAzMS4zIDMzLjMgNTkuNyA3Mi43IDg1IDExOGw3IDEzdjM1elwiLFxuICByaWdodGJyYWNldW5kZXI6IFwiTTM5OTk5NCAwbDYgNnYzNWwtNiAxMWMtNTYgMTA0LTEzNS4zIDE4MS4zLTIzOCAyMzItNTcuM1xcbiAyOC43LTExNyA0NS0xNzkgNTBILTMwMFYyMTRoMzk5ODk3YzQzLjMtNyA4MS0xNSAxMTMtMjYgMTAwLjctMzMgMTc5LjctOTEgMjM3XFxuLTE3NCAyLjctNSA2LTkgMTAtMTMgLjctMSA3LjMtMSAyMC0xaDE3elwiLFxuICByaWdodGdyb3VwOiBcIk0wIDgwaDM5OTU2NWMzNzEgMCAyNjYuNyAxNDkuNCA0MTQgMTgwIDUuOSAxLjIgMTggMCAxOCAwIDIgMFxcbiAzLTEgMy0zdi0zOGMtNzYtMTU4LTI1Ny0yMTktNDM1LTIxOUgwelwiLFxuICByaWdodGdyb3VwdW5kZXI6IFwiTTAgMjYyaDM5OTU2NWMzNzEgMCAyNjYuNy0xNDkuNCA0MTQtMTgwIDUuOS0xLjIgMTggMCAxOFxcbiAwIDIgMCAzIDEgMyAzdjM4Yy03NiAxNTgtMjU3IDIxOS00MzUgMjE5SDB6XCIsXG4gIHJpZ2h0aGFycG9vbjogXCJNMCAyNDF2NDBoMzk5OTkzYzQuNy00LjcgNy05LjMgNy0xNCAwLTkuM1xcbi0zLjctMTUuMy0xMS0xOC05Mi43LTU2LjctMTU5LTEzMy43LTE5OS0yMzEtMy4zLTkuMy02LTE0LjctOC0xNi0yLTEuMy03LTItMTUtMlxcbi0xMC43IDAtMTYuNyAyLTE4IDYtMiAyLjctMSA5LjcgMyAyMSAxNS4zIDQyIDM2LjcgODEuOCA2NCAxMTkuNSAyNy4zIDM3LjcgNThcXG4gNjkuMiA5MiA5NC41em0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRoYXJwb29ucGx1czogXCJNMCAyNDF2NDBoMzk5OTkzYzQuNy00LjcgNy05LjMgNy0xNCAwLTkuMy0zLjctMTUuMy0xMVxcbi0xOC05Mi43LTU2LjctMTU5LTEzMy43LTE5OS0yMzEtMy4zLTkuMy02LTE0LjctOC0xNi0yLTEuMy03LTItMTUtMi0xMC43IDAtMTYuN1xcbiAyLTE4IDYtMiAyLjctMSA5LjcgMyAyMSAxNS4zIDQyIDM2LjcgODEuOCA2NCAxMTkuNSAyNy4zIDM3LjcgNTggNjkuMiA5MiA5NC41elxcbm0wIDB2NDBoMzk5OTAwdi00MHogbTEwMCAxOTR2NDBoMzk5OTAwdi00MHptMCAwdjQwaDM5OTkwMHYtNDB6XCIsXG4gIHJpZ2h0aGFycG9vbmRvd246IFwiTTM5OTc0NyA1MTFjMCA3LjMgNi43IDExIDIwIDExIDggMCAxMy0uOCAxNS0yLjVzNC43LTYuOFxcbiA4LTE1LjVjNDAtOTQgOTkuMy0xNjYuMyAxNzgtMjE3IDEzLjMtOCAyMC4zLTEyLjMgMjEtMTMgNS4zLTMuMyA4LjUtNS44IDkuNVxcbi03LjUgMS0xLjcgMS41LTUuMiAxLjUtMTAuNXMtMi4zLTEwLjMtNy0xNUgwdjQwaDM5OTkwOGMtMzQgMjUuMy02NC43IDU3LTkyIDk1XFxuLTI3LjMgMzgtNDguNyA3Ny43LTY0IDExOS0zLjMgOC43LTUgMTQtNSAxNnpNMCAyNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRoYXJwb29uZG93bnBsdXM6IFwiTTM5OTc0NyA3MDVjMCA3LjMgNi43IDExIDIwIDExIDggMCAxMy0uOFxcbiAxNS0yLjVzNC43LTYuOCA4LTE1LjVjNDAtOTQgOTkuMy0xNjYuMyAxNzgtMjE3IDEzLjMtOCAyMC4zLTEyLjMgMjEtMTMgNS4zLTMuM1xcbiA4LjUtNS44IDkuNS03LjUgMS0xLjcgMS41LTUuMiAxLjUtMTAuNXMtMi4zLTEwLjMtNy0xNUgwdjQwaDM5OTkwOGMtMzQgMjUuM1xcbi02NC43IDU3LTkyIDk1LTI3LjMgMzgtNDguNyA3Ny43LTY0IDExOS0zLjMgOC43LTUgMTQtNSAxNnpNMCA0MzV2NDBoMzk5OTAwdi00MHpcXG5tMC0xOTR2NDBoNDAwMDAwdi00MHptMCAwdjQwaDQwMDAwMHYtNDB6XCIsXG4gIHJpZ2h0aG9vazogXCJNMzk5ODU5IDI0MWMtNzY0IDAgMCAwIDAgMCA0MC0zLjMgNjguNy0xNS43IDg2LTM3IDEwLTEyIDE1LTI1LjNcXG4gMTUtNDAgMC0yMi43LTkuOC00MC43LTI5LjUtNTQtMTkuNy0xMy4zLTQzLjUtMjEtNzEuNS0yMy0xNy4zLTEuMy0yNi04LTI2LTIwIDBcXG4tMTMuMyA4LjctMjAgMjYtMjAgMzggMCA3MSAxMS4yIDk5IDMzLjUgMCAwIDcgNS42IDIxIDE2LjcgMTQgMTEuMiAyMSAzMy41IDIxXFxuIDY2LjhzLTE0IDYxLjItNDIgODMuNWMtMjggMjIuMy02MSAzMy41LTk5IDMzLjVMMCAyNDF6IE0wIDI4MXYtNDBoMzk5ODU5djQwelwiLFxuICByaWdodGxpbmVzZWdtZW50OiBcIk0zOTk5NjAgMjQxIFY5NCBoNDAgVjQyOCBoLTQwIFYyODEgSDAgdi00MHpcXG5NMzk5OTYwIDI0MSBWOTQgaDQwIFY0MjggaC00MCBWMjgxIEgwIHYtNDB6XCIsXG4gIHJpZ2h0VG9Gcm9tOiBcIk00MDAwMDAgMTY3Yy03MC43LTQyLTExOC05Ny43LTE0Mi0xNjdoLTIzYy0xNS4zIDAtMjMgLjMtMjNcXG4gMSAwIDEuMyA1LjMgMTMuNyAxNiAzNyAxOCAzNS4zIDQxLjMgNjkgNzAgMTAxbDcgOEgwdjQwaDM5OTkwNWwtNyA4Yy0yOC43IDMyXFxuLTUyIDY1LjctNzAgMTAxLTEwLjcgMjMuMy0xNiAzNS43LTE2IDM3IDAgLjcgNy43IDEgMjMgMWgyM2MyNC02OS4zIDcxLjMtMTI1IDE0Mlxcbi0xNjd6IE0xMDAgMTQ3djQwaDM5OTkwMHYtNDB6TTAgMzQxdjQwaDM5OTkwMHYtNDB6XCIsXG4gIC8vIHR3b2hlYWRsZWZ0YXJyb3cgaXMgZnJvbSBnbHlwaCBVKzIxOUUgaW4gZm9udCBLYVRlWCBBTVMgUmVndWxhclxuICB0d29oZWFkbGVmdGFycm93OiBcIk0wIDE2N2M2OCA0MFxcbiAxMTUuNyA5NS43IDE0MyAxNjdoMjJjMTUuMyAwIDIzLS4zIDIzLTEgMC0xLjMtNS4zLTEzLjctMTYtMzctMTgtMzUuMy00MS4zLTY5XFxuLTcwLTEwMWwtNy04aDEyNWw5IDdjNTAuNyAzOS4zIDg1IDg2IDEwMyAxNDBoNDZjMC00LjctNi4zLTE4LjctMTktNDItMTgtMzUuM1xcbi00MC02Ny4zLTY2LTk2bC05LTloMzk5NzE2di00MEgyODRsOS05YzI2LTI4LjcgNDgtNjAuNyA2Ni05NiAxMi43LTIzLjMzMyAxOVxcbi0zNy4zMzMgMTktNDJoLTQ2Yy0xOCA1NC01Mi4zIDEwMC43LTEwMyAxNDBsLTkgN0g5NWw3LThjMjguNy0zMiA1Mi02NS43IDcwLTEwMVxcbiAxMC43LTIzLjMzMyAxNi0zNS43IDE2LTM3IDAtLjctNy43LTEtMjMtMWgtMjJDMTE1LjcgNzEuMyA2OCAxMjcgMCAxNjd6XCIsXG4gIHR3b2hlYWRyaWdodGFycm93OiBcIk00MDAwMDAgMTY3XFxuYy02OC00MC0xMTUuNy05NS43LTE0My0xNjdoLTIyYy0xNS4zIDAtMjMgLjMtMjMgMSAwIDEuMyA1LjMgMTMuNyAxNiAzNyAxOCAzNS4zXFxuIDQxLjMgNjkgNzAgMTAxbDcgOGgtMTI1bC05LTdjLTUwLjctMzkuMy04NS04Ni0xMDMtMTQwaC00NmMwIDQuNyA2LjMgMTguNyAxOSA0MlxcbiAxOCAzNS4zIDQwIDY3LjMgNjYgOTZsOSA5SDB2NDBoMzk5NzE2bC05IDljLTI2IDI4LjctNDggNjAuNy02NiA5Ni0xMi43IDIzLjMzM1xcbi0xOSAzNy4zMzMtMTkgNDJoNDZjMTgtNTQgNTIuMy0xMDAuNyAxMDMtMTQwbDktN2gxMjVsLTcgOGMtMjguNyAzMi01MiA2NS43LTcwXFxuIDEwMS0xMC43IDIzLjMzMy0xNiAzNS43LTE2IDM3IDAgLjcgNy43IDEgMjMgMWgyMmMyNy4zLTcxLjMgNzUtMTI3IDE0My0xNjd6XCIsXG4gIC8vIHRpbGRlMSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgYSBnbHlwaCBmcm9tIHRoZSBNblN5bWJvbCBwYWNrYWdlXG4gIHRpbGRlMTogXCJNMjAwIDU1LjUzOGMtNzcgMC0xNjggNzMuOTUzLTE3NyA3My45NTMtMyAwLTdcXG4tMi4xNzUtOS01LjQzN0wyIDk3Yy0xLTItMi00LTItNiAwLTQgMi03IDUtOWwyMC0xMkMxMTYgMTIgMTcxIDAgMjA3IDBjODYgMFxcbiAxMTQgNjggMTkxIDY4IDc4IDAgMTY4LTY4IDE3Ny02OCA0IDAgNyAyIDkgNWwxMiAxOWMxIDIuMTc1IDIgNC4zNSAyIDYuNTI1IDBcXG4gNC4zNS0yIDcuNjEzLTUgOS43ODhsLTE5IDEzLjA1Yy05MiA2My4wNzctMTE2LjkzNyA3NS4zMDgtMTgzIDc2LjEyOFxcbi02OC4yNjcuODQ3LTExMy03My45NTItMTkxLTczLjk1MnpcIixcbiAgLy8gZGl0dG8gdGlsZGUyLCB0aWxkZTMsICYgdGlsZGU0XG4gIHRpbGRlMjogXCJNMzQ0IDU1LjI2NmMtMTQyIDAtMzAwLjYzOCA4MS4zMTYtMzExLjUgODYuNDE4XFxuLTguMDEgMy43NjItMjIuNSAxMC45MS0yMy41IDUuNTYyTDEgMTIwYy0xLTItMS0zLTEtNCAwLTUgMy05IDgtMTBsMTguNC05QzE2MC45XFxuIDMxLjkgMjgzIDAgMzU4IDBjMTQ4IDAgMTg4IDEyMiAzMzEgMTIyczMxNC05NyAzMjYtOTdjNCAwIDggMiAxMCA3bDcgMjEuMTE0XFxuYzEgMi4xNCAxIDMuMjEgMSA0LjI4IDAgNS4zNDctMyA5LjYyNi03IDEwLjY5NmwtMjIuMyAxMi42MjJDODUyLjYgMTU4LjM3MiA3NTFcXG4gMTgxLjQ3NiA2NzYgMTgxLjQ3NmMtMTQ5IDAtMTg5LTEyNi4yMS0zMzItMTI2LjIxelwiLFxuICB0aWxkZTM6IFwiTTc4NiA1OUM0NTcgNTkgMzIgMTc1LjI0MiAxMyAxNzUuMjQyYy02IDAtMTAtMy40NTdcXG4tMTEtMTAuMzdMLjE1IDEzOGMtMS03IDMtMTIgMTAtMTNsMTkuMi02LjRDMzc4LjQgNDAuNyA2MzQuMyAwIDgwNC4zIDBjMzM3IDBcXG4gNDExLjggMTU3IDc0Ni44IDE1NyAzMjggMCA3NTQtMTEyIDc3My0xMTIgNSAwIDEwIDMgMTEgOWwxIDE0LjA3NWMxIDguMDY2LS42OTdcXG4gMTYuNTk1LTYuNjk3IDE3LjQ5MmwtMjEuMDUyIDcuMzFjLTM2Ny45IDk4LjE0Ni02MDkuMTUgMTIyLjY5Ni03NzguMTUgMTIyLjY5NlxcbiAtMzM4IDAtNDA5LTE1Ni41NzMtNzQ0LTE1Ni41NzN6XCIsXG4gIHRpbGRlNDogXCJNNzg2IDU4QzQ1NyA1OCAzMiAxNzcuNDg3IDEzIDE3Ny40ODdjLTYgMC0xMC0zLjM0NVxcbi0xMS0xMC4wMzVMLjE1IDE0M2MtMS03IDMtMTIgMTAtMTNsMjItNi43QzM4MS4yIDM1IDYzNy4xNSAwIDgwNy4xNSAwYzMzNyAwIDQwOVxcbiAxNzcgNzQ0IDE3NyAzMjggMCA3NTQtMTI3IDc3My0xMjcgNSAwIDEwIDMgMTEgOWwxIDE0Ljc5NGMxIDcuODA1LTMgMTMuMzgtOVxcbiAxNC40OTVsLTIwLjcgNS41NzRjLTM2Ni44NSA5OS43OS02MDcuMyAxMzkuMzcyLTc3Ni4zIDEzOS4zNzItMzM4IDAtNDA5XFxuIC0xNzUuMjM2LTc0NC0xNzUuMjM2elwiLFxuICAvLyB2ZWMgaXMgZnJvbSBnbHlwaCBVKzIwRDcgaW4gZm9udCBLYVRlWCBNYWluXG4gIHZlYzogXCJNMzc3IDIwYzAtNS4zMzMgMS44MzMtMTAgNS41LTE0UzM5MSAwIDM5NyAwYzQuNjY3IDAgOC42NjcgMS42NjcgMTIgNVxcbjMuMzMzIDIuNjY3IDYuNjY3IDkgMTAgMTkgNi42NjcgMjQuNjY3IDIwLjMzMyA0My42NjcgNDEgNTcgNy4zMzMgNC42NjcgMTFcXG4xMC42NjcgMTEgMTggMCA2LTEgMTAtMyAxMnMtNi42NjcgNS0xNCA5Yy0yOC42NjcgMTQuNjY3LTUzLjY2NyAzNS42NjctNzUgNjNcXG4tMS4zMzMgMS4zMzMtMy4xNjcgMy41LTUuNSA2LjVzLTQgNC44MzMtNSA1LjVjLTEgLjY2Ny0yLjUgMS4zMzMtNC41IDJzLTQuMzMzIDFcXG4tNyAxYy00LjY2NyAwLTkuMTY3LTEuODMzLTEzLjUtNS41UzMzNyAxODQgMzM3IDE3OGMwLTEyLjY2NyAxNS42NjctMzIuMzMzIDQ3LTU5XFxuSDIxM2wtMTcxLTFjLTguNjY3LTYtMTMtMTIuMzMzLTEzLTE5IDAtNC42NjcgNC4zMzMtMTEuMzMzIDEzLTIwaDM1OVxcbmMtMTYtMjUuMzMzLTI0LTQ1LTI0LTU5elwiLFxuICAvLyB3aWRlaGF0MSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgYSBnbHlwaCBmcm9tIHRoZSBNblN5bWJvbCBwYWNrYWdlXG4gIHdpZGVoYXQxOiBcIk01MjkgMGg1bDUxOSAxMTVjNSAxIDkgNSA5IDEwIDAgMS0xIDItMSAzbC00IDIyXFxuYy0xIDUtNSA5LTExIDloLTJMNTMyIDY3IDE5IDE1OWgtMmMtNSAwLTktNC0xMS05bC01LTIyYy0xLTYgMi0xMiA4LTEzelwiLFxuICAvLyBkaXR0byB3aWRlaGF0Miwgd2lkZWhhdDMsICYgd2lkZWhhdDRcbiAgd2lkZWhhdDI6IFwiTTExODEgMGgybDExNzEgMTc2YzYgMCAxMCA1IDEwIDExbC0yIDIzYy0xIDYtNSAxMFxcbi0xMSAxMGgtMUwxMTgyIDY3IDE1IDIyMGgtMWMtNiAwLTEwLTQtMTEtMTBsLTItMjNjLTEtNiA0LTExIDEwLTExelwiLFxuICB3aWRlaGF0MzogXCJNMTE4MSAwaDJsMTE3MSAyMzZjNiAwIDEwIDUgMTAgMTFsLTIgMjNjLTEgNi01IDEwXFxuLTExIDEwaC0xTDExODIgNjcgMTUgMjgwaC0xYy02IDAtMTAtNC0xMS0xMGwtMi0yM2MtMS02IDQtMTEgMTAtMTF6XCIsXG4gIHdpZGVoYXQ0OiBcIk0xMTgxIDBoMmwxMTcxIDI5NmM2IDAgMTAgNSAxMCAxMWwtMiAyM2MtMSA2LTUgMTBcXG4tMTEgMTBoLTFMMTE4MiA2NyAxNSAzNDBoLTFjLTYgMC0xMC00LTExLTEwbC0yLTIzYy0xLTYgNC0xMSAxMC0xMXpcIixcbiAgLy8gd2lkZWNoZWNrIHBhdGhzIGFyZSBhbGwgaW52ZXJ0ZWQgdmVyc2lvbnMgb2Ygd2lkZWhhdFxuICB3aWRlY2hlY2sxOiBcIk01MjksMTU5aDVsNTE5LC0xMTVjNSwtMSw5LC01LDksLTEwYzAsLTEsLTEsLTIsLTEsLTNsLTQsLTIyYy0xLFxcbi01LC01LC05LC0xMSwtOWgtMmwtNTEyLDkybC01MTMsLTkyaC0yYy01LDAsLTksNCwtMTEsOWwtNSwyMmMtMSw2LDIsMTIsOCwxM3pcIixcbiAgd2lkZWNoZWNrMjogXCJNMTE4MSwyMjBoMmwxMTcxLC0xNzZjNiwwLDEwLC01LDEwLC0xMWwtMiwtMjNjLTEsLTYsLTUsLTEwLFxcbi0xMSwtMTBoLTFsLTExNjgsMTUzbC0xMTY3LC0xNTNoLTFjLTYsMCwtMTAsNCwtMTEsMTBsLTIsMjNjLTEsNiw0LDExLDEwLDExelwiLFxuICB3aWRlY2hlY2szOiBcIk0xMTgxLDI4MGgybDExNzEsLTIzNmM2LDAsMTAsLTUsMTAsLTExbC0yLC0yM2MtMSwtNiwtNSwtMTAsXFxuLTExLC0xMGgtMWwtMTE2OCwyMTNsLTExNjcsLTIxM2gtMWMtNiwwLC0xMCw0LC0xMSwxMGwtMiwyM2MtMSw2LDQsMTEsMTAsMTF6XCIsXG4gIHdpZGVjaGVjazQ6IFwiTTExODEsMzQwaDJsMTE3MSwtMjk2YzYsMCwxMCwtNSwxMCwtMTFsLTIsLTIzYy0xLC02LC01LC0xMCxcXG4tMTEsLTEwaC0xbC0xMTY4LDI3M2wtMTE2NywtMjczaC0xYy02LDAsLTEwLDQsLTExLDEwbC0yLDIzYy0xLDYsNCwxMSwxMCwxMXpcIixcbiAgLy8gVGhlIG5leHQgdGVuIHBhdGhzIHN1cHBvcnQgcmVhY3Rpb24gYXJyb3dzIGZyb20gdGhlIG1oY2hlbSBwYWNrYWdlLlxuICAvLyBBcnJvd3MgZm9yIFxcY2V7PC0tPn0gYXJlIG9mZnNldCBmcm9tIHhBeGlzIGJ5IDAuMjJleCwgcGVyIG1oY2hlbSBpbiBMYVRlWFxuICAvLyBiYXJhYm92ZWxlZnRhcnJvdyBpcyBtb3N0bHkgZnJvbSBnbHlwaCBVKzIxOTAgaW4gZm9udCBLYVRlWCBNYWluXG4gIGJhcmFib3ZlbGVmdGFycm93OiBcIk00MDAwMDAgNjIwaC0zOTk4OTBsMyAtM2M2OC43IC01Mi43IDExMy43IC0xMjAgMTM1IC0yMDJcXG5jNCAtMTQuNyA2IC0yMyA2IC0yNWMwIC03LjMgLTcgLTExIC0yMSAtMTFjLTggMCAtMTMuMiAwLjggLTE1LjUgMi41XFxuYy0yLjMgMS43IC00LjIgNS44IC01LjUgMTIuNWMtMS4zIDQuNyAtMi43IDEwLjMgLTQgMTdjLTEyIDQ4LjcgLTM0LjggOTIgLTY4LjUgMTMwXFxucy03NC4yIDY2LjMgLTEyMS41IDg1Yy0xMCA0IC0xNiA3LjcgLTE4IDExYzAgOC43IDYgMTQuMyAxOCAxN2M0Ny4zIDE4LjcgODcuOCA0N1xcbjEyMS41IDg1czU2LjUgODEuMyA2OC41IDEzMGMwLjcgMiAxLjMgNSAyIDlzMS4yIDYuNyAxLjUgOGMwLjMgMS4zIDEgMy4zIDIgNlxcbnMyLjIgNC41IDMuNSA1LjVjMS4zIDEgMy4zIDEuOCA2IDIuNXM2IDEgMTAgMWMxNCAwIDIxIC0zLjcgMjEgLTExXFxuYzAgLTIgLTIgLTEwLjMgLTYgLTI1Yy0yMCAtNzkuMyAtNjUgLTE0Ni43IC0xMzUgLTIwMmwtMyAtM2gzOTk4OTB6XFxuTTEwMCA2MjB2NDBoMzk5OTAwdi00MHogTTAgMjQxdjQwaDM5OTkwMHYtNDB6TTAgMjQxdjQwaDM5OTkwMHYtNDB6XCIsXG4gIC8vIHJpZ2h0YXJyb3dhYm92ZWJhciBpcyBtb3N0bHkgZnJvbSBnbHlwaCBVKzIxOTIsIEthVGVYIE1haW5cbiAgcmlnaHRhcnJvd2Fib3ZlYmFyOiBcIk0wIDI0MXY0MGgzOTk4OTFjLTQ3LjMgMzUuMy04NCA3OC0xMTAgMTI4LTE2LjcgMzJcXG4tMjcuNyA2My43LTMzIDk1IDAgMS4zLS4yIDIuNy0uNSA0LS4zIDEuMy0uNSAyLjMtLjUgMyAwIDcuMyA2LjcgMTEgMjAgMTEgOCAwXFxuMTMuMi0uOCAxNS41LTIuNSAyLjMtMS43IDQuMi01LjUgNS41LTExLjUgMi0xMy4zIDUuNy0yNyAxMS00MSAxNC43LTQ0LjcgMzlcXG4tODQuNSA3My0xMTkuNXM3My43LTYwLjIgMTE5LTc1LjVjNi0yIDktNS43IDktMTFzLTMtOS05LTExYy00NS4zLTE1LjMtODUtNDAuNVxcbi0xMTktNzUuNXMtNTguMy03NC44LTczLTExOS41Yy00LjctMTQtOC4zLTI3LjMtMTEtNDAtMS4zLTYuNy0zLjItMTAuOC01LjVcXG4tMTIuNS0yLjMtMS43LTcuNS0yLjUtMTUuNS0yLjUtMTQgMC0yMSAzLjctMjEgMTEgMCAyIDIgMTAuMyA2IDI1IDIwLjcgODMuMyA2N1xcbjE1MS43IDEzOSAyMDV6bTk2IDM3OWgzOTk4OTR2NDBIMHptMCAwaDM5OTkwNHY0MEgwelwiLFxuICAvLyBUaGUgc2hvcnQgbGVmdCBoYXJwb29uIGhhcyAwLjVlbSAoaS5lLiA1MDAgdW5pdHMpIGtlcm4gb24gdGhlIGxlZnQgZW5kLlxuICAvLyBSZWYgZnJvbSBtaGNoZW0uc3R5OiBcXHJsYXB7XFxyYWlzZWJveHstLjIyZXh9eyRcXGtlcm4wLjVlbVxuICBiYXJhYm92ZXNob3J0bGVmdGhhcnBvb246IFwiTTUwNyw0MzVjLTQsNCwtNi4zLDguNywtNywxNGMwLDUuMywwLjcsOSwyLDExXFxuYzEuMywyLDUuMyw1LjMsMTIsMTBjOTAuNyw1NCwxNTYsMTMwLDE5NiwyMjhjMy4zLDEwLjcsNi4zLDE2LjMsOSwxN1xcbmMyLDAuNyw1LDEsOSwxYzAsMCw1LDAsNSwwYzEwLjcsMCwxNi43LC0yLDE4LC02YzIsLTIuNywxLC05LjcsLTMsLTIxXFxuYy0zMiwtODcuMywtODIuNywtMTU3LjcsLTE1MiwtMjExYzAsMCwtMywtMywtMywtM2wzOTkzNTEsMGwwLC00MFxcbmMtMzk4NTcwLDAsLTM5OTQzNywwLC0zOTk0MzcsMHogTTU5MyA0MzUgdjQwIEgzOTk1MDAgdi00MHpcXG5NMCAyODEgdi00MCBIMzk5OTA4IHY0MHogTTAgMjgxIHYtNDAgSDM5OTkwOCB2NDB6XCIsXG4gIHJpZ2h0aGFycG9vbmFib3Zlc2hvcnRiYXI6IFwiTTAsMjQxIGwwLDQwYzM5OTEyNiwwLDM5OTk5MywwLDM5OTk5MywwXFxuYzQuNywtNC43LDcsLTkuMyw3LC0xNGMwLC05LjMsLTMuNywtMTUuMywtMTEsLTE4Yy05Mi43LC01Ni43LC0xNTksLTEzMy43LC0xOTksXFxuLTIzMWMtMy4zLC05LjMsLTYsLTE0LjcsLTgsLTE2Yy0yLC0xLjMsLTcsLTIsLTE1LC0yYy0xMC43LDAsLTE2LjcsMiwtMTgsNlxcbmMtMiwyLjcsLTEsOS43LDMsMjFjMTUuMyw0MiwzNi43LDgxLjgsNjQsMTE5LjVjMjcuMywzNy43LDU4LDY5LjIsOTIsOTQuNXpcXG5NMCAyNDEgdjQwIEgzOTk5MDggdi00MHogTTAgNDc1IHYtNDAgSDM5OTUwMCB2NDB6IE0wIDQ3NSB2LTQwIEgzOTk1MDAgdjQwelwiLFxuICBzaG9ydGJhcmFib3ZlbGVmdGhhcnBvb246IFwiTTcsNDM1Yy00LDQsLTYuMyw4LjcsLTcsMTRjMCw1LjMsMC43LDksMiwxMVxcbmMxLjMsMiw1LjMsNS4zLDEyLDEwYzkwLjcsNTQsMTU2LDEzMCwxOTYsMjI4YzMuMywxMC43LDYuMywxNi4zLDksMTdjMiwwLjcsNSwxLDksXFxuMWMwLDAsNSwwLDUsMGMxMC43LDAsMTYuNywtMiwxOCwtNmMyLC0yLjcsMSwtOS43LC0zLC0yMWMtMzIsLTg3LjMsLTgyLjcsLTE1Ny43LFxcbi0xNTIsLTIxMWMwLDAsLTMsLTMsLTMsLTNsMzk5OTA3LDBsMCwtNDBjLTM5OTEyNiwwLC0zOTk5OTMsMCwtMzk5OTkzLDB6XFxuTTkzIDQzNSB2NDAgSDQwMDAwMCB2LTQweiBNNTAwIDI0MSB2NDAgSDQwMDAwMCB2LTQweiBNNTAwIDI0MSB2NDAgSDQwMDAwMCB2LTQwelwiLFxuICBzaG9ydHJpZ2h0aGFycG9vbmFib3ZlYmFyOiBcIk01MywyNDFsMCw0MGMzOTg1NzAsMCwzOTk0MzcsMCwzOTk0MzcsMFxcbmM0LjcsLTQuNyw3LC05LjMsNywtMTRjMCwtOS4zLC0zLjcsLTE1LjMsLTExLC0xOGMtOTIuNywtNTYuNywtMTU5LC0xMzMuNywtMTk5LFxcbi0yMzFjLTMuMywtOS4zLC02LC0xNC43LC04LC0xNmMtMiwtMS4zLC03LC0yLC0xNSwtMmMtMTAuNywwLC0xNi43LDIsLTE4LDZcXG5jLTIsMi43LC0xLDkuNywzLDIxYzE1LjMsNDIsMzYuNyw4MS44LDY0LDExOS41YzI3LjMsMzcuNyw1OCw2OS4yLDkyLDk0LjV6XFxuTTUwMCAyNDEgdjQwIEgzOTk0MDggdi00MHogTTUwMCA0MzUgdjQwIEg0MDAwMDAgdi00MHpcIlxufTtcbmNvbnN0IHRhbGxEZWxpbSA9IGZ1bmN0aW9uIChsYWJlbCwgbWlkSGVpZ2h0KSB7XG4gIHN3aXRjaCAobGFiZWwpIHtcbiAgICBjYXNlIFwibGJyYWNrXCI6XG4gICAgICByZXR1cm4gXCJNNDAzIDE3NTkgVjg0IEg2NjYgVjAgSDMxOSBWMTc1OSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2MTc1OSBoMzQ3IHYtODRcXG5INDAzeiBNNDAzIDE3NTkgVjAgSDMxOSBWMTc1OSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2MTc1OSBoODR6XCI7XG5cbiAgICBjYXNlIFwicmJyYWNrXCI6XG4gICAgICByZXR1cm4gXCJNMzQ3IDE3NTkgVjAgSDAgVjg0IEgyNjMgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjE3NTkgSDAgdjg0IEgzNDd6XFxuTTM0NyAxNzU5IFYwIEgyNjMgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjE3NTkgaDg0elwiO1xuXG4gICAgY2FzZSBcInZlcnRcIjpcbiAgICAgIHJldHVybiBcIk0xNDUgMTUgdjU4NSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2NTg1IGMyLjY2NywxMCw5LjY2NywxNSwyMSwxNVxcbmMxMCwwLDE2LjY2NywtNSwyMCwtMTUgdi01ODUgdlwiICsgLW1pZEhlaWdodCArIFwiIHYtNTg1IGMtMi42NjcsLTEwLC05LjY2NywtMTUsLTIxLC0xNVxcbmMtMTAsMCwtMTYuNjY3LDUsLTIwLDE1eiBNMTg4IDE1IEgxNDUgdjU4NSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2NTg1IGg0M3pcIjtcblxuICAgIGNhc2UgXCJkb3VibGV2ZXJ0XCI6XG4gICAgICByZXR1cm4gXCJNMTQ1IDE1IHY1ODUgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjU4NSBjMi42NjcsMTAsOS42NjcsMTUsMjEsMTVcXG5jMTAsMCwxNi42NjcsLTUsMjAsLTE1IHYtNTg1IHZcIiArIC1taWRIZWlnaHQgKyBcIiB2LTU4NSBjLTIuNjY3LC0xMCwtOS42NjcsLTE1LC0yMSwtMTVcXG5jLTEwLDAsLTE2LjY2Nyw1LC0yMCwxNXogTTE4OCAxNSBIMTQ1IHY1ODUgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjU4NSBoNDN6XFxuTTM2NyAxNSB2NTg1IHZcIiArIG1pZEhlaWdodCArIFwiIHY1ODUgYzIuNjY3LDEwLDkuNjY3LDE1LDIxLDE1XFxuYzEwLDAsMTYuNjY3LC01LDIwLC0xNSB2LTU4NSB2XCIgKyAtbWlkSGVpZ2h0ICsgXCIgdi01ODUgYy0yLjY2NywtMTAsLTkuNjY3LC0xNSwtMjEsLTE1XFxuYy0xMCwwLC0xNi42NjcsNSwtMjAsMTV6IE00MTAgMTUgSDM2NyB2NTg1IHZcIiArIG1pZEhlaWdodCArIFwiIHY1ODUgaDQzelwiO1xuXG4gICAgY2FzZSBcImxmbG9vclwiOlxuICAgICAgcmV0dXJuIFwiTTMxOSA2MDIgVjAgSDQwMyBWNjAyIHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzE1IGgyNjMgdjg0IEgzMTl6XFxuTU0zMTkgNjAyIFYwIEg0MDMgVjYwMiB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2MTcxNSBIMzE5elwiO1xuXG4gICAgY2FzZSBcInJmbG9vclwiOlxuICAgICAgcmV0dXJuIFwiTTMxOSA2MDIgVjAgSDQwMyBWNjAyIHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzk5IEgwIHYtODQgSDMxOXpcXG5NTTMxOSA2MDIgVjAgSDQwMyBWNjAyIHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzE1IEgzMTl6XCI7XG5cbiAgICBjYXNlIFwibGNlaWxcIjpcbiAgICAgIHJldHVybiBcIk00MDMgMTc1OSBWODQgSDY2NiBWMCBIMzE5IFYxNzU5IHZcIiArIG1pZEhlaWdodCArIFwiIHY2MDIgaDg0elxcbk00MDMgMTc1OSBWMCBIMzE5IFYxNzU5IHZcIiArIG1pZEhlaWdodCArIFwiIHY2MDIgaDg0elwiO1xuXG4gICAgY2FzZSBcInJjZWlsXCI6XG4gICAgICByZXR1cm4gXCJNMzQ3IDE3NTkgVjAgSDAgVjg0IEgyNjMgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjYwMiBoODR6XFxuTTM0NyAxNzU5IFYwIGgtODQgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjYwMiBoODR6XCI7XG5cbiAgICBjYXNlIFwibHBhcmVuXCI6XG4gICAgICByZXR1cm4gXCJNODYzLDljMCwtMiwtMiwtNSwtNiwtOWMwLDAsLTE3LDAsLTE3LDBjLTEyLjcsMCwtMTkuMywwLjMsLTIwLDFcXG5jLTUuMyw1LjMsLTEwLjMsMTEsLTE1LDE3Yy0yNDIuNywyOTQuNywtMzk1LjMsNjgyLC00NTgsMTE2MmMtMjEuMywxNjMuMywtMzMuMywzNDksXFxuLTM2LDU1NyBsMCxcIiArIChtaWRIZWlnaHQgKyA4NCkgKyBcImMwLjIsNiwwLDI2LDAsNjBjMiwxNTkuMywxMCwzMTAuNywyNCw0NTRjNTMuMyw1MjgsMjEwLFxcbjk0OS43LDQ3MCwxMjY1YzQuNyw2LDkuNywxMS43LDE1LDE3YzAuNywwLjcsNywxLDE5LDFjMCwwLDE4LDAsMTgsMGM0LC00LDYsLTcsNiwtOVxcbmMwLC0yLjcsLTMuMywtOC43LC0xMCwtMThjLTEzNS4zLC0xOTIuNywtMjM1LjUsLTQxNC4zLC0zMDAuNSwtNjY1Yy02NSwtMjUwLjcsLTEwMi41LFxcbi01NDQuNywtMTEyLjUsLTg4MmMtMiwtMTA0LC0zLC0xNjcsLTMsLTE4OVxcbmwwLC1cIiArIChtaWRIZWlnaHQgKyA5MikgKyBcImMwLC0xNjIuNyw1LjcsLTMxNCwxNywtNDU0YzIwLjcsLTI3Miw2My43LC01MTMsMTI5LC03MjNjNjUuMyxcXG4tMjEwLDE1NS4zLC0zOTYuMywyNzAsLTU1OWM2LjcsLTkuMywxMCwtMTUuMywxMCwtMTh6XCI7XG5cbiAgICBjYXNlIFwicnBhcmVuXCI6XG4gICAgICByZXR1cm4gXCJNNzYsMGMtMTYuNywwLC0yNSwzLC0yNSw5YzAsMiwyLDYuMyw2LDEzYzIxLjMsMjguNyw0Mi4zLDYwLjMsXFxuNjMsOTVjOTYuNywxNTYuNywxNzIuOCwzMzIuNSwyMjguNSw1MjcuNWM1NS43LDE5NSw5Mi44LDQxNi41LDExMS41LDY2NC41XFxuYzExLjMsMTM5LjMsMTcsMjkwLjcsMTcsNDU0YzAsMjgsMS43LDQzLDMuMyw0NWwwLFwiICsgKG1pZEhlaWdodCArIDkpICsgXCJcXG5jLTMsNCwtMy4zLDE2LjcsLTMuMywzOGMwLDE2MiwtNS43LDMxMy43LC0xNyw0NTVjLTE4LjcsMjQ4LC01NS44LDQ2OS4zLC0xMTEuNSw2NjRcXG5jLTU1LjcsMTk0LjcsLTEzMS44LDM3MC4zLC0yMjguNSw1MjdjLTIwLjcsMzQuNywtNDEuNyw2Ni4zLC02Myw5NWMtMiwzLjMsLTQsNywtNiwxMVxcbmMwLDcuMyw1LjcsMTEsMTcsMTFjMCwwLDExLDAsMTEsMGM5LjMsMCwxNC4zLC0wLjMsMTUsLTFjNS4zLC01LjMsMTAuMywtMTEsMTUsLTE3XFxuYzI0Mi43LC0yOTQuNywzOTUuMywtNjgxLjcsNDU4LC0xMTYxYzIxLjMsLTE2NC43LDMzLjMsLTM1MC43LDM2LC01NThcXG5sMCwtXCIgKyAobWlkSGVpZ2h0ICsgMTQ0KSArIFwiYy0yLC0xNTkuMywtMTAsLTMxMC43LC0yNCwtNDU0Yy01My4zLC01MjgsLTIxMCwtOTQ5LjcsXFxuLTQ3MCwtMTI2NWMtNC43LC02LC05LjcsLTExLjcsLTE1LC0xN2MtMC43LC0wLjcsLTYuNywtMSwtMTgsLTF6XCI7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBldmVyIGdldCBoZXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdHJldGNoeSBkZWxpbWl0ZXIuXCIpO1xuICB9XG59O1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RyZWUuanNcblxuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIHdoaWNoIGNvbnRhaW5zIGVsZW1lbnRzLCBidXQgd2hlblxuICogcGxhY2VkIGludG8gdGhlIERPTSBkb2Vzbid0IGhhdmUgYW55IHJlcHJlc2VudGF0aW9uIGl0c2VsZi4gSXQgb25seSBjb250YWluc1xuICogY2hpbGRyZW4gYW5kIGRvZXNuJ3QgaGF2ZSBhbnkgRE9NIG5vZGUgcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgRG9jdW1lbnRGcmFnbWVudCB7XG4gIC8vIEh0bWxEb21Ob2RlXG4gIC8vIE5ldmVyIHVzZWQ7IG5lZWRlZCBmb3Igc2F0aXNmeWluZyBpbnRlcmZhY2UuXG4gIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRoZSBmcmFnbWVudCBpbnRvIGEgbm9kZS4gKi9cblxuXG4gIHRvTm9kZSgpIHtcbiAgICBjb25zdCBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRoZSBmcmFnbWVudCBpbnRvIEhUTUwgbWFya3VwLiAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgbGV0IG1hcmt1cCA9IFwiXCI7IC8vIFNpbXBseSBjb25jYXRlbmF0ZSB0aGUgbWFya3VwIGZvciB0aGUgY2hpbGRyZW4gdG9nZXRoZXIuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dC4gQXBwbGllcyB0b1xuICAgKiBNYXRoRG9tTm9kZSdzIG9ubHkuXG4gICAqL1xuXG5cbiAgdG9UZXh0KCkge1xuICAgIC8vIFRvIGF2b2lkIHRoaXMsIHdlIHdvdWxkIHN1YmNsYXNzIGRvY3VtZW50RnJhZ21lbnQgc2VwYXJhdGVseSBmb3JcbiAgICAvLyBNYXRoTUwsIGJ1dCBwb2x5ZmlsbHMgZm9yIHN1YmNsYXNzaW5nIGlzIGV4cGVuc2l2ZSBwZXIgUFIgMTQ2OS5cbiAgICAvLyAkRmxvd0ZpeE1lOiBPbmx5IHdvcmtzIGZvciBDaGlsZFR5cGUgPSBNYXRoRG9tTm9kZS5cbiAgICBjb25zdCB0b1RleHQgPSBjaGlsZCA9PiBjaGlsZC50b1RleHQoKTtcblxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcCh0b1RleHQpLmpvaW4oXCJcIik7XG4gIH1cblxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2ZvbnRNZXRyaWNzRGF0YS5qc1xuLy8gVGhpcyBmaWxlIGlzIEdFTkVSQVRFRCBieSBidWlsZE1ldHJpY3Muc2guIERPIE5PVCBNT0RJRlkuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmb250TWV0cmljc0RhdGEgPSAoe1xuICBcIkFNUy1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjY2XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjY4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjY5XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjcxXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjczXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjc0XCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwLCAwLjVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNzZcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuOTQ0NDVdLFxuICAgIFwiNzhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNzlcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODBcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODFcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODJcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODVcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODZcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDEuMF0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2NVwiOiBbMCwgMC42NzUsIDAuMDI1LCAwLCAwLjc1XSxcbiAgICBcIjE3NFwiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMCwgMC45NDY2Nl0sXG4gICAgXCIyNDBcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMjk1XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSxcbiAgICBcIjcxMFwiOiBbMCwgMC44MjUsIDAsIDAsIDIuMzMzMzRdLFxuICAgIFwiNzMyXCI6IFswLCAwLjksIDAsIDAsIDIuMzMzMzRdLFxuICAgIFwiNzcwXCI6IFswLCAwLjgyNSwgMCwgMCwgMi4zMzMzNF0sXG4gICAgXCI3NzFcIjogWzAsIDAuOSwgMCwgMCwgMi4zMzMzNF0sXG4gICAgXCI5ODlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTAwOFwiOiBbMCwgMC40MzA1NiwgMC4wNDAyOCwgMCwgMC42NjY2N10sXG4gICAgXCI4MjQ1XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjI3NV0sXG4gICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSxcbiAgICBcIjg0ODdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODQ5OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NTAyXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg1MDNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODUwNFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NTEzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg1OTJcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjVdLFxuICAgIFwiODU5NFwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNV0sXG4gICAgXCI4NjAyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDNcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwNlwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDhcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMF0sXG4gICAgXCI4NjEwXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg2MTFcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODYxOVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MjBcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjIxXCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMCwgMS4zODg4OV0sXG4gICAgXCI4NjIyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2MjRcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNV0sXG4gICAgXCI4NjI1XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLFxuICAgIFwiODYzMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MzFcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjM0XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg2MzVcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODYzOFwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI4NjM5XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg2NDJcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiODY0M1wiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI4NjQ0XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0NlwiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDdcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQ4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg2NDlcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUwXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg2NTFcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUyXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1M1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTVcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2NlwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NjdcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjY5XCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NzJcIjogWy0wLjA2NCwgMC40MzcsIDAsIDAsIDEuMzM0XSxcbiAgICBcIjg2NzRcIjogWy0wLjA2NCwgMC40MzcsIDAsIDAsIDEuMzM0XSxcbiAgICBcIjg3MDVcIjogWzAsIDAuODI1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcwOFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzA5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDI5MTddLFxuICAgIFwiODcyMlwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI0XCI6IFswLjA4MTk4LCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MjZcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODczM1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzdcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczOFwiOiBbMC4wMzUxNywgMC41MjIzOSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjIyMjIyXSxcbiAgICBcIjg3NDBcIjogWzAuMjUxNDIsIDAuNzQxMTEsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODc0MVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI4NzQyXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwLCAwLjVdLFxuICAgIFwiODc1NlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzU3XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NjRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NjVcIjogWy0wLjEzMzEzLCAwLjM3Nzg4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NjlcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzBcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzRcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3NlwiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3OFwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzgyXCI6IFswLjA2MDYyLCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODNcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4NVwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzg2XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODdcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc5MFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzkxXCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3OTZcIjogWzAuMDgxOTgsIDAuOTE2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwNlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA3XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwOVwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODEyXCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjVdLFxuICAgIFwiODgxNFwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE1XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTZcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxN1wiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE4XCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTlcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyMlwiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODIzXCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyOVwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODMwXCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzMlwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODMzXCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0MVwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQyXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDNcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0N1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQ4XCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NThcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1OVwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODYxXCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjJcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjNcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjRcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjVcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NzJcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg3M1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4ODc0XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjg4NzZcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg3N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODc4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg4NzlcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODg4MlwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODgzXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4ODRcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg4NVwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODg4XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg4OTBcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODg5MVwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODkyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg5MDFcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODkwM1wiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA1XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDZcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwN1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA4XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDlcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MTBcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzYwNDJdLFxuICAgIFwiODkxMVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43NjA0Ml0sXG4gICAgXCI4OTEyXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MTNcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkxNFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4OTE1XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5MTZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODkxOFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkxOVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyMFwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMS4zMzMzNF0sXG4gICAgXCI4OTIxXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAxLjMzMzM0XSxcbiAgICBcIjg5MjJcIjogWzAuMzg1NjksIDAuODg1NjksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyM1wiOiBbMC4zODU2OSwgMC44ODU2OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTI2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjdcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyOFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTI5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzRcIjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzNVwiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM2XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzdcIjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzOFwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM5XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5NDBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODk0MVwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTk0XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5OTVcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTQxNlwiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMCwgMC45MDIyMl0sXG4gICAgXCI5NDg0XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTQ4OFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSxcbiAgICBcIjk0OTJcIjogWzAsIDAuMzc3ODgsIDAsIDAsIDAuNV0sXG4gICAgXCI5NDk2XCI6IFswLCAwLjM3Nzg4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTU4NVwiOiBbMC4xOTQ0NCwgMC42ODg4OSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5NTg2XCI6IFswLjE5NDQ0LCAwLjc0MTExLCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk2MzJcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk2MzNcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk2NTBcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTY1MVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5NjU0XCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk2NjBcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTY2MVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5NjY0XCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk2NzRcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTczM1wiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCIxMDAwM1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIxMDAxNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIxMDczMVwiOiBbMC4xMTExMSwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxMDg0NlwiOiBbMC4xOTQ0NCwgMC43NTU4MywgMCwgMCwgMC42MTExMV0sXG4gICAgXCIxMDg3N1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg3OFwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4NVwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4NlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4N1wiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4OFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4OVwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg5MFwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg5MVwiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg5MlwiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkwMVwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkwMlwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzM1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzNFwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzNVwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzNlwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzN1wiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzOFwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDk0OVwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDk1MFwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDk1NVwiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDk1NlwiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1MFwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4yMjIyMl0sXG4gICAgXCI1NzM1MVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI1NzM1MlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1M1wiOiBbMCwgMC40MzA1NiwgMC4wNDAyOCwgMCwgMC42NjY2N10sXG4gICAgXCI1NzM1NlwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1OFwiOiBbMC40MTk1MSwgMC45MTk1MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1OVwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2MVwiOiBbMC40MTk1MSwgMC45MTk1MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2NlwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2OFwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2OVwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM3MFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM3MVwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF1cbiAgfSxcbiAgXCJDYWxpZ3JhcGhpYy1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLjE5NDQ1LCAwLjc5ODQ3XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjAzMDQxLCAwLjEzODg5LCAwLjY1NjgxXSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA1ODM0LCAwLjEzODg5LCAwLjUyNjUzXSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA4MzM0LCAwLjc3MTM5XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA4OTQ0LCAwLjExMTExLCAwLjUyNzc4XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjExMTExLCAwLjcxODc1XSxcbiAgICBcIjcxXCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjA1OTMsIDAuMTExMTEsIDAuNTk0ODddLFxuICAgIFwiNzJcIjogWzAsIDAuNjgzMzMsIDAuMDA5NjUsIDAuMTExMTEsIDAuODQ0NTJdLFxuICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDczODIsIDAsIDAuNTQ0NTJdLFxuICAgIFwiNzRcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMTg0NzIsIDAuMTY2NjcsIDAuNjc3NzhdLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAuMDE0NDUsIDAuMDU1NTYsIDAuNzYxOTVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODksIDAuNjg5NzJdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODksIDEuMjAwOV0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xNDczNiwgMC4wODMzNCwgMC44MjA0OV0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4xMTExMSwgMC43OTYxMV0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNCwgMC42OTU1Nl0sXG4gICAgXCI4MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMCwgMC4xMTExMSwgMC44MTY2N10sXG4gICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC44NDc1XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjA3NSwgMC4xMzg4OSwgMC42MDU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODMzMywgMC4yNTQxNywgMCwgMC41NDQ2NF0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4wOTkzMSwgMC4wODMzNCwgMC42MjU4M10sXG4gICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMCwgMC42MTI3OF0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNCwgMC45ODc3OF0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4xNDY0MywgMC4xMzg4OSwgMC43MTMzXSxcbiAgICBcIjg5XCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0LCAwLjY2ODM0XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3OTQ0LCAwLjEzODg5LCAwLjcyNDczXSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV1cbiAgfSxcbiAgXCJGcmFrdHVyLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjk1NzRdLFxuICAgIFwiMzRcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjE0NzFdLFxuICAgIFwiMzhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzM3ODZdLFxuICAgIFwiMzlcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjEyMDFdLFxuICAgIFwiNDBcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuMzg4NjVdLFxuICAgIFwiNDFcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuMzg4NjVdLFxuICAgIFwiNDJcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuMjc3NjRdLFxuICAgIFwiNDNcIjogWzAuMDgzMTksIDAuNTgyODMsIDAsIDAsIDAuNzU2MjNdLFxuICAgIFwiNDRcIjogWzAsIDAuMTA4MDMsIDAsIDAsIDAuMjc3NjRdLFxuICAgIFwiNDVcIjogWzAuMDgzMTksIDAuNTgyODMsIDAsIDAsIDAuNzU2MjNdLFxuICAgIFwiNDZcIjogWzAsIDAuMTA4MDMsIDAsIDAsIDAuMjc3NjRdLFxuICAgIFwiNDdcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNDhcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNDlcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNTBcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNTFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNTJcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNTNcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNTRcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNTVcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNTZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNTdcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLFxuICAgIFwiNThcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuMjE2MDZdLFxuICAgIFwiNTlcIjogWzAuMTI2MDQsIDAuNDc1MzQsIDAsIDAsIDAuMjE2MDZdLFxuICAgIFwiNjFcIjogWy0wLjEzMDk5LCAwLjM2ODY2LCAwLCAwLCAwLjc1NjIzXSxcbiAgICBcIjYzXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjM2MjQ1XSxcbiAgICBcIjY1XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjcxNzZdLFxuICAgIFwiNjZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODgzOTddLFxuICAgIFwiNjdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjEyNTRdLFxuICAgIFwiNjhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODMxNThdLFxuICAgIFwiNjlcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjYyNzhdLFxuICAgIFwiNzBcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDAsIDAuNjExMTldLFxuICAgIFwiNzFcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzg1MzldLFxuICAgIFwiNzJcIjogWzAuMDYzMDIsIDAuNjkxNDEsIDAsIDAsIDAuNzIwM10sXG4gICAgXCI3M1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41NTQ0OF0sXG4gICAgXCI3NFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMCwgMC41NTIzMV0sXG4gICAgXCI3NVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42Njg0NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42NjYwMl0sXG4gICAgXCI3N1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMS4wNDk1M10sXG4gICAgXCI3OFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MzIxMl0sXG4gICAgXCI3OVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MjY5OV0sXG4gICAgXCI4MFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC44Mjc1M10sXG4gICAgXCI4MVwiOiBbMC4wMzc4MSwgMC42OTE0MSwgMCwgMCwgMC44MjY5OV0sXG4gICAgXCI4MlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MjgwN10sXG4gICAgXCI4M1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44Mjg2MV0sXG4gICAgXCI4NFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42Njg5OV0sXG4gICAgXCI4NVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42NDU3Nl0sXG4gICAgXCI4NlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MzEzMV0sXG4gICAgXCI4N1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMS4wNDYwMl0sXG4gICAgXCI4OFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43MTkyMl0sXG4gICAgXCI4OVwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC44MzI5M10sXG4gICAgXCI5MFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMCwgMC42MDIwMV0sXG4gICAgXCI5MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI5M1wiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC40OTk2NV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDA0Nl0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41MTMxNV0sXG4gICAgXCI5OVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC4zODk0Nl0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuNDk4NTddLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjQwMDUzXSxcbiAgICBcIjEwMlwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC4zMjYyNl0sXG4gICAgXCIxMDNcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAzN10sXG4gICAgXCIxMDRcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuNTIxMjZdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI3ODk5XSxcbiAgICBcIjEwNlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yODA4OF0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMzg5NDZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI3OTUzXSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC43NjY3Nl0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTI2NjZdLFxuICAgIFwiMTExXCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjQ4ODg1XSxcbiAgICBcIjExMlwiOiBbMC4xODkwNiwgMC41MjM5NiwgMCwgMCwgMC41MDA0Nl0sXG4gICAgXCIxMTNcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNDg5MTJdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjM4OTE5XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC40NDI2Nl0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuMzMzMDFdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUxNzJdLFxuICAgIFwiMTE4XCI6IFswLCAwLjUyMzk2LCAwLCAwLCAwLjUxMThdLFxuICAgIFwiMTE5XCI6IFswLCAwLjUyMzk2LCAwLCAwLCAwLjc3MzUxXSxcbiAgICBcIjEyMFwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC4zODg2NV0sXG4gICAgXCIxMjFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNDk4ODRdLFxuICAgIFwiMTIyXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjM5MDU0XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxNDcxXSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjE0NzFdLFxuICAgIFwiNTgxMTJcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuNDk3NDldLFxuICAgIFwiNTgxMTNcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuNDk4M10sXG4gICAgXCI1ODExNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC4zMzMyOF0sXG4gICAgXCI1ODExNVwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC4zMjkyM10sXG4gICAgXCI1ODExNlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDM0M10sXG4gICAgXCI1ODExN1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4zMzMwMV0sXG4gICAgXCI1ODExOFwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4zMzQwOV0sXG4gICAgXCI1ODExOVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDA3M11cbiAgfSxcbiAgXCJNYWluLUJvbGRcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzVdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjAyNzhdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI0M1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI0NFwiOiBbMC4xOTQ0NCwgMC4xNTU1NiwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zODMzM10sXG4gICAgXCI0NlwiOiBbMCwgMC4xNTU1NiwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUyXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU1XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjU5XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjYwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjYxXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI2MlwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDMwNV0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MTgwNV0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44ODE5NF0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NTU1NV0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43MjM2MV0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45MDQxNl0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45XSxcbiAgICBcIjczXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjQzNjExXSxcbiAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjU5NDQ0XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjkwMTM4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjY5MTY2XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLCAwLCAxLjA5MTY2XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODYzODhdLFxuICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzg2MTFdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjg2MTEsIDAsIDAsIDAuODYzODhdLFxuICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODYyNV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg4NDcyXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjAxNTk3LCAwLCAwLjg2OTQ0XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjAxNTk3LCAwLCAxLjE4ODg4XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjAyODc1LCAwLCAwLjg2OTQ0XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTVcIjogWzAuMzEsIDAuMTM0NDQsIDAuMDMxOTQsIDAsIDAuNTc1XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU1OTAyXSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTI3MDhdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjEwOTAzLCAwLCAwLjM1MTM5XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTU5NywgMCwgMC41NzVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMzUxMzldLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwNjk0XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MDY5NF0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDczNjFdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ1MzYxXSxcbiAgICBcIjExNlwiOiBbMCwgMC42MzQ5MiwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjYwNjk0XSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4wMTU5NywgMCwgMC44MzA1NV0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjYwNjk0XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCIxMjNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjEyNFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zNDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44Njg1M10sXG4gICAgXCIxNjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjE3MlwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiMTc3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCIxOThcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDEuMDQxNjZdLFxuICAgIFwiMjE1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjIxNlwiOiBbMC4wNDg2MSwgMC43MzQ3MiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIyMjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTk3MjJdLFxuICAgIFwiMjMwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjI0N1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIyNDhcIjogWzAuMDk3MjIsIDAuNTQxNjcsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCIzMzhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDEuMTY5NDRdLFxuICAgIFwiMzM5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC4zNTEzOV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjU5NjExLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjczMlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNjkxNjZdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODA1NTVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMCwgMC41NzVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDI3OF0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwMjc4XSxcbiAgICBcIjgyMjRcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODIyNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4MjQyXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjM0NDQ0XSxcbiAgICBcIjg0MDdcIjogWzAsIDAuNzI0NDQsIDAuMTU0ODYsIDAsIDAuNTc1XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY3NTldLFxuICAgIFwiODQ2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI4NDY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ3MzYxXSxcbiAgICBcIjg0NzJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNzQwMjddLFxuICAgIFwiODQ3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI4NTAxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg1OTJcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg1OTNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg1OTRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg1OTVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg1OTZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg1OTdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg1OThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjAwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2MDFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODYzNlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODYzN1wiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY0MFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY0MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY1NlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY1N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4NjU4XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjU5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg2NjBcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NjFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODcwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4NzA2XCI6IFswLCAwLjY5NDQ0LCAwLjA2Mzg5LCAwLCAwLjYyODQ3XSxcbiAgICBcIjg3MDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODcwOVwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcxMVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45NTgzM10sXG4gICAgXCI4NzEyXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3MTVcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODcyMlwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzIzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MjdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzI4XCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyOVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MzBcIjogWzAuMTgsIDAuODIsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiODczM1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzM0XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczOVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI4NzQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzQzXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3NDRcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0NVwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3NDdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTI3NzgsIDAsIDAuNTY4NzVdLFxuICAgIFwiODc2NFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODc2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI4NzcxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3NzNcIjogWzAuMDI3LCAwLjYzOCwgMCwgMCwgMC44OTRdLFxuICAgIFwiODc3NlwiOiBbMC4wMjQ0NCwgMC41MjQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzgxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MDFcIjogWzAuMDAyMjIsIDAuNTAyMjIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgwNFwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODA1XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MTBcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODgxMVwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4ODI2XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MjdcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgzNFwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM1XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MzhcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgzOVwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg4NDlcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1MFwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg4NTJcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODg1M1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODU0XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTVcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1NlwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODU3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODg2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODkwMFwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg5MDFcIjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjg5MDJcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjg5NjlcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk3MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjg5OTRcIjogWy0wLjEzODg5LCAwLjM2MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg5OTVcIjogWy0wLjEzODg5LCAwLjM2MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjk2NTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMDIyMjJdLFxuICAgIFwiOTY1N1wiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjk2NjFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMDIyMjJdLFxuICAgIFwiOTY2N1wiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiOTgyNFwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5ODI1XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MjZcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTgyN1wiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5ODM3XCI6IFswLCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjk4MzhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiOTgzOVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCIxMDIxNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCIxMDIxN1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCIxMDgxNVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45XSxcbiAgICBcIjEwOTI3XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjEwOTI4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjU3Mzc2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwXVxuICB9LFxuICBcIk1haW4tQm9sZEl0YWxpY1wiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMC4xMTQxNywgMCwgMC4zODYxMV0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMC4wNzkzOSwgMCwgMC42MjA1NV0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjgzMywgMCwgMC45NDQ0NF0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMC4xMjg2MSwgMCwgMC45NDQ0NF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMC4wODUyOCwgMCwgMC44ODU1NV0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMC4xNTgwNiwgMCwgMC40NzMzM10sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMC4wMzMwNiwgMCwgMC40NzMzM10sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xNDMzMywgMCwgMC41OTExMV0sXG4gICAgXCI0M1wiOiBbMC4xMDMzMywgMC42MDMzMywgMC4wMzMwNiwgMCwgMC44ODU1NV0sXG4gICAgXCI0NFwiOiBbMC4xOTQ0NCwgMC4xNDcyMiwgMCwgMCwgMC4zNTU1NV0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMC4wMjYxMSwgMCwgMC40MTQ0NF0sXG4gICAgXCI0NlwiOiBbMCwgMC4xNDcyMiwgMCwgMCwgMC4zNTU1NV0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMC4xNTgwNiwgMCwgMC41OTExMV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMC4xMzE2NywgMCwgMC41OTExMV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMC4wNjY5NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNjY5NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI2MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAuMDY4MzMsIDAsIDAuODg1NTVdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAuMDkyMDgsIDAsIDAuODg1NTVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY1NTVdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg2MTEsIDAuMDk5MiwgMCwgMC44MTY2Nl0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMC4xNDIwOCwgMCwgMC44MjY2Nl0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44NzU1NV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMC43NTY2Nl0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMC4xMjkwMywgMCwgMC43MjcyMl0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODYxMSwgMC4wNzM0NywgMCwgMC44OTUyN10sXG4gICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMC44OTYxXSxcbiAgICBcIjczXCI6IFswLCAwLjY4NjExLCAwLjE1NjgxLCAwLCAwLjQ3MTY2XSxcbiAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLjE0NSwgMCwgMC42MTA1NV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMC4xNDIwOCwgMCwgMC44OTQ5OV0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42OTc3N10sXG4gICAgXCI3N1wiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMS4wNzI3N10sXG4gICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMC44OTYxXSxcbiAgICBcIjc5XCI6IFswLCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg1NDk5XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLjA5OTIsIDAsIDAuNzg3MjFdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODU0OTldLFxuICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAuMDI1NTksIDAsIDAuODU5NDRdLFxuICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAuMTEyNjQsIDAsIDAuNjQ5OTldLFxuICAgIFwiODRcIjogWzAsIDAuNjg2MTEsIDAuMTI5MDMsIDAsIDAuNzk2MV0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMC44ODA4M10sXG4gICAgXCI4NlwiOiBbMCwgMC42ODYxMSwgMC4xODYyNSwgMCwgMC44NjU1NV0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4xODYyNSwgMCwgMS4xNTk5OV0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMC4xNTY4MSwgMCwgMC44NjU1NV0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODYxMSwgMC4xOTgwMywgMCwgMC44NjU1NV0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMC4xNDIwOCwgMCwgMC43MDg4OF0sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMC4xODc1LCAwLCAwLjM1NjExXSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLjA5OTcyLCAwLCAwLjM1NjExXSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLjA2NzA5LCAwLCAwLjU5MTExXSxcbiAgICBcIjk1XCI6IFswLjMxLCAwLjEzNDQ0LCAwLjA5ODExLCAwLCAwLjU5MTExXSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjU5MTExXSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLjA3ODYxLCAwLCAwLjUzMjIyXSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLjA1MjIyLCAwLCAwLjUzMjIyXSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMC4xMDg2MSwgMCwgMC41OTExMV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAuMDg1LCAwLCAwLjUzMjIyXSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4yMTc3OCwgMCwgMC40XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDUsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLjA5NDI2LCAwLCAwLjU5MTExXSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTMyNiwgMC4xMTM4NywgMCwgMC4zNTU1NV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMTY3MiwgMCwgMC4zNTU1NV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMTExMTEsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjEwODYxLCAwLCAwLjI5NjY2XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC45NDQ0NF0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuNjQ5OTldLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLjA3ODYxLCAwLCAwLjU5MTExXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNzg2MSwgMCwgMC41OTExMV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA1LCAwLCAwLjUzMjIyXSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4xMTExMSwgMCwgMC41MDE2N10sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAuMDgxNjcsIDAsIDAuNDg2OTRdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYzNDkyLCAwLjA5NjM5LCAwLCAwLjM4NV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuNjIwNTVdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjExMTExLCAwLCAwLjUzMjIyXSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4xMTExMSwgMCwgMC43Njc3N10sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAuMTI1ODMsIDAsIDAuNTYwNTVdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwNSwgMCwgMC41NjE2Nl0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMTM4ODksIDAsIDAuNDkwNTVdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjM0NDQ0LCAwLjExNDcyLCAwLCAwLjU5MTExXSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzMsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjk0ODg4XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC41MzIyMl0sXG4gICAgXCIxOThcIjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDEuMDIyNzddLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczNDcyLCAwLjA5MDYyLCAwLCAwLjg4NTU1XSxcbiAgICBcIjIyM1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wOTczNiwgMCwgMC42NjVdLFxuICAgIFwiMjMwXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NSwgMCwgMC44MjY2Nl0sXG4gICAgXCIyNDhcIjogWzAuMDk3MjIsIDAuNTQxNjcsIDAuMDk0NTgsIDAsIDAuNTkxMTFdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjM1NTU1XSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMS4xNDA1NF0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDQ0NDQsIDAuMDg1LCAwLCAwLjgyNjY2XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNDYxMSwgMCwgMC4zODVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLjA2NzA5LCAwLCAwLjU5MTExXSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMC4wODI3MSwgMCwgMC41OTExMV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTk0NDQsIDAuMTA0NDQsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLjA4NTI4LCAwLCAwLjU5MTExXSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41OTExMV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45NDg4OF0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLjExNDcyLCAwLCAwLjU5MTExXSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xMjkwMywgMCwgMC42OTc3N10sXG4gICAgXCI5MTZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTQ0NDRdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg4NTU1XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDY2Nl0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjg2MTEsIDAuMTUwOTIsIDAsIDAuNzY3NzddLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg5NjFdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAwLjgyNjY2XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMC4xMDc3OCwgMCwgMC44ODU1NV0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAuMDU2MzIsIDAsIDAuODI2NjZdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4NjExLCAwLjEwNzc4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMC4wOTkyLCAwLCAwLjgyNjY2XSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDk4MTEsIDAsIDAuNTkxMTFdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wOTgxMSwgMCwgMS4xODIyMV0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMC4xNjc3MiwgMCwgMC42MjA1NV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLjA3OTM5LCAwLCAwLjYyMDU1XVxuICB9LFxuICBcIk1haW4tSXRhbGljXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwLCAwLjUxNDQ0XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2NjE2LCAwLCAwLjgxNzc3XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLjEzNjM5LCAwLCAwLjgxNzc3XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwLCAwLjc2NjY2XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwLCAwLjQwODg5XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzNjk0LCAwLCAwLjQwODg5XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLjE0OTE3LCAwLCAwLjUxMTExXSxcbiAgICBcIjQzXCI6IFswLjA1NjY3LCAwLjU2MTY3LCAwLjAzNjk0LCAwLCAwLjc2NjY2XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwLCAwLjMwNjY3XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLjAyODI2LCAwLCAwLjM1Nzc4XSxcbiAgICBcIjQ2XCI6IFswLCAwLjEwNTU2LCAwLCAwLCAwLjMwNjY3XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwLCAwLjUxMTExXSxcbiAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjUyXCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU1XCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSxcbiAgICBcIjU4XCI6IFswLCAwLjQzMDU2LCAwLjA1ODIsIDAsIDAuMzA2NjddLFxuICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDU4MiwgMCwgMC4zMDY2N10sXG4gICAgXCI2MVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAuMDY2MTYsIDAsIDAuNzY2NjZdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAuMTIyNSwgMCwgMC41MTExMV0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTU5NywgMCwgMC43NjY2Nl0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NDMzM10sXG4gICAgXCI2NlwiOiBbMCwgMC42ODMzMywgMC4xMDI1NywgMCwgMC43MDM4OV0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMCwgMC43MTU1NV0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMCwgMC43NTVdLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuNjc4MzNdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAuMTMzMDUsIDAsIDAuNjUyNzddLFxuICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAuMDg3MjIsIDAsIDAuNzczNjFdLFxuICAgIFwiNzJcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMTU4MDYsIDAsIDAuMzg1NTVdLFxuICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMTQwMjgsIDAsIDAuNTI1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjc2ODg4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYyNzIyXSxcbiAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjg5NjY2XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSxcbiAgICBcIjc5XCI6IFswLCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc2NjY2XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwLCAwLjY3ODMzXSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc2NjY2XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4MzMzLCAwLjAzODY4LCAwLCAwLjcyOTQ0XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjExOTcyLCAwLCAwLjU2MjIyXSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwLCAwLjcxNTU1XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwLCAwLjc0MzMzXSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwLCAwLjk5ODg4XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE1ODA2LCAwLCAwLjc0MzMzXSxcbiAgICBcIjg5XCI6IFswLCAwLjY4MzMzLCAwLjE5MzgzLCAwLCAwLjc0MzMzXSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjYxMzMzXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLjE4NzUsIDAsIDAuMzA2NjddLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAuMTA1MjgsIDAsIDAuMzA2NjddLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDAsIDAuNTExMTFdLFxuICAgIFwiOTVcIjogWzAuMzEsIDAuMTIwNTYsIDAuMDkyMDgsIDAsIDAuNTExMTFdLFxuICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuNTExMTFdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDYzMTIsIDAsIDAuNDZdLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAuMDU2NTMsIDAsIDAuNDZdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLjEwMzMzLCAwLCAwLjUxMTExXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMCwgMC40Nl0sXG4gICAgXCIxMDJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMjExOTQsIDAsIDAuMzA2NjddLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwLCAwLjQ2XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wNzY3MSwgMCwgMC41MTExMV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjU1MzYsIDAuMTAxOSwgMCwgMC4zMDY2N10sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU1MzYsIDAuMTQ0NjcsIDAsIDAuMzA2NjddLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjEwNzY0LCAwLCAwLjQ2XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4xMDMzMywgMCwgMC4yNTU1NV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuODE3NzddLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwLCAwLjU2MjIyXSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMC4wNjMxMiwgMCwgMC41MTExMV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDYzMTIsIDAsIDAuNTExMTFdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwLCAwLjQ2XSxcbiAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMCwgMC40MjE2Nl0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAuMDgyMDgsIDAsIDAuNDA4ODldLFxuICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLjA5NDg2LCAwLCAwLjMzMjIyXSxcbiAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC41MzY2Nl0sXG4gICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDAsIDAuNDZdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwLCAwLjY2NDQ0XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMC4xMjA0MiwgMCwgMC40NjM4OV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDg1NTVdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLjEyMjkyLCAwLCAwLjQwODg5XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMC4xMTU4NSwgMCwgMC41MTExMV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY2Nzg2LCAwLjEwNDc0LCAwLCAwLjUxMTExXSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzEyOV0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDZdLFxuICAgIFwiMTk4XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjg4Mjc3XSxcbiAgICBcIjIxNlwiOiBbMC4wNDg2MSwgMC43MzE5NCwgMC4wOTQwMywgMCwgMC43NjY2Nl0sXG4gICAgXCIyMjNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTA1MTQsIDAsIDAuNTM2NjZdLFxuICAgIFwiMjMwXCI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjcxNTU1XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41Mjc3OCwgMC4wOTE5NCwgMCwgMC41MTExMV0sXG4gICAgXCIzMzhcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuOTg0OTldLFxuICAgIFwiMzM5XCI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjcxNTU1XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMC4wNjY0NiwgMCwgMC41MTExMV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjI4NDcsIDAuMDgyOTUsIDAsIDAuNTExMTFdLFxuICAgIFwiNzEzXCI6IFswLCAwLjU2MTY3LCAwLjEwMzMzLCAwLCAwLjUxMTExXSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMC4wOTY5NCwgMCwgMC41MTExMV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLjEwODA2LCAwLCAwLjUxMTExXSxcbiAgICBcIjcyOVwiOiBbMCwgMC42Njc4NiwgMC4xMTc1MiwgMCwgMC4zMDY2N10sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMxMjldLFxuICAgIFwiNzMyXCI6IFswLCAwLjY2Nzg2LCAwLjExNTg1LCAwLCAwLjUxMTExXSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwLCAwLjUxMTExXSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMCwgMC42MjcyMl0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuODE3NzddLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42OTIyMl0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMTUyOTQsIDAsIDAuNjY0NDRdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMCwgMC43MTU1NV0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTExMTEsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4MzMzLCAwLjA1OTg2LCAwLCAwLjcxNTU1XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMCwgMC43NjY2Nl0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDAsIDAuNzE1NTVdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40MzA1NiwgMC4wOTIwOCwgMCwgMC41MTExMV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwLCAxLjAyMjIyXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMCwgMC4zMDY2N10sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE2ODUsIDAsIDAuNTE0NDRdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMC4wNjk2MSwgMCwgMC41MTQ0NF0sXG4gICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XVxuICB9LFxuICBcIk1haW4tUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI0M1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI0NFwiOiBbMC4xOTQ0NCwgMC4xMDU1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0NVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4zMzMzM10sXG4gICAgXCI0NlwiOiBbMCwgMC4xMDU1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNjBcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2MlwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzA4MzRdLFxuICAgIFwiNjdcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzYzODldLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjgwNTZdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjUyNzhdLFxuICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzg0NzJdLFxuICAgIFwiNzJcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuMzYxMTFdLFxuICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNTEzODldLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjI1XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjkxNjY3XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY4MDU2XSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjczNjExXSxcbiAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjAxMzg5LCAwLCAwLjc1XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjAxMzg5LCAwLCAxLjAyNzc4XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4MzMzLCAwLjAyNSwgMCwgMC43NV0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42MTExMV0sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI5MlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTVcIjogWzAuMzEsIDAuMTIwNTYsIDAuMDI3NzgsIDAsIDAuNV0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjA3Nzc4LCAwLCAwLjMwNTU2XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjY3ODYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY2Nzg2LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4zOTE2N10sXG4gICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMzk0NDVdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDAsIDAuNTI3NzhdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjcyMjIyXSxcbiAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDEzODksIDAsIDAuNTI3NzhdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjEyNFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzE3ODYsIDAsIDAsIDAuNV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc2OTA5XSxcbiAgICBcIjE2N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAsIDAsIDAuNV0sXG4gICAgXCIxNzJcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc1XSxcbiAgICBcIjE3N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxODJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC45MDI3OF0sXG4gICAgXCIyMTVcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczMTk0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjIyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjIzMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCIyNDdcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMjQ4XCI6IFswLjA5NzIyLCAwLjUyNzc4LCAwLCAwLCAwLjVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMS4wMTM4OV0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42Mjg0NywgMCwgMCwgMC41XSxcbiAgICBcIjcxM1wiOiBbMCwgMC41Njc3OCwgMCwgMCwgMC41XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzVdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjVdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYyNV0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42OTQ0NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMC41XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAsIDEuMF0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4MjI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjgyMjVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODIzMFwiOiBbMCwgMC4xMjMsIDAsIDAsIDEuMTcyXSxcbiAgICBcIjgyNDJcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuMjc1XSxcbiAgICBcIjg0MDdcIjogWzAsIDAuNzE0NDQsIDAuMTUzODIsIDAsIDAuNV0sXG4gICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSxcbiAgICBcIjg0NjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODQ2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4xMTExMSwgMC40MTY2N10sXG4gICAgXCI4NDcyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjExMTExLCAwLjYzNjQ2XSxcbiAgICBcIjg0NzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODUwMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NTkyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg1OTNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4NTk0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg1OTVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4NTk2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg1OTdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NTk4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDBcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjAxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiODYxNFwiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjBdLFxuICAgIFwiODYxN1wiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjEyNl0sXG4gICAgXCI4NjE4XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMTI2XSxcbiAgICBcIjg2MzZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODYzN1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQwXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1MlwiOiBbMC4wMTEsIDAuNjcxLCAwLCAwLCAxLjBdLFxuICAgIFwiODY1NlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg2NThcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NjYwXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NjFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODcwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzA2XCI6IFswLCAwLjY5NDQ0LCAwLjA1NTU2LCAwLjA4MzM0LCAwLjUzMDldLFxuICAgIFwiODcwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcxMVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4NzEyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzE1XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzIyXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MjNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjhcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyOVwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzMwXCI6IFswLjIsIDAuOCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4NzMzXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MzRcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzlcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODc0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc0NFwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMTExMSwgMCwgMC40MTY2N10sXG4gICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg3NzFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzNcIjogWy0wLjAyMiwgMC41ODksIDAsIDAsIDAuNzc4XSxcbiAgICBcIjg3NzZcIjogWy0wLjAxNjg4LCAwLjQ4MzEyLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODRcIjogWy0wLjEzMywgMC42NzMsIDAsIDAsIDAuNzc4XSxcbiAgICBcIjg4MDFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDRcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwNVwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODEwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMS4wXSxcbiAgICBcIjg4MTFcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAxLjBdLFxuICAgIFwiODgyNlwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyN1wiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzNFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzNVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzOFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODg0OVwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODUwXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTFcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODg1MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4ODUzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTRcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1NVwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU2XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTdcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODcyXCI6IFswLjI0OSwgMC43NSwgMCwgMCwgMC44NjddLFxuICAgIFwiODkwMFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuNV0sXG4gICAgXCI4OTAxXCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4OTAyXCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSxcbiAgICBcIjg5MDRcIjogWzAuMDA1LCAwLjUwNSwgMCwgMCwgMC45XSxcbiAgICBcIjg5NDJcIjogWzAuMDMsIDAuOTAzLCAwLCAwLCAwLjI3OF0sXG4gICAgXCI4OTQzXCI6IFstMC4xOSwgMC4zMTMsIDAsIDAsIDEuMTcyXSxcbiAgICBcIjg5NDVcIjogWy0wLjEsIDAuODIzLCAwLCAwLCAxLjI4Ml0sXG4gICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg5NjlcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk3MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg5OTRcIjogWy0wLjE0MjM2LCAwLjM1NzY0LCAwLCAwLCAxLjBdLFxuICAgIFwiODk5NVwiOiBbLTAuMTQyMzYsIDAuMzU3NjQsIDAsIDAsIDEuMF0sXG4gICAgXCI5MTM2XCI6IFswLjI0NCwgMC43NDQsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjkxMzdcIjogWzAuMjQ0LCAwLjc0NSwgMCwgMCwgMC40MTJdLFxuICAgIFwiOTY1MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5NjU3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSxcbiAgICBcIjk2NjFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTY2N1wiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDAsIDAuNV0sXG4gICAgXCI5NzExXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiOTgyNFwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5ODI1XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MjZcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTgyN1wiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5ODM3XCI6IFswLCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjk4MzhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiOTgzOVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCIxMDIxNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCIxMDIxN1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCIxMDIyMlwiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwLCAwLjQxMl0sXG4gICAgXCIxMDIyM1wiOiBbMC4yNDQsIDAuNzQ1LCAwLCAwLCAwLjQxMl0sXG4gICAgXCIxMDIyOVwiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjYwOV0sXG4gICAgXCIxMDIzMFwiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjYzOF0sXG4gICAgXCIxMDIzMVwiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjg1OV0sXG4gICAgXCIxMDIzMlwiOiBbMC4wMjQsIDAuNTI1LCAwLCAwLCAxLjYwOV0sXG4gICAgXCIxMDIzM1wiOiBbMC4wMjQsIDAuNTI1LCAwLCAwLCAxLjYzOF0sXG4gICAgXCIxMDIzNFwiOiBbMC4wMjQsIDAuNTI1LCAwLCAwLCAxLjg1OF0sXG4gICAgXCIxMDIzNlwiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjYzOF0sXG4gICAgXCIxMDgxNVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCIxMDkyN1wiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkyOFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM3NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMF1cbiAgfSxcbiAgXCJNYXRoLUJvbGRJdGFsaWNcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjQ5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1M1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU1XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwLCAwLjg2NjRdLFxuICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAuMDY5NzksIDAsIDAuODE2OTRdLFxuICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDAsIDAuOTM4MTJdLFxuICAgIFwiNjlcIjogWzAsIDAuNjg2MTEsIDAuMDU0NTEsIDAsIDAuODEwMDddLFxuICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjg4ODldLFxuICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODg2NzNdLFxuICAgIFwiNzJcIjogWzAsIDAuNjg2MTEsIDAuMDgyMjksIDAsIDAuOTgyMjldLFxuICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAuMDc3NzgsIDAsIDAuNTExMTFdLFxuICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTAwNjksIDAsIDAuNjMxMjVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjg2MTEsIDAuMDY5NzksIDAsIDAuOTcxMThdLFxuICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzU1NTVdLFxuICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDAsIDEuMTQyMDFdLFxuICAgIFwiNzhcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDAsIDAuOTUwMzRdLFxuICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDAsIDAuODM2NjZdLFxuICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNzIzMDldLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjg2MTEsIDAsIDAsIDAuODY4NjFdLFxuICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAuMDA0MjEsIDAsIDAuODcyMzVdLFxuICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAuMDUzODIsIDAsIDAuNjkyNzFdLFxuICAgIFwiODRcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjM2NjNdLFxuICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDAsIDAuODAwMjddLFxuICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDAsIDAuNjc3NzhdLFxuICAgIFwiODdcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDEuMDkzMDVdLFxuICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAuMDc3NzgsIDAsIDAuOTQ3MjJdLFxuICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDAsIDAuNjc0NThdLFxuICAgIFwiOTBcIjogWzAsIDAuNjg2MTEsIDAuMDY5NzksIDAsIDAuNzcyNTddLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjMyODddLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTIwODNdLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTEzNDJdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwOTcyXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NTM2MV0sXG4gICAgXCIxMDJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTEwNDIsIDAsIDAuNTY4MDZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjU0NDldLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NzU5XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTMyNiwgMCwgMCwgMC40MDQ4XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTMyNiwgMC4wNjIyLCAwLCAwLjQ3MDgzXSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMTg1MiwgMCwgMC42MDM3XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4wMDg4LCAwLCAwLjM0ODE1XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMS4wMzI0XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC43MTI5Nl0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTg0NzJdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYwMDkyXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41NDIxM10sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDAuNTI4N10sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTMxMjVdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYzNDkyLCAwLCAwLCAwLjQxNTI4XSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42ODEwMl0sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTY2NjZdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAyNzc4LCAwLCAwLjgzMTQ4XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42NTkwM10sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTkwMjhdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLjA0MjEzLCAwLCAwLjU1NTA5XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjU2OTRdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC44NjcyMl0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODA1NTVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4NjExLCAwLjA3NDU4LCAwLCAwLjg0MTI1XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODYxMSwgMC4wODIyOSwgMCwgMC45ODIyOV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAuMDU0NTEsIDAsIDAuODg1MDddLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjY3MDgzXSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAuMTE2NTMsIDAsIDAuNzE0MDJdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwLCAwLjg3ODldLFxuICAgIFwiOTQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc2MDY0XSxcbiAgICBcIjk0NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzQwMywgMCwgMC42NTk3Ml0sXG4gICAgXCI5NDdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDYzODksIDAsIDAuNTkwMDNdLFxuICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzODE5LCAwLCAwLjUyMjIyXSxcbiAgICBcIjk0OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41Mjg4Ml0sXG4gICAgXCI5NTBcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDYyMTUsIDAsIDAuNTA4MzNdLFxuICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjZdLFxuICAgIFwiOTUyXCI6IFswLCAwLjY5NDQ0LCAwLjAzMTk0LCAwLCAwLjU2MThdLFxuICAgIFwiOTUzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQxMjA0XSxcbiAgICBcIjk1NFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42Njc1OV0sXG4gICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjcwODNdLFxuICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjcwNzg3XSxcbiAgICBcIjk1N1wiOiBbMCwgMC40NDQ0NCwgMC4wNjg5OCwgMCwgMC41NzY4NV0sXG4gICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDMwMjEsIDAsIDAuNTA4MzNdLFxuICAgIFwiOTU5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU4NDcyXSxcbiAgICBcIjk2MFwiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC42ODI0MV0sXG4gICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjExOF0sXG4gICAgXCI5NjJcIjogWzAuMDk3MjIsIDAuNDQ0NDQsIDAuMDc5MTcsIDAsIDAuNDIzNjFdLFxuICAgIFwiOTYzXCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjY4NTg4XSxcbiAgICBcIjk2NFwiOiBbMCwgMC40NDQ0NCwgMC4xMzQ3MiwgMCwgMC41MjA4M10sXG4gICAgXCI5NjVcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNjMwNTVdLFxuICAgIFwiOTY2XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjc0NzIyXSxcbiAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43MTgwNV0sXG4gICAgXCI5NjhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDM3MDQsIDAsIDAuNzU4MzNdLFxuICAgIFwiOTY5XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjcxNzgyXSxcbiAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42OTE1NV0sXG4gICAgXCI5ODFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzEyNV0sXG4gICAgXCI5ODJcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDAuOTc1XSxcbiAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjExOF0sXG4gICAgXCIxMDEzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ4MzMzXSxcbiAgICBcIjU3NjQ5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjM5MzUyXSxcbiAgICBcIjU3OTExXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjQzODg5XVxuICB9LFxuICBcIk1hdGgtSXRhbGljXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjQ4XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1M1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODksIDAuNzVdLFxuICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzQsIDAuNzU4NTFdLFxuICAgIFwiNjdcIjogWzAsIDAuNjgzMzMsIDAuMDcxNTMsIDAuMDgzMzQsIDAuNzE0NzJdLFxuICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTYsIDAuODI3OTJdLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNzM4Ml0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC42NDMwNl0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC43ODYyNV0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1NiwgMC44MzEyNV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMSwgMC40Mzk1OF0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMC4wOTYxOCwgMC4xNjY2NywgMC41NTQ1MV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wNTU1NiwgMC44NDkzMV0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OCwgMC42ODA1Nl0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wODMzNCwgMC45NzAxNF0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wODMzNCwgMC44MDM0N10sXG4gICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNCwgMC43NjI3OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC42NDIwMV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC43OTA1Nl0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNCwgMC43NTkyOV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODMzMywgMC4wNTc2NCwgMC4wODMzNCwgMC42MTMyXSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjU4NDM4XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjAyNzc4LCAwLjY4Mjc4XSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjIyMjIyLCAwLCAwLjU4MzMzXSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjA3ODQ3LCAwLjA4MzM0LCAwLjgyODQ3XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4MzMzLCAwLjIyMjIyLCAwLCAwLjU4MDU2XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0LCAwLjY4MjY0XSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyODU5XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQyOTE3XSxcbiAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQzMjc2XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMC4xNjY2NywgMC41MjA0OV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDY1NjNdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3LCAwLjQ4OTU5XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC40NzY5N10sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc2MTZdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwLCAwLjM0NDUxXSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTk1MiwgMC4wNTcyNCwgMCwgMC40MTE4MV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMDMxNDgsIDAsIDAuNTIwNl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDE5NjgsIDAuMDgzMzQsIDAuMjk4MzhdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjg3ODAxXSxcbiAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC42MDAyM10sXG4gICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDg0NzJdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUwMzEzXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNCwgMC40NDY0MV0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAuMDU1NTYsIDAuNDUxMTZdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ2ODc1XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNCwgMC4zNjExMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNTcyNDZdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjQ4NDcyXSxcbiAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNCwgMC43MTU5Ml0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNTcxNTNdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2LCAwLjQ5MDI4XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1NiwgMC40NjUwNV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjYxNTI4XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODMzMywgMCwgMC4xNjY2NywgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzYyNzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3LCAwLjY5NDQ1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODMzMywgMC4wNzU2OSwgMC4wODMzNCwgMC43NDIzNl0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMDgxMjUsIDAuMDU1NTYsIDAuODMxMjVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0LCAwLjc3OTg2XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wNTU1NiwgMC41ODMzM10sXG4gICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNjY2NjddLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2LCAwLjYxMjIyXSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODMzMywgMC4wNTAxNywgMC4wODMzNCwgMC43NzI0XSxcbiAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4LCAwLjYzOTddLFxuICAgIFwiOTQ2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA1Mjc4LCAwLjA4MzM0LCAwLjU2NTYzXSxcbiAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMCwgMC41MTc3M10sXG4gICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM3ODUsIDAuMDU1NTYsIDAuNDQ0NDRdLFxuICAgIFwiOTQ5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjQ2NjMyXSxcbiAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNCwgMC40Mzc1XSxcbiAgICBcIjk1MVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wNTU1NiwgMC40OTY1M10sXG4gICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNDY5NDRdLFxuICAgIFwiOTUzXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjM1Mzk0XSxcbiAgICBcIjk1NFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41NzYxNl0sXG4gICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjYwMjU1XSxcbiAgICBcIjk1N1wiOiBbMCwgMC40MzA1NiwgMC4wNjM2NiwgMC4wMjc3OCwgMC40OTM5OF0sXG4gICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTEsIDAuNDM3NV0sXG4gICAgXCI5NTlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDg0NzJdLFxuICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjU3MDAzXSxcbiAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MTcwMl0sXG4gICAgXCI5NjJcIjogWzAuMDk3MjIsIDAuNDMwNTYsIDAuMDc5ODYsIDAuMDgzMzQsIDAuMzYyODVdLFxuICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjU3MTQxXSxcbiAgICBcIjk2NFwiOiBbMCwgMC40MzA1NiwgMC4xMTMyLCAwLjAyNzc4LCAwLjQzNzE1XSxcbiAgICBcIjk2NVwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC41NDAyOF0sXG4gICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNjU0MTddLFxuICAgIFwiOTY3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjYyNTY5XSxcbiAgICBcIjk2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzU4OCwgMC4xMTExMSwgMC42NTEzOV0sXG4gICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNjIyNDVdLFxuICAgIFwiOTc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjA4MzM0LCAwLjU5MTQ0XSxcbiAgICBcIjk4MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMC4wODMzNCwgMC41OTU4M10sXG4gICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAsIDAuODI4MTNdLFxuICAgIFwiMTAwOVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MTcwMl0sXG4gICAgXCIxMDEzXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQwNTldLFxuICAgIFwiNTc2NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuMzIyNDZdLFxuICAgIFwiNTc5MTFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuMzg0MDNdXG4gIH0sXG4gIFwiU2Fuc1NlcmlmLUJvbGRcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzY2NjddLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU4MzRdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuOTE2NjddLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNTVdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDEuMDI5MTJdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMwNTZdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDI3NzhdLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDI3NzhdLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAsIDAsIDAuNTVdLFxuICAgIFwiNDNcIjogWzAuMTE2NjcsIDAuNjE2NjcsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiNDRcIjogWzAuMTA1NTYsIDAuMTMwNTYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNDVcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuMzY2NjddLFxuICAgIFwiNDZcIjogWzAsIDAuMTMwNTYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNThcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNTlcIjogWzAuMTA1NTYsIDAuNDU4MzMsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNjFcIjogWy0wLjA5Mzc1LCAwLjQwNjI1LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxOTQ1XSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc4XSxcbiAgICBcIjY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY0MTY3XSxcbiAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjcxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjcyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMzMDU2XSxcbiAgICBcIjc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxOTQ1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc2Mzg5XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU4MDU2XSxcbiAgICBcIjc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjk3Nzc4XSxcbiAgICBcIjc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc4XSxcbiAgICBcIjgxXCI6IFswLjEwNTU2LCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjgyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc4XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc2Mzg5XSxcbiAgICBcIjg2XCI6IFswLCAwLjY5NDQ0LCAwLjAxNTI4LCAwLCAwLjczMzM0XSxcbiAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjAxNTI4LCAwLCAxLjAzODg5XSxcbiAgICBcIjg4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjg5XCI6IFswLCAwLjY5NDQ0LCAwLjAyNzUsIDAsIDAuNzMzMzRdLFxuICAgIFwiOTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjcyMjNdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzQzMDZdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzQzMDZdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiOTVcIjogWzAuMzUsIDAuMTA4MzMsIDAuMDMwNTYsIDAsIDAuNTVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjk5XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjQ4ODg5XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjA3NjM5LCAwLCAwLjMzNjExXSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC41NV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI1NTU2XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4yODYxMV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTMwNTZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI1NTU2XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC44NjY2N10sXG4gICAgXCIxMTBcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTExXCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjU1XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjM3MjIyXSxcbiAgICBcIjExNVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC40MjE2N10sXG4gICAgXCIxMTZcIjogWzAsIDAuNTg5MjksIDAsIDAsIDAuNDA0MTddLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjExOFwiOiBbMCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC41XSxcbiAgICBcIjExOVwiOiBbMCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC43NDQ0NV0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuNV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNDc2MzldLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjM0NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjE4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDg4ODldLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjI1NTU2XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40NTgzMywgMCwgMCwgMC4yODYxMV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzNTQyLCAwLCAwLCAwLjU1XSxcbiAgICBcIjcxM1wiOiBbMCwgMC42Mzc3OCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41ODA1Nl0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTE2NjddLFxuICAgIFwiOTIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NzIyM10sXG4gICAgXCI5MjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40NTgzMywgMC4wMzA1NiwgMCwgMC41NV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ1ODMzLCAwLjAzMDU2LCAwLCAxLjEwMDAxXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1ODM0XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU4MzRdXG4gIH0sXG4gIFwiU2Fuc1NlcmlmLUl0YWxpY1wiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMC4wNTczMywgMCwgMC4zMTk0NV0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMC4wMDMxNiwgMCwgMC41XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA1MDg3LCAwLCAwLjgzMzM0XSxcbiAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMDMxMjYsIDAsIDAuODMzMzRdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAuMDMwNTgsIDAsIDAuNzU4MzRdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAuMDc4MTYsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTMxNjQsIDAsIDAuMzg4ODldLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAuMDI1MzYsIDAsIDAuMzg4ODldLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAuMTE3NzUsIDAsIDAuNV0sXG4gICAgXCI0M1wiOiBbMC4wODMzMywgMC41ODMzMywgMC4wMjUzNiwgMCwgMC43Nzc3OF0sXG4gICAgXCI0NFwiOiBbMC4xMjUsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAuMDE5NDYsIDAsIDAuMzMzMzNdLFxuICAgIFwiNDZcIjogWzAsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAuMTMxNjQsIDAsIDAuNV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjQ5XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjUyXCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU1XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLjAyNTAyLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjU5XCI6IFswLjEyNSwgMC40NDQ0NCwgMC4wMjUwMiwgMCwgMC4yNzc3OF0sXG4gICAgXCI2MVwiOiBbLTAuMTMsIDAuMzcsIDAuMDUwODcsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAuMTE4MDksIDAsIDAuNDcyMjJdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNjY2NjddLFxuICAgIFwiNjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNjY2NjddLFxuICAgIFwiNjdcIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNjM4ODldLFxuICAgIFwiNjhcIjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzIyMjNdLFxuICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNTk3MjJdLFxuICAgIFwiNzBcIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNTY5NDVdLFxuICAgIFwiNzFcIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNjY2NjddLFxuICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNzA4MzRdLFxuICAgIFwiNzNcIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuMjc3NzhdLFxuICAgIFwiNzRcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNDcyMjJdLFxuICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNjk0NDVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQxNjddLFxuICAgIFwiNzdcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuODc1XSxcbiAgICBcIjc4XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjcwODM0XSxcbiAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjczNjExXSxcbiAgICBcIjgwXCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjYzODg5XSxcbiAgICBcIjgxXCI6IFswLjEyNSwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43MzYxMV0sXG4gICAgXCI4MlwiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC42NDU4NF0sXG4gICAgXCI4M1wiOiBbMCwgMC42OTQ0NCwgMC4wOTIwNSwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC42ODA1Nl0sXG4gICAgXCI4NVwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC42ODc1XSxcbiAgICBcIjg2XCI6IFswLCAwLjY5NDQ0LCAwLjE2MTUsIDAsIDAuNjY2NjddLFxuICAgIFwiODdcIjogWzAsIDAuNjk0NDQsIDAuMTYxNSwgMCwgMC45NDQ0NV0sXG4gICAgXCI4OFwiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC42NjY2N10sXG4gICAgXCI4OVwiOiBbMCwgMC42OTQ0NCwgMC4xNzI2MSwgMCwgMC42NjY2N10sXG4gICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42MTExMV0sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMC4xNTk0MiwgMCwgMC4yODg4OV0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4wODcxOSwgMCwgMC4yODg4OV0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMC4wNzk5LCAwLCAwLjVdLFxuICAgIFwiOTVcIjogWzAuMzUsIDAuMDk0NDQsIDAuMDg2MTYsIDAsIDAuNV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMC4wMDk4MSwgMCwgMC40ODA1Nl0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMC4wMzA1NywgMCwgMC41MTY2N10sXG4gICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMC4wODMzNiwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMDk0ODMsIDAsIDAuNTE2NjddLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLjA2Nzc4LCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4yMTcwNSwgMCwgMC4zMDU1Nl0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA4MzYsIDAsIDAuNV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAuMDE3NzgsIDAsIDAuNTE2NjddLFxuICAgIFwiMTA1XCI6IFswLCAwLjY3OTM3LCAwLjA5NzE4LCAwLCAwLjIzODg5XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NzkzNywgMC4wOTE2MiwgMCwgMC4yNjY2N10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMDgzMzYsIDAsIDAuNDg4ODldLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjA5NDgzLCAwLCAwLjIzODg5XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMC4wMTc3OCwgMCwgMC43OTQ0NV0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAuMDE3NzgsIDAsIDAuNTE2NjddLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLjA2NjEzLCAwLCAwLjVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzODksIDAsIDAuNTE2NjddLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA0MTY5LCAwLCAwLjUxNjY3XSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC4zNDE2N10sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAuMDc3OCwgMCwgMC4zODMzM10sXG4gICAgXCIxMTZcIjogWzAsIDAuNTcxNDMsIDAuMDcyMjUsIDAsIDAuMzYxMTFdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ0NDQ0LCAwLjA0MTY5LCAwLCAwLjUxNjY3XSxcbiAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC40NjExMV0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMTA4MzYsIDAsIDAuNjgzMzRdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ0NDQ0LCAwLjA5MTY5LCAwLCAwLjQ2MTExXSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC40NjExMV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMDg3NTIsIDAsIDAuNDM0NzJdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjMyNjU5LCAwLjA4ODI2LCAwLCAwLjVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42NzkzNywgMC4wNjM4NSwgMCwgMC41XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Mzc1Ml0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ0NDQ0LCAwLjA0MTY5LCAwLCAwLjIzODg5XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNDE2OSwgMCwgMC4yNjY2N10sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAuMDc5OSwgMCwgMC41XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMC4wODQzMiwgMCwgMC41XSxcbiAgICBcIjcxM1wiOiBbMCwgMC42MDg4OSwgMC4wODc3NiwgMCwgMC41XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMC4wOTIwNSwgMCwgMC41XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMC4wOTQ4MywgMCwgMC41XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42NzkzNywgMC4wNzc3NCwgMCwgMC4yNzc3OF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzM3NTJdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY3NjU5LCAwLjA4ODI2LCAwLCAwLjVdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA1LCAwLCAwLjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjU0MTY3XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42OTQ0NCwgMC4xMjgxNiwgMCwgMC42NjY2N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNzA4MzRdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzM1wiOiBbMCwgMC42OTQ0NCwgMC4wOTAzMSwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjk0NDQsIDAuMDQ2MDMsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLjA5MDMxLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC43MjIyMl0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NjE2LCAwLCAwLjVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wODYxNiwgMCwgMS4wXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAuMDc4MTYsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMC4wNzgxNiwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE0MjA1LCAwLCAwLjVdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMC4wMDMxNiwgMCwgMC41XVxuICB9LFxuICBcIlNhbnNTZXJpZi1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ1XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NTgzNF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjQzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zMzMzM10sXG4gICAgXCI0NlwiOiBbMCwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUxXCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU0XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU3XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNThcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNTlcIjogWzAuMTI1LCAwLjQ0NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyM10sXG4gICAgXCI2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCI3MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41Njk0NV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI3M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI3NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42OTQ0NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDE2N10sXG4gICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NzVdLFxuICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzA4MzRdLFxuICAgIFwiNzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiODBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLCAwLCAwLjczNjExXSxcbiAgICBcIjgyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY0NTg0XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY4MDU2XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY4NzVdLFxuICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDEzODksIDAsIDAuNjY2NjddLFxuICAgIFwiODdcIjogWzAsIDAuNjk0NDQsIDAuMDEzODksIDAsIDAuOTQ0NDVdLFxuICAgIFwiODhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI1LCAwLCAwLjY2NjY3XSxcbiAgICBcIjkwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI4ODg5XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI4ODg5XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTVcIjogWzAuMzUsIDAuMDk0NDQsIDAuMDI3NzgsIDAsIDAuNV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40ODA1Nl0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNjk0NCwgMCwgMC4zMDU1Nl0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTA1XCI6IFswLCAwLjY3OTM3LCAwLCAwLCAwLjIzODg5XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NzkzNywgMCwgMCwgMC4yNjY2N10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDg4ODldLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjIzODg5XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuMzQxNjddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjM4MzMzXSxcbiAgICBcIjExNlwiOiBbMCwgMC41NzE0MywgMCwgMCwgMC4zNjExMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjQ2MTExXSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC42ODMzNF0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjQ2MTExXSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40MzQ3Ml0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAsIDAsIDAuNV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY3OTM3LCAwLCAwLCAwLjVdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMjM4ODldLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjI2NjY3XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxM1wiOiBbMCwgMC42MDg4OSwgMCwgMCwgMC41XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42NzkzNywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzMyXCI6IFswLCAwLjY3NjU5LCAwLCAwLCAwLjVdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MTY3XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzA4MzRdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ0NDQ0LCAwLjAyNzc4LCAwLCAwLjVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wMjc3OCwgMCwgMS4wXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XVxuICB9LFxuICBcIlNjcmlwdC1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjY1XCI6IFswLCAwLjcsIDAuMjI5MjUsIDAsIDAuODAyNTNdLFxuICAgIFwiNjZcIjogWzAsIDAuNywgMC4wNDA4NywgMCwgMC45MDc1N10sXG4gICAgXCI2N1wiOiBbMCwgMC43LCAwLjE2ODksIDAsIDAuNjY2MTldLFxuICAgIFwiNjhcIjogWzAsIDAuNywgMC4wOTM3MSwgMCwgMC43NzQ0M10sXG4gICAgXCI2OVwiOiBbMCwgMC43LCAwLjE4NTgzLCAwLCAwLjU2MTYyXSxcbiAgICBcIjcwXCI6IFswLCAwLjcsIDAuMTM2MzQsIDAsIDAuODk1NDRdLFxuICAgIFwiNzFcIjogWzAsIDAuNywgMC4xNzMyMiwgMCwgMC42MDk2MV0sXG4gICAgXCI3MlwiOiBbMCwgMC43LCAwLjI5Njk0LCAwLCAwLjk2OTE5XSxcbiAgICBcIjczXCI6IFswLCAwLjcsIDAuMTkxODksIDAsIDAuODA5MDddLFxuICAgIFwiNzRcIjogWzAuMjc3NzgsIDAuNywgMC4xOTE4OSwgMCwgMS4wNTE1OV0sXG4gICAgXCI3NVwiOiBbMCwgMC43LCAwLjMxMjU5LCAwLCAwLjkxMzY0XSxcbiAgICBcIjc2XCI6IFswLCAwLjcsIDAuMTkxODksIDAsIDAuODczNzNdLFxuICAgIFwiNzdcIjogWzAsIDAuNywgMC4xNTk4MSwgMCwgMS4wODAzMV0sXG4gICAgXCI3OFwiOiBbMCwgMC43LCAwLjM1MjUsIDAsIDAuOTAxNV0sXG4gICAgXCI3OVwiOiBbMCwgMC43LCAwLjA4MDc4LCAwLCAwLjczNzg3XSxcbiAgICBcIjgwXCI6IFswLCAwLjcsIDAuMDgwNzgsIDAsIDEuMDEyNjJdLFxuICAgIFwiODFcIjogWzAsIDAuNywgMC4wMzMwNSwgMCwgMC44ODI4Ml0sXG4gICAgXCI4MlwiOiBbMCwgMC43LCAwLjA2MjU5LCAwLCAwLjg1XSxcbiAgICBcIjgzXCI6IFswLCAwLjcsIDAuMTkxODksIDAsIDAuODY3NjddLFxuICAgIFwiODRcIjogWzAsIDAuNywgMC4yOTA4NywgMCwgMC43NDY5N10sXG4gICAgXCI4NVwiOiBbMCwgMC43LCAwLjI1ODE1LCAwLCAwLjc5OTk2XSxcbiAgICBcIjg2XCI6IFswLCAwLjcsIDAuMjc1MjMsIDAsIDAuNjIyMDRdLFxuICAgIFwiODdcIjogWzAsIDAuNywgMC4yNzUyMywgMCwgMC44MDUzMl0sXG4gICAgXCI4OFwiOiBbMCwgMC43LCAwLjI2MDA2LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg5XCI6IFswLCAwLjcsIDAuMjkzOSwgMCwgMC43MDk2MV0sXG4gICAgXCI5MFwiOiBbMCwgMC43LCAwLjI0MDM3LCAwLCAwLjgyMTJdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XVxuICB9LFxuICBcIlNpemUxLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNDBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDU4MzRdLFxuICAgIFwiNDFcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDU4MzRdLFxuICAgIFwiNDdcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTc3NzhdLFxuICAgIFwiOTFcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiOTJcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTc3NzhdLFxuICAgIFwiOTNcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiMTIzXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjEyNVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjczMlwiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI3NzBcIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiNzcxXCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjgyMTRcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NTkzXCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg1OTVcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODY1N1wiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NjU5XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MTlcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODcyMFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCI4NzIxXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjA1NTU2XSxcbiAgICBcIjg3MzBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NzM5XCI6IFstMC4wMDU5OSwgMC42MDYsIDAsIDAsIDAuMzMzMzNdLFxuICAgIFwiODc0MVwiOiBbLTAuMDA1OTksIDAuNjA2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3NDdcIjogWzAuMzA2MTIsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg3NDhcIjogWzAuMzA2LCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sXG4gICAgXCI4NzQ5XCI6IFswLjMwNiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLFxuICAgIFwiODc1MFwiOiBbMC4zMDYxMiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLFxuICAgIFwiODg5NlwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4ODk3XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg4OThcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODg5OVwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4OTY4XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg5NjlcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiODk3MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI4OTcxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjkxNjhcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxMDIxNlwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCIxMDIxN1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCIxMDc1MlwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCIxMDc1M1wiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCIxMDc1NFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCIxMDc1NlwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIxMDc1OFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF1cbiAgfSxcbiAgXCJTaXplMi1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjQwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjU5NzIyXSxcbiAgICBcIjQxXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjU5NzIyXSxcbiAgICBcIjQ3XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjgxMTExXSxcbiAgICBcIjkxXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjkyXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjgxMTExXSxcbiAgICBcIjkzXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjEyM1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxMjVcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjcxMFwiOiBbMCwgMC43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjczMlwiOiBbMCwgMC43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjc3MVwiOiBbMCwgMC43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg3MTlcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMjc3NzhdLFxuICAgIFwiODcyMFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI4NzIxXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjg3MzBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NzQ3XCI6IFswLjg2MjI1LCAxLjM2LCAwLjQ0NDQ1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3NDhcIjogWzAuODYyLCAxLjM2LCAwLjQ0NDQ1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3NDlcIjogWzAuODYyLCAxLjM2LCAwLjQ0NDQ1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3NTBcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODg5NlwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4ODk3XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg4OThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODg5OVwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4OTY4XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjg5NjlcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiODk3MFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI4OTcxXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEwMjE2XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjEwMjE3XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjEwNzUyXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjUxMTEyXSxcbiAgICBcIjEwNzUzXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjUxMTEyXSxcbiAgICBcIjEwNzU0XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjUxMTEyXSxcbiAgICBcIjEwNzU2XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjEwNzU4XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXVxuICB9LFxuICBcIlNpemUzLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNDBcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiNDFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiNDdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDEuMDQ0NDVdLFxuICAgIFwiOTFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiOTJcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDEuMDQ0NDVdLFxuICAgIFwiOTNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTIzXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjc1XSxcbiAgICBcIjEyNVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjczMlwiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI3NzBcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjg3MzBcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDEuMF0sXG4gICAgXCI4OTY4XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjg5NjlcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiODk3MFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI4OTcxXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjEwMjE2XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjc1XSxcbiAgICBcIjEwMjE3XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjc1XVxuICB9LFxuICBcIlNpemU0LVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNDBcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNzkxNjddLFxuICAgIFwiNDFcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNzkxNjddLFxuICAgIFwiNDdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDEuMjc3NzhdLFxuICAgIFwiOTFcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiOTJcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDEuMjc3NzhdLFxuICAgIFwiOTNcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiMTIzXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSxcbiAgICBcIjEyNVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC44MDU1Nl0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSxcbiAgICBcIjczMlwiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sXG4gICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLFxuICAgIFwiNzcxXCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSxcbiAgICBcIjg3MzBcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4OTY4XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg5NjlcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODk3MFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4OTcxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjkxMTVcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTE2XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTE3XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTExOFwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMTlcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMjBcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTIxXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTIyXCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyM1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyNFwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyNVwiOiBbLTAuMDAwOTksIDAuNjAxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjZcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjdcIjogWzFlLTA1LCAwLjksIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEyOFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTI5XCI6IFswLjkwMDAxLCAwLCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMzBcIjogWzAsIDAuMywgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTMxXCI6IFsxZS0wNSwgMC45LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMzJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEzM1wiOiBbMC45MDAwMSwgMCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTQzXCI6IFswLjg4NTAyLCAwLjkxNSwgMCwgMCwgMS4wNTU1Nl0sXG4gICAgXCIxMDIxNlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC44MDU1Nl0sXG4gICAgXCIxMDIxN1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC44MDU1Nl0sXG4gICAgXCI1NzM0NFwiOiBbLTAuMDA0OTksIDAuNjA1LCAwLCAwLCAxLjA1NTU2XSxcbiAgICBcIjU3MzQ1XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDAsIDEuMDU1NTZdLFxuICAgIFwiNTc2ODBcIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLFxuICAgIFwiNTc2ODFcIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLFxuICAgIFwiNTc2ODJcIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLFxuICAgIFwiNTc2ODNcIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdXG4gIH0sXG4gIFwiVHlwZXdyaXRlci1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzNlwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzdcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzOVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDBcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQxXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0MlwiOiBbMCwgMC41MjA4MywgMCwgMCwgMC41MjVdLFxuICAgIFwiNDNcIjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0NFwiOiBbMC4xMzg4OSwgMC4xMjUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ1XCI6IFstMC4wODA1NiwgMC41MzA1NSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDZcIjogWzAsIDAuMTI1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0N1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjUyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1M1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU4XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1OVwiOiBbMC4xMzg4OSwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjBcIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2MVwiOiBbLTAuMTk1NDksIDAuNDE1NjIsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjYyXCI6IFstMC4wNTU1NiwgMC41NTU1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2NVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjczXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3N1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODFcIjogWzAuMTM4ODksIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4M1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4OVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkxXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MlwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTNcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5NVwiOiBbMC4wOTUxNCwgMCwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwM1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwNlwiOiBbMC4yMjIyMiwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExMlwiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTEzXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE2XCI6IFswLCAwLjU1MzU4LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyMVwiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjNcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyNFwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTI1XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyN1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjE4NFwiOiBbMC4xOTQ0NSwgMCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1NjdcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxMVwiOiBbMCwgMC41NjU5NywgMCwgMCwgMC41MjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjU2NTU1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc3MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzcxXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NzZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTE2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTMzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTM3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MjQyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjUxXCI6IFswLjExMTExLCAwLjIxOTQ0LCAwLCAwLCAwLjUyNV1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZm9udE1ldHJpY3MuanNcblxuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBtZXRyaWNzIHJlZ2FyZGluZyBmb250cyBhbmQgaW5kaXZpZHVhbCBzeW1ib2xzLiBUaGUgc2lnbWFcbiAqIGFuZCB4aSB2YXJpYWJsZXMsIGFzIHdlbGwgYXMgdGhlIG1ldHJpY01hcCBtYXAgY29udGFpbiBkYXRhIGV4dHJhY3RlZCBmcm9tXG4gKiBUZVgsIFRlWCBmb250IG1ldHJpY3MsIGFuZCB0aGUgVFRGIGZpbGVzLiBUaGVzZSBkYXRhIGFyZSB0aGVuIGV4cG9zZWQgdmlhIHRoZVxuICogYG1ldHJpY3NgIHZhcmlhYmxlIGFuZCB0aGUgZ2V0Q2hhcmFjdGVyTWV0cmljcyBmdW5jdGlvbi5cbiAqL1xuLy8gSW4gVGVYLCB0aGVyZSBhcmUgYWN0dWFsbHkgdGhyZWUgc2V0cyBvZiBkaW1lbnNpb25zLCBvbmUgZm9yIGVhY2ggb2Zcbi8vIHRleHRzdHlsZSAoc2l6ZSBpbmRleCA1IGFuZCBoaWdoZXI6ID49OXB0KSwgc2NyaXB0c3R5bGUgKHNpemUgaW5kZXggMyBhbmQgNDpcbi8vIDctOHB0KSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlIChzaXplIGluZGV4IDEgYW5kIDI6IDUtNnB0KS4gIFRoZXNlIGFyZVxuLy8gcHJvdmlkZWQgaW4gdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG4vLyBUaGUgZm9udCBtZXRyaWNzIGFyZSBzdG9yZWQgaW4gZm9udHMgY21zeTEwLCBjbXN5NywgYW5kIGNtc3k1IHJlc3BlY3RpdmVseS5cbi8vIFRoaXMgd2FzIGRldGVybWluZWQgYnkgcnVubmluZyB0aGUgZm9sbG93aW5nIHNjcmlwdDpcbi8vXG4vLyAgICAgbGF0ZXggLWludGVyYWN0aW9uPW5vbnN0b3Btb2RlIFxcXG4vLyAgICAgJ1xcZG9jdW1lbnRjbGFzc3thcnRpY2xlfVxcdXNlcGFja2FnZXthbXNtYXRofVxcYmVnaW57ZG9jdW1lbnR9JyBcXFxuLy8gICAgICckYSQgXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFx0ZXh0Zm9udDInIFxcXG4vLyAgICAgJ1xcZXhwYW5kYWZ0ZXJcXHNob3dcXHRoZVxcc2NyaXB0Zm9udDInIFxcXG4vLyAgICAgJ1xcZXhwYW5kYWZ0ZXJcXHNob3dcXHRoZVxcc2NyaXB0c2NyaXB0Zm9udDInIFxcXG4vLyAgICAgJ1xcc3RvcCdcbi8vXG4vLyBUaGUgbWV0cmljcyB0aGVtc2VsdmVzIHdlcmUgcmV0cmlldmVkIHVzaW5nIHRoZSBmb2xsb3dpbmcgY29tbWFuZHM6XG4vL1xuLy8gICAgIHRmdG9wbCBjbXN5MTBcbi8vICAgICB0ZnRvcGwgY21zeTdcbi8vICAgICB0ZnRvcGwgY21zeTVcbi8vXG4vLyBUaGUgb3V0cHV0IG9mIGVhY2ggb2YgdGhlc2UgY29tbWFuZHMgaXMgcXVpdGUgbGVuZ3RoeS4gIFRoZSBvbmx5IHBhcnQgd2Vcbi8vIGNhcmUgYWJvdXQgaXMgdGhlIEZPTlRESU1FTiBzZWN0aW9uLiBFYWNoIHZhbHVlIGlzIG1lYXN1cmVkIGluIEVNcy5cbmNvbnN0IHNpZ21hc0FuZFhpcyA9IHtcbiAgc2xhbnQ6IFswLjI1MCwgMC4yNTAsIDAuMjUwXSxcbiAgLy8gc2lnbWExXG4gIHNwYWNlOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sXG4gIC8vIHNpZ21hMlxuICBzdHJldGNoOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sXG4gIC8vIHNpZ21hM1xuICBzaHJpbms6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWE0XG4gIHhIZWlnaHQ6IFswLjQzMSwgMC40MzEsIDAuNDMxXSxcbiAgLy8gc2lnbWE1XG4gIHF1YWQ6IFsxLjAwMCwgMS4xNzEsIDEuNDcyXSxcbiAgLy8gc2lnbWE2XG4gIGV4dHJhU3BhY2U6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWE3XG4gIG51bTE6IFswLjY3NywgMC43MzIsIDAuOTI1XSxcbiAgLy8gc2lnbWE4XG4gIG51bTI6IFswLjM5NCwgMC4zODQsIDAuMzg3XSxcbiAgLy8gc2lnbWE5XG4gIG51bTM6IFswLjQ0NCwgMC40NzEsIDAuNTA0XSxcbiAgLy8gc2lnbWExMFxuICBkZW5vbTE6IFswLjY4NiwgMC43NTIsIDEuMDI1XSxcbiAgLy8gc2lnbWExMVxuICBkZW5vbTI6IFswLjM0NSwgMC4zNDQsIDAuNTMyXSxcbiAgLy8gc2lnbWExMlxuICBzdXAxOiBbMC40MTMsIDAuNTAzLCAwLjUwNF0sXG4gIC8vIHNpZ21hMTNcbiAgc3VwMjogWzAuMzYzLCAwLjQzMSwgMC40MDRdLFxuICAvLyBzaWdtYTE0XG4gIHN1cDM6IFswLjI4OSwgMC4yODYsIDAuMjk0XSxcbiAgLy8gc2lnbWExNVxuICBzdWIxOiBbMC4xNTAsIDAuMTQzLCAwLjIwMF0sXG4gIC8vIHNpZ21hMTZcbiAgc3ViMjogWzAuMjQ3LCAwLjI4NiwgMC40MDBdLFxuICAvLyBzaWdtYTE3XG4gIHN1cERyb3A6IFswLjM4NiwgMC4zNTMsIDAuNDk0XSxcbiAgLy8gc2lnbWExOFxuICBzdWJEcm9wOiBbMC4wNTAsIDAuMDcxLCAwLjEwMF0sXG4gIC8vIHNpZ21hMTlcbiAgZGVsaW0xOiBbMi4zOTAsIDEuNzAwLCAxLjk4MF0sXG4gIC8vIHNpZ21hMjBcbiAgZGVsaW0yOiBbMS4wMTAsIDEuMTU3LCAxLjQyMF0sXG4gIC8vIHNpZ21hMjFcbiAgYXhpc0hlaWdodDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLFxuICAvLyBzaWdtYTIyXG4gIC8vIFRoZXNlIGZvbnQgbWV0cmljcyBhcmUgZXh0cmFjdGVkIGZyb20gVGVYIGJ5IHVzaW5nIHRmdG9wbCBvbiBjbWV4MTAudGZtO1xuICAvLyB0aGV5IGNvcnJlc3BvbmQgdG8gdGhlIGZvbnQgcGFyYW1ldGVycyBvZiB0aGUgZXh0ZW5zaW9uIGZvbnRzIChmYW1pbHkgMykuXG4gIC8vIFNlZSB0aGUgVGVYYm9vaywgcGFnZSA0NDEuIEluIEFNU1RlWCwgdGhlIGV4dGVuc2lvbiBmb250cyBzY2FsZTsgdG9cbiAgLy8gbWF0Y2ggY21leDcsIHdlJ2QgdXNlIGNtZXg3LnRmbSB2YWx1ZXMgZm9yIHNjcmlwdCBhbmQgc2NyaXB0c2NyaXB0XG4gIC8vIHZhbHVlcy5cbiAgZGVmYXVsdFJ1bGVUaGlja25lc3M6IFswLjA0LCAwLjA0OSwgMC4wNDldLFxuICAvLyB4aTg7IGNtZXg3OiAwLjA0OVxuICBiaWdPcFNwYWNpbmcxOiBbMC4xMTEsIDAuMTExLCAwLjExMV0sXG4gIC8vIHhpOVxuICBiaWdPcFNwYWNpbmcyOiBbMC4xNjYsIDAuMTY2LCAwLjE2Nl0sXG4gIC8vIHhpMTBcbiAgYmlnT3BTcGFjaW5nMzogWzAuMiwgMC4yLCAwLjJdLFxuICAvLyB4aTExXG4gIGJpZ09wU3BhY2luZzQ6IFswLjYsIDAuNjExLCAwLjYxMV0sXG4gIC8vIHhpMTI7IGNtZXg3OiAwLjYxMVxuICBiaWdPcFNwYWNpbmc1OiBbMC4xLCAwLjE0MywgMC4xNDNdLFxuICAvLyB4aTEzOyBjbWV4NzogMC4xNDNcbiAgLy8gVGhlIFxcc3FydCBydWxlIHdpZHRoIGlzIHRha2VuIGZyb20gdGhlIGhlaWdodCBvZiB0aGUgc3VyZCBjaGFyYWN0ZXIuXG4gIC8vIFNpbmNlIHdlIHVzZSB0aGUgc2FtZSBmb250IGF0IGFsbCBzaXplcywgdGhpcyB0aGlja25lc3MgZG9lc24ndCBzY2FsZS5cbiAgc3FydFJ1bGVUaGlja25lc3M6IFswLjA0LCAwLjA0LCAwLjA0XSxcbiAgLy8gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBsYXJnZSBhIHB0IGlzLCBmb3IgbWV0cmljcyB3aGljaCBhcmUgZGVmaW5lZFxuICAvLyBpbiB0ZXJtcyBvZiBwdHMuXG4gIC8vIFRoaXMgdmFsdWUgaXMgYWxzbyB1c2VkIGluIGthdGV4LnNjc3M7IGlmIHlvdSBjaGFuZ2UgaXQgbWFrZSBzdXJlIHRoZVxuICAvLyB2YWx1ZXMgbWF0Y2guXG4gIHB0UGVyRW06IFsxMC4wLCAxMC4wLCAxMC4wXSxcbiAgLy8gVGhlIHNwYWNlIGJldHdlZW4gYWRqYWNlbnQgYHxgIGNvbHVtbnMgaW4gYW4gYXJyYXkgZGVmaW5pdGlvbi4gRnJvbVxuICAvLyBgXFxzaG93dGhlXFxkb3VibGVydWxlc2VwYCBpbiBMYVRlWC4gRXF1YWxzIDIuMCAvIHB0UGVyRW0uXG4gIGRvdWJsZVJ1bGVTZXA6IFswLjIsIDAuMiwgMC4yXSxcbiAgLy8gVGhlIHdpZHRoIG9mIHNlcGFyYXRvciBsaW5lcyBpbiB7YXJyYXl9IGVudmlyb25tZW50cy4gRnJvbVxuICAvLyBgXFxzaG93dGhlXFxhcnJheXJ1bGV3aWR0aGAgaW4gTGFUZVguIEVxdWFscyAwLjQgLyBwdFBlckVtLlxuICBhcnJheVJ1bGVXaWR0aDogWzAuMDQsIDAuMDQsIDAuMDRdLFxuICAvLyBUd28gdmFsdWVzIGZyb20gTGFUZVggc291cmNlMmU6XG4gIGZib3hzZXA6IFswLjMsIDAuMywgMC4zXSxcbiAgLy8gICAgICAgIDMgcHQgLyBwdFBlckVtXG4gIGZib3hydWxlOiBbMC4wNCwgMC4wNCwgMC4wNF0gLy8gMC40IHB0IC8gcHRQZXJFbVxuXG59OyAvLyBUaGlzIG1hcCBjb250YWlucyBhIG1hcHBpbmcgZnJvbSBmb250IG5hbWUgYW5kIGNoYXJhY3RlciBjb2RlIHRvIGNoYXJhY3RlclxuLy8gbWV0cmljcywgaW5jbHVkaW5nIGhlaWdodCwgZGVwdGgsIGl0YWxpYyBjb3JyZWN0aW9uLCBhbmQgc2tldyAoa2VybiBmcm9tIHRoZVxuLy8gY2hhcmFjdGVyIHRvIHRoZSBjb3JyZXNwb25kaW5nIFxcc2tld2NoYXIpXG4vLyBUaGlzIG1hcCBpcyBnZW5lcmF0ZWQgdmlhIGBtYWtlIG1ldHJpY3NgLiBJdCBzaG91bGQgbm90IGJlIGNoYW5nZWQgbWFudWFsbHkuXG5cbiAvLyBUaGVzZSBhcmUgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9ucy4gIFdlIGRlZmF1bHQgdG8gVGltZXMgTmV3IFJvbWFuIHdoaWNoXG4vLyBzaG91bGQgaGF2ZSBMYXRpbi0xIGFuZCBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBidXQgbWF5IG5vdCBkZXBlbmRpbmcgb24gdGhlXG4vLyBvcGVyYXRpbmcgc3lzdGVtLiAgVGhlIG1ldHJpY3MgZG8gbm90IGFjY291bnQgZm9yIGV4dHJhIGhlaWdodCBmcm9tIHRoZVxuLy8gYWNjZW50cy4gIEluIHRoZSBjYXNlIG9mIEN5cmlsbGljIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBib3RoIGFzY2VuZGVycyBhbmRcbi8vIGRlc2NlbmRlcnMgd2UgcHJlZmVyIGFwcHJveGltYXRpb25zIHdpdGggYXNjZW5kZXJzLCBwcmltYXJpbHkgdG8gcHJldmVudFxuLy8gdGhlIGZyYWN0aW9uIGJhciBvciByb290IGxpbmUgZnJvbSBpbnRlcnNlY3RpbmcgdGhlIGdseXBoLlxuLy8gVE9ETyhrZXZpbmIpIGFsbG93IHVuaW9uIG9mIG11bHRpcGxlIGdseXBoIG1ldHJpY3MgZm9yIGJldHRlciBhY2N1cmFjeS5cblxuY29uc3QgZXh0cmFDaGFyYWN0ZXJNYXAgPSB7XG4gIC8vIExhdGluLTFcbiAgJ8OFJzogJ0EnLFxuICAnw5AnOiAnRCcsXG4gICfDnic6ICdvJyxcbiAgJ8OlJzogJ2EnLFxuICAnw7AnOiAnZCcsXG4gICfDvic6ICdvJyxcbiAgLy8gQ3lyaWxsaWNcbiAgJ9CQJzogJ0EnLFxuICAn0JEnOiAnQicsXG4gICfQkic6ICdCJyxcbiAgJ9CTJzogJ0YnLFxuICAn0JQnOiAnQScsXG4gICfQlSc6ICdFJyxcbiAgJ9CWJzogJ0snLFxuICAn0JcnOiAnMycsXG4gICfQmCc6ICdOJyxcbiAgJ9CZJzogJ04nLFxuICAn0JonOiAnSycsXG4gICfQmyc6ICdOJyxcbiAgJ9CcJzogJ00nLFxuICAn0J0nOiAnSCcsXG4gICfQnic6ICdPJyxcbiAgJ9CfJzogJ04nLFxuICAn0KAnOiAnUCcsXG4gICfQoSc6ICdDJyxcbiAgJ9CiJzogJ1QnLFxuICAn0KMnOiAneScsXG4gICfQpCc6ICdPJyxcbiAgJ9ClJzogJ1gnLFxuICAn0KYnOiAnVScsXG4gICfQpyc6ICdoJyxcbiAgJ9CoJzogJ1cnLFxuICAn0KknOiAnVycsXG4gICfQqic6ICdCJyxcbiAgJ9CrJzogJ1gnLFxuICAn0KwnOiAnQicsXG4gICfQrSc6ICczJyxcbiAgJ9CuJzogJ1gnLFxuICAn0K8nOiAnUicsXG4gICfQsCc6ICdhJyxcbiAgJ9CxJzogJ2InLFxuICAn0LInOiAnYScsXG4gICfQsyc6ICdyJyxcbiAgJ9C0JzogJ3knLFxuICAn0LUnOiAnZScsXG4gICfQtic6ICdtJyxcbiAgJ9C3JzogJ2UnLFxuICAn0LgnOiAnbicsXG4gICfQuSc6ICduJyxcbiAgJ9C6JzogJ24nLFxuICAn0LsnOiAnbicsXG4gICfQvCc6ICdtJyxcbiAgJ9C9JzogJ24nLFxuICAn0L4nOiAnbycsXG4gICfQvyc6ICduJyxcbiAgJ9GAJzogJ3AnLFxuICAn0YEnOiAnYycsXG4gICfRgic6ICdvJyxcbiAgJ9GDJzogJ3knLFxuICAn0YQnOiAnYicsXG4gICfRhSc6ICd4JyxcbiAgJ9GGJzogJ24nLFxuICAn0YcnOiAnbicsXG4gICfRiCc6ICd3JyxcbiAgJ9GJJzogJ3cnLFxuICAn0YonOiAnYScsXG4gICfRiyc6ICdtJyxcbiAgJ9GMJzogJ2EnLFxuICAn0Y0nOiAnZScsXG4gICfRjic6ICdtJyxcbiAgJ9GPJzogJ3InXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRkcyBuZXcgZm9udCBtZXRyaWNzIHRvIGRlZmF1bHQgbWV0cmljTWFwXG4gKiBJdCBjYW4gYWxzbyBvdmVycmlkZSBleGlzdGluZyBtZXRyaWNzXG4gKi9cbmZ1bmN0aW9uIHNldEZvbnRNZXRyaWNzKGZvbnROYW1lLCBtZXRyaWNzKSB7XG4gIGZvbnRNZXRyaWNzRGF0YVtmb250TmFtZV0gPSBtZXRyaWNzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGxvb2tpbmcgdXAgaW5mb3JtYXRpb24gaW4gdGhlXG4gKiBtZXRyaWNNYXAgdGFibGUuIEl0IHRha2VzIGEgY2hhcmFjdGVyIGFzIGEgc3RyaW5nLCBhbmQgYSBmb250LlxuICpcbiAqIE5vdGU6IHRoZSBgd2lkdGhgIHByb3BlcnR5IG1heSBiZSB1bmRlZmluZWQgaWYgZm9udE1ldHJpY3NEYXRhLmpzIHdhc24ndFxuICogYnVpbHQgdXNpbmcgYE1ha2UgZXh0ZW5kZWRfbWV0cmljc2AuXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyTWV0cmljcyhjaGFyYWN0ZXIsIGZvbnQsIG1vZGUpIHtcbiAgaWYgKCFmb250TWV0cmljc0RhdGFbZm9udF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IG1ldHJpY3Mgbm90IGZvdW5kIGZvciBmb250OiBcIiArIGZvbnQgKyBcIi5cIik7XG4gIH1cblxuICBsZXQgY2ggPSBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKTtcbiAgbGV0IG1ldHJpY3MgPSBmb250TWV0cmljc0RhdGFbZm9udF1bY2hdO1xuXG4gIGlmICghbWV0cmljcyAmJiBjaGFyYWN0ZXJbMF0gaW4gZXh0cmFDaGFyYWN0ZXJNYXApIHtcbiAgICBjaCA9IGV4dHJhQ2hhcmFjdGVyTWFwW2NoYXJhY3RlclswXV0uY2hhckNvZGVBdCgwKTtcbiAgICBtZXRyaWNzID0gZm9udE1ldHJpY3NEYXRhW2ZvbnRdW2NoXTtcbiAgfVxuXG4gIGlmICghbWV0cmljcyAmJiBtb2RlID09PSAndGV4dCcpIHtcbiAgICAvLyBXZSBkb24ndCB0eXBpY2FsbHkgaGF2ZSBmb250IG1ldHJpY3MgZm9yIEFzaWFuIHNjcmlwdHMuXG4gICAgLy8gQnV0IHNpbmNlIHdlIHN1cHBvcnQgdGhlbSBpbiB0ZXh0IG1vZGUsIHdlIG5lZWQgdG8gcmV0dXJuXG4gICAgLy8gc29tZSBzb3J0IG9mIG1ldHJpY3MuXG4gICAgLy8gU28gaWYgdGhlIGNoYXJhY3RlciBpcyBpbiBhIHNjcmlwdCB3ZSBzdXBwb3J0IGJ1dCB3ZVxuICAgIC8vIGRvbid0IGhhdmUgbWV0cmljcyBmb3IgaXQsIGp1c3QgdXNlIHRoZSBtZXRyaWNzIGZvclxuICAgIC8vIHRoZSBMYXRpbiBjYXBpdGFsIGxldHRlciBNLiBUaGlzIGlzIGNsb3NlIGVub3VnaCBiZWNhdXNlXG4gICAgLy8gd2UgKGN1cnJlbnRseSkgb25seSBjYXJlIGFib3V0IHRoZSBoZWlnaHQgb2YgdGhlIGdseXBoXG4gICAgLy8gbm90IGl0cyB3aWR0aC5cbiAgICBpZiAoc3VwcG9ydGVkQ29kZXBvaW50KGNoKSkge1xuICAgICAgbWV0cmljcyA9IGZvbnRNZXRyaWNzRGF0YVtmb250XVs3N107IC8vIDc3IGlzIHRoZSBjaGFyY29kZSBmb3IgJ00nXG4gICAgfVxuICB9XG5cbiAgaWYgKG1ldHJpY3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVwdGg6IG1ldHJpY3NbMF0sXG4gICAgICBoZWlnaHQ6IG1ldHJpY3NbMV0sXG4gICAgICBpdGFsaWM6IG1ldHJpY3NbMl0sXG4gICAgICBza2V3OiBtZXRyaWNzWzNdLFxuICAgICAgd2lkdGg6IG1ldHJpY3NbNF1cbiAgICB9O1xuICB9XG59XG5jb25zdCBmb250TWV0cmljc0J5U2l6ZUluZGV4ID0ge307XG4vKipcbiAqIEdldCB0aGUgZm9udCBtZXRyaWNzIGZvciBhIGdpdmVuIHNpemUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0R2xvYmFsTWV0cmljcyhzaXplKSB7XG4gIGxldCBzaXplSW5kZXg7XG5cbiAgaWYgKHNpemUgPj0gNSkge1xuICAgIHNpemVJbmRleCA9IDA7XG4gIH0gZWxzZSBpZiAoc2l6ZSA+PSAzKSB7XG4gICAgc2l6ZUluZGV4ID0gMTtcbiAgfSBlbHNlIHtcbiAgICBzaXplSW5kZXggPSAyO1xuICB9XG5cbiAgaWYgKCFmb250TWV0cmljc0J5U2l6ZUluZGV4W3NpemVJbmRleF0pIHtcbiAgICBjb25zdCBtZXRyaWNzID0gZm9udE1ldHJpY3NCeVNpemVJbmRleFtzaXplSW5kZXhdID0ge1xuICAgICAgY3NzRW1QZXJNdTogc2lnbWFzQW5kWGlzLnF1YWRbc2l6ZUluZGV4XSAvIDE4XG4gICAgfTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNpZ21hc0FuZFhpcykge1xuICAgICAgaWYgKHNpZ21hc0FuZFhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIG1ldHJpY3Nba2V5XSA9IHNpZ21hc0FuZFhpc1trZXldW3NpemVJbmRleF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvbnRNZXRyaWNzQnlTaXplSW5kZXhbc2l6ZUluZGV4XTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9PcHRpb25zLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3B0aW9ucyB0aGF0IHRoZSBQYXJzZXIgY2Fycmllc1xuICogYXJvdW5kIHdpdGggaXQgd2hpbGUgcGFyc2luZy4gRGF0YSBpcyBoZWxkIGluIGFuIGBPcHRpb25zYCBvYmplY3QsIGFuZCB3aGVuXG4gKiByZWN1cnNpbmcsIGEgbmV3IGBPcHRpb25zYCBvYmplY3QgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYC53aXRoKmAgYW5kXG4gKiBgLnJlc2V0YCBmdW5jdGlvbnMuXG4gKi9cblxuY29uc3Qgc2l6ZVN0eWxlTWFwID0gWy8vIEVhY2ggZWxlbWVudCBjb250YWlucyBbdGV4dHNpemUsIHNjcmlwdHNpemUsIHNjcmlwdHNjcmlwdHNpemVdLlxuLy8gVGhlIHNpemUgbWFwcGluZ3MgYXJlIHRha2VuIGZyb20gVGVYIHdpdGggXFxub3JtYWxzaXplPTEwcHQuXG5bMSwgMSwgMV0sIC8vIHNpemUxOiBbNSwgNSwgNV0gICAgICAgICAgICAgIFxcdGlueVxuWzIsIDEsIDFdLCAvLyBzaXplMjogWzYsIDUsIDVdXG5bMywgMSwgMV0sIC8vIHNpemUzOiBbNywgNSwgNV0gICAgICAgICAgICAgIFxcc2NyaXB0c2l6ZVxuWzQsIDIsIDFdLCAvLyBzaXplNDogWzgsIDYsIDVdICAgICAgICAgICAgICBcXGZvb3Rub3Rlc2l6ZVxuWzUsIDIsIDFdLCAvLyBzaXplNTogWzksIDYsIDVdICAgICAgICAgICAgICBcXHNtYWxsXG5bNiwgMywgMV0sIC8vIHNpemU2OiBbMTAsIDcsIDVdICAgICAgICAgICAgIFxcbm9ybWFsc2l6ZVxuWzcsIDQsIDJdLCAvLyBzaXplNzogWzEyLCA4LCA2XSAgICAgICAgICAgICBcXGxhcmdlXG5bOCwgNiwgM10sIC8vIHNpemU4OiBbMTQuNCwgMTAsIDddICAgICAgICAgIFxcTGFyZ2Vcbls5LCA3LCA2XSwgLy8gc2l6ZTk6IFsxNy4yOCwgMTIsIDEwXSAgICAgICAgXFxMQVJHRVxuWzEwLCA4LCA3XSwgLy8gc2l6ZTEwOiBbMjAuNzQsIDE0LjQsIDEyXSAgICAgXFxodWdlXG5bMTEsIDEwLCA5XSAvLyBzaXplMTE6IFsyNC44OCwgMjAuNzQsIDE3LjI4XSBcXEhVR0Vcbl07XG5jb25zdCBzaXplTXVsdGlwbGllcnMgPSBbLy8gZm9udE1ldHJpY3MuanM6Z2V0R2xvYmFsTWV0cmljcyBhbHNvIHVzZXMgc2l6ZSBpbmRleGVzLCBzbyBpZlxuLy8geW91IGNoYW5nZSBzaXplIGluZGV4ZXMsIGNoYW5nZSB0aGF0IGZ1bmN0aW9uLlxuMC41LCAwLjYsIDAuNywgMC44LCAwLjksIDEuMCwgMS4yLCAxLjQ0LCAxLjcyOCwgMi4wNzQsIDIuNDg4XTtcblxuY29uc3Qgc2l6ZUF0U3R5bGUgPSBmdW5jdGlvbiAoc2l6ZSwgc3R5bGUpIHtcbiAgcmV0dXJuIHN0eWxlLnNpemUgPCAyID8gc2l6ZSA6IHNpemVTdHlsZU1hcFtzaXplIC0gMV1bc3R5bGUuc2l6ZSAtIDFdO1xufTsgLy8gSW4gdGhlc2UgdHlwZXMsIFwiXCIgKGVtcHR5IHN0cmluZykgbWVhbnMgXCJubyBjaGFuZ2VcIi5cblxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gb3B0aW9ucyBjbGFzcy4gSXQgY29udGFpbnMgdGhlIGN1cnJlbnQgc3R5bGUsIHNpemUsIGNvbG9yLFxuICogYW5kIGZvbnQuXG4gKlxuICogT3B0aW9ucyBvYmplY3RzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuIFRvIGNyZWF0ZSBhIG5ldyBPcHRpb25zIHdpdGhcbiAqIGRpZmZlcmVudCBwcm9wZXJ0aWVzLCBjYWxsIGEgYC5oYXZpbmcqYCBtZXRob2QuXG4gKi9cbmNsYXNzIE9wdGlvbnMge1xuICAvLyBBIGZvbnQgZmFtaWx5IGFwcGxpZXMgdG8gYSBncm91cCBvZiBmb250cyAoaS5lLiBTYW5zU2VyaWYpLCB3aGlsZSBhIGZvbnRcbiAgLy8gcmVwcmVzZW50cyBhIHNwZWNpZmljIGZvbnQgKGkuZS4gU2Fuc1NlcmlmIEJvbGQpLlxuICAvLyBTZWU6IGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yMjM1MC9kaWZmZXJlbmNlLWJldHdlZW4tdGV4dHJtLWFuZC1tYXRocm1cblxuICAvKipcbiAgICogVGhlIGJhc2Ugc2l6ZSBpbmRleC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5waGFudG9tID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNoYXBlID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhTaXplID0gdm9pZCAwO1xuICAgIHRoaXMubWluUnVsZVRoaWNrbmVzcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9mb250TWV0cmljcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICB0aGlzLmNvbG9yID0gZGF0YS5jb2xvcjtcbiAgICB0aGlzLnNpemUgPSBkYXRhLnNpemUgfHwgT3B0aW9ucy5CQVNFU0laRTtcbiAgICB0aGlzLnRleHRTaXplID0gZGF0YS50ZXh0U2l6ZSB8fCB0aGlzLnNpemU7XG4gICAgdGhpcy5waGFudG9tID0gISFkYXRhLnBoYW50b207XG4gICAgdGhpcy5mb250ID0gZGF0YS5mb250IHx8IFwiXCI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gZGF0YS5mb250RmFtaWx5IHx8IFwiXCI7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gZGF0YS5mb250V2VpZ2h0IHx8ICcnO1xuICAgIHRoaXMuZm9udFNoYXBlID0gZGF0YS5mb250U2hhcGUgfHwgJyc7XG4gICAgdGhpcy5zaXplTXVsdGlwbGllciA9IHNpemVNdWx0aXBsaWVyc1t0aGlzLnNpemUgLSAxXTtcbiAgICB0aGlzLm1heFNpemUgPSBkYXRhLm1heFNpemU7XG4gICAgdGhpcy5taW5SdWxlVGhpY2tuZXNzID0gZGF0YS5taW5SdWxlVGhpY2tuZXNzO1xuICAgIHRoaXMuX2ZvbnRNZXRyaWNzID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhcyBcInRoaXNcIi4gIFByb3BlcnRpZXNcbiAgICogZnJvbSBcImV4dGVuc2lvblwiIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgb3B0aW9ucyBvYmplY3QuXG4gICAqL1xuXG5cbiAgZXh0ZW5kKGV4dGVuc2lvbikge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBzdHlsZTogdGhpcy5zdHlsZSxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIHRleHRTaXplOiB0aGlzLnRleHRTaXplLFxuICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICBwaGFudG9tOiB0aGlzLnBoYW50b20sXG4gICAgICBmb250OiB0aGlzLmZvbnQsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQsXG4gICAgICBmb250U2hhcGU6IHRoaXMuZm9udFNoYXBlLFxuICAgICAgbWF4U2l6ZTogdGhpcy5tYXhTaXplLFxuICAgICAgbWluUnVsZVRoaWNrbmVzczogdGhpcy5taW5SdWxlVGhpY2tuZXNzXG4gICAgfTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGV4dGVuc2lvbikge1xuICAgICAgaWYgKGV4dGVuc2lvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgT3B0aW9ucyhkYXRhKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHN0eWxlLiBJZiBgdGhpcy5zdHlsZSA9PT0gc3R5bGVgLFxuICAgKiByZXR1cm5zIGB0aGlzYC5cbiAgICovXG5cblxuICBoYXZpbmdTdHlsZShzdHlsZSkge1xuICAgIGlmICh0aGlzLnN0eWxlID09PSBzdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc2l6ZTogc2l6ZUF0U3R5bGUodGhpcy50ZXh0U2l6ZSwgc3R5bGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGEgY3JhbXBlZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHN0eWxlLiBJZlxuICAgKiB0aGUgY3VycmVudCBzdHlsZSBpcyBjcmFtcGVkLCByZXR1cm5zIGB0aGlzYC5cbiAgICovXG5cblxuICBoYXZpbmdDcmFtcGVkU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGF2aW5nU3R5bGUodGhpcy5zdHlsZS5jcmFtcCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNpemUgYW5kIGluIGF0IGxlYXN0IGBcXHRleHRzdHlsZWAuXG4gICAqIFJldHVybnMgYHRoaXNgIGlmIGFwcHJvcHJpYXRlLlxuICAgKi9cblxuXG4gIGhhdmluZ1NpemUoc2l6ZSkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IHNpemUgJiYgdGhpcy50ZXh0U2l6ZSA9PT0gc2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLnRleHQoKSxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgdGV4dFNpemU6IHNpemUsXG4gICAgICAgIHNpemVNdWx0aXBsaWVyOiBzaXplTXVsdGlwbGllcnNbc2l6ZSAtIDFdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExpa2UgYHRoaXMuaGF2aW5nU2l6ZShCQVNFU0laRSkuaGF2aW5nU3R5bGUoc3R5bGUpYC4gSWYgYHN0eWxlYCBpcyBvbWl0dGVkLFxuICAgKiBjaGFuZ2VzIHRvIGF0IGxlYXN0IGBcXHRleHRzdHlsZWAuXG4gICAqL1xuXG5cbiAgaGF2aW5nQmFzZVN0eWxlKHN0eWxlKSB7XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB0aGlzLnN0eWxlLnRleHQoKTtcbiAgICBjb25zdCB3YW50U2l6ZSA9IHNpemVBdFN0eWxlKE9wdGlvbnMuQkFTRVNJWkUsIHN0eWxlKTtcblxuICAgIGlmICh0aGlzLnNpemUgPT09IHdhbnRTaXplICYmIHRoaXMudGV4dFNpemUgPT09IE9wdGlvbnMuQkFTRVNJWkUgJiYgdGhpcy5zdHlsZSA9PT0gc3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHNpemU6IHdhbnRTaXplXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWZmZWN0IG9mIHNpemluZyBjaGFuZ2VzIHN1Y2ggYXMgXFxIdWdlLlxuICAgKiBLZWVwIHRoZSBlZmZlY3Qgb2YgdGhlIGN1cnJlbnQgc3R5bGUsIHN1Y2ggYXMgXFxzY3JpcHRzdHlsZS5cbiAgICovXG5cblxuICBoYXZpbmdCYXNlU2l6aW5nKCkge1xuICAgIGxldCBzaXplO1xuXG4gICAgc3dpdGNoICh0aGlzLnN0eWxlLmlkKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHNpemUgPSAzOyAvLyBub3JtYWxzaXplIGluIHNjcmlwdHN0eWxlXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgc2l6ZSA9IDE7IC8vIG5vcm1hbHNpemUgaW4gc2NyaXB0c2NyaXB0c3R5bGVcblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2l6ZSA9IDY7XG4gICAgICAvLyBub3JtYWxzaXplIGluIHRleHRzdHlsZSBvciBkaXNwbGF5c3R5bGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgc3R5bGU6IHRoaXMuc3R5bGUudGV4dCgpLFxuICAgICAgc2l6ZTogc2l6ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29sb3IuXG4gICAqL1xuXG5cbiAgd2l0aENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCBcInBoYW50b21cIiBzZXQgdG8gdHJ1ZS5cbiAgICovXG5cblxuICB3aXRoUGhhbnRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgcGhhbnRvbTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG1hdGggZm9udCBvciBvbGQgdGV4dCBmb250LlxuICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgKi9cblxuXG4gIHdpdGhGb250KGZvbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3RzIHdpdGggdGhlIGdpdmVuIGZvbnRGYW1pbHkuXG4gICAqL1xuXG5cbiAgd2l0aFRleHRGb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBmb250IHdlaWdodFxuICAgKi9cblxuXG4gIHdpdGhUZXh0Rm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHRcbiAgICovXG5cblxuICB3aXRoVGV4dEZvbnRTaGFwZShmb250U2hhcGUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFNoYXBlLFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIENTUyBzaXppbmcgY2xhc3NlcyByZXF1aXJlZCB0byBzd2l0Y2ggZnJvbSBlbmNsb3Npbmcgb3B0aW9uc1xuICAgKiBgb2xkT3B0aW9uc2AgdG8gYHRoaXNgLiBSZXR1cm5zIGFuIGFycmF5IG9mIGNsYXNzZXMuXG4gICAqL1xuXG5cbiAgc2l6aW5nQ2xhc3NlcyhvbGRPcHRpb25zKSB7XG4gICAgaWYgKG9sZE9wdGlvbnMuc2l6ZSAhPT0gdGhpcy5zaXplKSB7XG4gICAgICByZXR1cm4gW1wic2l6aW5nXCIsIFwicmVzZXQtc2l6ZVwiICsgb2xkT3B0aW9ucy5zaXplLCBcInNpemVcIiArIHRoaXMuc2l6ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQ1NTIHNpemluZyBjbGFzc2VzIHJlcXVpcmVkIHRvIHN3aXRjaCB0byB0aGUgYmFzZSBzaXplLiBMaWtlXG4gICAqIGB0aGlzLmhhdmluZ1NpemUoQkFTRVNJWkUpLnNpemluZ0NsYXNzZXModGhpcylgLlxuICAgKi9cblxuXG4gIGJhc2VTaXppbmdDbGFzc2VzKCkge1xuICAgIGlmICh0aGlzLnNpemUgIT09IE9wdGlvbnMuQkFTRVNJWkUpIHtcbiAgICAgIHJldHVybiBbXCJzaXppbmdcIiwgXCJyZXNldC1zaXplXCIgKyB0aGlzLnNpemUsIFwic2l6ZVwiICsgT3B0aW9ucy5CQVNFU0laRV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZm9udCBtZXRyaWNzIGZvciB0aGlzIHNpemUuXG4gICAqL1xuXG5cbiAgZm9udE1ldHJpY3MoKSB7XG4gICAgaWYgKCF0aGlzLl9mb250TWV0cmljcykge1xuICAgICAgdGhpcy5fZm9udE1ldHJpY3MgPSBnZXRHbG9iYWxNZXRyaWNzKHRoaXMuc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRNZXRyaWNzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBDU1MgY29sb3Igb2YgdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3RcbiAgICovXG5cblxuICBnZXRDb2xvcigpIHtcbiAgICBpZiAodGhpcy5waGFudG9tKSB7XG4gICAgICByZXR1cm4gXCJ0cmFuc3BhcmVudFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICB9XG4gIH1cblxufVxuXG5PcHRpb25zLkJBU0VTSVpFID0gNjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19PcHRpb25zID0gKE9wdGlvbnMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3VuaXRzLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBkb2VzIGNvbnZlcnNpb24gYmV0d2VlbiB1bml0cy4gIEluIHBhcnRpY3VsYXIsIGl0IHByb3ZpZGVzXG4gKiBjYWxjdWxhdGVTaXplIHRvIGNvbnZlcnQgb3RoZXIgdW5pdHMgaW50byBlbXMuXG4gKi9cblxuIC8vIFRoaXMgdGFibGUgZ2l2ZXMgdGhlIG51bWJlciBvZiBUZVggcHRzIGluIG9uZSBvZiBlYWNoICphYnNvbHV0ZSogVGVYIHVuaXQuXG4vLyBUaHVzLCBtdWx0aXBseWluZyBhIGxlbmd0aCBieSB0aGlzIG51bWJlciBjb252ZXJ0cyB0aGUgbGVuZ3RoIGZyb20gdW5pdHNcbi8vIGludG8gcHRzLiAgRGl2aWRpbmcgdGhlIHJlc3VsdCBieSBwdFBlckVtIGdpdmVzIHRoZSBudW1iZXIgb2YgZW1zXG4vLyAqYXNzdW1pbmcqIGEgZm9udCBzaXplIG9mIHB0UGVyRW0gKG5vcm1hbCBzaXplLCBub3JtYWwgc3R5bGUpLlxuXG5jb25zdCBwdFBlclVuaXQgPSB7XG4gIC8vIGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0xhVGVYL0xlbmd0aHMgYW5kXG4gIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL2EvODI2M1xuICBcInB0XCI6IDEsXG4gIC8vIFRlWCBwb2ludFxuICBcIm1tXCI6IDcyMjcgLyAyNTQwLFxuICAvLyBtaWxsaW1ldGVyXG4gIFwiY21cIjogNzIyNyAvIDI1NCxcbiAgLy8gY2VudGltZXRlclxuICBcImluXCI6IDcyLjI3LFxuICAvLyBpbmNoXG4gIFwiYnBcIjogODAzIC8gODAwLFxuICAvLyBiaWcgKFBvc3RTY3JpcHQpIHBvaW50c1xuICBcInBjXCI6IDEyLFxuICAvLyBwaWNhXG4gIFwiZGRcIjogMTIzOCAvIDExNTcsXG4gIC8vIGRpZG90XG4gIFwiY2NcIjogMTQ4NTYgLyAxMTU3LFxuICAvLyBjaWNlcm8gKDEyIGRpZG90KVxuICBcIm5kXCI6IDY4NSAvIDY0MixcbiAgLy8gbmV3IGRpZG90XG4gIFwibmNcIjogMTM3MCAvIDEwNyxcbiAgLy8gbmV3IGNpY2VybyAoMTIgbmV3IGRpZG90KVxuICBcInNwXCI6IDEgLyA2NTUzNixcbiAgLy8gc2NhbGVkIHBvaW50IChUZVgncyBpbnRlcm5hbCBzbWFsbGVzdCB1bml0KVxuICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9hLzQxMzcxXG4gIFwicHhcIjogODAzIC8gODAwIC8vIFxccGRmcHhkaW1lbiBkZWZhdWx0cyB0byAxIGJwIGluIHBkZlRlWCBhbmQgTHVhVGVYXG5cbn07IC8vIERpY3Rpb25hcnkgb2YgcmVsYXRpdmUgdW5pdHMsIGZvciBmYXN0IHZhbGlkaXR5IHRlc3RpbmcuXG5cbmNvbnN0IHJlbGF0aXZlVW5pdCA9IHtcbiAgXCJleFwiOiB0cnVlLFxuICBcImVtXCI6IHRydWUsXG4gIFwibXVcIjogdHJ1ZVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgc3BlY2lmaWVkIHVuaXQgKGVpdGhlciBhIHN0cmluZyBkZWZpbmluZyB0aGUgdW5pdFxuICogb3IgYSBcInNpemVcIiBwYXJzZSBub2RlIGNvbnRhaW5pbmcgYSB1bml0IGZpZWxkKSBpcyB2YWxpZC5cbiAqL1xuY29uc3QgdmFsaWRVbml0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgaWYgKHR5cGVvZiB1bml0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5pdCA9IHVuaXQudW5pdDtcbiAgfVxuXG4gIHJldHVybiB1bml0IGluIHB0UGVyVW5pdCB8fCB1bml0IGluIHJlbGF0aXZlVW5pdCB8fCB1bml0ID09PSBcImV4XCI7XG59O1xuLypcbiAqIENvbnZlcnQgYSBcInNpemVcIiBwYXJzZSBub2RlICh3aXRoIG51bWVyaWMgXCJudW1iZXJcIiBhbmQgc3RyaW5nIFwidW5pdFwiIGZpZWxkcyxcbiAqIGFzIHBhcnNlZCBieSBmdW5jdGlvbnMuanMgYXJnVHlwZSBcInNpemVcIikgaW50byBhIENTUyBlbSB2YWx1ZSBmb3IgdGhlXG4gKiBjdXJyZW50IHN0eWxlL3NjYWxlLiAgYG9wdGlvbnNgIGdpdmVzIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gKi9cblxuY29uc3QgY2FsY3VsYXRlU2l6ZSA9IGZ1bmN0aW9uIChzaXplVmFsdWUsIG9wdGlvbnMpIHtcbiAgbGV0IHNjYWxlO1xuXG4gIGlmIChzaXplVmFsdWUudW5pdCBpbiBwdFBlclVuaXQpIHtcbiAgICAvLyBBYnNvbHV0ZSB1bml0c1xuICAgIHNjYWxlID0gcHRQZXJVbml0W3NpemVWYWx1ZS51bml0XSAvLyBDb252ZXJ0IHVuaXQgdG8gcHRcbiAgICAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtIC8vIENvbnZlcnQgcHQgdG8gQ1NTIGVtXG4gICAgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyOyAvLyBVbnNjYWxlIHRvIG1ha2UgYWJzb2x1dGUgdW5pdHNcbiAgfSBlbHNlIGlmIChzaXplVmFsdWUudW5pdCA9PT0gXCJtdVwiKSB7XG4gICAgLy8gYG11YCB1bml0cyBzY2FsZSB3aXRoIHNjcmlwdHN0eWxlL3NjcmlwdHNjcmlwdHN0eWxlLlxuICAgIHNjYWxlID0gb3B0aW9ucy5mb250TWV0cmljcygpLmNzc0VtUGVyTXU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXIgcmVsYXRpdmUgdW5pdHMgYWx3YXlzIHJlZmVyIHRvIHRoZSAqdGV4dHN0eWxlKiBmb250XG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgc2l6ZS5cbiAgICBsZXQgdW5pdE9wdGlvbnM7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgIC8vIGlzVGlnaHQoKSBtZWFucyBjdXJyZW50IHN0eWxlIGlzIHNjcmlwdC9zY3JpcHRzY3JpcHQuXG4gICAgICB1bml0T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS50ZXh0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfSAvLyBUT0RPOiBJbiBUZVggdGhlc2UgdW5pdHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBxdWFkIG9mIHRoZSBjdXJyZW50XG4gICAgLy8gKnRleHQqIGZvbnQsIGUuZy4gY21yMTAuIEthVGVYIGluc3RlYWQgdXNlcyB2YWx1ZXMgZnJvbSB0aGVcbiAgICAvLyBjb21wYXJhYmx5LXNpemVkICpDb21wdXRlciBNb2Rlcm4gc3ltYm9sKiBmb250LiBBdCAxMHB0LCB0aGVzZVxuICAgIC8vIG1hdGNoLiBBdCA3cHQgYW5kIDVwdCwgdGhleSBkaWZmZXI6IGNtcjc9MS4xMzg4OTQsIGNtc3k3PTEuMTcwNjQxO1xuICAgIC8vIGNtcjU9MS4zNjExMzMsIGNtc3k1PTEuNDcyMjQxLiBDb25zaWRlciAkXFxzY3JpcHRzaXplIGFcXGtlcm4xZW1iJC5cbiAgICAvLyBUZVggXFxzaG93bGlzdHMgc2hvd3MgYSBrZXJuIG9mIDEuMTM4ODkgKiBmb250c2l6ZTtcbiAgICAvLyBLYVRlWCBzaG93cyBhIGtlcm4gb2YgMS4xNzEgKiBmb250c2l6ZS5cblxuXG4gICAgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcImV4XCIpIHtcbiAgICAgIHNjYWxlID0gdW5pdE9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwiZW1cIikge1xuICAgICAgc2NhbGUgPSB1bml0T3B0aW9ucy5mb250TWV0cmljcygpLnF1YWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgc2l6ZVZhbHVlLnVuaXQgKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKHVuaXRPcHRpb25zICE9PSBvcHRpb25zKSB7XG4gICAgICBzY2FsZSAqPSB1bml0T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1hdGgubWluKHNpemVWYWx1ZS5udW1iZXIgKiBzY2FsZSwgb3B0aW9ucy5tYXhTaXplKTtcbn07XG4vKipcbiAqIFJvdW5kIGBuYCB0byA0IGRlY2ltYWwgcGxhY2VzLCBvciB0byB0aGUgbmVhcmVzdCAxLzEwLDAwMHRoIGVtLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LYVRlWC9LYVRlWC9wdWxsLzI0NjAuXG4gKi9cblxuY29uc3QgbWFrZUVtID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuICtuLnRvRml4ZWQoNCkgKyBcImVtXCI7XG59O1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RvbVRyZWUuanNcbi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSB0aGUgZGF0YSBhYm91dCB0aGUgRE9NIG5vZGVzIHdlIGNyZWF0ZSwgYXMgd2VsbCBhcyBzb21lXG4gKiBleHRyYSBkYXRhLiBUaGV5IGNhbiB0aGVuIGJlIHRyYW5zZm9ybWVkIGludG8gcmVhbCBET00gbm9kZXMgd2l0aCB0aGVcbiAqIGB0b05vZGVgIGZ1bmN0aW9uIG9yIEhUTUwgbWFya3VwIHVzaW5nIGB0b01hcmt1cGAuIFRoZXkgYXJlIHVzZWZ1bCBmb3IgYm90aFxuICogc3RvcmluZyBleHRyYSBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcywgYXMgd2VsbCBhcyBwcm92aWRpbmcgYSB3YXkgdG8gZWFzaWx5XG4gKiB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBTaW1pbGFyIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIE1hdGhNTCBub2RlcyBleGlzdCBpbiBtYXRoTUxUcmVlLmpzLlxuICpcbiAqIFRPRE86IHJlZmFjdG9yIGBzcGFuYCBhbmQgYGFuY2hvcmAgaW50byBjb21tb24gc3VwZXJjbGFzcyB3aGVuXG4gKiB0YXJnZXQgZW52aXJvbm1lbnRzIHN1cHBvcnQgY2xhc3MgaW5oZXJpdGFuY2VcbiAqL1xuXG5cblxuXG5cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGNsYXNzTmFtZSBiYXNlZCBvbiBhIGxpc3Qgb2YgY2xhc3Nlcy4gSW4gYWRkaXRpb24gdG8gam9pbmluZ1xuICogd2l0aCBzcGFjZXMsIHdlIGFsc28gcmVtb3ZlIGVtcHR5IGNsYXNzZXMuXG4gKi9cbmNvbnN0IGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgcmV0dXJuIGNsYXNzZXMuZmlsdGVyKGNscyA9PiBjbHMpLmpvaW4oXCIgXCIpO1xufTtcblxuY29uc3QgaW5pdE5vZGUgPSBmdW5jdGlvbiAoY2xhc3Nlcywgb3B0aW9ucywgc3R5bGUpIHtcbiAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgdGhpcy5kZXB0aCA9IDA7XG4gIHRoaXMubWF4Rm9udFNpemUgPSAwO1xuICB0aGlzLnN0eWxlID0gc3R5bGUgfHwge307XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBub2RlXG4gKi9cblxuXG5jb25zdCB0b05vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTsgLy8gQXBwbHkgdGhlIGNsYXNzXG5cbiAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpOyAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG5cbiAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzZWVtIHRvIHVuZGVyc3RhbmQgc3Bhbi5zdHlsZSdzIHR5cGUuXG4gICAgICBub2RlLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgIH1cbiAgfSAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cblxuICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICB9XG4gIH0gLy8gQXBwZW5kIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBIVE1MIG5vZGVzXG5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBodHRwczovL3czYy5naXRodWIuaW8vaHRtbC1yZWZlcmVuY2Uvc3ludGF4Lmh0bWwjc3ludGF4LWF0dHJpYnV0ZXNcbiAqXG4gKiA+IEF0dHJpYnV0ZSBOYW1lcyBtdXN0IGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgY2hhcmFjdGVyc1xuICogb3RoZXIgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVycywgVSswMDAwIE5VTEwsXG4gKiAnXCInLCBcIidcIiwgXCI+XCIsIFwiL1wiLCBcIj1cIiwgdGhlIGNvbnRyb2wgY2hhcmFjdGVycyxcbiAqIGFuZCBhbnkgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgZGVmaW5lZCBieSBVbmljb2RlLlxuICovXG5cblxuY29uc3QgaW52YWxpZEF0dHJpYnV0ZU5hbWVSZWdleCA9IC9bXFxzXCInPi89XFx4MDAtXFx4MWZdLztcbi8qKlxuICogQ29udmVydCBpbnRvIGFuIEhUTUwgbWFya3VwIHN0cmluZ1xuICovXG5cbmNvbnN0IHRvTWFya3VwID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgbGV0IG1hcmt1cCA9IFwiPFwiICsgdGFnTmFtZTsgLy8gQWRkIHRoZSBjbGFzc1xuXG4gIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgbWFya3VwICs9IFwiIGNsYXNzPVxcXCJcIiArIHV0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKSArIFwiXFxcIlwiO1xuICB9XG5cbiAgbGV0IHN0eWxlcyA9IFwiXCI7IC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuXG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlcykge1xuICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICB9IC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuXG5cbiAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlTmFtZVJlZ2V4LnRlc3QoYXR0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZSAnXCIgKyBhdHRyICsgXCInXCIpO1xuICAgICAgfVxuXG4gICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSkgKyBcIlxcXCJcIjtcbiAgICB9XG4gIH1cblxuICBtYXJrdXAgKz0gXCI+XCI7IC8vIEFkZCB0aGUgbWFya3VwIG9mIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBtYXJrdXBcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICB9XG5cbiAgbWFya3VwICs9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgcmV0dXJuIG1hcmt1cDtcbn07IC8vIE1ha2luZyB0aGUgdHlwZSBiZWxvdyBleGFjdCB3aXRoIGFsbCBvcHRpb25hbCBmaWVsZHMgZG9lc24ndCB3b3JrIGR1ZSB0b1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDU4MlxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNTY4OFxuLy8gSG93ZXZlciwgc2luY2UgKmFsbCogZmllbGRzIGFyZSBvcHRpb25hbCwgJFNoYXBlPD4gd29ya3MgYXMgc3VnZ2VzdGVkIGluIDU2ODhcbi8vIGFib3ZlLlxuLy8gVGhpcyB0eXBlIGRvZXMgbm90IGluY2x1ZGUgYWxsIENTUyBwcm9wZXJ0aWVzLiBBZGRpdGlvbmFsIHByb3BlcnRpZXMgc2hvdWxkXG4vLyBiZSBhZGRlZCBhcyBuZWVkZWQuXG5cblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYW4gbm9kZSwgd2l0aCBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmRcbiAqIGFuIGlubGluZSBzdHlsZS4gSXQgYWxzbyBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBpdHMgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqXG4gKiBSZXByZXNlbnRzIHR3byB0eXBlcyB3aXRoIGRpZmZlcmVudCB1c2VzOiBTdmdTcGFuIHRvIHdyYXAgYW4gU1ZHIGFuZCBEb21TcGFuXG4gKiBvdGhlcndpc2UuIFRoaXMgdHlwZXNhZmV0eSBpcyBpbXBvcnRhbnQgd2hlbiBIVE1MIGJ1aWxkZXJzIGFjY2VzcyBhIHNwYW4nc1xuICogY2hpbGRyZW4uXG4gKi9cbmNsYXNzIFNwYW4ge1xuICBjb25zdHJ1Y3RvcihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICBpbml0Tm9kZS5jYWxsKHRoaXMsIGNsYXNzZXMsIG9wdGlvbnMsIHN0eWxlKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gYXJiaXRyYXJ5IGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi4gV2FybmluZzogdXNlIHRoaXMgd2lzZWx5LiBOb3RcbiAgICogYWxsIGJyb3dzZXJzIHN1cHBvcnQgYXR0cmlidXRlcyB0aGUgc2FtZSwgYW5kIGhhdmluZyB0b28gbWFueSBjdXN0b21cbiAgICogYXR0cmlidXRlcyBpcyBwcm9iYWJseSBiYWQuXG4gICAqL1xuXG5cbiAgc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlO1xuICB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gdG9Ob2RlLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHRvTWFya3VwLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG5cbn1cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYW4gYW5jaG9yICg8YT4pIGVsZW1lbnQgd2l0aCBhIGh5cGVybGluay4gIFNlZSBgc3BhbmBcbiAqIGZvciBmdXJ0aGVyIGRldGFpbHMuXG4gKi9cblxuY2xhc3MgQW5jaG9yIHtcbiAgY29uc3RydWN0b3IoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIHRvTm9kZS5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB0b01hcmt1cC5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGFuIGltYWdlIGVtYmVkICg8aW1nPikgZWxlbWVudC5cbiAqL1xuXG5jbGFzcyBJbWcge1xuICBjb25zdHJ1Y3RvcihzcmMsIGFsdCwgc3R5bGUpIHtcbiAgICB0aGlzLnNyYyA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdCA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHQgPSBhbHQ7XG4gICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgdGhpcy5jbGFzc2VzID0gW1wibW9yZFwiXTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpO1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIG5vZGUuc3JjID0gdGhpcy5zcmM7XG4gICAgbm9kZS5hbHQgPSB0aGlzLmFsdDtcbiAgICBub2RlLmNsYXNzTmFtZSA9IFwibW9yZFwiOyAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG5cbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8aW1nIHNyYz1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5zcmMpICsgXCJcXFwiXCIgKyAoXCIgYWx0PVxcXCJcIiArIHV0aWxzLmVzY2FwZSh0aGlzLmFsdCkgKyBcIlxcXCJcIik7IC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuXG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG5cbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICBtYXJrdXAgKz0gXCIgc3R5bGU9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHN0eWxlcykgKyBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCInLz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbn1cbmNvbnN0IGlDb21iaW5hdGlvbnMgPSB7XG4gICfDric6ICdcXHUwMTMxXFx1MDMwMicsXG4gICfDryc6ICdcXHUwMTMxXFx1MDMwOCcsXG4gICfDrSc6ICdcXHUwMTMxXFx1MDMwMScsXG4gIC8vICfEqyc6ICdcXHUwMTMxXFx1MDMwNCcsIC8vIGVuYWJsZSB3aGVuIHdlIGFkZCBFeHRlbmRlZCBMYXRpblxuICAnw6wnOiAnXFx1MDEzMVxcdTAzMDAnXG59O1xuLyoqXG4gKiBBIHN5bWJvbCBub2RlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGEgc2luZ2xlIHN5bWJvbC4gSXQgZWl0aGVyIHJlbmRlcnNcbiAqIHRvIGEgc2luZ2xlIHRleHQgbm9kZSwgb3IgYSBzcGFuIHdpdGggYSBzaW5nbGUgdGV4dCBub2RlIGluIGl0LCBkZXBlbmRpbmcgb25cbiAqIHdoZXRoZXIgaXQgaGFzIENTUyBjbGFzc2VzLCBzdHlsZXMsIG9yIG5lZWRzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICovXG5cbmNsYXNzIFN5bWJvbE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBoZWlnaHQsIGRlcHRoLCBpdGFsaWMsIHNrZXcsIHdpZHRoLCBjbGFzc2VzLCBzdHlsZSkge1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMuaXRhbGljID0gdm9pZCAwO1xuICAgIHRoaXMuc2tldyA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aCB8fCAwO1xuICAgIHRoaXMuaXRhbGljID0gaXRhbGljIHx8IDA7XG4gICAgdGhpcy5za2V3ID0gc2tldyB8fCAwO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwOyAvLyBNYXJrIHRleHQgZnJvbSBub24tTGF0aW4gc2NyaXB0cyB3aXRoIHNwZWNpZmljIGNsYXNzZXMgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBzcGVjaWZ5IHdoaWNoIGZvbnRzIHRvIHVzZS4gIFRoaXMgYWxsb3dzIHVzIHRvIHJlbmRlciB0aGVzZVxuICAgIC8vIGNoYXJhY3RlcnMgd2l0aCBhIHNlcmlmIGZvbnQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgYnJvd3NlciB3b3VsZFxuICAgIC8vIGVpdGhlciBkZWZhdWx0IHRvIGEgc2FucyBzZXJpZiBvciByZW5kZXIgYSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIuXG4gICAgLy8gV2UgdXNlIENTUyBjbGFzcyBuYW1lcyBsaWtlIGNqa19mYWxsYmFjaywgaGFuZ3VsX2ZhbGxiYWNrIGFuZFxuICAgIC8vIGJyYWhtaWNfZmFsbGJhY2suIFNlZSAuL3VuaWNvZGVTY3JpcHRzLmpzIGZvciB0aGUgc2V0IG9mIHBvc3NpYmxlXG4gICAgLy8gc2NyaXB0IG5hbWVzXG5cbiAgICBjb25zdCBzY3JpcHQgPSBzY3JpcHRGcm9tQ29kZXBvaW50KHRoaXMudGV4dC5jaGFyQ29kZUF0KDApKTtcblxuICAgIGlmIChzY3JpcHQpIHtcbiAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKHNjcmlwdCArIFwiX2ZhbGxiYWNrXCIpO1xuICAgIH1cblxuICAgIGlmICgvW8Ouw6/DrcOsXS8udGVzdCh0aGlzLnRleHQpKSB7XG4gICAgICAvLyBhZGQgxKsgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAgIHRoaXMudGV4dCA9IGlDb21iaW5hdGlvbnNbdGhpcy50ZXh0XTtcbiAgICB9XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGV4dCBub2RlIG9yIHNwYW4gZnJvbSBhIHN5bWJvbCBub2RlLiBOb3RlIHRoYXQgYSBzcGFuIGlzIG9ubHlcbiAgICogY3JlYXRlZCBpZiBpdCBpcyBuZWVkZWQuXG4gICAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICAgIGxldCBzcGFuID0gbnVsbDtcblxuICAgIGlmICh0aGlzLml0YWxpYyA+IDApIHtcbiAgICAgIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSBtYWtlRW0odGhpcy5pdGFsaWMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7IC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHNlZW0gdG8gdW5kZXJzdGFuZCBzcGFuLnN0eWxlJ3MgdHlwZS5cblxuICAgICAgICBzcGFuLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGFuKSB7XG4gICAgICBzcGFuLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgcmV0dXJuIHNwYW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgc3ltYm9sIG5vZGUuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgLy8gVE9ETyhhbHBlcnQpOiBNb3JlIGR1cGxpY2F0aW9uIHRoYW4gSSdkIGxpa2UgZnJvbVxuICAgIC8vIHNwYW4ucHJvdG90eXBlLnRvTWFya3VwIGFuZCBzeW1ib2xOb2RlLnByb3RvdHlwZS50b05vZGUuLi5cbiAgICBsZXQgbmVlZHNTcGFuID0gZmFsc2U7XG4gICAgbGV0IG1hcmt1cCA9IFwiPHNwYW5cIjtcblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgbWFya3VwICs9IFwiIGNsYXNzPVxcXCJcIjtcbiAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSk7XG4gICAgICBtYXJrdXAgKz0gXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG5cbiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7XG4gICAgICBzdHlsZXMgKz0gXCJtYXJnaW4tcmlnaHQ6XCIgKyB0aGlzLml0YWxpYyArIFwiZW07XCI7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbmVlZHNTcGFuID0gdHJ1ZTtcbiAgICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICAgIH1cblxuICAgIGNvbnN0IGVzY2FwZWQgPSB1dGlscy5lc2NhcGUodGhpcy50ZXh0KTtcblxuICAgIGlmIChuZWVkc1NwYW4pIHtcbiAgICAgIG1hcmt1cCArPSBcIj5cIjtcbiAgICAgIG1hcmt1cCArPSBlc2NhcGVkO1xuICAgICAgbWFya3VwICs9IFwiPC9zcGFuPlwiO1xuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuICB9XG5cbn1cbi8qKlxuICogU1ZHIG5vZGVzIGFyZSB1c2VkIHRvIHJlbmRlciBzdHJldGNoeSB3aWRlIGVsZW1lbnRzLlxuICovXG5cbmNsYXNzIFN2Z05vZGUge1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgYXR0cmlidXRlcykge1xuICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwic3ZnXCIpOyAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcIjsgLy8gQXBwbHkgYXR0cmlidXRlc1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKSArIFwiXFxcIlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI8L3N2Zz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbn1cbmNsYXNzIFBhdGhOb2RlIHtcbiAgY29uc3RydWN0b3IocGF0aE5hbWUsIGFsdGVybmF0ZSkge1xuICAgIHRoaXMucGF0aE5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHRlcm5hdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoTmFtZSA9IHBhdGhOYW1lO1xuICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlOyAvLyBVc2VkIG9ubHkgZm9yIFxcc3FydCwgXFxwaGFzZSwgJiB0YWxsIGRlbGltc1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwicGF0aFwiKTtcblxuICAgIGlmICh0aGlzLmFsdGVybmF0ZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkXCIsIHRoaXMuYWx0ZXJuYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkXCIsIHBhdGhbdGhpcy5wYXRoTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgaWYgKHRoaXMuYWx0ZXJuYXRlKSB7XG4gICAgICByZXR1cm4gXCI8cGF0aCBkPVxcXCJcIiArIHV0aWxzLmVzY2FwZSh0aGlzLmFsdGVybmF0ZSkgKyBcIlxcXCIvPlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCI8cGF0aCBkPVxcXCJcIiArIHV0aWxzLmVzY2FwZShwYXRoW3RoaXMucGF0aE5hbWVdKSArIFwiXFxcIi8+XCI7XG4gICAgfVxuICB9XG5cbn1cbmNsYXNzIExpbmVOb2RlIHtcbiAgY29uc3RydWN0b3IoYXR0cmlidXRlcykge1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwibGluZVwiKTsgLy8gQXBwbHkgYXR0cmlidXRlc1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8bGluZVwiO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKSArIFwiXFxcIlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIi8+XCI7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuXG59XG5mdW5jdGlvbiBhc3NlcnRTeW1ib2xEb21Ob2RlKGdyb3VwKSB7XG4gIGlmIChncm91cCBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3ltYm9sTm9kZSBidXQgZ290IFwiICsgU3RyaW5nKGdyb3VwKSArIFwiLlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U3Bhbihncm91cCkge1xuICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBTcGFuKSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHNwYW48SHRtbERvbU5vZGU+IGJ1dCBnb3QgXCIgKyBTdHJpbmcoZ3JvdXApICsgXCIuXCIpO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3ltYm9scy5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgaG9sZHMgYSBsaXN0IG9mIGFsbCBuby1hcmd1bWVudCBmdW5jdGlvbnMgYW5kIHNpbmdsZS1jaGFyYWN0ZXJcbiAqIHN5bWJvbHMgKGxpa2UgJ2EnIG9yICc7JykuXG4gKlxuICogRm9yIGVhY2ggb2YgdGhlIHN5bWJvbHMsIHRoZXJlIGFyZSB0aHJlZSBwcm9wZXJ0aWVzIHRoZXkgY2FuIGhhdmU6XG4gKiAtIGZvbnQgKHJlcXVpcmVkKTogdGhlIGZvbnQgdG8gYmUgdXNlZCBmb3IgdGhpcyBzeW1ib2wuIEVpdGhlciBcIm1haW5cIiAodGhlXG4gICAgIG5vcm1hbCBmb250KSwgb3IgXCJhbXNcIiAodGhlIGFtcyBmb250cykuXG4gKiAtIGdyb3VwIChyZXF1aXJlZCk6IHRoZSBQYXJzZU5vZGUgZ3JvdXAgdHlwZSB0aGUgc3ltYm9sIHNob3VsZCBoYXZlIChpLmUuXG4gICAgIFwidGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgZXRjKS5cbiAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LYVRlWC9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuLy8gU29tZSBvZiB0aGVzZSBoYXZlIGEgXCItdG9rZW5cIiBzdWZmaXggc2luY2UgdGhlc2UgYXJlIGFsc28gdXNlZCBhcyBgUGFyc2VOb2RlYFxuLy8gdHlwZXMgZm9yIHJhdyB0ZXh0IHRva2VucywgYW5kIHdlIHdhbnQgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaGlnaGVyLWxldmVsXG4vLyBgUGFyc2VOb2RlYCB0eXBlcy4gVGhlc2UgYFBhcnNlTm9kZWBzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoaW4gYFBhcnNlcmAgYnlcbi8vIGxvb2tpbmcgdXAgdGhlIGBzeW1ib2xzYCBtYXAuXG5jb25zdCBBVE9NUyA9IHtcbiAgXCJiaW5cIjogMSxcbiAgXCJjbG9zZVwiOiAxLFxuICBcImlubmVyXCI6IDEsXG4gIFwib3BlblwiOiAxLFxuICBcInB1bmN0XCI6IDEsXG4gIFwicmVsXCI6IDFcbn07XG5jb25zdCBOT05fQVRPTVMgPSB7XG4gIFwiYWNjZW50LXRva2VuXCI6IDEsXG4gIFwibWF0aG9yZFwiOiAxLFxuICBcIm9wLXRva2VuXCI6IDEsXG4gIFwic3BhY2luZ1wiOiAxLFxuICBcInRleHRvcmRcIjogMVxufTtcbmNvbnN0IHN5bWJvbHMgPSB7XG4gIFwibWF0aFwiOiB7fSxcbiAgXCJ0ZXh0XCI6IHt9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3N5bWJvbHMgPSAoc3ltYm9scyk7XG4vKiogYGFjY2VwdFVuaWNvZGVDaGFyID0gdHJ1ZWAgaXMgb25seSBhcHBsaWNhYmxlIGlmIGByZXBsYWNlYCBpcyBzZXQuICovXG5cbmZ1bmN0aW9uIGRlZmluZVN5bWJvbChtb2RlLCBmb250LCBncm91cCwgcmVwbGFjZSwgbmFtZSwgYWNjZXB0VW5pY29kZUNoYXIpIHtcbiAgc3ltYm9sc1ttb2RlXVtuYW1lXSA9IHtcbiAgICBmb250LFxuICAgIGdyb3VwLFxuICAgIHJlcGxhY2VcbiAgfTtcblxuICBpZiAoYWNjZXB0VW5pY29kZUNoYXIgJiYgcmVwbGFjZSkge1xuICAgIHN5bWJvbHNbbW9kZV1bcmVwbGFjZV0gPSBzeW1ib2xzW21vZGVdW25hbWVdO1xuICB9XG59IC8vIFNvbWUgYWJicmV2aWF0aW9ucyBmb3IgY29tbW9ubHkgdXNlZCBzdHJpbmdzLlxuLy8gVGhpcyBoZWxwcyBtaW5pZnkgdGhlIGNvZGUsIGFuZCBhbHNvIHNwb3R0aW5nIHR5cG9zIHVzaW5nIGpzaGludC5cbi8vIG1vZGVzOlxuXG5jb25zdCBtYXRoID0gXCJtYXRoXCI7XG5jb25zdCBzeW1ib2xzX3RleHQgPSBcInRleHRcIjsgLy8gZm9udHM6XG5cbmNvbnN0IG1haW4gPSBcIm1haW5cIjtcbmNvbnN0IGFtcyA9IFwiYW1zXCI7IC8vIGdyb3VwczpcblxuY29uc3QgYWNjZW50ID0gXCJhY2NlbnQtdG9rZW5cIjtcbmNvbnN0IGJpbiA9IFwiYmluXCI7XG5jb25zdCBzeW1ib2xzX2Nsb3NlID0gXCJjbG9zZVwiO1xuY29uc3QgaW5uZXIgPSBcImlubmVyXCI7XG5jb25zdCBtYXRob3JkID0gXCJtYXRob3JkXCI7XG5jb25zdCBvcCA9IFwib3AtdG9rZW5cIjtcbmNvbnN0IHN5bWJvbHNfb3BlbiA9IFwib3BlblwiO1xuY29uc3QgcHVuY3QgPSBcInB1bmN0XCI7XG5jb25zdCByZWwgPSBcInJlbFwiO1xuY29uc3Qgc3BhY2luZyA9IFwic3BhY2luZ1wiO1xuY29uc3QgdGV4dG9yZCA9IFwidGV4dG9yZFwiOyAvLyBOb3cgY29tZXMgdGhlIHN5bWJvbCB0YWJsZVxuLy8gUmVsYXRpb24gU3ltYm9sc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjFcIiwgXCJcXFxcZXF1aXZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyN2FcIiwgXCJcXFxccHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI3YlwiLCBcIlxcXFxzdWNjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjNjXCIsIFwiXFxcXHNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJhNVwiLCBcIlxcXFxwZXJwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyYWFmXCIsIFwiXFxcXHByZWNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MmFiMFwiLCBcIlxcXFxzdWNjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDNcIiwgXCJcXFxcc2ltZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMjNcIiwgXCJcXFxcbWlkXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjZhXCIsIFwiXFxcXGxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjZiXCIsIFwiXFxcXGdnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjRkXCIsIFwiXFxcXGFzeW1wXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmM4XCIsIFwiXFxcXGJvd3RpZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjMyM1wiLCBcIlxcXFxzbWlsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI5MVwiLCBcIlxcXFxzcXN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkyXCIsIFwiXFxcXHNxc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNTBcIiwgXCJcXFxcZG90ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIzMjJcIiwgXCJcXFxcZnJvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcbmlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxccHJvcHRvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmEyXCIsIFwiXFxcXHZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmEzXCIsIFwiXFxcXGRhc2h2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjBiXCIsIFwiXFxcXG93bnNcIik7IC8vIFB1bmN0dWF0aW9uXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCJcXHUwMDJlXCIsIFwiXFxcXGxkb3RwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdHBcIik7IC8vIE1pc2MgU3ltYm9sc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMDIzXCIsIFwiXFxcXCNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwMjNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwMjZcIiwgXCJcXFxcJlwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEzNVwiLCBcIlxcXFxhbGVwaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDBcIiwgXCJcXFxcZm9yYWxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwM1wiLCBcIlxcXFxleGlzdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExOFwiLCBcIlxcXFx3cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NmZcIiwgXCJcXFxcc2hhcnBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExY1wiLCBcIlxcXFxSZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjFcIiwgXCJcXFxcaGVhcnRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjBcIiwgXCJcXFxcc3BhZGVzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhN1wiLCBcIlxcXFxTXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGE3XCIsIFwiXFxcXFNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGI2XCIsIFwiXFxcXFBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjZcIiwgXCJcXFxcUFwiKTsgLy8gTWF0aCBhbmQgVGV4dFxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMFwiLCBcIlxcXFxkYWdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcdGV4dGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXHRleHRkYWdnZXJkYmxcIik7IC8vIExhcmdlIERlbGltaXRlcnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjNiMVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJcXHUyM2IwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyN2VmXCIsIFwiXFxcXHJncm91cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjdlZVwiLCBcIlxcXFxsZ3JvdXBcIiwgdHJ1ZSk7IC8vIEJpbmFyeSBPcGVyYXRvcnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEzXCIsIFwiXFxcXG1wXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk2XCIsIFwiXFxcXG9taW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI4ZVwiLCBcIlxcXFx1cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5M1wiLCBcIlxcXFxzcWNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxN1wiLCBcIlxcXFxhc3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTRcIiwgXCJcXFxcc3FjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1ZWZcIiwgXCJcXFxcYmlnY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxOVwiLCBcIlxcXFxidWxsZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI0MFwiLCBcIlxcXFx3clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MmEzZlwiLCBcIlxcXFxhbWFsZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MDAyNlwiLCBcIlxcXFxBbmRcIik7IC8vIGZyb20gYW1zbWF0aFxuLy8gQXJyb3cgU3ltYm9sc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMFwiLCBcIlxcXFxMZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjhcIiwgXCJcXFxcTG9uZ2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMlwiLCBcIlxcXFxSaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y5XCIsIFwiXFxcXExvbmdyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y3XCIsIFwiXFxcXGxvbmdsZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNFwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmYVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYTZcIiwgXCJcXFxcbWFwc3RvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2ZjXCIsIFwiXFxcXGxvbmdtYXBzdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFhOVwiLCBcIlxcXFxob29rbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWFhXCIsIFwiXFxcXGhvb2tyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYmNcIiwgXCJcXFxcbGVmdGhhcnBvb251cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMFwiLCBcIlxcXFxyaWdodGhhcnBvb251cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWJkXCIsIFwiXFxcXGxlZnRoYXJwb29uZG93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMVwiLCBcIlxcXFxyaWdodGhhcnBvb25kb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxY2NcIiwgXCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIiwgdHJ1ZSk7IC8vIEFNUyBOZWdhdGVkIEJpbmFyeSBSZWxhdGlvbnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmVcIiwgXCJcXFxcbmxlc3NcIiwgdHJ1ZSk7IC8vIFN5bWJvbCBuYW1lcyBwcmVjZWRlZCBieSBcIkBcIiBlYWNoIGhhdmUgYSBjb3JyZXNwb25kaW5nIG1hY3JvLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxMFwiLCBcIlxcXFxAbmxlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTFcIiwgXCJcXFxcQG5sZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODdcIiwgXCJcXFxcbG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY4XCIsIFwiXFxcXGxuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGNcIiwgXCJcXFxcQGx2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU2XCIsIFwiXFxcXGxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODlcIiwgXCJcXFxcbG5hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4MFwiLCBcIlxcXFxucHJlY1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMCB0byBcXG5wcmVjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTBcIiwgXCJcXFxcbnByZWNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU4XCIsIFwiXFxcXHByZWNuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjlcIiwgXCJcXFxccHJlY25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0MVwiLCBcIlxcXFxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMDZcIiwgXCJcXFxcQG5zaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI0XCIsIFwiXFxcXG5taWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhY1wiLCBcIlxcXFxudmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhZFwiLCBcIlxcXFxudkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlYVwiLCBcIlxcXFxudHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWNcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGFcIiwgXCJcXFxcc3Vic2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMWFcIiwgXCJcXFxcQHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNiXCIsIFwiXFxcXHN1YnNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxN1wiLCBcIlxcXFxAdmFyc3Vic2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZmXCIsIFwiXFxcXG5ndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwZlwiLCBcIlxcXFxAbmdlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGVcIiwgXCJcXFxcQG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODhcIiwgXCJcXFxcZ25lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY5XCIsIFwiXFxcXGduZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGRcIiwgXCJcXFxcQGd2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU3XCIsIFwiXFxcXGduc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOGFcIiwgXCJcXFxcZ25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4MVwiLCBcIlxcXFxuc3VjY1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMSB0byBcXG5zdWNjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU5XCIsIFwiXFxcXHN1Y2Nuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYmFcIiwgXCJcXFxcc3VjY25hcHByb3hcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyNDYgdG8gXFxzaW1uZXFxLiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDA3XCIsIFwiXFxcXEBuc2hvcnRwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI2XCIsIFwiXFxcXG5wYXJhbGxlbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFmXCIsIFwiXFxcXG5WRGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmViXCIsIFwiXFxcXG50cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWRcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDE4XCIsIFwiXFxcXEBuc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGJcIiwgXCJcXFxcc3Vwc2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMWJcIiwgXCJcXFxcQHZhcnN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxOVwiLCBcIlxcXFxAdmFyc3Vwc2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFlXCIsIFwiXFxcXG5WZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI1XCIsIFwiXFxcXHByZWNuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjZcIiwgXCJcXFxcc3VjY25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxNlwiLCBcIlxcXFxAbnN1YnNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmI0XCIsIFwiXFxcXHVubGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjVcIiwgXCJcXFxcdW5yaGRcIik7IC8vIEFNUyBOZWdhdGVkIEFycm93c1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5YVwiLCBcIlxcXFxubGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxOWJcIiwgXCJcXFxcbnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZFwiLCBcIlxcXFxuTGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2ZcIiwgXCJcXFxcblJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhZVwiLCBcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZVwiLCBcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7IC8vIEFNUyBNaXNjXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjRjOFwiLCBcIlxcXFxjaXJjbGVkU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgdGV4dG9yZCwgXCJcXHUwMGFlXCIsIFwiXFxcXGNpcmNsZWRSXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjIxXCIsIFwiXFxcXG1lYXN1cmVkYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIyMDRcIiwgXCJcXFxcbmV4aXN0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEyN1wiLCBcIlxcXFxtaG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzJcIiwgXCJcXFxcRmludlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjE0MVwiLCBcIlxcXFxHYW1lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMDM1XCIsIFwiXFxcXGJhY2twcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViMlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWJjXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWEwXCIsIFwiXFxcXGJsYWNrc3F1YXJlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyOWViXCIsIFwiXFxcXGJsYWNrbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjIyXCIsIFwiXFxcXHNwaGVyaWNhbGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjAxXCIsIFwiXFxcXGNvbXBsZW1lbnRcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrRjAgdG8gXFxtYXRoZXRoLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxcZXRoXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBmMFwiLCBcIlxcXFxldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXHUwMGYwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjU3MlwiLCBcIlxcXFxkaWFnZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXERpYW1vbmRcIik7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrQTUgdG8gXFxtYXRoeWVuLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxceWVuXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIpOyAvLyBBTVMgSGVicmV3XG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEzNlwiLCBcIlxcXFxiZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM4XCIsIFwiXFxcXGRhbGV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEzN1wiLCBcIlxcXFxnaW1lbFwiLCB0cnVlKTsgLy8gQU1TIEdyZWVrXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDNkZFwiLCBcIlxcXFxkaWdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwM2YwXCIsIFwiXFxcXHZhcmthcHBhXCIpOyAvLyBBTVMgRGVsaW1pdGVyc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBzeW1ib2xzX29wZW4sIFwiXFx1MjUwY1wiLCBcIlxcXFxAdWxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTI1MTBcIiwgXCJcXFxcQHVyY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgc3ltYm9sc19vcGVuLCBcIlxcdTI1MTRcIiwgXCJcXFxcQGxsY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgc3ltYm9sc19jbG9zZSwgXCJcXHUyNTE4XCIsIFwiXFxcXEBscmNvcm5lclwiLCB0cnVlKTsgLy8gQU1TIEJpbmFyeSBSZWxhdGlvbnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjZcIiwgXCJcXFxcbGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTdkXCIsIFwiXFxcXGxlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOTVcIiwgXCJcXFxcZXFzbGFudGxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3MlwiLCBcIlxcXFxsZXNzc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODVcIiwgXCJcXFxcbGVzc2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjRhXCIsIFwiXFxcXGFwcHJveGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDZcIiwgXCJcXFxcbGVzc2RvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ4XCIsIFwiXFxcXGxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc2XCIsIFwiXFxcXGxlc3NndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkYVwiLCBcIlxcXFxsZXNzZXFndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4YlwiLCBcIlxcXFxsZXNzZXFxZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcZG90ZXFkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1M1wiLCBcIlxcXFxyaXNpbmdkb3RzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MlwiLCBcIlxcXFxmYWxsaW5nZG90c2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyM2RcIiwgXCJcXFxcYmFja3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmNkXCIsIFwiXFxcXGJhY2tzaW1lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWM1XCIsIFwiXFxcXHN1YnNldGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQwXCIsIFwiXFxcXFN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhmXCIsIFwiXFxcXHNxc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2NcIiwgXCJcXFxccHJlY2N1cmx5ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkZVwiLCBcIlxcXFxjdXJseWVxcHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdlXCIsIFwiXFxcXHByZWNzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiN1wiLCBcIlxcXFxwcmVjYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjJcIiwgXCJcXFxcdmFydHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjRcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhOFwiLCBcIlxcXFx2RGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFhXCIsIFwiXFxcXFZ2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtYWxsc21pbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxzbWFsbGZyb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGZcIiwgXCJcXFxcYnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGVcIiwgXCJcXFxcQnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjdcIiwgXCJcXFxcZ2VxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTdlXCIsIFwiXFxcXGdlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOTZcIiwgXCJcXFxcZXFzbGFudGd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjczXCIsIFwiXFxcXGd0cnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg2XCIsIFwiXFxcXGd0cmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQ3XCIsIFwiXFxcXGd0cmRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ5XCIsIFwiXFxcXGdnZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc3XCIsIFwiXFxcXGd0cmxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkYlwiLCBcIlxcXFxndHJlcWxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4Y1wiLCBcIlxcXFxndHJlcXFsZXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTZcIiwgXCJcXFxcZXFjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTdcIiwgXCJcXFxcY2lyY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNWNcIiwgXCJcXFxcdHJpYW5nbGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcdGhpY2tzaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFx0aGlja2FwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWM2XCIsIFwiXFxcXHN1cHNldGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQxXCIsIFwiXFxcXFN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjkwXCIsIFwiXFxcXHNxc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2RcIiwgXCJcXFxcc3VjY2N1cmx5ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkZlwiLCBcIlxcXFxjdXJseWVxc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdmXCIsIFwiXFxcXHN1Y2NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiOFwiLCBcIlxcXFxzdWNjYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjNcIiwgXCJcXFxcdmFydHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmI1XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmE5XCIsIFwiXFxcXFZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjNcIiwgXCJcXFxcc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxzaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmNcIiwgXCJcXFxcYmV0d2VlblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ0XCIsIFwiXFxcXHBpdGNoZm9ya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjFkXCIsIFwiXFxcXHZhcnByb3B0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWMwXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVsZWZ0XCIpOyAvLyB1bmljb2RlLW1hdGggc2F5cyB0aGF0IFxcdGhlcmVmb3JlIGlzIGEgbWF0aG9yZCBhdG9tLlxuLy8gV2Uga2VwdCB0aGUgYW1zc3ltYiBhdG9tIHR5cGUsIHdoaWNoIGlzIHJlbC5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzRcIiwgXCJcXFxcdGhlcmVmb3JlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMGRcIiwgXCJcXFxcYmFja2Vwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjViNlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlcmlnaHRcIik7IC8vIHVuaWNvZGUtbWF0aCBzYXlzIHRoYXQgXFxiZWNhdXNlIGlzIGEgbWF0aG9yZCBhdG9tLlxuLy8gV2Uga2VwdCB0aGUgYW1zc3ltYiBhdG9tIHR5cGUsIHdoaWNoIGlzIHJlbC5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzVcIiwgXCJcXFxcYmVjYXVzZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ4XCIsIFwiXFxcXGxsbGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ5XCIsIFwiXFxcXGdnZ3RyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjJcIiwgXCJcXFxcbGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjNcIiwgXCJcXFxccmhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNDJcIiwgXCJcXFxcZXFzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYzhcIiwgXCJcXFxcSm9pblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUxXCIsIFwiXFxcXERvdGVxXCIsIHRydWUpOyAvLyBBTVMgQmluYXJ5IE9wZXJhdG9yc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjIxNFwiLCBcIlxcXFxkb3RwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc21hbGxzZXRtaW51c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXENhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXEN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyYTVlXCIsIFwiXFxcXGRvdWJsZWJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyOWZcIiwgXCJcXFxcYm94bWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZVwiLCBcIlxcXFxib3hwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzdcIiwgXCJcXFxcZGl2aWRlb250aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmM5XCIsIFwiXFxcXGx0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNhXCIsIFwiXFxcXHJ0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNiXCIsIFwiXFxcXGxlZnR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2NcIiwgXCJcXFxccmlnaHR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2ZcIiwgXCJcXFxcY3VybHl3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNlXCIsIFwiXFxcXGN1cmx5dmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyOWRcIiwgXCJcXFxcY2lyY2xlZGRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5YlwiLCBcIlxcXFxjaXJjbGVkYXN0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzVcIiwgXCJcXFxcY2VudGVyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmFcIiwgXCJcXFxcaW50ZXJjYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkMlwiLCBcIlxcXFxkb3VibGVjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkM1wiLCBcIlxcXFxkb3VibGVjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJhMFwiLCBcIlxcXFxib3h0aW1lc1wiLCB0cnVlKTsgLy8gQU1TIEFycm93c1xuLy8gTm90ZTogdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFlMiB0byB0aGVpciBvd24gZnVuY3Rpb24gXFxyaWdodGRhc2hhcnJvdy5cbi8vIFdlJ2xsIG1hcCBpdCB0byBBTVMgZnVuY3Rpb24gXFxkYXNocmlnaHRhcnJvdy4gSXQgcHJvZHVjZXMgdGhlIHNhbWUgYXRvbS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZTJcIiwgXCJcXFxcZGFzaHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxZTAgdG8gXFxsZWZ0ZGFzaGFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFlMFwiLCBcIlxcXFxkYXNobGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzdcIiwgXCJcXFxcbGVmdGxlZnRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjNlwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkYVwiLCBcIlxcXFxMbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxOWVcIiwgXCJcXFxcdHdvaGVhZGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWEyXCIsIFwiXFxcXGxlZnRhcnJvd3RhaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhYlwiLCBcIlxcXFxsb29wYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2JcIiwgXCJcXFxcbGVmdHJpZ2h0aGFycG9vbnNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiNlwiLCBcIlxcXFxjdXJ2ZWFycm93bGVmdFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFiYSB0byBcXGFjd29wZW5jaXJjbGVhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjBcIiwgXCJcXFxcTHNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJmXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjM1wiLCBcIlxcXFxkb3duaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYjZcIiwgXCJcXFxcb3JpZ29mXCIsIHRydWUpOyAvLyBub3QgaW4gZm9udFxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYjdcIiwgXCJcXFxcaW1hZ2VvZlwiLCB0cnVlKTsgLy8gbm90IGluIGZvbnRcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjhcIiwgXCJcXFxcbXVsdGltYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhZFwiLCBcIlxcXFxsZWZ0cmlnaHRzcXVpZ2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzlcIiwgXCJcXFxccmlnaHRyaWdodGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWM0XCIsIFwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWEwXCIsIFwiXFxcXHR3b2hlYWRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTNcIiwgXCJcXFxccmlnaHRhcnJvd3RhaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhY1wiLCBcIlxcXFxsb29wYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWI3XCIsIFwiXFxcXGN1cnZlYXJyb3dyaWdodFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFiYiB0byBcXGN3b3BlbmNpcmNsZWFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiYlwiLCBcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjFcIiwgXCJcXFxcUnNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2FcIiwgXCJcXFxcZG93bmRvd25hcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFx1cGhhcnBvb25yaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWMyXCIsIFwiXFxcXGRvd25oYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxyaWdodHNxdWlnYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxsZWFkc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGJcIiwgXCJcXFxcUnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFxyZXN0cmljdGlvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCIkXCIsIFwiXFxcXCRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIiRcIiwgXCJcXFxcdGV4dGRvbGxhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIiVcIiwgXCJcXFxcJVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJfXCIsIFwiXFxcXF9cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIl9cIiwgXCJcXFxcdGV4dHVuZGVyc2NvcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjIwXCIsIFwiXFxcXGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIxZVwiLCBcIlxcXFxpbmZ0eVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMzJcIiwgXCJcXFxccHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNWIzXCIsIFwiXFxcXHRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5M1wiLCBcIlxcXFxHYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOTRcIiwgXCJcXFxcRGVsdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzk4XCIsIFwiXFxcXFRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5YlwiLCBcIlxcXFxMYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzllXCIsIFwiXFxcXFhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhMFwiLCBcIlxcXFxQaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTNcIiwgXCJcXFxcU2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E1XCIsIFwiXFxcXFVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E2XCIsIFwiXFxcXFBoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYThcIiwgXCJcXFxcUHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhOVwiLCBcIlxcXFxPbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIkFcIiwgXCJcXHUwMzkxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiQlwiLCBcIlxcdTAzOTJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJFXCIsIFwiXFx1MDM5NVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlpcIiwgXCJcXHUwMzk2XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiSFwiLCBcIlxcdTAzOTdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJJXCIsIFwiXFx1MDM5OVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIktcIiwgXCJcXHUwMzlBXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiTVwiLCBcIlxcdTAzOUNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJOXCIsIFwiXFx1MDM5RFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIk9cIiwgXCJcXHUwMzlGXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiUFwiLCBcIlxcdTAzQTFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJUXCIsIFwiXFx1MDNBNFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlhcIiwgXCJcXHUwM0E3XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhY1wiLCBcIlxcXFxuZWdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGFjXCIsIFwiXFxcXGxub3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMmE0XCIsIFwiXFxcXHRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyYTVcIiwgXCJcXFxcYm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwNVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIwNVwiLCBcIlxcXFx2YXJub3RoaW5nXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiMVwiLCBcIlxcXFxhbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjJcIiwgXCJcXFxcYmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjNcIiwgXCJcXFxcZ2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I0XCIsIFwiXFxcXGRlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNmNVwiLCBcIlxcXFxlcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiNlwiLCBcIlxcXFx6ZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiN1wiLCBcIlxcXFxldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I4XCIsIFwiXFxcXHRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiOVwiLCBcIlxcXFxpb3RhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiYVwiLCBcIlxcXFxrYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmJcIiwgXCJcXFxcbGFtYmRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiY1wiLCBcIlxcXFxtdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmRcIiwgXCJcXFxcbnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JlXCIsIFwiXFxcXHhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiZlwiLCBcIlxcXFxvbWljcm9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjMFwiLCBcIlxcXFxwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzFcIiwgXCJcXFxccmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjM1wiLCBcIlxcXFxzaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzRcIiwgXCJcXFxcdGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNVwiLCBcIlxcXFx1cHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNkNVwiLCBcIlxcXFxwaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M3XCIsIFwiXFxcXGNoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzhcIiwgXCJcXFxccHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjOVwiLCBcIlxcXFxvbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjVcIiwgXCJcXFxcdmFyZXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZDFcIiwgXCJcXFxcdmFydGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Q2XCIsIFwiXFxcXHZhcnBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNmMVwiLCBcIlxcXFx2YXJyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MyXCIsIFwiXFxcXHZhcnNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNlwiLCBcIlxcXFx2YXJwaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTdcIiwgXCIqXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCIrXCIsIFwiK1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxMlwiLCBcIi1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxOFwiLCBcIlxcXFxjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGY3XCIsIFwiXFxcXGRpdlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MDBiMVwiLCBcIlxcXFxwbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MDBkN1wiLCBcIlxcXFx0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOVwiLCBcIlxcXFxjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMmFcIiwgXCJcXFxcY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE2XCIsIFwiXFxcXHNldG1pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI3XCIsIFwiXFxcXGxhbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcbG9yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI3XCIsIFwiXFxcXHdlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI4XCIsIFwiXFxcXHZlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMWFcIiwgXCJcXFxcc3VyZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjdlOFwiLCBcIlxcXFxsYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTIyMjNcIiwgXCJcXFxcbHZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTIyMjVcIiwgXCJcXFxcbFZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCI/XCIsIFwiP1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIiFcIiwgXCIhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjdlOVwiLCBcIlxcXFxyYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMjIzXCIsIFwiXFxcXHJ2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjIyNVwiLCBcIlxcXFxyVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPVwiLCBcIj1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIjpcIiwgXCI6XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXGFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0NVwiLCBcIlxcXFxjb25nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxnZXRzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI+XCIsIFwiXFxcXGd0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjA4XCIsIFwiXFxcXGluXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHVlMDIwXCIsIFwiXFxcXEBub3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODJcIiwgXCJcXFxcc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjgzXCIsIFwiXFxcXHN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4NlwiLCBcIlxcXFxzdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4N1wiLCBcIlxcXFxzdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjg4XCIsIFwiXFxcXG5zdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjg5XCIsIFwiXFxcXG5zdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJhOFwiLCBcIlxcXFxtb2RlbHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPFwiLCBcIlxcXFxsdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFxyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXHNwYWNlXCIpOyAvLyBSZWY6IExhVGVYIFNvdXJjZSAyZTogXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXG5vYnJlYWtzcGFjZX17JVxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFwgXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiIFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxzcGFjZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxub2JyZWFrc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcbm9icmVha1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBudWxsLCBcIlxcXFxhbGxvd2JyZWFrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIixcIiwgXCIsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIjtcIiwgXCI7XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmNcIiwgXCJcXFxcYmFyd2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiYlwiLCBcIlxcXFx2ZWViYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTlcIiwgXCJcXFxcb2RvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5NVwiLCBcIlxcXFxvcGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5N1wiLCBcIlxcXFxvdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjAyXCIsIFwiXFxcXHBhcnRpYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOThcIiwgXCJcXFxcb3NsYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyOWFcIiwgXCJcXFxcY2lyY2xlZGNpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJhMVwiLCBcIlxcXFxib3hkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YjNcIiwgXCJcXFxcYmlndHJpYW5nbGV1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjViZFwiLCBcIlxcXFxiaWd0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMmM0XCIsIFwiXFxcXGRpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyYzZcIiwgXCJcXFxcc3RhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjVjM1wiLCBcIlxcXFx0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YjlcIiwgXCJcXFxcdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwie1wiLCBcIlxcXFx7XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIntcIiwgXCJcXFxcdGV4dGJyYWNlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIn1cIiwgXCJcXFxcfVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ9XCIsIFwiXFxcXHRleHRicmFjZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJ7XCIsIFwiXFxcXGxicmFjZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIn1cIiwgXCJcXFxccmJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIihcIiwgXCJcXFxcbHBhcmVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiKVwiLCBcIlxcXFxycGFyZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIjxcIiwgXCJcXFxcdGV4dGxlc3NcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCI+XCIsIFwiXFxcXHRleHRncmVhdGVyXCIsIHRydWUpOyAvLyBpbiBUMSBmb250ZW5jXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjMwYVwiLCBcIlxcXFxsZmxvb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMzBiXCIsIFwiXFxcXHJmbG9vclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTIzMDlcIiwgXCJcXFxccmNlaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXFxcXCIsIFwiXFxcXGJhY2tzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJ8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyM1wiLCBcIlxcXFx2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ8XCIsIFwiXFxcXHRleHRiYXJcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyNVwiLCBcIlxcXFx8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyNVwiLCBcIlxcXFxWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjI1XCIsIFwiXFxcXHRleHRiYXJkYmxcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIn5cIiwgXCJcXFxcdGV4dGFzY2lpdGlsZGVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcXFxcIiwgXCJcXFxcdGV4dGJhY2tzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXlwiLCBcIlxcXFx0ZXh0YXNjaWljaXJjdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTFcIiwgXCJcXFxcdXBhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMVwiLCBcIlxcXFxVcGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkzXCIsIFwiXFxcXGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkM1wiLCBcIlxcXFxEb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTVcIiwgXCJcXFxcdXBkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxZDVcIiwgXCJcXFxcVXBkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIxMFwiLCBcIlxcXFxjb3Byb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJjMVwiLCBcIlxcXFxiaWd2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJjMFwiLCBcIlxcXFxiaWd3ZWRnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyYTA0XCIsIFwiXFxcXGJpZ3VwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyYzJcIiwgXCJcXFxcYmlnY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyYzNcIiwgXCJcXFxcYmlnY3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcaW50b3BcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyY1wiLCBcIlxcXFxpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmRcIiwgXCJcXFxcaWlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIwZlwiLCBcIlxcXFxwcm9kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMTFcIiwgXCJcXFxcc3VtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDJcIiwgXCJcXFxcYmlnb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDFcIiwgXCJcXFxcYmlnb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MmEwMFwiLCBcIlxcXFxiaWdvZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmVcIiwgXCJcXFxcb2ludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMjJmXCIsIFwiXFxcXG9paW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMzBcIiwgXCJcXFxcb2lpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcdGV4dGVsbGlwc2lzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbWF0aGVsbGlwc2lzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFxsZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIyZWZcIiwgXCJcXFxcQGNkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIyZjFcIiwgXCJcXFxcZGRvdHNcIiwgdHJ1ZSk7IC8vIFxcdmRvdHMgaXMgYSBtYWNybyB0aGF0IHVzZXMgb25lIG9mIHRoZXNlIHR3byBzeW1ib2xzICh3aXRoIG1hZGUtdXAgbmFtZXMpOlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMmVlXCIsIFwiXFxcXHZhcnZkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMmVlXCIsIFwiXFxcXHZhcnZkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmNhXCIsIFwiXFxcXGFjdXRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmNiXCIsIFwiXFxcXGdyYXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMGE4XCIsIFwiXFxcXGRkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAwN2VcIiwgXCJcXFxcdGlsZGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyYzlcIiwgXCJcXFxcYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXGJyZXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXGNoZWNrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMDVlXCIsIFwiXFxcXGhhdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MjBkN1wiLCBcIlxcXFx2ZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXG1hdGhyaW5nXCIpOyAvLyBcXGltYXRoIGFuZCBcXGptYXRoIHNob3VsZCBiZSBpbnZhcmlhbnQgdG8gXFxtYXRocm0sIFxcbWF0aGJmLCBldGMuLCBzbyB1c2UgUFVBXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdWUxMzFcIiwgXCJcXFxcQGltYXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1ZTIzN1wiLCBcIlxcXFxAam1hdGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTMxXCIsIFwiXFx1MDEzMVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXHUwMjM3XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTMxXCIsIFwiXFxcXGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcalwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBkZlwiLCBcIlxcXFxzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBlNlwiLCBcIlxcXFxhZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDE1M1wiLCBcIlxcXFxvZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBmOFwiLCBcIlxcXFxvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGM2XCIsIFwiXFxcXEFFXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTUyXCIsIFwiXFxcXE9FXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGQ4XCIsIFwiXFxcXE9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjYVwiLCBcIlxcXFwnXCIpOyAvLyBhY3V0ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjYlwiLCBcIlxcXFxgXCIpOyAvLyBncmF2ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjNlwiLCBcIlxcXFxeXCIpOyAvLyBjaXJjdW1mbGV4XG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmRjXCIsIFwiXFxcXH5cIik7IC8vIHRpbGRlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM5XCIsIFwiXFxcXD1cIik7IC8vIG1hY3JvblxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFx1XCIpOyAvLyBicmV2ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOVwiLCBcIlxcXFwuXCIpOyAvLyBkb3QgYWJvdmVcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAwYjhcIiwgXCJcXFxcY1wiKTsgLy8gY2VkaWxsYVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkYVwiLCBcIlxcXFxyXCIpOyAvLyByaW5nIGFib3ZlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXHZcIik7IC8vIGNhcm9uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMGE4XCIsICdcXFxcXCInKTsgLy8gZGlhcmVzaXNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZGRcIiwgXCJcXFxcSFwiKTsgLy8gZG91YmxlIGFjdXRlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIGFjY2VudCwgXCJcXHUyNWVmXCIsIFwiXFxcXHRleHRjaXJjbGVkXCIpOyAvLyBcXGJpZ2NpcmMgZ2x5cGhcbi8vIFRoZXNlIGxpZ2F0dXJlcyBhcmUgZGV0ZWN0ZWQgYW5kIGNyZWF0ZWQgaW4gUGFyc2VyLmpzJ3MgYGZvcm1MaWdhdHVyZXNgLlxuXG5jb25zdCBsaWdhdHVyZXMgPSB7XG4gIFwiLS1cIjogdHJ1ZSxcbiAgXCItLS1cIjogdHJ1ZSxcbiAgXCJgYFwiOiB0cnVlLFxuICBcIicnXCI6IHRydWVcbn07XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMTNcIiwgXCItLVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxM1wiLCBcIlxcXFx0ZXh0ZW5kYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiXFxcXHRleHRlbWRhc2hcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiXFxcXHRleHRxdW90ZWxlZnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCInXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiXFxcXHRleHRxdW90ZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiYGBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWNcIiwgXCJcXFxcdGV4dHF1b3RlZGJsbGVmdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxZFwiLCBcIicnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiXFxcXHRleHRxdW90ZWRibHJpZ2h0XCIpOyAvLyAgXFxkZWdyZWUgZnJvbSBnZW5zeW1iIHBhY2thZ2VcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIpOyAvLyBcXHRleHRkZWdyZWUgZnJvbSBpbnB1dGVuYyBwYWNrYWdlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFx0ZXh0ZGVncmVlXCIsIHRydWUpOyAvLyBUT0RPOiBJbiBMYVRlWCwgXFxwb3VuZHMgY2FuIGdlbmVyYXRlIGEgZGlmZmVyZW50IGNoYXJhY3RlciBpbiB0ZXh0IGFuZCBtYXRoXG4vLyBtb2RlLCBidXQgYW1vbmcgb3VyIGZvbnRzLCBvbmx5IE1haW4tUmVndWxhciBkZWZpbmVzIHRoaXMgY2hhcmFjdGVyIFwiMTYzXCIuXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFxtYXRoc3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHRleHRzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MjBcIiwgXCJcXFxcbWFsdGVzZVwiKTsgLy8gVGhlcmUgYXJlIGxvdHMgb2Ygc3ltYm9scyB3aGljaCBhcmUgdGhlIHNhbWUsIHNvIHdlIGFkZCB0aGVtIGluIGFmdGVyd2FyZHMuXG4vLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIG1hdGggbW9kZVxuXG5jb25zdCBtYXRoVGV4dFN5bWJvbHMgPSBcIjAxMjM0NTY3ODkvQC5cXFwiXCI7XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgbWF0aFRleHRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59IC8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gdGV4dCBtb2RlXG5cblxuY29uc3QgdGV4dFN5bWJvbHMgPSBcIjAxMjM0NTY3ODkhQCooKS09K1xcXCI7Oj8vLixcIjtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IHRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn0gLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcblxuXG5jb25zdCBsZXR0ZXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IGxldHRlcnMuY2hhckF0KGkpO1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgY2gsIGNoKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn0gLy8gQmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQgbGV0dGVycyBpbiBVbmljb2RlIHJhbmdlXG5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJDXCIsIFwiXFx1MjEwMlwiKTsgLy8gYmxhY2tib2FyZCBib2xkXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgdGV4dG9yZCwgXCJDXCIsIFwiXFx1MjEwMlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiSFwiLCBcIlxcdTIxMERcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHRleHRvcmQsIFwiSFwiLCBcIlxcdTIxMERcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIk5cIiwgXCJcXHUyMTE1XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCB0ZXh0b3JkLCBcIk5cIiwgXCJcXHUyMTE1XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJQXCIsIFwiXFx1MjExOVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgdGV4dG9yZCwgXCJQXCIsIFwiXFx1MjExOVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiUVwiLCBcIlxcdTIxMUFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHRleHRvcmQsIFwiUVwiLCBcIlxcdTIxMUFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlJcIiwgXCJcXHUyMTFEXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlJcIiwgXCJcXHUyMTFEXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJaXCIsIFwiXFx1MjEyNFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgdGV4dG9yZCwgXCJaXCIsIFwiXFx1MjEyNFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcImhcIiwgXCJcXHUyMTBFXCIpOyAvLyBpdGFsaWMgaCwgUGxhbmNrIGNvbnN0YW50XG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIG1hdGhvcmQsIFwiaFwiLCBcIlxcdTIxMEVcIik7IC8vIFRoZSBuZXh0IGxvb3AgbG9hZHMgd2lkZSAoc3Vycm9nYXRlIHBhaXIpIGNoYXJhY3RlcnMuXG4vLyBXZSBzdXBwb3J0IHNvbWUgbGV0dGVycyBpbiB0aGUgVW5pY29kZSByYW5nZSBVKzFENDAwIHRvIFUrMUQ3RkYsXG4vLyBNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHMuXG4vLyBTb21lIGVkaXRvcnMgZG8gbm90IGRlYWwgd2VsbCB3aXRoIHdpZGUgY2hhcmFjdGVycy4gU28gZG9uJ3Qgd3JpdGUgdGhlXG4vLyBzdHJpbmcgaW50byB0aGlzIGZpbGUuIEluc3RlYWQsIGNyZWF0ZSB0aGUgc3RyaW5nIGZyb20gdGhlIHN1cnJvZ2F0ZSBwYWlyLlxuXG5sZXQgd2lkZUNoYXIgPSBcIlwiO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY2ggPSBsZXR0ZXJzLmNoYXJBdChpKTsgLy8gVGhlIGhleCBudW1iZXJzIGluIHRoZSBuZXh0IGxpbmUgYXJlIGEgc3Vycm9nYXRlIHBhaXIuXG4gIC8vIDB4RDgzNSBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgZm9yIGFsbCBsZXR0ZXJzIGluIHRoZSByYW5nZSB3ZSBzdXBwb3J0LlxuICAvLyAweERDMDAgaXMgdGhlIGxvdyBzdXJyb2dhdGUgZm9yIGJvbGQgQS5cblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDMDAgKyBpKTsgLy8gQS1aIGEteiBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REMzNCArIGkpOyAvLyBBLVogYS16IGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDNjggKyBpKTsgLy8gQS1aIGEteiBib2xkIGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREMDQgKyBpKTsgLy8gQS1aIGEteiBGcmFrdHVyXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REQ2QyArIGkpOyAvLyBBLVogYS16IGJvbGQgRnJha3R1clxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREQTAgKyBpKTsgLy8gQS1aIGEteiBzYW5zLXNlcmlmXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4RERENCArIGkpOyAvLyBBLVogYS16IHNhbnMgYm9sZFxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERFMDggKyBpKTsgLy8gQS1aIGEteiBzYW5zIGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERFNzAgKyBpKTsgLy8gQS1aIGEteiBtb25vc3BhY2VcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgY2gsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIHdpZGVDaGFyKTtcblxuICBpZiAoaSA8IDI2KSB7XG4gICAgLy8gS2FUZVggZm9udHMgaGF2ZSBvbmx5IGNhcGl0YWwgbGV0dGVycyBmb3IgYmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQuXG4gICAgLy8gU2VlIGV4Y2VwdGlvbiBmb3IgayBiZWxvdy5cbiAgICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREMzggKyBpKTsgLy8gQS1aIGRvdWJsZSBzdHJ1Y2tcblxuICAgIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICAgIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gICAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhEQzlDICsgaSk7IC8vIEEtWiBzY3JpcHRcblxuICAgIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICAgIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIH0gLy8gVE9ETzogQWRkIGJvbGQgc2NyaXB0IHdoZW4gaXQgaXMgc3VwcG9ydGVkIGJ5IGEgS2FUZVggZm9udC5cblxufSAvLyBcImtcIiBpcyB0aGUgb25seSBkb3VibGUgc3RydWNrIGxvd2VyIGNhc2UgbGV0dGVyIGluIHRoZSBLYVRlWCBmb250cy5cblxuXG53aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERENUMpOyAvLyBrIGRvdWJsZSBzdHJ1Y2tcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwia1wiLCB3aWRlQ2hhcik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBcImtcIiwgd2lkZUNoYXIpOyAvLyBOZXh0LCBzb21lIHdpZGUgY2hhcmFjdGVyIG51bWVyYWxzXG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICBjb25zdCBjaCA9IGkudG9TdHJpbmcoKTtcbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkNFICsgaSk7IC8vIDAtOSBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REZFMiArIGkpOyAvLyAwLTkgc2FucyBzZXJpZlxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRUMgKyBpKTsgLy8gMC05IGJvbGQgc2Fuc1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRjYgKyBpKTsgLy8gMC05IG1vbm9zcGFjZVxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xufSAvLyBXZSBhZGQgdGhlc2UgTGF0aW4tMSBsZXR0ZXJzIGFzIHN5bWJvbHMgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LFxuLy8gYnV0IHRoZXkgYXJlIG5vdCBhY3R1YWxseSBpbiB0aGUgZm9udCwgbm9yIGFyZSB0aGV5IHN1cHBvcnRlZCBieSB0aGVcbi8vIFVuaWNvZGUgYWNjZW50IG1lY2hhbmlzbSwgc28gdGhleSBmYWxsIGJhY2sgdG8gVGltZXMgZm9udCBhbmQgbG9vayB1Z2x5LlxuLy8gVE9ETyhlZGVtYWluZSk6IEZpeCB0aGlzLlxuXG5cbmNvbnN0IGV4dHJhTGF0aW4gPSBcIlxcdTAwZDBcXHUwMGRlXFx1MDBmZVwiO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IGV4dHJhTGF0aW4ubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY2ggPSBleHRyYUxhdGluLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCBjaCk7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd2lkZS1jaGFyYWN0ZXIuanNcbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFVuaWNvZGUgcmFuZ2UgVSsxRDQwMCB0byBVKzFEN0ZGLFxuICogTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzLlxuICpcbiAqIEZ1bmN0aW9uIHdpZGVDaGFyYWN0ZXJGb250IHRha2VzIGEgd2lkZSBjaGFyYWN0ZXIgYXMgaW5wdXQgYW5kIHJldHVybnNcbiAqIHRoZSBmb250IGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byByZW5kZXIgaXQgcHJvcGVybHkuXG4gKi9cblxuLyoqXG4gKiBEYXRhIGJlbG93IGlzIGZyb20gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvY2hhcnRzL1BERi9VMUQ0MDAucGRmXG4gKiBUaGF0IGRvY3VtZW50IHNvcnRzIGNoYXJhY3RlcnMgaW50byBncm91cHMgYnkgZm9udCB0eXBlLCBzYXkgYm9sZCBvciBpdGFsaWMuXG4gKlxuICogSW4gdGhlIGFycmF5cyBiZWxvdywgZWFjaCBzdWJhcnJheSBjb25zaXN0cyB0aHJlZSBlbGVtZW50czpcbiAqICAgICAgKiBUaGUgQ1NTIGNsYXNzIG9mIHRoYXQgZ3JvdXAgd2hlbiBpbiBtYXRoIG1vZGUuXG4gKiAgICAgICogVGhlIENTUyBjbGFzcyBvZiB0aGF0IGdyb3VwIHdoZW4gaW4gdGV4dCBtb2RlLlxuICogICAgICAqIFRoZSBmb250IG5hbWUsIHNvIHRoYXQgS2FUZVggY2FuIGdldCBmb250IG1ldHJpY3MuXG4gKi9cblxuY29uc3Qgd2lkZUxhdGluTGV0dGVyRGF0YSA9IFtbXCJtYXRoYmZcIiwgXCJ0ZXh0YmZcIiwgXCJNYWluLUJvbGRcIl0sIC8vIEEtWiBib2xkIHVwcmlnaHRcbltcIm1hdGhiZlwiLCBcInRleHRiZlwiLCBcIk1haW4tQm9sZFwiXSwgLy8gYS16IGJvbGQgdXByaWdodFxuW1wibWF0aG5vcm1hbFwiLCBcInRleHRpdFwiLCBcIk1hdGgtSXRhbGljXCJdLCAvLyBBLVogaXRhbGljXG5bXCJtYXRobm9ybWFsXCIsIFwidGV4dGl0XCIsIFwiTWF0aC1JdGFsaWNcIl0sIC8vIGEteiBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBBLVogYm9sZCBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBhLXogYm9sZCBpdGFsaWNcbi8vIE1hcCBmYW5jeSBBLVogbGV0dGVycyB0byBzY3JpcHQsIG5vdCBjYWxsaWdyYXBoaWMuXG4vLyBUaGlzIGFsaWducyB3aXRoIHVuaWNvZGUtbWF0aCBhbmQgbWF0aCBmb250cyAoZXhjZXB0IENhbWJyaWEgTWF0aCkuXG5bXCJtYXRoc2NyXCIsIFwidGV4dHNjclwiLCBcIlNjcmlwdC1SZWd1bGFyXCJdLCAvLyBBLVogc2NyaXB0XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBzY3JpcHQuICBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIHNjcmlwdC4gTm8gZm9udFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyBhLXogYm9sZCBzY3JpcHQuIE5vIGZvbnRcbltcIm1hdGhmcmFrXCIsIFwidGV4dGZyYWtcIiwgXCJGcmFrdHVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBGcmFrdHVyXG5bXCJtYXRoZnJha1wiLCBcInRleHRmcmFrXCIsIFwiRnJha3R1ci1SZWd1bGFyXCJdLCAvLyBhLXogRnJha3R1clxuW1wibWF0aGJiXCIsIFwidGV4dGJiXCIsIFwiQU1TLVJlZ3VsYXJcIl0sIC8vIEEtWiBkb3VibGUtc3RydWNrXG5bXCJtYXRoYmJcIiwgXCJ0ZXh0YmJcIiwgXCJBTVMtUmVndWxhclwiXSwgLy8gayBkb3VibGUtc3RydWNrXG4vLyBOb3RlIHRoYXQgd2UgYXJlIHVzaW5nIGEgYm9sZCBmb250LCBidXQgZm9udCBtZXRyaWNzIGZvciByZWd1bGFyIEZyYWt0dXIuXG5bXCJtYXRoYm9sZGZyYWtcIiwgXCJ0ZXh0Ym9sZGZyYWtcIiwgXCJGcmFrdHVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBib2xkIEZyYWt0dXJcbltcIm1hdGhib2xkZnJha1wiLCBcInRleHRib2xkZnJha1wiLCBcIkZyYWt0dXItUmVndWxhclwiXSwgLy8gYS16IGJvbGQgRnJha3R1clxuW1wibWF0aHNmXCIsIFwidGV4dHNmXCIsIFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIl0sIC8vIEEtWiBzYW5zLXNlcmlmXG5bXCJtYXRoc2ZcIiwgXCJ0ZXh0c2ZcIiwgXCJTYW5zU2VyaWYtUmVndWxhclwiXSwgLy8gYS16IHNhbnMtc2VyaWZcbltcIm1hdGhib2xkc2ZcIiwgXCJ0ZXh0Ym9sZHNmXCIsIFwiU2Fuc1NlcmlmLUJvbGRcIl0sIC8vIEEtWiBib2xkIHNhbnMtc2VyaWZcbltcIm1hdGhib2xkc2ZcIiwgXCJ0ZXh0Ym9sZHNmXCIsIFwiU2Fuc1NlcmlmLUJvbGRcIl0sIC8vIGEteiBib2xkIHNhbnMtc2VyaWZcbltcIm1hdGhpdHNmXCIsIFwidGV4dGl0c2ZcIiwgXCJTYW5zU2VyaWYtSXRhbGljXCJdLCAvLyBBLVogaXRhbGljIHNhbnMtc2VyaWZcbltcIm1hdGhpdHNmXCIsIFwidGV4dGl0c2ZcIiwgXCJTYW5zU2VyaWYtSXRhbGljXCJdLCAvLyBhLXogaXRhbGljIHNhbnMtc2VyaWZcbltcIlwiLCBcIlwiLCBcIlwiXSwgLy8gQS1aIGJvbGQgaXRhbGljIHNhbnMuIE5vIGZvbnRcbltcIlwiLCBcIlwiLCBcIlwiXSwgLy8gYS16IGJvbGQgaXRhbGljIHNhbnMuIE5vIGZvbnRcbltcIm1hdGh0dFwiLCBcInRleHR0dFwiLCBcIlR5cGV3cml0ZXItUmVndWxhclwiXSwgLy8gQS1aIG1vbm9zcGFjZVxuW1wibWF0aHR0XCIsIFwidGV4dHR0XCIsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCJdIC8vIGEteiBtb25vc3BhY2Vcbl07XG5jb25zdCB3aWRlTnVtZXJhbERhdGEgPSBbW1wibWF0aGJmXCIsIFwidGV4dGJmXCIsIFwiTWFpbi1Cb2xkXCJdLCAvLyAwLTkgYm9sZFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyAwLTkgZG91YmxlLXN0cnVjay4gTm8gS2FUZVggZm9udC5cbltcIm1hdGhzZlwiLCBcInRleHRzZlwiLCBcIlNhbnNTZXJpZi1SZWd1bGFyXCJdLCAvLyAwLTkgc2Fucy1zZXJpZlxuW1wibWF0aGJvbGRzZlwiLCBcInRleHRib2xkc2ZcIiwgXCJTYW5zU2VyaWYtQm9sZFwiXSwgLy8gMC05IGJvbGQgc2Fucy1zZXJpZlxuW1wibWF0aHR0XCIsIFwidGV4dHR0XCIsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCJdIC8vIDAtOSBtb25vc3BhY2Vcbl07XG5jb25zdCB3aWRlQ2hhcmFjdGVyRm9udCA9IGZ1bmN0aW9uICh3aWRlQ2hhciwgbW9kZSkge1xuICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgY29kZVBvaW50QXQoKS4gU28gd29yayB3aXRoIHRoZSBzdXJyb2dhdGUgcGFpci5cbiAgY29uc3QgSCA9IHdpZGVDaGFyLmNoYXJDb2RlQXQoMCk7IC8vIGhpZ2ggc3Vycm9nYXRlXG5cbiAgY29uc3QgTCA9IHdpZGVDaGFyLmNoYXJDb2RlQXQoMSk7IC8vIGxvdyBzdXJyb2dhdGVcblxuICBjb25zdCBjb2RlUG9pbnQgPSAoSCAtIDB4RDgwMCkgKiAweDQwMCArIChMIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIGNvbnN0IGogPSBtb2RlID09PSBcIm1hdGhcIiA/IDAgOiAxOyAvLyBjb2x1bW4gaW5kZXggZm9yIENTUyBjbGFzcy5cblxuICBpZiAoMHgxRDQwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgxRDZBNCkge1xuICAgIC8vIHdpZGVMYXRpbkxldHRlckRhdGEgY29udGFpbnMgZXhhY3RseSAyNiBjaGFycyBvbiBlYWNoIHJvdy5cbiAgICAvLyBTbyB3ZSBjYW4gY2FsY3VsYXRlIHRoZSByZWxldmFudCByb3cuIE5vIHRyYXZlcnNlIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcigoY29kZVBvaW50IC0gMHgxRDQwMCkgLyAyNik7XG4gICAgcmV0dXJuIFt3aWRlTGF0aW5MZXR0ZXJEYXRhW2ldWzJdLCB3aWRlTGF0aW5MZXR0ZXJEYXRhW2ldW2pdXTtcbiAgfSBlbHNlIGlmICgweDFEN0NFIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHgxRDdGRikge1xuICAgIC8vIE51bWVyYWxzLCB0ZW4gcGVyIHJvdy5cbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcigoY29kZVBvaW50IC0gMHgxRDdDRSkgLyAxMCk7XG4gICAgcmV0dXJuIFt3aWRlTnVtZXJhbERhdGFbaV1bMl0sIHdpZGVOdW1lcmFsRGF0YVtpXVtqXV07XG4gIH0gZWxzZSBpZiAoY29kZVBvaW50ID09PSAweDFENkE1IHx8IGNvZGVQb2ludCA9PT0gMHgxRDZBNikge1xuICAgIC8vIGRvdGxlc3MgaSBvciBqXG4gICAgcmV0dXJuIFt3aWRlTGF0aW5MZXR0ZXJEYXRhWzBdWzJdLCB3aWRlTGF0aW5MZXR0ZXJEYXRhWzBdW2pdXTtcbiAgfSBlbHNlIGlmICgweDFENkE2IDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MUQ3Q0UpIHtcbiAgICAvLyBHcmVlayBsZXR0ZXJzLiBOb3Qgc3VwcG9ydGVkLCB5ZXQuXG4gICAgcmV0dXJuIFtcIlwiLCBcIlwiXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBkb24ndCBzdXBwb3J0IGFueSB3aWRlIGNoYXJhY3RlcnMgb3V0c2lkZSAxRDQwMOKAkzFEN0ZGLlxuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoYXJhY3RlcjogXCIgKyB3aWRlQ2hhcik7XG4gIH1cbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRDb21tb24uanNcbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBnZW5lcmFsIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGZvciBidWlsZGluZ1xuICogZGlmZmVyZW50IGtpbmRzIG9mIGRvbVRyZWUgbm9kZXMgaW4gYSBjb25zaXN0ZW50IG1hbm5lci5cbiAqL1xuXG5cblxuXG5cblxuXG4vKipcbiAqIExvb2tzIHVwIHRoZSBnaXZlbiBzeW1ib2wgaW4gZm9udE1ldHJpY3MsIGFmdGVyIGFwcGx5aW5nIGFueSBzeW1ib2xcbiAqIHJlcGxhY2VtZW50cyBkZWZpbmVkIGluIHN5bWJvbC5qc1xuICovXG5jb25zdCBsb29rdXBTeW1ib2wgPSBmdW5jdGlvbiAodmFsdWUsIC8vIFRPRE8oIzk2Myk6IFVzZSBhIHVuaW9uIHR5cGUgZm9yIHRoaXMuXG5mb250TmFtZSwgbW9kZSkge1xuICAvLyBSZXBsYWNlIHRoZSB2YWx1ZSB3aXRoIGl0cyByZXBsYWNlZCB2YWx1ZSBmcm9tIHN5bWJvbC5qc1xuICBpZiAoc3JjX3N5bWJvbHNbbW9kZV1bdmFsdWVdICYmIHNyY19zeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlKSB7XG4gICAgdmFsdWUgPSBzcmNfc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG1ldHJpY3M6IGdldENoYXJhY3Rlck1ldHJpY3ModmFsdWUsIGZvbnROYW1lLCBtb2RlKVxuICB9O1xufTtcbi8qKlxuICogTWFrZXMgYSBzeW1ib2xOb2RlIGFmdGVyIHRyYW5zbGF0aW9uIHZpYSB0aGUgbGlzdCBvZiBzeW1ib2xzIGluIHN5bWJvbHMuanMuXG4gKiBDb3JyZWN0bHkgcHVsbHMgb3V0IG1ldHJpY3MgZm9yIHRoZSBjaGFyYWN0ZXIsIGFuZCBvcHRpb25hbGx5IHRha2VzIGEgbGlzdCBvZlxuICogY2xhc3NlcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZS5cbiAqXG4gKiBUT0RPOiBtYWtlIGFyZ3VtZW50IG9yZGVyIGNsb3NlciB0byBtYWtlU3BhblxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqIFRPRE8oIzk1Myk6IE1ha2UgYG9wdGlvbnNgIG1hbmRhdG9yeSBhbmQgYWx3YXlzIHBhc3MgaXQgaW4uXG4gKi9cblxuXG5jb25zdCBtYWtlU3ltYm9sID0gZnVuY3Rpb24gKHZhbHVlLCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICBjb25zdCBsb29rdXAgPSBsb29rdXBTeW1ib2wodmFsdWUsIGZvbnROYW1lLCBtb2RlKTtcbiAgY29uc3QgbWV0cmljcyA9IGxvb2t1cC5tZXRyaWNzO1xuICB2YWx1ZSA9IGxvb2t1cC52YWx1ZTtcbiAgbGV0IHN5bWJvbE5vZGU7XG5cbiAgaWYgKG1ldHJpY3MpIHtcbiAgICBsZXQgaXRhbGljID0gbWV0cmljcy5pdGFsaWM7XG5cbiAgICBpZiAobW9kZSA9PT0gXCJ0ZXh0XCIgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmZvbnQgPT09IFwibWF0aGl0XCIpIHtcbiAgICAgIGl0YWxpYyA9IDA7XG4gICAgfVxuXG4gICAgc3ltYm9sTm9kZSA9IG5ldyBTeW1ib2xOb2RlKHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsIG1ldHJpY3Mud2lkdGgsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8oZW1pbHkpOiBGaWd1cmUgb3V0IGEgZ29vZCB3YXkgdG8gb25seSBwcmludCB0aGlzIGluIGRldmVsb3BtZW50XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTm8gY2hhcmFjdGVyIG1ldHJpY3MgXCIgKyAoXCJmb3IgJ1wiICsgdmFsdWUgKyBcIicgaW4gc3R5bGUgJ1wiICsgZm9udE5hbWUgKyBcIicgYW5kIG1vZGUgJ1wiICsgbW9kZSArIFwiJ1wiKSk7XG4gICAgc3ltYm9sTm9kZSA9IG5ldyBTeW1ib2xOb2RlKHZhbHVlLCAwLCAwLCAwLCAwLCAwLCBjbGFzc2VzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgc3ltYm9sTm9kZS5tYXhGb250U2l6ZSA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgIHN5bWJvbE5vZGUuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBzeW1ib2xOb2RlLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bWJvbE5vZGU7XG59O1xuLyoqXG4gKiBNYWtlcyBhIHN5bWJvbCBpbiBNYWluLVJlZ3VsYXIgb3IgQU1TLVJlZ3VsYXIuXG4gKiBVc2VkIGZvciByZWwsIGJpbiwgb3BlbiwgY2xvc2UsIGlubmVyLCBhbmQgcHVuY3QuXG4gKi9cblxuXG5jb25zdCBtYXRoc3ltID0gZnVuY3Rpb24gKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHtcbiAgICBjbGFzc2VzID0gW107XG4gIH1cblxuICAvLyBEZWNpZGUgd2hhdCBmb250IHRvIHJlbmRlciB0aGUgc3ltYm9sIGluIGJ5IGl0cyBlbnRyeSBpbiB0aGUgc3ltYm9sc1xuICAvLyB0YWJsZS5cbiAgLy8gSGF2ZSBhIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiB0aGUgdmFsdWUgPSBcXCBiZWNhdXNlIHRoZSBcXCBpcyB1c2VkIGFzIGFcbiAgLy8gdGV4dG9yZCBpbiB1bnN1cHBvcnRlZCBjb21tYW5kIGVycm9ycyBidXQgY2Fubm90IGJlIHBhcnNlZCBhcyBhIHJlZ3VsYXJcbiAgLy8gdGV4dCBvcmRpbmFsIGFuZCBpcyB0aGVyZWZvcmUgbm90IHByZXNlbnQgYXMgYSBzeW1ib2wgaW4gdGhlIHN5bWJvbHNcbiAgLy8gdGFibGUgZm9yIHRleHQsIGFzIHdlbGwgYXMgYSBzcGVjaWFsIGNhc2UgZm9yIGJvbGRzeW1ib2wgYmVjYXVzZSBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgYm9sZCArIGFuZCAtXG4gIGlmIChvcHRpb25zLmZvbnQgPT09IFwiYm9sZHN5bWJvbFwiICYmIGxvb2t1cFN5bWJvbCh2YWx1ZSwgXCJNYWluLUJvbGRcIiwgbW9kZSkubWV0cmljcykge1xuICAgIHJldHVybiBtYWtlU3ltYm9sKHZhbHVlLCBcIk1haW4tQm9sZFwiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRoYmZcIl0pKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIgfHwgc3JjX3N5bWJvbHNbbW9kZV1bdmFsdWVdLmZvbnQgPT09IFwibWFpblwiKSB7XG4gICAgcmV0dXJuIG1ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWtlU3ltYm9sKHZhbHVlLCBcIkFNUy1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcImFtc3JtXCJdKSk7XG4gIH1cbn07XG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggb2YgdGhlIHR3byBmb250IG5hbWVzIChNYWluLUJvbGQgYW5kIE1hdGgtQm9sZEl0YWxpYykgYW5kXG4gKiBjb3JyZXNwb25kaW5nIHN0eWxlIHRhZ3MgKG1hdGhiZiBvciBib2xkc3ltYm9sKSB0byB1c2UgZm9yIGZvbnQgXCJib2xkc3ltYm9sXCIsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHN5bWJvbC4gIFVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgZm9udE1hcCBmb3IgZm9udFxuICogXCJib2xkc3ltYm9sXCIuXG4gKi9cblxuXG5jb25zdCBib2xkc3ltYm9sID0gZnVuY3Rpb24gKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLCB0eXBlKSB7XG4gIGlmICh0eXBlICE9PSBcInRleHRvcmRcIiAmJiBsb29rdXBTeW1ib2wodmFsdWUsIFwiTWF0aC1Cb2xkSXRhbGljXCIsIG1vZGUpLm1ldHJpY3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9udE5hbWU6IFwiTWF0aC1Cb2xkSXRhbGljXCIsXG4gICAgICBmb250Q2xhc3M6IFwiYm9sZHN5bWJvbFwiXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTb21lIGdseXBocyBkbyBub3QgZXhpc3QgaW4gTWF0aC1Cb2xkSXRhbGljIHNvIHdlIG5lZWQgdG8gdXNlXG4gICAgLy8gTWFpbi1Cb2xkIGluc3RlYWQuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIk1haW4tQm9sZFwiLFxuICAgICAgZm9udENsYXNzOiBcIm1hdGhiZlwiXG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogTWFrZXMgZWl0aGVyIGEgbWF0aG9yZCBvciB0ZXh0b3JkIGluIHRoZSBjb3JyZWN0IGZvbnQgYW5kIGNvbG9yLlxuICovXG5cblxuY29uc3QgbWFrZU9yZCA9IGZ1bmN0aW9uIChncm91cCwgb3B0aW9ucywgdHlwZSkge1xuICBjb25zdCBtb2RlID0gZ3JvdXAubW9kZTtcbiAgY29uc3QgdGV4dCA9IGdyb3VwLnRleHQ7XG4gIGNvbnN0IGNsYXNzZXMgPSBbXCJtb3JkXCJdOyAvLyBNYXRoIG1vZGUgb3IgT2xkIGZvbnQgKGkuZS4gXFxybSlcblxuICBjb25zdCBpc0ZvbnQgPSBtb2RlID09PSBcIm1hdGhcIiB8fCBtb2RlID09PSBcInRleHRcIiAmJiBvcHRpb25zLmZvbnQ7XG4gIGNvbnN0IGZvbnRPckZhbWlseSA9IGlzRm9udCA/IG9wdGlvbnMuZm9udCA6IG9wdGlvbnMuZm9udEZhbWlseTtcbiAgbGV0IHdpZGVGb250TmFtZSA9IFwiXCI7XG4gIGxldCB3aWRlRm9udENsYXNzID0gXCJcIjtcblxuICBpZiAodGV4dC5jaGFyQ29kZUF0KDApID09PSAweEQ4MzUpIHtcbiAgICBbd2lkZUZvbnROYW1lLCB3aWRlRm9udENsYXNzXSA9IHdpZGVDaGFyYWN0ZXJGb250KHRleHQsIG1vZGUpO1xuICB9XG5cbiAgaWYgKHdpZGVGb250TmFtZS5sZW5ndGggPiAwKSB7XG4gICAgLy8gc3Vycm9nYXRlIHBhaXJzIGdldCBzcGVjaWFsIHRyZWF0bWVudFxuICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIHdpZGVGb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQod2lkZUZvbnRDbGFzcykpO1xuICB9IGVsc2UgaWYgKGZvbnRPckZhbWlseSkge1xuICAgIGxldCBmb250TmFtZTtcbiAgICBsZXQgZm9udENsYXNzZXM7XG5cbiAgICBpZiAoZm9udE9yRmFtaWx5ID09PSBcImJvbGRzeW1ib2xcIikge1xuICAgICAgY29uc3QgZm9udERhdGEgPSBib2xkc3ltYm9sKHRleHQsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMsIHR5cGUpO1xuICAgICAgZm9udE5hbWUgPSBmb250RGF0YS5mb250TmFtZTtcbiAgICAgIGZvbnRDbGFzc2VzID0gW2ZvbnREYXRhLmZvbnRDbGFzc107XG4gICAgfSBlbHNlIGlmIChpc0ZvbnQpIHtcbiAgICAgIGZvbnROYW1lID0gZm9udE1hcFtmb250T3JGYW1pbHldLmZvbnROYW1lO1xuICAgICAgZm9udENsYXNzZXMgPSBbZm9udE9yRmFtaWx5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9udE5hbWUgPSByZXRyaWV2ZVRleHRGb250TmFtZShmb250T3JGYW1pbHksIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpO1xuICAgICAgZm9udENsYXNzZXMgPSBbZm9udE9yRmFtaWx5LCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlXTtcbiAgICB9XG5cbiAgICBpZiAobG9va3VwU3ltYm9sKHRleHQsIGZvbnROYW1lLCBtb2RlKS5tZXRyaWNzKSB7XG4gICAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0LCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoZm9udENsYXNzZXMpKTtcbiAgICB9IGVsc2UgaWYgKGxpZ2F0dXJlcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0KSAmJiBmb250TmFtZS5zbGljZSgwLCAxMCkgPT09IFwiVHlwZXdyaXRlclwiKSB7XG4gICAgICAvLyBEZWNvbnN0cnVjdCBsaWdhdHVyZXMgaW4gbW9ub3NwYWNlIGZvbnRzIChcXHRleHR0dCwgXFx0dCkuXG4gICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMucHVzaChtYWtlU3ltYm9sKHRleHRbaV0sIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChmb250Q2xhc3NlcykpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ha2VGcmFnbWVudChwYXJ0cyk7XG4gICAgfVxuICB9IC8vIE1ha2VzIGEgc3ltYm9sIGluIHRoZSBkZWZhdWx0IGZvbnQgZm9yIG1hdGhvcmRzIGFuZCB0ZXh0b3Jkcy5cblxuXG4gIGlmICh0eXBlID09PSBcIm1hdGhvcmRcIikge1xuICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIFwiTWF0aC1JdGFsaWNcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wibWF0aG5vcm1hbFwiXSkpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidGV4dG9yZFwiKSB7XG4gICAgY29uc3QgZm9udCA9IHNyY19zeW1ib2xzW21vZGVdW3RleHRdICYmIHNyY19zeW1ib2xzW21vZGVdW3RleHRdLmZvbnQ7XG5cbiAgICBpZiAoZm9udCA9PT0gXCJhbXNcIikge1xuICAgICAgY29uc3QgZm9udE5hbWUgPSByZXRyaWV2ZVRleHRGb250TmFtZShcImFtc3JtXCIsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpO1xuICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodGV4dCwgZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFwiYW1zcm1cIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYWluXCIgfHwgIWZvbnQpIHtcbiAgICAgIGNvbnN0IGZvbnROYW1lID0gcmV0cmlldmVUZXh0Rm9udE5hbWUoXCJ0ZXh0cm1cIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7XG4gICAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0LCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQob3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb250cyBhZGRlZCBieSBwbHVnaW5zXG4gICAgICBjb25zdCBmb250TmFtZSA9IHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnQsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpOyAvLyBXZSBhZGQgZm9udCBuYW1lIGFzIGEgY3NzIGNsYXNzXG5cbiAgICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChmb250TmFtZSwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGU6IFwiICsgdHlwZSArIFwiIGluIG1ha2VPcmRcIik7XG4gIH1cbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzdWJzZXF1ZW50IHN5bWJvbE5vZGVzIGhhdmUgdGhlIHNhbWUgY2xhc3Nlcywgc2tldywgbWF4Rm9udCxcbiAqIGFuZCBzdHlsZXMuXG4gKi9cblxuXG5jb25zdCBjYW5Db21iaW5lID0gKHByZXYsIG5leHQpID0+IHtcbiAgaWYgKGNyZWF0ZUNsYXNzKHByZXYuY2xhc3NlcykgIT09IGNyZWF0ZUNsYXNzKG5leHQuY2xhc3NlcykgfHwgcHJldi5za2V3ICE9PSBuZXh0LnNrZXcgfHwgcHJldi5tYXhGb250U2l6ZSAhPT0gbmV4dC5tYXhGb250U2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiBwcmV2IGFuZCBuZXh0IGJvdGggYXJlIGp1c3QgXCJtYmluXCJzIG9yIFwibW9yZFwicyB3ZSBkb24ndCBjb21iaW5lIHRoZW1cbiAgLy8gc28gdGhhdCB0aGUgcHJvcGVyIHNwYWNpbmcgY2FuIGJlIHByZXNlcnZlZC5cblxuXG4gIGlmIChwcmV2LmNsYXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgY2xzID0gcHJldi5jbGFzc2VzWzBdO1xuXG4gICAgaWYgKGNscyA9PT0gXCJtYmluXCIgfHwgY2xzID09PSBcIm1vcmRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gcHJldi5zdHlsZSkge1xuICAgIGlmIChwcmV2LnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSAmJiBwcmV2LnN0eWxlW3N0eWxlXSAhPT0gbmV4dC5zdHlsZVtzdHlsZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHN0eWxlIGluIG5leHQuc3R5bGUpIHtcbiAgICBpZiAobmV4dC5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkgJiYgcHJldi5zdHlsZVtzdHlsZV0gIT09IG5leHQuc3R5bGVbc3R5bGVdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBDb21iaW5lIGNvbnNlY3V0aXZlIGRvbVRyZWUuc3ltYm9sTm9kZXMgaW50byBhIHNpbmdsZSBzeW1ib2xOb2RlLlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBhcmd1bWVudC5cbiAqL1xuXG5cbmNvbnN0IHRyeUNvbWJpbmVDaGFycyA9IGNoYXJzID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBwcmV2ID0gY2hhcnNbaV07XG4gICAgY29uc3QgbmV4dCA9IGNoYXJzW2kgKyAxXTtcblxuICAgIGlmIChwcmV2IGluc3RhbmNlb2YgU3ltYm9sTm9kZSAmJiBuZXh0IGluc3RhbmNlb2YgU3ltYm9sTm9kZSAmJiBjYW5Db21iaW5lKHByZXYsIG5leHQpKSB7XG4gICAgICBwcmV2LnRleHQgKz0gbmV4dC50ZXh0O1xuICAgICAgcHJldi5oZWlnaHQgPSBNYXRoLm1heChwcmV2LmhlaWdodCwgbmV4dC5oZWlnaHQpO1xuICAgICAgcHJldi5kZXB0aCA9IE1hdGgubWF4KHByZXYuZGVwdGgsIG5leHQuZGVwdGgpOyAvLyBVc2UgdGhlIGxhc3QgY2hhcmFjdGVyJ3MgaXRhbGljIGNvcnJlY3Rpb24gc2luY2Ugd2UgdXNlXG4gICAgICAvLyBpdCB0byBhZGQgcGFkZGluZyB0byB0aGUgcmlnaHQgb2YgdGhlIHNwYW4gY3JlYXRlZCBmcm9tXG4gICAgICAvLyB0aGUgY29tYmluZWQgY2hhcmFjdGVycy5cblxuICAgICAgcHJldi5pdGFsaWMgPSBuZXh0Lml0YWxpYztcbiAgICAgIGNoYXJzLnNwbGljZShpICsgMSwgMSk7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoYXJzO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBoZWlnaHQsIGRlcHRoLCBhbmQgbWF4Rm9udFNpemUgb2YgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHNcbiAqIGNoaWxkcmVuLlxuICovXG5cblxuY29uc3Qgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZWxlbSkge1xuICBsZXQgaGVpZ2h0ID0gMDtcbiAgbGV0IGRlcHRoID0gMDtcbiAgbGV0IG1heEZvbnRTaXplID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGVsZW0uY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQuaGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLmRlcHRoID4gZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gY2hpbGQuZGVwdGg7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHtcbiAgICAgIG1heEZvbnRTaXplID0gY2hpbGQubWF4Rm9udFNpemU7XG4gICAgfVxuICB9XG5cbiAgZWxlbS5oZWlnaHQgPSBoZWlnaHQ7XG4gIGVsZW0uZGVwdGggPSBkZXB0aDtcbiAgZWxlbS5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xufTtcbi8qKlxuICogTWFrZXMgYSBzcGFuIHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2xhc3NlcywgbGlzdCBvZiBjaGlsZHJlbiwgYW5kIG9wdGlvbnMuXG4gKlxuICogVE9ETygjOTUzKTogRW5zdXJlIHRoYXQgYG9wdGlvbnNgIGlzIGFsd2F5cyBwcm92aWRlZCAoY3VycmVudGx5IHNvbWUgY2FsbFxuICogc2l0ZXMgZG9uJ3QgcGFzcyBpdCkgYW5kIG1ha2UgdGhlIHR5cGUgYmVsb3cgbWFuZGF0b3J5LlxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqL1xuXG5cbmNvbnN0IG1ha2VTcGFuID0gZnVuY3Rpb24gKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSkge1xuICBjb25zdCBzcGFuID0gbmV3IFNwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKTtcbiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oc3Bhbik7XG4gIHJldHVybiBzcGFuO1xufTsgLy8gU1ZHIG9uZSBpcyBzaW1wbGVyIC0tIGRvZXNuJ3QgcmVxdWlyZSBoZWlnaHQsIGRlcHRoLCBtYXgtZm9udCBzZXR0aW5nLlxuLy8gVGhpcyBpcyBhbHNvIGEgc2VwYXJhdGUgbWV0aG9kIGZvciB0eXBlc2FmZXR5LlxuXG5cbmNvbnN0IG1ha2VTdmdTcGFuID0gKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSkgPT4gbmV3IFNwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKTtcblxuY29uc3QgbWFrZUxpbmVTcGFuID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgb3B0aW9ucywgdGhpY2tuZXNzKSB7XG4gIGNvbnN0IGxpbmUgPSBtYWtlU3BhbihbY2xhc3NOYW1lXSwgW10sIG9wdGlvbnMpO1xuICBsaW5lLmhlaWdodCA9IE1hdGgubWF4KHRoaWNrbmVzcyB8fCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3MsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyk7XG4gIGxpbmUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBtYWtlRW0obGluZS5oZWlnaHQpO1xuICBsaW5lLm1heEZvbnRTaXplID0gMS4wO1xuICByZXR1cm4gbGluZTtcbn07XG4vKipcbiAqIE1ha2VzIGFuIGFuY2hvciB3aXRoIHRoZSBnaXZlbiBocmVmLCBsaXN0IG9mIGNsYXNzZXMsIGxpc3Qgb2YgY2hpbGRyZW4sXG4gKiBhbmQgb3B0aW9ucy5cbiAqL1xuXG5cbmNvbnN0IG1ha2VBbmNob3IgPSBmdW5jdGlvbiAoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgY29uc3QgYW5jaG9yID0gbmV3IEFuY2hvcihocmVmLCBjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucyk7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKGFuY2hvcik7XG4gIHJldHVybiBhbmNob3I7XG59O1xuLyoqXG4gKiBNYWtlcyBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5jb25zdCBtYWtlRnJhZ21lbnQgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKGZyYWdtZW50KTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxuICogV3JhcHMgZ3JvdXAgaW4gYSBzcGFuIGlmIGl0J3MgYSBkb2N1bWVudCBmcmFnbWVudCwgYWxsb3dpbmcgdG8gYXBwbHkgY2xhc3Nlc1xuICogYW5kIHN0eWxlc1xuICovXG5cblxuY29uc3Qgd3JhcEZyYWdtZW50ID0gZnVuY3Rpb24gKGdyb3VwLCBvcHRpb25zKSB7XG4gIGlmIChncm91cCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICByZXR1cm4gbWFrZVNwYW4oW10sIFtncm91cF0sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwO1xufTsgLy8gVGhlc2UgYXJlIGV4YWN0IG9iamVjdCB0eXBlcyB0byBjYXRjaCB0eXBvcyBpbiB0aGUgbmFtZXMgb2YgdGhlIG9wdGlvbmFsIGZpZWxkcy5cblxuXG4vLyBDb21wdXRlcyB0aGUgdXBkYXRlZCBgY2hpbGRyZW5gIGxpc3QgYW5kIHRoZSBvdmVyYWxsIGRlcHRoLlxuLy9cbi8vIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGZvciBtYWtlVkxpc3QgbWFrZXMgaXQgZWFzaWVyIHRvIGVuZm9yY2UgdHlwZSBzYWZldHkgYnlcbi8vIGFsbG93aW5nIGVhcmx5IGV4aXRzIChyZXR1cm5zKSBpbiB0aGUgbG9naWMuXG5jb25zdCBnZXRWTGlzdENoaWxkcmVuQW5kRGVwdGggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcImluZGl2aWR1YWxTaGlmdFwiKSB7XG4gICAgY29uc3Qgb2xkQ2hpbGRyZW4gPSBwYXJhbXMuY2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbb2xkQ2hpbGRyZW5bMF1dOyAvLyBBZGQgaW4ga2VybnMgdG8gdGhlIGxpc3Qgb2YgcGFyYW1zLmNoaWxkcmVuIHRvIGdldCBlYWNoIGVsZW1lbnQgdG8gYmVcbiAgICAvLyBzaGlmdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWNpZmllZCBzaGlmdFxuXG4gICAgY29uc3QgZGVwdGggPSAtb2xkQ2hpbGRyZW5bMF0uc2hpZnQgLSBvbGRDaGlsZHJlblswXS5lbGVtLmRlcHRoO1xuICAgIGxldCBjdXJyUG9zID0gZGVwdGg7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaWZmID0gLW9sZENoaWxkcmVuW2ldLnNoaWZ0IC0gY3VyclBvcyAtIG9sZENoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICBjb25zdCBzaXplID0gZGlmZiAtIChvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5oZWlnaHQgKyBvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5kZXB0aCk7XG4gICAgICBjdXJyUG9zID0gY3VyclBvcyArIGRpZmY7XG4gICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemVcbiAgICAgIH0pO1xuICAgICAgY2hpbGRyZW4ucHVzaChvbGRDaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGVwdGhcbiAgICB9O1xuICB9XG5cbiAgbGV0IGRlcHRoO1xuXG4gIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcInRvcFwiKSB7XG4gICAgLy8gV2UgYWx3YXlzIHN0YXJ0IGF0IHRoZSBib3R0b20sIHNvIGNhbGN1bGF0ZSB0aGUgYm90dG9tIGJ5IGFkZGluZyB1cFxuICAgIC8vIGFsbCB0aGUgc2l6ZXNcbiAgICBsZXQgYm90dG9tID0gcGFyYW1zLnBvc2l0aW9uRGF0YTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmFtcy5jaGlsZHJlbltpXTtcbiAgICAgIGJvdHRvbSAtPSBjaGlsZC50eXBlID09PSBcImtlcm5cIiA/IGNoaWxkLnNpemUgOiBjaGlsZC5lbGVtLmhlaWdodCArIGNoaWxkLmVsZW0uZGVwdGg7XG4gICAgfVxuXG4gICAgZGVwdGggPSBib3R0b207XG4gIH0gZWxzZSBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJib3R0b21cIikge1xuICAgIGRlcHRoID0gLXBhcmFtcy5wb3NpdGlvbkRhdGE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmFtcy5jaGlsZHJlblswXTtcblxuICAgIGlmIChmaXJzdENoaWxkLnR5cGUgIT09IFwiZWxlbVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGNoaWxkIG11c3QgaGF2ZSB0eXBlIFwiZWxlbVwiLicpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcInNoaWZ0XCIpIHtcbiAgICAgIGRlcHRoID0gLWZpcnN0Q2hpbGQuZWxlbS5kZXB0aCAtIHBhcmFtcy5wb3NpdGlvbkRhdGE7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcImZpcnN0QmFzZWxpbmVcIikge1xuICAgICAgZGVwdGggPSAtZmlyc3RDaGlsZC5lbGVtLmRlcHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBvc2l0aW9uVHlwZSBcIiArIHBhcmFtcy5wb3NpdGlvblR5cGUgKyBcIi5cIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaGlsZHJlbjogcGFyYW1zLmNoaWxkcmVuLFxuICAgIGRlcHRoXG4gIH07XG59O1xuLyoqXG4gKiBNYWtlcyBhIHZlcnRpY2FsIGxpc3QgYnkgc3RhY2tpbmcgZWxlbWVudHMgYW5kIGtlcm5zIG9uIHRvcCBvZiBlYWNoIG90aGVyLlxuICogQWxsb3dzIGZvciBtYW55IGRpZmZlcmVudCB3YXlzIG9mIHNwZWNpZnlpbmcgdGhlIHBvc2l0aW9uaW5nIG1ldGhvZC5cbiAqXG4gKiBTZWUgVkxpc3RQYXJhbSBkb2N1bWVudGF0aW9uIGFib3ZlLlxuICovXG5cblxuY29uc3QgbWFrZVZMaXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVwdGhcbiAgfSA9IGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aChwYXJhbXMpOyAvLyBDcmVhdGUgYSBzdHJ1dCB0aGF0IGlzIHRhbGxlciB0aGFuIGFueSBsaXN0IGl0ZW0uIFRoZSBzdHJ1dCBpcyBhZGRlZCB0b1xuICAvLyBlYWNoIGl0ZW0sIHdoZXJlIGl0IHdpbGwgZGV0ZXJtaW5lIHRoZSBpdGVtJ3MgYmFzZWxpbmUuIFNpbmNlIGl0IGhhc1xuICAvLyBgb3ZlcmZsb3c6aGlkZGVuYCwgdGhlIHN0cnV0J3MgdG9wIGVkZ2Ugd2lsbCBzaXQgb24gdGhlIGl0ZW0ncyBsaW5lIGJveCdzXG4gIC8vIHRvcCBlZGdlIGFuZCB0aGUgc3RydXQncyBib3R0b20gZWRnZSB3aWxsIHNpdCBvbiB0aGUgaXRlbSdzIGJhc2VsaW5lLFxuICAvLyB3aXRoIG5vIGFkZGl0aW9uYWwgbGluZS1oZWlnaHQgc3BhY2luZy4gVGhpcyBhbGxvd3MgdGhlIGl0ZW0gYmFzZWxpbmUgdG9cbiAgLy8gYmUgcG9zaXRpb25lZCBwcmVjaXNlbHkgd2l0aG91dCB3b3JyeWluZyBhYm91dCBmb250IGFzY2VudCBhbmRcbiAgLy8gbGluZS1oZWlnaHQuXG5cbiAgbGV0IHBzdHJ1dFNpemUgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZWxlbVwiKSB7XG4gICAgICBjb25zdCBlbGVtID0gY2hpbGQuZWxlbTtcbiAgICAgIHBzdHJ1dFNpemUgPSBNYXRoLm1heChwc3RydXRTaXplLCBlbGVtLm1heEZvbnRTaXplLCBlbGVtLmhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgcHN0cnV0U2l6ZSArPSAyO1xuICBjb25zdCBwc3RydXQgPSBtYWtlU3BhbihbXCJwc3RydXRcIl0sIFtdKTtcbiAgcHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShwc3RydXRTaXplKTsgLy8gQ3JlYXRlIGEgbmV3IGxpc3Qgb2YgYWN0dWFsIGNoaWxkcmVuIGF0IHRoZSBjb3JyZWN0IG9mZnNldHNcblxuICBjb25zdCByZWFsQ2hpbGRyZW4gPSBbXTtcbiAgbGV0IG1pblBvcyA9IGRlcHRoO1xuICBsZXQgbWF4UG9zID0gZGVwdGg7XG4gIGxldCBjdXJyUG9zID0gZGVwdGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJrZXJuXCIpIHtcbiAgICAgIGN1cnJQb3MgKz0gY2hpbGQuc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWxlbSA9IGNoaWxkLmVsZW07XG4gICAgICBjb25zdCBjbGFzc2VzID0gY2hpbGQud3JhcHBlckNsYXNzZXMgfHwgW107XG4gICAgICBjb25zdCBzdHlsZSA9IGNoaWxkLndyYXBwZXJTdHlsZSB8fCB7fTtcbiAgICAgIGNvbnN0IGNoaWxkV3JhcCA9IG1ha2VTcGFuKGNsYXNzZXMsIFtwc3RydXQsIGVsZW1dLCB1bmRlZmluZWQsIHN0eWxlKTtcbiAgICAgIGNoaWxkV3JhcC5zdHlsZS50b3AgPSBtYWtlRW0oLXBzdHJ1dFNpemUgLSBjdXJyUG9zIC0gZWxlbS5kZXB0aCk7XG5cbiAgICAgIGlmIChjaGlsZC5tYXJnaW5MZWZ0KSB7XG4gICAgICAgIGNoaWxkV3JhcC5zdHlsZS5tYXJnaW5MZWZ0ID0gY2hpbGQubWFyZ2luTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLm1hcmdpblJpZ2h0KSB7XG4gICAgICAgIGNoaWxkV3JhcC5zdHlsZS5tYXJnaW5SaWdodCA9IGNoaWxkLm1hcmdpblJpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZWFsQ2hpbGRyZW4ucHVzaChjaGlsZFdyYXApO1xuICAgICAgY3VyclBvcyArPSBlbGVtLmhlaWdodCArIGVsZW0uZGVwdGg7XG4gICAgfVxuXG4gICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCBjdXJyUG9zKTtcbiAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIGN1cnJQb3MpO1xuICB9IC8vIFRoZSB2bGlzdCBjb250ZW50cyBnbyBpbiBhIHRhYmxlLWNlbGwgd2l0aCBgdmVydGljYWwtYWxpZ246Ym90dG9tYC5cbiAgLy8gVGhpcyBjZWxsJ3MgYm90dG9tIGVkZ2Ugd2lsbCBkZXRlcm1pbmUgdGhlIGNvbnRhaW5pbmcgdGFibGUncyBiYXNlbGluZVxuICAvLyB3aXRob3V0IG92ZXJseSBleHBhbmRpbmcgdGhlIGNvbnRhaW5pbmcgbGluZS1ib3guXG5cblxuICBjb25zdCB2bGlzdCA9IG1ha2VTcGFuKFtcInZsaXN0XCJdLCByZWFsQ2hpbGRyZW4pO1xuICB2bGlzdC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0obWF4UG9zKTsgLy8gQSBzZWNvbmQgcm93IGlzIHVzZWQgaWYgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgdmxpc3QncyBkZXB0aC5cblxuICBsZXQgcm93cztcblxuICBpZiAobWluUG9zIDwgMCkge1xuICAgIC8vIFdlIHdpbGwgZGVmaW5lIGRlcHRoIGluIGFuIGVtcHR5IHNwYW4gd2l0aCBkaXNwbGF5OiB0YWJsZS1jZWxsLlxuICAgIC8vIEl0IHNob3VsZCByZW5kZXIgd2l0aCB0aGUgaGVpZ2h0IHRoYXQgd2UgZGVmaW5lLiBCdXQgQ2hyb21lLCBpblxuICAgIC8vIGNvbnRlbnRlZGl0YWJsZSBtb2RlIG9ubHksIHRyZWF0cyB0aGF0IHNwYW4gYXMgaWYgaXQgY29udGFpbnMgc29tZVxuICAgIC8vIHRleHQgY29udGVudC4gQW5kIHRoYXQgbWluLWhlaWdodCBvdmVyLXJpZGVzIG91ciBkZXNpcmVkIGhlaWdodC5cbiAgICAvLyBTbyB3ZSBwdXQgYW5vdGhlciBlbXB0eSBzcGFuIGluc2lkZSB0aGUgZGVwdGggc3RydXQgc3Bhbi5cbiAgICBjb25zdCBlbXB0eVNwYW4gPSBtYWtlU3BhbihbXSwgW10pO1xuICAgIGNvbnN0IGRlcHRoU3RydXQgPSBtYWtlU3BhbihbXCJ2bGlzdFwiXSwgW2VtcHR5U3Bhbl0pO1xuICAgIGRlcHRoU3RydXQuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKC1taW5Qb3MpOyAvLyBTYWZhcmkgd2FudHMgdGhlIGZpcnN0IHJvdyB0byBoYXZlIGlubGluZSBjb250ZW50OyBvdGhlcndpc2UgaXRcbiAgICAvLyBwdXRzIHRoZSBib3R0b20gb2YgdGhlICpzZWNvbmQqIHJvdyBvbiB0aGUgYmFzZWxpbmUuXG5cbiAgICBjb25zdCB0b3BTdHJ1dCA9IG1ha2VTcGFuKFtcInZsaXN0LXNcIl0sIFtuZXcgU3ltYm9sTm9kZShcIlxcdTIwMGJcIildKTtcbiAgICByb3dzID0gW21ha2VTcGFuKFtcInZsaXN0LXJcIl0sIFt2bGlzdCwgdG9wU3RydXRdKSwgbWFrZVNwYW4oW1widmxpc3QtclwiXSwgW2RlcHRoU3RydXRdKV07XG4gIH0gZWxzZSB7XG4gICAgcm93cyA9IFttYWtlU3BhbihbXCJ2bGlzdC1yXCJdLCBbdmxpc3RdKV07XG4gIH1cblxuICBjb25zdCB2dGFibGUgPSBtYWtlU3BhbihbXCJ2bGlzdC10XCJdLCByb3dzKTtcblxuICBpZiAocm93cy5sZW5ndGggPT09IDIpIHtcbiAgICB2dGFibGUuY2xhc3Nlcy5wdXNoKFwidmxpc3QtdDJcIik7XG4gIH1cblxuICB2dGFibGUuaGVpZ2h0ID0gbWF4UG9zO1xuICB2dGFibGUuZGVwdGggPSAtbWluUG9zO1xuICByZXR1cm4gdnRhYmxlO1xufTsgLy8gR2x1ZSBpcyBhIGNvbmNlcHQgZnJvbSBUZVggd2hpY2ggaXMgYSBmbGV4aWJsZSBzcGFjZSBiZXR3ZWVuIGVsZW1lbnRzIGluXG4vLyBlaXRoZXIgYSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGxpc3QuIEluIEthVGVYLCBhdCBsZWFzdCBmb3Igbm93LCBpdCdzXG4vLyBzdGF0aWMgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyBpbiBhIGhvcml6b250YWwgbGF5b3V0LlxuXG5cbmNvbnN0IG1ha2VHbHVlID0gKG1lYXN1cmVtZW50LCBvcHRpb25zKSA9PiB7XG4gIC8vIE1ha2UgYW4gZW1wdHkgc3BhbiBmb3IgdGhlIHNwYWNlXG4gIGNvbnN0IHJ1bGUgPSBtYWtlU3BhbihbXCJtc3BhY2VcIl0sIFtdLCBvcHRpb25zKTtcbiAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVNpemUobWVhc3VyZW1lbnQsIG9wdGlvbnMpO1xuICBydWxlLnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFrZUVtKHNpemUpO1xuICByZXR1cm4gcnVsZTtcbn07IC8vIFRha2VzIGZvbnQgb3B0aW9ucywgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGZvbnRMb29rdXAgbmFtZVxuXG5cbmNvbnN0IHJldHJpZXZlVGV4dEZvbnROYW1lID0gZnVuY3Rpb24gKGZvbnRGYW1pbHksIGZvbnRXZWlnaHQsIGZvbnRTaGFwZSkge1xuICBsZXQgYmFzZUZvbnROYW1lID0gXCJcIjtcblxuICBzd2l0Y2ggKGZvbnRGYW1pbHkpIHtcbiAgICBjYXNlIFwiYW1zcm1cIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiQU1TXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0cm1cIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiTWFpblwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHNmXCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIlNhbnNTZXJpZlwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHR0XCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIlR5cGV3cml0ZXJcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJhc2VGb250TmFtZSA9IGZvbnRGYW1pbHk7XG4gICAgLy8gdXNlIGZvbnRzIGFkZGVkIGJ5IGEgcGx1Z2luXG4gIH1cblxuICBsZXQgZm9udFN0eWxlc05hbWU7XG5cbiAgaWYgKGZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIgJiYgZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkJvbGRJdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkJvbGRcIjtcbiAgfSBlbHNlIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRpdFwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkl0YWxpY1wiO1xuICB9IGVsc2Uge1xuICAgIGZvbnRTdHlsZXNOYW1lID0gXCJSZWd1bGFyXCI7XG4gIH1cblxuICByZXR1cm4gYmFzZUZvbnROYW1lICsgXCItXCIgKyBmb250U3R5bGVzTmFtZTtcbn07XG4vKipcbiAqIE1hcHMgVGVYIGZvbnQgY29tbWFuZHMgdG8gb2JqZWN0cyBjb250YWluaW5nOlxuICogLSB2YXJpYW50OiBzdHJpbmcgdXNlZCBmb3IgXCJtYXRodmFyaWFudFwiIGF0dHJpYnV0ZSBpbiBidWlsZE1hdGhNTC5qc1xuICogLSBmb250TmFtZTogdGhlIFwic3R5bGVcIiBwYXJhbWV0ZXIgdG8gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljc1xuICovXG4vLyBBIG1hcCBiZXR3ZWVuIHRleCBmb250IGNvbW1hbmRzIGFuIE1hdGhNTCBtYXRodmFyaWFudCBhdHRyaWJ1dGUgdmFsdWVzXG5cblxuY29uc3QgZm9udE1hcCA9IHtcbiAgLy8gc3R5bGVzXG4gIFwibWF0aGJmXCI6IHtcbiAgICB2YXJpYW50OiBcImJvbGRcIixcbiAgICBmb250TmFtZTogXCJNYWluLUJvbGRcIlxuICB9LFxuICBcIm1hdGhybVwiOiB7XG4gICAgdmFyaWFudDogXCJub3JtYWxcIixcbiAgICBmb250TmFtZTogXCJNYWluLVJlZ3VsYXJcIlxuICB9LFxuICBcInRleHRpdFwiOiB7XG4gICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICBmb250TmFtZTogXCJNYWluLUl0YWxpY1wiXG4gIH0sXG4gIFwibWF0aGl0XCI6IHtcbiAgICB2YXJpYW50OiBcIml0YWxpY1wiLFxuICAgIGZvbnROYW1lOiBcIk1haW4tSXRhbGljXCJcbiAgfSxcbiAgXCJtYXRobm9ybWFsXCI6IHtcbiAgICB2YXJpYW50OiBcIml0YWxpY1wiLFxuICAgIGZvbnROYW1lOiBcIk1hdGgtSXRhbGljXCJcbiAgfSxcbiAgXCJtYXRoc2ZpdFwiOiB7XG4gICAgdmFyaWFudDogXCJzYW5zLXNlcmlmLWl0YWxpY1wiLFxuICAgIGZvbnROYW1lOiBcIlNhbnNTZXJpZi1JdGFsaWNcIlxuICB9LFxuICAvLyBcImJvbGRzeW1ib2xcIiBpcyBtaXNzaW5nIGJlY2F1c2UgdGhleSByZXF1aXJlIHRoZSB1c2Ugb2YgbXVsdGlwbGUgZm9udHM6XG4gIC8vIE1hdGgtQm9sZEl0YWxpYyBhbmQgTWFpbi1Cb2xkLiAgVGhpcyBpcyBoYW5kbGVkIGJ5IGEgc3BlY2lhbCBjYXNlIGluXG4gIC8vIG1ha2VPcmQgd2hpY2ggZW5kcyB1cCBjYWxsaW5nIGJvbGRzeW1ib2wuXG4gIC8vIGZhbWlsaWVzXG4gIFwibWF0aGJiXCI6IHtcbiAgICB2YXJpYW50OiBcImRvdWJsZS1zdHJ1Y2tcIixcbiAgICBmb250TmFtZTogXCJBTVMtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aGNhbFwiOiB7XG4gICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICBmb250TmFtZTogXCJDYWxpZ3JhcGhpYy1SZWd1bGFyXCJcbiAgfSxcbiAgXCJtYXRoZnJha1wiOiB7XG4gICAgdmFyaWFudDogXCJmcmFrdHVyXCIsXG4gICAgZm9udE5hbWU6IFwiRnJha3R1ci1SZWd1bGFyXCJcbiAgfSxcbiAgXCJtYXRoc2NyXCI6IHtcbiAgICB2YXJpYW50OiBcInNjcmlwdFwiLFxuICAgIGZvbnROYW1lOiBcIlNjcmlwdC1SZWd1bGFyXCJcbiAgfSxcbiAgXCJtYXRoc2ZcIjoge1xuICAgIHZhcmlhbnQ6IFwic2Fucy1zZXJpZlwiLFxuICAgIGZvbnROYW1lOiBcIlNhbnNTZXJpZi1SZWd1bGFyXCJcbiAgfSxcbiAgXCJtYXRodHRcIjoge1xuICAgIHZhcmlhbnQ6IFwibW9ub3NwYWNlXCIsXG4gICAgZm9udE5hbWU6IFwiVHlwZXdyaXRlci1SZWd1bGFyXCJcbiAgfVxufTtcbmNvbnN0IHN2Z0RhdGEgPSB7XG4gIC8vICAgcGF0aCwgd2lkdGgsIGhlaWdodFxuICB2ZWM6IFtcInZlY1wiLCAwLjQ3MSwgMC43MTRdLFxuICAvLyB2YWx1ZXMgZnJvbSB0aGUgZm9udCBnbHlwaFxuICBvaWludFNpemUxOiBbXCJvaWludFNpemUxXCIsIDAuOTU3LCAwLjQ5OV0sXG4gIC8vIG92YWwgdG8gb3ZlcmxheSB0aGUgaW50ZWdyYW5kXG4gIG9paW50U2l6ZTI6IFtcIm9paW50U2l6ZTJcIiwgMS40NzIsIDAuNjU5XSxcbiAgb2lpaW50U2l6ZTE6IFtcIm9paWludFNpemUxXCIsIDEuMzA0LCAwLjQ5OV0sXG4gIG9paWludFNpemUyOiBbXCJvaWlpbnRTaXplMlwiLCAxLjk4LCAwLjY1OV1cbn07XG5cbmNvbnN0IHN0YXRpY1N2ZyA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGVsZW1lbnQuXG4gIGNvbnN0IFtwYXRoTmFtZSwgd2lkdGgsIGhlaWdodF0gPSBzdmdEYXRhW3ZhbHVlXTtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoTm9kZShwYXRoTmFtZSk7XG4gIGNvbnN0IHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICBcIndpZHRoXCI6IG1ha2VFbSh3aWR0aCksXG4gICAgXCJoZWlnaHRcIjogbWFrZUVtKGhlaWdodCksXG4gICAgLy8gT3ZlcnJpZGUgQ1NTIHJ1bGUgYC5rYXRleCBzdmcgeyB3aWR0aDogMTAwJSB9YFxuICAgIFwic3R5bGVcIjogXCJ3aWR0aDpcIiArIG1ha2VFbSh3aWR0aCksXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIFwiICsgMTAwMCAqIHdpZHRoICsgXCIgXCIgKyAxMDAwICogaGVpZ2h0LFxuICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcInhNaW5ZTWluXCJcbiAgfSk7XG4gIGNvbnN0IHNwYW4gPSBtYWtlU3ZnU3BhbihbXCJvdmVybGF5XCJdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpO1xuICBzcGFuLmhlaWdodCA9IGhlaWdodDtcbiAgc3Bhbi5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oaGVpZ2h0KTtcbiAgc3Bhbi5zdHlsZS53aWR0aCA9IG1ha2VFbSh3aWR0aCk7XG4gIHJldHVybiBzcGFuO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYnVpbGRDb21tb24gPSAoe1xuICBmb250TWFwLFxuICBtYWtlU3ltYm9sLFxuICBtYXRoc3ltLFxuICBtYWtlU3BhbixcbiAgbWFrZVN2Z1NwYW4sXG4gIG1ha2VMaW5lU3BhbixcbiAgbWFrZUFuY2hvcixcbiAgbWFrZUZyYWdtZW50LFxuICB3cmFwRnJhZ21lbnQsXG4gIG1ha2VWTGlzdCxcbiAgbWFrZU9yZCxcbiAgbWFrZUdsdWUsXG4gIHN0YXRpY1N2ZyxcbiAgc3ZnRGF0YSxcbiAgdHJ5Q29tYmluZUNoYXJzXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zcGFjaW5nRGF0YS5qc1xuLyoqXG4gKiBEZXNjcmliZXMgc3BhY2VzIGJldHdlZW4gZGlmZmVyZW50IGNsYXNzZXMgb2YgYXRvbXMuXG4gKi9cbmNvbnN0IHRoaW5zcGFjZSA9IHtcbiAgbnVtYmVyOiAzLFxuICB1bml0OiBcIm11XCJcbn07XG5jb25zdCBtZWRpdW1zcGFjZSA9IHtcbiAgbnVtYmVyOiA0LFxuICB1bml0OiBcIm11XCJcbn07XG5jb25zdCB0aGlja3NwYWNlID0ge1xuICBudW1iZXI6IDUsXG4gIHVuaXQ6IFwibXVcIlxufTsgLy8gTWFraW5nIHRoZSB0eXBlIGJlbG93IGV4YWN0IHdpdGggYWxsIG9wdGlvbmFsIGZpZWxkcyBkb2Vzbid0IHdvcmsgZHVlIHRvXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy80NTgyXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy81Njg4XG4vLyBIb3dldmVyLCBzaW5jZSAqYWxsKiBmaWVsZHMgYXJlIG9wdGlvbmFsLCAkU2hhcGU8PiB3b3JrcyBhcyBzdWdnZXN0ZWQgaW4gNTY4OFxuLy8gYWJvdmUuXG5cbi8vIFNwYWNpbmcgcmVsYXRpb25zaGlwcyBmb3IgZGlzcGxheSBhbmQgdGV4dCBzdHlsZXNcbmNvbnN0IHNwYWNpbmdzID0ge1xuICBtb3JkOiB7XG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbWJpbjogbWVkaXVtc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtb3A6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtYmluOiB7XG4gICAgbW9yZDogbWVkaXVtc3BhY2UsXG4gICAgbW9wOiBtZWRpdW1zcGFjZSxcbiAgICBtb3BlbjogbWVkaXVtc3BhY2UsXG4gICAgbWlubmVyOiBtZWRpdW1zcGFjZVxuICB9LFxuICBtcmVsOiB7XG4gICAgbW9yZDogdGhpY2tzcGFjZSxcbiAgICBtb3A6IHRoaWNrc3BhY2UsXG4gICAgbW9wZW46IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGlja3NwYWNlXG4gIH0sXG4gIG1vcGVuOiB7fSxcbiAgbWNsb3NlOiB7XG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbWJpbjogbWVkaXVtc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtcHVuY3Q6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtb3BlbjogdGhpbnNwYWNlLFxuICAgIG1jbG9zZTogdGhpbnNwYWNlLFxuICAgIG1wdW5jdDogdGhpbnNwYWNlLFxuICAgIG1pbm5lcjogdGhpbnNwYWNlXG4gIH0sXG4gIG1pbm5lcjoge1xuICAgIG1vcmQ6IHRoaW5zcGFjZSxcbiAgICBtb3A6IHRoaW5zcGFjZSxcbiAgICBtYmluOiBtZWRpdW1zcGFjZSxcbiAgICBtcmVsOiB0aGlja3NwYWNlLFxuICAgIG1vcGVuOiB0aGluc3BhY2UsXG4gICAgbXB1bmN0OiB0aGluc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfVxufTsgLy8gU3BhY2luZyByZWxhdGlvbnNoaXBzIGZvciBzY3JpcHQgYW5kIHNjcmlwdHNjcmlwdCBzdHlsZXNcblxuY29uc3QgdGlnaHRTcGFjaW5ncyA9IHtcbiAgbW9yZDoge1xuICAgIG1vcDogdGhpbnNwYWNlXG4gIH0sXG4gIG1vcDoge1xuICAgIG1vcmQ6IHRoaW5zcGFjZSxcbiAgICBtb3A6IHRoaW5zcGFjZVxuICB9LFxuICBtYmluOiB7fSxcbiAgbXJlbDoge30sXG4gIG1vcGVuOiB7fSxcbiAgbWNsb3NlOiB7XG4gICAgbW9wOiB0aGluc3BhY2VcbiAgfSxcbiAgbXB1bmN0OiB7fSxcbiAgbWlubmVyOiB7XG4gICAgbW9wOiB0aGluc3BhY2VcbiAgfVxufTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kZWZpbmVGdW5jdGlvbi5qc1xuLyoqIENvbnRleHQgcHJvdmlkZWQgdG8gZnVuY3Rpb24gaGFuZGxlcnMgZm9yIGVycm9yIG1lc3NhZ2VzLiAqL1xuLy8gTm90ZTogcmV2ZXJzZSB0aGUgb3JkZXIgb2YgdGhlIHJldHVybiB0eXBlIHVuaW9uIHdpbGwgY2F1c2UgYSBmbG93IGVycm9yLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8zNjYzLlxuLy8gTW9yZSBnZW5lcmFsIHZlcnNpb24gb2YgYEh0bWxCdWlsZGVyYCBmb3Igbm9kZXMgKGUuZy4gXFxzdW0sIGFjY2VudCB0eXBlcylcbi8vIHdob3NlIHByZXNlbmNlIGltcGFjdHMgc3VwZXIvc3Vic2NyaXB0aW5nLiBJbiB0aGlzIGNhc2UsIFBhcnNlTm9kZTxcInN1cHN1YlwiPlxuLy8gZGVsZWdhdGVzIGl0cyBIVE1MIGJ1aWxkaW5nIHRvIHRoZSBIdG1sQnVpbGRlciBjb3JyZXNwb25kaW5nIHRvIHRoZXNlIG5vZGVzLlxuXG4vKipcbiAqIEZpbmFsIGZ1bmN0aW9uIHNwZWMgZm9yIHVzZSBhdCBwYXJzZSB0aW1lLlxuICogVGhpcyBpcyBhbG1vc3QgaWRlbnRpY2FsIHRvIGBGdW5jdGlvblByb3BTcGVjYCwgZXhjZXB0IGl0XG4gKiAxLiBpbmNsdWRlcyB0aGUgZnVuY3Rpb24gaGFuZGxlciwgYW5kXG4gKiAyLiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGV4Y2VwdCBhcmdUeXBlcy5cbiAqIEl0IGlzIGdlbmVyYXRlZCBieSBgZGVmaW5lRnVuY3Rpb24oKWAgYmVsb3cuXG4gKi9cblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBmdW5jdGlvbnMuXG4gKiBgZnVuY3Rpb25zLmpzYCBqdXN0IGV4cG9ydHMgdGhpcyBzYW1lIGRpY3Rpb25hcnkgYWdhaW4gYW5kIG1ha2VzIGl0IHB1YmxpYy5cbiAqIGBQYXJzZXIuanNgIHJlcXVpcmVzIHRoaXMgZGljdGlvbmFyeS5cbiAqL1xuY29uc3QgX2Z1bmN0aW9ucyA9IHt9O1xuLyoqXG4gKiBBbGwgSFRNTCBidWlsZGVycy4gU2hvdWxkIGJlIG9ubHkgdXNlZCBpbiB0aGUgYGRlZmluZSpgIGFuZCB0aGUgYGJ1aWxkKk1MYFxuICogZnVuY3Rpb25zLlxuICovXG5cbmNvbnN0IF9odG1sR3JvdXBCdWlsZGVycyA9IHt9O1xuLyoqXG4gKiBBbGwgTWF0aE1MIGJ1aWxkZXJzLiBTaG91bGQgYmUgb25seSB1c2VkIGluIHRoZSBgZGVmaW5lKmAgYW5kIHRoZSBgYnVpbGQqTUxgXG4gKiBmdW5jdGlvbnMuXG4gKi9cblxuY29uc3QgX21hdGhtbEdyb3VwQnVpbGRlcnMgPSB7fTtcbmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uKF9yZWYpIHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIG5hbWVzLFxuICAgIHByb3BzLFxuICAgIGhhbmRsZXIsXG4gICAgaHRtbEJ1aWxkZXIsXG4gICAgbWF0aG1sQnVpbGRlclxuICB9ID0gX3JlZjtcbiAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGZ1bmN0aW9uc1xuICBjb25zdCBkYXRhID0ge1xuICAgIHR5cGUsXG4gICAgbnVtQXJnczogcHJvcHMubnVtQXJncyxcbiAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6ICEhcHJvcHMuYWxsb3dlZEluQXJndW1lbnQsXG4gICAgYWxsb3dlZEluVGV4dDogISFwcm9wcy5hbGxvd2VkSW5UZXh0LFxuICAgIGFsbG93ZWRJbk1hdGg6IHByb3BzLmFsbG93ZWRJbk1hdGggPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwcm9wcy5hbGxvd2VkSW5NYXRoLFxuICAgIG51bU9wdGlvbmFsQXJnczogcHJvcHMubnVtT3B0aW9uYWxBcmdzIHx8IDAsXG4gICAgaW5maXg6ICEhcHJvcHMuaW5maXgsXG4gICAgcHJpbWl0aXZlOiAhIXByb3BzLnByaW1pdGl2ZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIF9mdW5jdGlvbnNbbmFtZXNbaV1dID0gZGF0YTtcbiAgfVxuXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKGh0bWxCdWlsZGVyKSB7XG4gICAgICBfaHRtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBodG1sQnVpbGRlcjtcbiAgICB9XG5cbiAgICBpZiAobWF0aG1sQnVpbGRlcikge1xuICAgICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBVc2UgdGhpcyB0byByZWdpc3RlciBvbmx5IHRoZSBIVE1MIGFuZCBNYXRoTUwgYnVpbGRlcnMgZm9yIGEgZnVuY3Rpb24gKGUuZy5cbiAqIGlmIHRoZSBmdW5jdGlvbidzIFBhcnNlTm9kZSBpcyBnZW5lcmF0ZWQgaW4gUGFyc2VyLmpzIHJhdGhlciB0aGFuIHZpYSBhXG4gKiBzdGFuZC1hbG9uZSBoYW5kbGVyIHByb3ZpZGVkIHRvIGBkZWZpbmVGdW5jdGlvbmApLlxuICovXG5cbmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGh0bWxCdWlsZGVyLFxuICAgIG1hdGhtbEJ1aWxkZXJcbiAgfSA9IF9yZWYyO1xuICBkZWZpbmVGdW5jdGlvbih7XG4gICAgdHlwZSxcbiAgICBuYW1lczogW10sXG4gICAgcHJvcHM6IHtcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9LFxuXG4gICAgaGFuZGxlcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGJlIGNhbGxlZC4nKTtcbiAgICB9LFxuXG4gICAgaHRtbEJ1aWxkZXIsXG4gICAgbWF0aG1sQnVpbGRlclxuICB9KTtcbn1cbmNvbnN0IG5vcm1hbGl6ZUFyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIiAmJiBhcmcuYm9keS5sZW5ndGggPT09IDEgPyBhcmcuYm9keVswXSA6IGFyZztcbn07IC8vIFNpbmNlIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkSFRNTC9idWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xuXG5jb25zdCBvcmRhcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgPyBhcmcuYm9keSA6IFthcmddO1xufTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9idWlsZEhUTUwuanNcbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgdGhlIG1haW4gd29yayBvZiBidWlsZGluZyBhIGRvbVRyZWUgc3RydWN0dXJlIGZyb20gYSBwYXJzZVxuICogdHJlZS4gVGhlIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRIVE1MYCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwYXJzZSB0cmVlLlxuICogVGhlbiwgdGhlIGJ1aWxkRXhwcmVzc2lvbiwgYnVpbGRHcm91cCwgYW5kIHZhcmlvdXMgZ3JvdXBCdWlsZGVycyBmdW5jdGlvbnNcbiAqIGFyZSBjYWxsZWQsIHRvIHByb2R1Y2UgYSBmaW5hbCBIVE1MIHRyZWUuXG4gKi9cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IGJ1aWxkSFRNTF9tYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuOyAvLyBCaW5hcnkgYXRvbXMgKGZpcnN0IGNsYXNzIGBtYmluYCkgY2hhbmdlIGludG8gb3JkaW5hcnkgYXRvbXMgKGBtb3JkYClcbi8vIGRlcGVuZGluZyBvbiB0aGVpciBzdXJyb3VuZGluZ3MuIFNlZSBUZVhib29rIHBnLiA0NDItNDQ2LCBSdWxlcyA1IGFuZCA2LFxuLy8gYW5kIHRoZSB0ZXh0IGJlZm9yZSBSdWxlIDE5LlxuXG5jb25zdCBiaW5MZWZ0Q2FuY2VsbGVyID0gW1wibGVmdG1vc3RcIiwgXCJtYmluXCIsIFwibW9wZW5cIiwgXCJtcmVsXCIsIFwibW9wXCIsIFwibXB1bmN0XCJdO1xuY29uc3QgYmluUmlnaHRDYW5jZWxsZXIgPSBbXCJyaWdodG1vc3RcIiwgXCJtcmVsXCIsIFwibWNsb3NlXCIsIFwibXB1bmN0XCJdO1xuY29uc3Qgc3R5bGVNYXAgPSB7XG4gIFwiZGlzcGxheVwiOiBzcmNfU3R5bGUuRElTUExBWSxcbiAgXCJ0ZXh0XCI6IHNyY19TdHlsZS5URVhULFxuICBcInNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBULFxuICBcInNjcmlwdHNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBUU0NSSVBUXG59O1xuY29uc3QgRG9tRW51bSA9IHtcbiAgbW9yZDogXCJtb3JkXCIsXG4gIG1vcDogXCJtb3BcIixcbiAgbWJpbjogXCJtYmluXCIsXG4gIG1yZWw6IFwibXJlbFwiLFxuICBtb3BlbjogXCJtb3BlblwiLFxuICBtY2xvc2U6IFwibWNsb3NlXCIsXG4gIG1wdW5jdDogXCJtcHVuY3RcIixcbiAgbWlubmVyOiBcIm1pbm5lclwiXG59O1xuXG4vKipcbiAqIFRha2UgYSBsaXN0IG9mIG5vZGVzLCBidWlsZCB0aGVtIGluIG9yZGVyLCBhbmQgcmV0dXJuIGEgbGlzdCBvZiB0aGUgYnVpbHRcbiAqIG5vZGVzLiBkb2N1bWVudEZyYWdtZW50cyBhcmUgZmxhdHRlbmVkIGludG8gdGhlaXIgY29udGVudHMsIHNvIHRoZVxuICogcmV0dXJuZWQgbGlzdCBjb250YWlucyBubyBmcmFnbWVudHMuIGBpc1JlYWxHcm91cGAgaXMgdHJ1ZSBpZiBgZXhwcmVzc2lvbmBcbiAqIGlzIGEgcmVhbCBncm91cCAobm8gYXRvbXMgd2lsbCBiZSBhZGRlZCBvbiBlaXRoZXIgc2lkZSksIGFzIG9wcG9zZWQgdG9cbiAqIGEgcGFydGlhbCBncm91cCAoZS5nLiBvbmUgY3JlYXRlZCBieSBcXGNvbG9yKS4gYHN1cnJvdW5kaW5nYCBpcyBhbiBhcnJheVxuICogY29uc2lzdGluZyB0eXBlIG9mIG5vZGVzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbGVmdCBhbmQgcmlnaHQuXG4gKi9cbmNvbnN0IGJ1aWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBvcHRpb25zLCBpc1JlYWxHcm91cCwgc3Vycm91bmRpbmcpIHtcbiAgaWYgKHN1cnJvdW5kaW5nID09PSB2b2lkIDApIHtcbiAgICBzdXJyb3VuZGluZyA9IFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIC8vIFBhcnNlIGV4cHJlc3Npb25zIGludG8gYGdyb3Vwc2AuXG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG91dHB1dCA9IGJ1aWxkR3JvdXAoZXhwcmVzc2lvbltpXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBvdXRwdXQuY2hpbGRyZW47XG4gICAgICBncm91cHMucHVzaCguLi5jaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwcy5wdXNoKG91dHB1dCk7XG4gICAgfVxuICB9IC8vIENvbWJpbmUgY29uc2VjdXRpdmUgZG9tVHJlZS5zeW1ib2xOb2RlcyBpbnRvIGEgc2luZ2xlIHN5bWJvbE5vZGUuXG5cblxuICBidWlsZENvbW1vbi50cnlDb21iaW5lQ2hhcnMoZ3JvdXBzKTsgLy8gSWYgYGV4cHJlc3Npb25gIGlzIGEgcGFydGlhbCBncm91cCwgbGV0IHRoZSBwYXJlbnQgaGFuZGxlIHNwYWNpbmdzXG4gIC8vIHRvIGF2b2lkIHByb2Nlc3NpbmcgZ3JvdXBzIG11bHRpcGxlIHRpbWVzLlxuXG4gIGlmICghaXNSZWFsR3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG5cbiAgbGV0IGdsdWVPcHRpb25zID0gb3B0aW9ucztcblxuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBub2RlID0gZXhwcmVzc2lvblswXTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwic2l6aW5nXCIpIHtcbiAgICAgIGdsdWVPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKG5vZGUuc2l6ZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwic3R5bGluZ1wiKSB7XG4gICAgICBnbHVlT3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGVNYXBbbm9kZS5zdHlsZV0pO1xuICAgIH1cbiAgfSAvLyBEdW1teSBzcGFucyBmb3IgZGV0ZXJtaW5pbmcgc3BhY2luZ3MgYmV0d2VlbiBzdXJyb3VuZGluZyBhdG9tcy5cbiAgLy8gSWYgYGV4cHJlc3Npb25gIGhhcyBubyBhdG9tcyBvbiB0aGUgbGVmdCBvciByaWdodCwgY2xhc3MgXCJsZWZ0bW9zdFwiXG4gIC8vIG9yIFwicmlnaHRtb3N0XCIsIHJlc3BlY3RpdmVseSwgaXMgdXNlZCB0byBpbmRpY2F0ZSBpdC5cblxuXG4gIGNvbnN0IGR1bW15UHJldiA9IGJ1aWxkSFRNTF9tYWtlU3Bhbihbc3Vycm91bmRpbmdbMF0gfHwgXCJsZWZ0bW9zdFwiXSwgW10sIG9wdGlvbnMpO1xuICBjb25zdCBkdW1teU5leHQgPSBidWlsZEhUTUxfbWFrZVNwYW4oW3N1cnJvdW5kaW5nWzFdIHx8IFwicmlnaHRtb3N0XCJdLCBbXSwgb3B0aW9ucyk7IC8vIFRPRE86IFRoZXNlIGNvZGUgYXNzdW1lcyB0aGF0IGEgbm9kZSdzIG1hdGggY2xhc3MgaXMgdGhlIGZpcnN0IGVsZW1lbnRcbiAgLy8gb2YgaXRzIGBjbGFzc2VzYCBhcnJheS4gQSBsYXRlciBjbGVhbnVwIHNob3VsZCBlbnN1cmUgdGhpcywgZm9yXG4gIC8vIGluc3RhbmNlIGJ5IGNoYW5naW5nIHRoZSBzaWduYXR1cmUgb2YgYG1ha2VTcGFuYC5cbiAgLy8gQmVmb3JlIGRldGVybWluaW5nIHdoYXQgc3BhY2VzIHRvIGluc2VydCwgcGVyZm9ybSBiaW4gY2FuY2VsbGF0aW9uLlxuICAvLyBCaW5hcnkgb3BlcmF0b3JzIGNoYW5nZSB0byBvcmRpbmFyeSBzeW1ib2xzIGluIHNvbWUgY29udGV4dHMuXG5cbiAgY29uc3QgaXNSb290ID0gaXNSZWFsR3JvdXAgPT09IFwicm9vdFwiO1xuICB0cmF2ZXJzZU5vblNwYWNlTm9kZXMoZ3JvdXBzLCAobm9kZSwgcHJldikgPT4ge1xuICAgIGNvbnN0IHByZXZUeXBlID0gcHJldi5jbGFzc2VzWzBdO1xuICAgIGNvbnN0IHR5cGUgPSBub2RlLmNsYXNzZXNbMF07XG5cbiAgICBpZiAocHJldlR5cGUgPT09IFwibWJpblwiICYmIHV0aWxzLmNvbnRhaW5zKGJpblJpZ2h0Q2FuY2VsbGVyLCB0eXBlKSkge1xuICAgICAgcHJldi5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm1iaW5cIiAmJiB1dGlscy5jb250YWlucyhiaW5MZWZ0Q2FuY2VsbGVyLCBwcmV2VHlwZSkpIHtcbiAgICAgIG5vZGUuY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgIH1cbiAgfSwge1xuICAgIG5vZGU6IGR1bW15UHJldlxuICB9LCBkdW1teU5leHQsIGlzUm9vdCk7XG4gIHRyYXZlcnNlTm9uU3BhY2VOb2Rlcyhncm91cHMsIChub2RlLCBwcmV2KSA9PiB7XG4gICAgY29uc3QgcHJldlR5cGUgPSBnZXRUeXBlT2ZEb21UcmVlKHByZXYpO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlT2ZEb21UcmVlKG5vZGUpOyAvLyAnbXRpZ2h0JyBpbmRpY2F0ZXMgdGhhdCB0aGUgbm9kZSBpcyBzY3JpcHQgb3Igc2NyaXB0c2NyaXB0IHN0eWxlLlxuXG4gICAgY29uc3Qgc3BhY2UgPSBwcmV2VHlwZSAmJiB0eXBlID8gbm9kZS5oYXNDbGFzcyhcIm10aWdodFwiKSA/IHRpZ2h0U3BhY2luZ3NbcHJldlR5cGVdW3R5cGVdIDogc3BhY2luZ3NbcHJldlR5cGVdW3R5cGVdIDogbnVsbDtcblxuICAgIGlmIChzcGFjZSkge1xuICAgICAgLy8gSW5zZXJ0IGdsdWUgKHNwYWNpbmcpIGFmdGVyIHRoZSBgcHJldmAuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUdsdWUoc3BhY2UsIGdsdWVPcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBub2RlOiBkdW1teVByZXZcbiAgfSwgZHVtbXlOZXh0LCBpc1Jvb3QpO1xuICByZXR1cm4gZ3JvdXBzO1xufTsgLy8gRGVwdGgtZmlyc3QgdHJhdmVyc2Ugbm9uLXNwYWNlIGBub2Rlc2AsIGNhbGxpbmcgYGNhbGxiYWNrYCB3aXRoIHRoZSBjdXJyZW50IGFuZFxuLy8gcHJldmlvdXMgbm9kZSBhcyBhcmd1bWVudHMsIG9wdGlvbmFsbHkgcmV0dXJuaW5nIGEgbm9kZSB0byBpbnNlcnQgYWZ0ZXIgdGhlXG4vLyBwcmV2aW91cyBub2RlLiBgcHJldmAgaXMgYW4gb2JqZWN0IHdpdGggdGhlIHByZXZpb3VzIG5vZGUgYW5kIGBpbnNlcnRBZnRlcmBcbi8vIGZ1bmN0aW9uIHRvIGluc2VydCBhZnRlciBpdC4gYG5leHRgIGlzIGEgbm9kZSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJpZ2h0LlxuLy8gVXNlZCBmb3IgYmluIGNhbmNlbGxhdGlvbiBhbmQgaW5zZXJ0aW5nIHNwYWNpbmdzLlxuXG5jb25zdCB0cmF2ZXJzZU5vblNwYWNlTm9kZXMgPSBmdW5jdGlvbiAobm9kZXMsIGNhbGxiYWNrLCBwcmV2LCBuZXh0LCBpc1Jvb3QpIHtcbiAgaWYgKG5leHQpIHtcbiAgICAvLyB0ZW1wb3JhcmlseSBhcHBlbmQgdGhlIHJpZ2h0IG5vZGUsIGlmIGV4aXN0c1xuICAgIG5vZGVzLnB1c2gobmV4dCk7XG4gIH1cblxuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBjb25zdCBwYXJ0aWFsR3JvdXAgPSBjaGVja1BhcnRpYWxHcm91cChub2RlKTtcblxuICAgIGlmIChwYXJ0aWFsR3JvdXApIHtcbiAgICAgIC8vIFJlY3Vyc2l2ZSBERlNcbiAgICAgIC8vICRGbG93Rml4TWU6IG1ha2Ugbm9kZXMgYSAkUmVhZE9ubHlBcnJheSBieSByZXR1cm5pbmcgYSBuZXcgYXJyYXlcbiAgICAgIHRyYXZlcnNlTm9uU3BhY2VOb2RlcyhwYXJ0aWFsR3JvdXAuY2hpbGRyZW4sIGNhbGxiYWNrLCBwcmV2LCBudWxsLCBpc1Jvb3QpO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBJZ25vcmUgZXhwbGljaXQgc3BhY2VzIChlLmcuLCBcXDssIFxcLCkgd2hlbiBkZXRlcm1pbmluZyB3aGF0IGltcGxpY2l0XG4gICAgLy8gc3BhY2luZyBzaG91bGQgZ28gYmV0d2VlbiBhdG9tcyBvZiBkaWZmZXJlbnQgY2xhc3Nlc1xuXG5cbiAgICBjb25zdCBub25zcGFjZSA9ICFub2RlLmhhc0NsYXNzKFwibXNwYWNlXCIpO1xuXG4gICAgaWYgKG5vbnNwYWNlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayhub2RlLCBwcmV2Lm5vZGUpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChwcmV2Lmluc2VydEFmdGVyKSB7XG4gICAgICAgICAgcHJldi5pbnNlcnRBZnRlcihyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluc2VydCBhdCBmcm9udFxuICAgICAgICAgIG5vZGVzLnVuc2hpZnQocmVzdWx0KTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9uc3BhY2UpIHtcbiAgICAgIHByZXYubm9kZSA9IG5vZGU7XG4gICAgfSBlbHNlIGlmIChpc1Jvb3QgJiYgbm9kZS5oYXNDbGFzcyhcIm5ld2xpbmVcIikpIHtcbiAgICAgIHByZXYubm9kZSA9IGJ1aWxkSFRNTF9tYWtlU3BhbihbXCJsZWZ0bW9zdFwiXSk7IC8vIHRyZWF0IGxpa2UgYmVnaW5uaW5nIG9mIGxpbmVcbiAgICB9XG5cbiAgICBwcmV2Lmluc2VydEFmdGVyID0gKGluZGV4ID0+IG4gPT4ge1xuICAgICAgbm9kZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbik7XG4gICAgICBpKys7XG4gICAgfSkoaSk7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5vZGVzLnBvcCgpO1xuICB9XG59OyAvLyBDaGVjayBpZiBnaXZlbiBub2RlIGlzIGEgcGFydGlhbCBncm91cCwgaS5lLiwgZG9lcyBub3QgYWZmZWN0IHNwYWNpbmcgYXJvdW5kLlxuXG5cbmNvbnN0IGNoZWNrUGFydGlhbEdyb3VwID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBBbmNob3IgfHwgbm9kZSBpbnN0YW5jZW9mIFNwYW4gJiYgbm9kZS5oYXNDbGFzcyhcImVuY2xvc2luZ1wiKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59OyAvLyBSZXR1cm4gdGhlIG91dGVybW9zdCBub2RlIG9mIGEgZG9tVHJlZS5cblxuXG5jb25zdCBnZXRPdXRlcm1vc3ROb2RlID0gZnVuY3Rpb24gKG5vZGUsIHNpZGUpIHtcbiAgY29uc3QgcGFydGlhbEdyb3VwID0gY2hlY2tQYXJ0aWFsR3JvdXAobm9kZSk7XG5cbiAgaWYgKHBhcnRpYWxHcm91cCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFydGlhbEdyb3VwLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgaWYgKHNpZGUgPT09IFwicmlnaHRcIikge1xuICAgICAgICByZXR1cm4gZ2V0T3V0ZXJtb3N0Tm9kZShjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSwgXCJyaWdodFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldE91dGVybW9zdE5vZGUoY2hpbGRyZW5bMF0sIFwibGVmdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07IC8vIFJldHVybiBtYXRoIGF0b20gY2xhc3MgKG1jbGFzcykgb2YgYSBkb21UcmVlLlxuLy8gSWYgYHNpZGVgIGlzIGdpdmVuLCBpdCB3aWxsIGdldCB0aGUgdHlwZSBvZiB0aGUgb3V0ZXJtb3N0IG5vZGUgYXQgZ2l2ZW4gc2lkZS5cblxuXG5jb25zdCBnZXRUeXBlT2ZEb21UcmVlID0gZnVuY3Rpb24gKG5vZGUsIHNpZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc2lkZSkge1xuICAgIG5vZGUgPSBnZXRPdXRlcm1vc3ROb2RlKG5vZGUsIHNpZGUpO1xuICB9IC8vIFRoaXMgbWFrZXMgYSBsb3Qgb2YgYXNzdW1wdGlvbnMgYXMgdG8gd2hlcmUgdGhlIHR5cGUgb2YgYXRvbVxuICAvLyBhcHBlYXJzLiAgV2Ugc2hvdWxkIGRvIGEgYmV0dGVyIGpvYiBvZiBlbmZvcmNpbmcgdGhpcy5cblxuXG4gIHJldHVybiBEb21FbnVtW25vZGUuY2xhc3Nlc1swXV0gfHwgbnVsbDtcbn07XG5jb25zdCBtYWtlTnVsbERlbGltaXRlciA9IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc2VzKSB7XG4gIGNvbnN0IG1vcmVDbGFzc2VzID0gW1wibnVsbGRlbGltaXRlclwiXS5jb25jYXQob3B0aW9ucy5iYXNlU2l6aW5nQ2xhc3NlcygpKTtcbiAgcmV0dXJuIGJ1aWxkSFRNTF9tYWtlU3BhbihjbGFzc2VzLmNvbmNhdChtb3JlQ2xhc3NlcykpO1xufTtcbi8qKlxuICogYnVpbGRHcm91cCBpcyB0aGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwIGFuZCBjYWxscyB0aGUgY29ycmVjdCBncm91cFR5cGVcbiAqIGZ1bmN0aW9uIGZvciBpdC4gSXQgYWxzbyBoYW5kbGVzIHRoZSBpbnRlcmFjdGlvbiBvZiBzaXplIGFuZCBzdHlsZSBjaGFuZ2VzXG4gKiBiZXR3ZWVuIHBhcmVudHMgYW5kIGNoaWxkcmVuLlxuICovXG5cbmNvbnN0IGJ1aWxkR3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXAsIG9wdGlvbnMsIGJhc2VPcHRpb25zKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gYnVpbGRIVE1MX21ha2VTcGFuKCk7XG4gIH1cblxuICBpZiAoX2h0bWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKSB7XG4gICAgLy8gQ2FsbCB0aGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICAgIC8vICRGbG93Rml4TWVcbiAgICBsZXQgZ3JvdXBOb2RlID0gX2h0bWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTsgLy8gSWYgdGhlIHNpemUgY2hhbmdlZCBiZXR3ZWVuIHRoZSBwYXJlbnQgYW5kIHRoZSBjdXJyZW50IGdyb3VwLCBhY2NvdW50XG4gICAgLy8gZm9yIHRoYXQgc2l6ZSBkaWZmZXJlbmNlLlxuXG4gICAgaWYgKGJhc2VPcHRpb25zICYmIG9wdGlvbnMuc2l6ZSAhPT0gYmFzZU9wdGlvbnMuc2l6ZSkge1xuICAgICAgZ3JvdXBOb2RlID0gYnVpbGRIVE1MX21ha2VTcGFuKG9wdGlvbnMuc2l6aW5nQ2xhc3NlcyhiYXNlT3B0aW9ucyksIFtncm91cE5vZGVdLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gYmFzZU9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgICBncm91cE5vZGUuaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgICBncm91cE5vZGUuZGVwdGggKj0gbXVsdGlwbGllcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXBOb2RlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkdvdCBncm91cCBvZiB1bmtub3duIHR5cGU6ICdcIiArIGdyb3VwLnR5cGUgKyBcIidcIik7XG4gIH1cbn07XG4vKipcbiAqIENvbWJpbmUgYW4gYXJyYXkgb2YgSFRNTCBET00gbm9kZXMgKGUuZy4sIHRoZSBvdXRwdXQgb2YgYGJ1aWxkRXhwcmVzc2lvbmApXG4gKiBpbnRvIGFuIHVuYnJlYWthYmxlIEhUTUwgbm9kZSBvZiBjbGFzcyAuYmFzZSwgd2l0aCBwcm9wZXIgc3RydXRzIHRvXG4gKiBndWFyYW50ZWUgY29ycmVjdCB2ZXJ0aWNhbCBleHRlbnQuICBgYnVpbGRIVE1MYCBjYWxscyB0aGlzIHJlcGVhdGVkbHkgdG9cbiAqIG1ha2UgdXAgdGhlIGVudGlyZSBleHByZXNzaW9uIGFzIGEgc2VxdWVuY2Ugb2YgdW5icmVha2FibGUgdW5pdHMuXG4gKi9cblxuZnVuY3Rpb24gYnVpbGRIVE1MVW5icmVha2FibGUoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgLy8gQ29tcHV0ZSBoZWlnaHQgYW5kIGRlcHRoIG9mIHRoaXMgY2h1bmsuXG4gIGNvbnN0IGJvZHkgPSBidWlsZEhUTUxfbWFrZVNwYW4oW1wiYmFzZVwiXSwgY2hpbGRyZW4sIG9wdGlvbnMpOyAvLyBBZGQgc3RydXQsIHdoaWNoIGVuc3VyZXMgdGhhdCB0aGUgdG9wIG9mIHRoZSBIVE1MIGVsZW1lbnQgZmFsbHMgYXRcbiAgLy8gdGhlIGhlaWdodCBvZiB0aGUgZXhwcmVzc2lvbiwgYW5kIHRoZSBib3R0b20gb2YgdGhlIEhUTUwgZWxlbWVudFxuICAvLyBmYWxscyBhdCB0aGUgZGVwdGggb2YgdGhlIGV4cHJlc3Npb24uXG5cbiAgY29uc3Qgc3RydXQgPSBidWlsZEhUTUxfbWFrZVNwYW4oW1wic3RydXRcIl0pO1xuICBzdHJ1dC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oYm9keS5oZWlnaHQgKyBib2R5LmRlcHRoKTtcblxuICBpZiAoYm9keS5kZXB0aCkge1xuICAgIHN0cnV0LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBtYWtlRW0oLWJvZHkuZGVwdGgpO1xuICB9XG5cbiAgYm9keS5jaGlsZHJlbi51bnNoaWZ0KHN0cnV0KTtcbiAgcmV0dXJuIGJvZHk7XG59XG4vKipcbiAqIFRha2UgYW4gZW50aXJlIHBhcnNlIHRyZWUsIGFuZCBidWlsZCBpdCBpbnRvIGFuIGFwcHJvcHJpYXRlIHNldCBvZiBIVE1MXG4gKiBub2Rlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKSB7XG4gIC8vIFN0cmlwIG9mZiBvdXRlciB0YWcgd3JhcHBlciBmb3IgcHJvY2Vzc2luZyBiZWxvdy5cbiAgbGV0IHRhZyA9IG51bGw7XG5cbiAgaWYgKHRyZWUubGVuZ3RoID09PSAxICYmIHRyZWVbMF0udHlwZSA9PT0gXCJ0YWdcIikge1xuICAgIHRhZyA9IHRyZWVbMF0udGFnO1xuICAgIHRyZWUgPSB0cmVlWzBdLmJvZHk7XG4gIH0gLy8gQnVpbGQgdGhlIGV4cHJlc3Npb24gY29udGFpbmVkIGluIHRoZSB0cmVlXG5cblxuICBjb25zdCBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMsIFwicm9vdFwiKTtcbiAgbGV0IGVxbk51bTtcblxuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDIgJiYgZXhwcmVzc2lvblsxXS5oYXNDbGFzcyhcInRhZ1wiKSkge1xuICAgIC8vIEFuIGVudmlyb25tZW50IHdpdGggYXV0b21hdGljIGVxdWF0aW9uIG51bWJlcnMsIGUuZy4ge2dhdGhlcn0uXG4gICAgZXFuTnVtID0gZXhwcmVzc2lvbi5wb3AoKTtcbiAgfVxuXG4gIGNvbnN0IGNoaWxkcmVuID0gW107IC8vIENyZWF0ZSBvbmUgYmFzZSBub2RlIGZvciBlYWNoIGNodW5rIGJldHdlZW4gcG90ZW50aWFsIGxpbmUgYnJlYWtzLlxuICAvLyBUaGUgVGVYQm9vayBbcC4xNzNdIHNheXMgXCJBIGZvcm11bGEgd2lsbCBiZSBicm9rZW4gb25seSBhZnRlciBhXG4gIC8vIHJlbGF0aW9uIHN5bWJvbCBsaWtlICQ9JCBvciAkPCQgb3IgJFxccmlnaHRhcnJvdyQsIG9yIGFmdGVyIGEgYmluYXJ5XG4gIC8vIG9wZXJhdGlvbiBzeW1ib2wgbGlrZSAkKyQgb3IgJC0kIG9yICRcXHRpbWVzJCwgd2hlcmUgdGhlIHJlbGF0aW9uIG9yXG4gIC8vIGJpbmFyeSBvcGVyYXRpb24gaXMgb24gdGhlIGBgb3V0ZXIgbGV2ZWwnJyBvZiB0aGUgZm9ybXVsYSAoaS5lLiwgbm90XG4gIC8vIGVuY2xvc2VkIGluIHsuLi59IGFuZCBub3QgcGFydCBvZiBhbiBcXG92ZXIgY29uc3RydWN0aW9uKS5cIlxuXG4gIGxldCBwYXJ0cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2goZXhwcmVzc2lvbltpXSk7XG5cbiAgICBpZiAoZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcIm1iaW5cIikgfHwgZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcIm1yZWxcIikgfHwgZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcImFsbG93YnJlYWtcIikpIHtcbiAgICAgIC8vIFB1dCBhbnkgcG9zdC1vcGVyYXRvciBnbHVlIG9uIHNhbWUgbGluZSBhcyBvcGVyYXRvci5cbiAgICAgIC8vIFdhdGNoIGZvciBcXG5vYnJlYWsgYWxvbmcgdGhlIHdheSwgYW5kIHN0b3AgYXQgXFxuZXdsaW5lLlxuICAgICAgbGV0IG5vYnJlYWsgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGkgPCBleHByZXNzaW9uLmxlbmd0aCAtIDEgJiYgZXhwcmVzc2lvbltpICsgMV0uaGFzQ2xhc3MoXCJtc3BhY2VcIikgJiYgIWV4cHJlc3Npb25baSArIDFdLmhhc0NsYXNzKFwibmV3bGluZVwiKSkge1xuICAgICAgICBpKys7XG4gICAgICAgIHBhcnRzLnB1c2goZXhwcmVzc2lvbltpXSk7XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJub2JyZWFrXCIpKSB7XG4gICAgICAgICAgbm9icmVhayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRG9uJ3QgYWxsb3cgYnJlYWsgaWYgXFxub2JyZWFrIGFtb25nIHRoZSBwb3N0LW9wZXJhdG9yIGdsdWUuXG5cblxuICAgICAgaWYgKCFub2JyZWFrKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRIVE1MVW5icmVha2FibGUocGFydHMsIG9wdGlvbnMpKTtcbiAgICAgICAgcGFydHMgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJuZXdsaW5lXCIpKSB7XG4gICAgICAvLyBXcml0ZSB0aGUgbGluZSBleGNlcHQgdGhlIG5ld2xpbmVcbiAgICAgIHBhcnRzLnBvcCgpO1xuXG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkSFRNTFVuYnJlYWthYmxlKHBhcnRzLCBvcHRpb25zKSk7XG4gICAgICAgIHBhcnRzID0gW107XG4gICAgICB9IC8vIFB1dCB0aGUgbmV3bGluZSBhdCB0aGUgdG9wIGxldmVsXG5cblxuICAgICAgY2hpbGRyZW4ucHVzaChleHByZXNzaW9uW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgIGNoaWxkcmVuLnB1c2goYnVpbGRIVE1MVW5icmVha2FibGUocGFydHMsIG9wdGlvbnMpKTtcbiAgfSAvLyBOb3csIGlmIHRoZXJlIHdhcyBhIHRhZywgYnVpbGQgaXQgdG9vIGFuZCBhcHBlbmQgaXQgYXMgYSBmaW5hbCBjaGlsZC5cblxuXG4gIGxldCB0YWdDaGlsZDtcblxuICBpZiAodGFnKSB7XG4gICAgdGFnQ2hpbGQgPSBidWlsZEhUTUxVbmJyZWFrYWJsZShidWlsZEV4cHJlc3Npb24odGFnLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgdGFnQ2hpbGQuY2xhc3NlcyA9IFtcInRhZ1wiXTtcbiAgICBjaGlsZHJlbi5wdXNoKHRhZ0NoaWxkKTtcbiAgfSBlbHNlIGlmIChlcW5OdW0pIHtcbiAgICBjaGlsZHJlbi5wdXNoKGVxbk51bSk7XG4gIH1cblxuICBjb25zdCBodG1sTm9kZSA9IGJ1aWxkSFRNTF9tYWtlU3BhbihbXCJrYXRleC1odG1sXCJdLCBjaGlsZHJlbik7XG4gIGh0bWxOb2RlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTsgLy8gQWRqdXN0IHRoZSBzdHJ1dCBvZiB0aGUgdGFnIHRvIGJlIHRoZSBtYXhpbXVtIGhlaWdodCBvZiBhbGwgY2hpbGRyZW5cbiAgLy8gKHRoZSBoZWlnaHQgb2YgdGhlIGVuY2xvc2luZyBodG1sTm9kZSkgZm9yIHByb3BlciB2ZXJ0aWNhbCBhbGlnbm1lbnQuXG5cbiAgaWYgKHRhZ0NoaWxkKSB7XG4gICAgY29uc3Qgc3RydXQgPSB0YWdDaGlsZC5jaGlsZHJlblswXTtcbiAgICBzdHJ1dC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oaHRtbE5vZGUuaGVpZ2h0ICsgaHRtbE5vZGUuZGVwdGgpO1xuXG4gICAgaWYgKGh0bWxOb2RlLmRlcHRoKSB7XG4gICAgICBzdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1odG1sTm9kZS5kZXB0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGh0bWxOb2RlO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21hdGhNTFRyZWUuanNcbi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSBkYXRhIGFib3V0IE1hdGhNTCBub2Rlcy4gVGhpcyBpcyB0aGUgTWF0aE1MIGVxdWl2YWxlbnRcbiAqIG9mIHRoZSB0eXBlcyBpbiBkb21UcmVlLmpzLiBTaW5jZSBNYXRoTUwgaGFuZGxlcyBpdHMgb3duIHJlbmRlcmluZywgYW5kXG4gKiBzaW5jZSB3ZSdyZSBtYWlubHkgdXNpbmcgTWF0aE1MIHRvIGltcHJvdmUgYWNjZXNzaWJpbGl0eSwgd2UgZG9uJ3QgbWFuYWdlXG4gKiBhbnkgb2YgdGhlIHN0eWxpbmcgc3RhdGUgdGhhdCB0aGUgcGxhaW4gRE9NIG5vZGVzIGRvLlxuICpcbiAqIFRoZSBgdG9Ob2RlYCBhbmQgYHRvTWFya3VwYCBmdW5jdGlvbnMgd29yayBzaW1pbGFybHkgdG8gaG93IHRoZXkgZG8gaW5cbiAqIGRvbVRyZWUuanMsIGNyZWF0aW5nIG5hbWVzcGFjZWQgRE9NIG5vZGVzIGFuZCBIVE1MIHRleHQgbWFya3VwIHJlc3BlY3RpdmVseS5cbiAqL1xuXG5cblxuXG5mdW5jdGlvbiBuZXdEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKSB7XG4gIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7XG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZ2VuZXJhbCBwdXJwb3NlIE1hdGhNTCBub2RlIG9mIGFueSB0eXBlLiBUaGVcbiAqIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSB0eXBlIG9mIG5vZGUgdG8gY3JlYXRlIChmb3IgZXhhbXBsZSwgYFwibW9cImAgb3JcbiAqIGBcIm1zcGFjZVwiYCwgY29ycmVzcG9uZGluZyB0byBgPG1vPmAgYW5kIGA8bXNwYWNlPmAgdGFncykuXG4gKi9cblxuY2xhc3MgTWF0aE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjaGlsZHJlbiwgY2xhc3Nlcykge1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS4gTWF0aE1MIGRlcGVuZHMgb24gYXR0cmlidXRlcyB0byBjb252ZXkgYVxuICAgKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAgICovXG5cblxuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS5cbiAgICovXG5cblxuICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIE1hdGhNTC1uYW1lc3BhY2VkIERPTSBlbGVtZW50LlxuICAgKi9cblxuXG4gIHRvTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBDb21iaW5lIG11bHRpcGxlIFRleHROb2RlcyBpbnRvIG9uZSBUZXh0Tm9kZSwgdG8gcHJldmVudFxuICAgICAgLy8gc2NyZWVuIHJlYWRlcnMgZnJvbSByZWFkaW5nIGVhY2ggYXMgYSBzZXBhcmF0ZSB3b3JkIFsjMzk5NV1cbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gaW5zdGFuY2VvZiBUZXh0Tm9kZSkge1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuY2hpbGRyZW5baV0udG9UZXh0KCkgKyB0aGlzLmNoaWxkcmVuWysraV0udG9UZXh0KCk7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGRyZW5baSArIDFdIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgICB0ZXh0ICs9IHRoaXMuY2hpbGRyZW5bKytpXS50b1RleHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3IFRleHROb2RlKHRleHQpLnRvTm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgbGV0IG1hcmt1cCA9IFwiPFwiICsgdGhpcy50eXBlOyAvLyBBZGQgdGhlIGF0dHJpYnV0ZXNcblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiO1xuICAgICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hcmt1cCArPSBcIiBjbGFzcyA9XFxcIlwiICsgdXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpICsgXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvXCIgKyB0aGlzLnR5cGUgKyBcIj5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LCBidXQgZXNjYXBlZC5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnRvVGV4dCgpKS5qb2luKFwiXCIpO1xuICB9XG5cbn1cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBwaWVjZSBvZiB0ZXh0LlxuICovXG5cbmNsYXNzIFRleHROb2RlIHtcbiAgY29uc3RydWN0b3IodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gYSBET00gdGV4dCBub2RlLlxuICAgKi9cblxuXG4gIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGVzY2FwZWQgSFRNTCBtYXJrdXBcbiAgICogKHJlcHJlc2VudGluZyB0aGUgdGV4dCBpdHNlbGYpLlxuICAgKi9cblxuXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB1dGlscy5lc2NhcGUodGhpcy50b1RleHQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBhIHN0cmluZ1xuICAgKiAocmVwcmVzZW50aW5nIHRoZSB0ZXh0IGl0c2VsZikuXG4gICAqL1xuXG5cbiAgdG9UZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cblxufVxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYWNlLCBidXQgbWF5IHJlbmRlciBhcyA8bXNwYWNlLi4uLz4gb3IgYXMgdGV4dCxcbiAqIGRlcGVuZGluZyBvbiB0aGUgd2lkdGguXG4gKi9cblxuY2xhc3MgU3BhY2VOb2RlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIFNwYWNlIG5vZGUgd2l0aCB3aWR0aCBnaXZlbiBpbiBDU1MgZW1zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhcmFjdGVyID0gdm9pZCAwO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDsgLy8gU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAwL1dELU1hdGhNTDItMjAwMDAzMjgvY2hhcHRlcjYuaHRtbFxuICAgIC8vIGZvciBhIHRhYmxlIG9mIHNwYWNlLWxpa2UgY2hhcmFjdGVycy4gIFdlIHVzZSBVbmljb2RlXG4gICAgLy8gcmVwcmVzZW50YXRpb25zIGluc3RlYWQgb2YgJkxvbmdOYW1lczsgYXMgaXQncyBub3QgY2xlYXIgaG93IHRvXG4gICAgLy8gbWFrZSB0aGUgbGF0dGVyIHZpYSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZS5cblxuICAgIGlmICh3aWR0aCA+PSAwLjA1NTU1ICYmIHdpZHRoIDw9IDAuMDU1NTYpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDBhXCI7IC8vICZWZXJ5VGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4xNjY2ICYmIHdpZHRoIDw9IDAuMTY2Nykge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDlcIjsgLy8gJlRoaW5TcGFjZTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMjIyMiAmJiB3aWR0aCA8PSAwLjIyMjMpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDA1XCI7IC8vICZNZWRpdW1TcGFjZTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMjc3NyAmJiB3aWR0aCA8PSAwLjI3NzgpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDA1XFx1MjAwYVwiOyAvLyAmVGhpY2tTcGFjZTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID49IC0wLjA1NTU2ICYmIHdpZHRoIDw9IC0wLjA1NTU1KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwYVxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlVmVyeVRoaW5TcGFjZTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID49IC0wLjE2NjcgJiYgd2lkdGggPD0gLTAuMTY2Nikge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDlcXHUyMDYzXCI7IC8vICZOZWdhdGl2ZVRoaW5TcGFjZTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID49IC0wLjIyMjMgJiYgd2lkdGggPD0gLTAuMjIyMikge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwNWZcXHUyMDYzXCI7IC8vICZOZWdhdGl2ZU1lZGl1bVNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMjc3OCAmJiB3aWR0aCA8PSAtMC4yNzc3KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwNVxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlVGhpY2tTcGFjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgTWF0aE1MLW5hbWVzcGFjZWQgRE9NIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIGlmICh0aGlzLmNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY2hhcmFjdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJtc3BhY2VcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIG1ha2VFbSh0aGlzLndpZHRoKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gXCI8bXRleHQ+XCIgKyB0aGlzLmNoYXJhY3RlciArIFwiPC9tdGV4dD5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiPG1zcGFjZSB3aWR0aD1cXFwiXCIgKyBtYWtlRW0odGhpcy53aWR0aCkgKyBcIlxcXCIvPlwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dC5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIiBcIjtcbiAgICB9XG4gIH1cblxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtYXRoTUxUcmVlID0gKHtcbiAgTWF0aE5vZGUsXG4gIFRleHROb2RlLFxuICBTcGFjZU5vZGUsXG4gIG5ld0RvY3VtZW50RnJhZ21lbnRcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2J1aWxkTWF0aE1MLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBjb252ZXJ0cyBhIHBhcnNlIHRyZWUgaW50byBhIGNvcnJlc3BvbmRpbmcgTWF0aE1MIHRyZWUuIFRoZSBtYWluXG4gKiBlbnRyeSBwb2ludCBpcyB0aGUgYGJ1aWxkTWF0aE1MYCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwYXJzZSB0cmVlIGZyb20gdGhlXG4gKiBwYXJzZXIuXG4gKi9cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogVGFrZXMgYSBzeW1ib2wgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBNYXRoTUwgdGV4dCBub2RlIGFmdGVyIHBlcmZvcm1pbmdcbiAqIG9wdGlvbmFsIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcy5cbiAqL1xuY29uc3QgbWFrZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgbW9kZSwgb3B0aW9ucykge1xuICBpZiAoc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZSAmJiB0ZXh0LmNoYXJDb2RlQXQoMCkgIT09IDB4RDgzNSAmJiAhKGxpZ2F0dXJlcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0KSAmJiBvcHRpb25zICYmIChvcHRpb25zLmZvbnRGYW1pbHkgJiYgb3B0aW9ucy5mb250RmFtaWx5LnNsaWNlKDQsIDYpID09PSBcInR0XCIgfHwgb3B0aW9ucy5mb250ICYmIG9wdGlvbnMuZm9udC5zbGljZSg0LCA2KSA9PT0gXCJ0dFwiKSkpIHtcbiAgICB0ZXh0ID0gc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh0ZXh0KTtcbn07XG4vKipcbiAqIFdyYXAgdGhlIGdpdmVuIGFycmF5IG9mIG5vZGVzIGluIGFuIDxtcm93PiBub2RlIGlmIG5lZWRlZCwgaS5lLixcbiAqIHVubGVzcyB0aGUgYXJyYXkgaGFzIGxlbmd0aCAxLiAgQWx3YXlzIHJldHVybnMgYSBzaW5nbGUgbm9kZS5cbiAqL1xuXG5jb25zdCBtYWtlUm93ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgaWYgKGJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGJvZHlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBib2R5KTtcbiAgfVxufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbWF0aCB2YXJpYW50IGFzIGEgc3RyaW5nIG9yIG51bGwgaWYgbm9uZSBpcyByZXF1aXJlZC5cbiAqL1xuXG5jb25zdCBnZXRWYXJpYW50ID0gZnVuY3Rpb24gKGdyb3VwLCBvcHRpb25zKSB7XG4gIC8vIEhhbmRsZSBcXHRleHQuLi4gZm9udCBzcGVjaWZpZXJzIGFzIGJlc3Qgd2UgY2FuLlxuICAvLyBNYXRoTUwgaGFzIGEgbGltaXRlZCBsaXN0IG9mIGFsbG93YWJsZSBtYXRodmFyaWFudCBzcGVjaWZpZXJzOyBzZWVcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL01hdGhNTDMvY2hhcHRlcjMuaHRtbCNwcmVzbS5jb21tYXR0XG4gIGlmIChvcHRpb25zLmZvbnRGYW1pbHkgPT09IFwidGV4dHR0XCIpIHtcbiAgICByZXR1cm4gXCJtb25vc3BhY2VcIjtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRGYW1pbHkgPT09IFwidGV4dHNmXCIpIHtcbiAgICBpZiAob3B0aW9ucy5mb250U2hhcGUgPT09IFwidGV4dGl0XCIgJiYgb3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIikge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZi1pdGFsaWNcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgICAgcmV0dXJuIFwiYm9sZC1zYW5zLXNlcmlmXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWZcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5mb250U2hhcGUgPT09IFwidGV4dGl0XCIgJiYgb3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZC1pdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIikge1xuICAgIHJldHVybiBcIml0YWxpY1wiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgIHJldHVybiBcImJvbGRcIjtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSBvcHRpb25zLmZvbnQ7XG5cbiAgaWYgKCFmb250IHx8IGZvbnQgPT09IFwibWF0aG5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBtb2RlID0gZ3JvdXAubW9kZTtcblxuICBpZiAoZm9udCA9PT0gXCJtYXRoaXRcIikge1xuICAgIHJldHVybiBcIml0YWxpY1wiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwiYm9sZHN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIGdyb3VwLnR5cGUgPT09IFwidGV4dG9yZFwiID8gXCJib2xkXCIgOiBcImJvbGQtaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoYmZcIikge1xuICAgIHJldHVybiBcImJvbGRcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhiYlwiKSB7XG4gICAgcmV0dXJuIFwiZG91YmxlLXN0cnVja1wiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aHNmaXRcIikge1xuICAgIHJldHVybiBcInNhbnMtc2VyaWYtaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoZnJha1wiKSB7XG4gICAgcmV0dXJuIFwiZnJha3R1clwiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aHNjclwiIHx8IGZvbnQgPT09IFwibWF0aGNhbFwiKSB7XG4gICAgLy8gTWF0aE1MIG1ha2VzIG5vIGRpc3RpbmN0aW9uIGJldHdlZW4gc2NyaXB0IGFuZCBjYWxsaWdyYXBoaWNcbiAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhzZlwiKSB7XG4gICAgcmV0dXJuIFwic2Fucy1zZXJpZlwiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aHR0XCIpIHtcbiAgICByZXR1cm4gXCJtb25vc3BhY2VcIjtcbiAgfVxuXG4gIGxldCB0ZXh0ID0gZ3JvdXAudGV4dDtcblxuICBpZiAodXRpbHMuY29udGFpbnMoW1wiXFxcXGltYXRoXCIsIFwiXFxcXGptYXRoXCJdLCB0ZXh0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHNyY19zeW1ib2xzW21vZGVdW3RleHRdICYmIHNyY19zeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2UpIHtcbiAgICB0ZXh0ID0gc3JjX3N5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIGNvbnN0IGZvbnROYW1lID0gYnVpbGRDb21tb24uZm9udE1hcFtmb250XS5mb250TmFtZTtcblxuICBpZiAoZ2V0Q2hhcmFjdGVyTWV0cmljcyh0ZXh0LCBmb250TmFtZSwgbW9kZSkpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24uZm9udE1hcFtmb250XS52YXJpYW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBDaGVjayBmb3IgPG1pPi48L21pPiB3aGljaCBpcyBob3cgYSBkb3QgcmVuZGVycyBpbiBNYXRoTUwsXG4gKiBvciA8bW8gc2VwYXJhdG9yPVwidHJ1ZVwiIGxzcGFjZT1cIjBlbVwiIHJzcGFjZT1cIjBlbVwiPiw8L21vPlxuICogd2hpY2ggaXMgaG93IGEgYnJhY2VkIGNvbW1hIHssfSByZW5kZXJzIGluIE1hdGhNTFxuICovXG5cbmZ1bmN0aW9uIGlzTnVtYmVyUHVuY3R1YXRpb24oZ3JvdXApIHtcbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChncm91cC50eXBlID09PSAnbWknICYmIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gJy4nO1xuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09ICdtbycgJiYgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGdyb3VwLmdldEF0dHJpYnV0ZSgnc2VwYXJhdG9yJykgPT09ICd0cnVlJyAmJiBncm91cC5nZXRBdHRyaWJ1dGUoJ2xzcGFjZScpID09PSAnMGVtJyAmJiBncm91cC5nZXRBdHRyaWJ1dGUoJ3JzcGFjZScpID09PSAnMGVtJykge1xuICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gJywnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2Ygbm9kZXMsIGJ1aWxkcyB0aGVtLCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgdGhlIGdlbmVyYXRlZFxuICogTWF0aE1MIG5vZGVzLiAgQWxzbyBjb21iaW5lIGNvbnNlY3V0aXZlIDxtdGV4dD4gb3V0cHV0cyBpbnRvIGEgc2luZ2xlXG4gKiA8bXRleHQ+IHRhZy5cbiAqL1xuXG5cbmNvbnN0IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBvcHRpb25zLCBpc09yZGdyb3VwKSB7XG4gIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGdyb3VwID0gYnVpbGRNYXRoTUxfYnVpbGRHcm91cChleHByZXNzaW9uWzBdLCBvcHRpb25zKTtcblxuICAgIGlmIChpc09yZGdyb3VwICYmIGdyb3VwIGluc3RhbmNlb2YgTWF0aE5vZGUgJiYgZ3JvdXAudHlwZSA9PT0gXCJtb1wiKSB7XG4gICAgICAvLyBXaGVuIFRlWCB3cml0ZXJzIHdhbnQgdG8gc3VwcHJlc3Mgc3BhY2luZyBvbiBhbiBvcGVyYXRvcixcbiAgICAgIC8vIHRoZXkgb2Z0ZW4gcHV0IHRoZSBvcGVyYXRvciBieSBpdHNlbGYgaW5zaWRlIGJyYWNlcy5cbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjBlbVwiKTtcbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjBlbVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2dyb3VwXTtcbiAgfVxuXG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgbGFzdEdyb3VwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGdyb3VwID0gYnVpbGRNYXRoTUxfYnVpbGRHcm91cChleHByZXNzaW9uW2ldLCBvcHRpb25zKTtcblxuICAgIGlmIChncm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGxhc3RHcm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlKSB7XG4gICAgICAvLyBDb25jYXRlbmF0ZSBhZGphY2VudCA8bXRleHQ+c1xuICAgICAgaWYgKGdyb3VwLnR5cGUgPT09ICdtdGV4dCcgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtdGV4dCcgJiYgZ3JvdXAuZ2V0QXR0cmlidXRlKCdtYXRodmFyaWFudCcpID09PSBsYXN0R3JvdXAuZ2V0QXR0cmlidXRlKCdtYXRodmFyaWFudCcpKSB7XG4gICAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLmdyb3VwLmNoaWxkcmVuKTtcbiAgICAgICAgY29udGludWU7IC8vIENvbmNhdGVuYXRlIGFkamFjZW50IDxtbj5zXG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09ICdtbicgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uZ3JvdXAuY2hpbGRyZW4pO1xuICAgICAgICBjb250aW51ZTsgLy8gQ29uY2F0ZW5hdGUgPG1uPi4uLjwvbW4+IGZvbGxvd2VkIGJ5IDxtaT4uPC9taT5cbiAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXJQdW5jdHVhdGlvbihncm91cCkgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uZ3JvdXAuY2hpbGRyZW4pO1xuICAgICAgICBjb250aW51ZTsgLy8gQ29uY2F0ZW5hdGUgPG1pPi48L21pPiBmb2xsb3dlZCBieSA8bW4+Li4uPC9tbj5cbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gJ21uJyAmJiBpc051bWJlclB1bmN0dWF0aW9uKGxhc3RHcm91cCkpIHtcbiAgICAgICAgZ3JvdXAuY2hpbGRyZW4gPSBbLi4ubGFzdEdyb3VwLmNoaWxkcmVuLCAuLi5ncm91cC5jaGlsZHJlbl07XG4gICAgICAgIGdyb3Vwcy5wb3AoKTsgLy8gUHV0IHByZWNlZGluZyA8bW4+Li4uPC9tbj4gb3IgPG1pPi48L21pPiBpbnNpZGUgYmFzZSBvZlxuICAgICAgICAvLyA8bXN1cD48bW4+Li4uYmFzZS4uLjwvbW4+Li4uZXhwb25lbnQuLi48L21zdXA+IChvciA8bXN1Yj4pXG4gICAgICB9IGVsc2UgaWYgKChncm91cC50eXBlID09PSAnbXN1cCcgfHwgZ3JvdXAudHlwZSA9PT0gJ21zdWInKSAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPj0gMSAmJiAobGFzdEdyb3VwLnR5cGUgPT09ICdtbicgfHwgaXNOdW1iZXJQdW5jdHVhdGlvbihsYXN0R3JvdXApKSkge1xuICAgICAgICBjb25zdCBiYXNlID0gZ3JvdXAuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBiYXNlLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgICBiYXNlLmNoaWxkcmVuID0gWy4uLmxhc3RHcm91cC5jaGlsZHJlbiwgLi4uYmFzZS5jaGlsZHJlbl07XG4gICAgICAgICAgZ3JvdXBzLnBvcCgpO1xuICAgICAgICB9IC8vIFxcbm90XG5cbiAgICAgIH0gZWxzZSBpZiAobGFzdEdyb3VwLnR5cGUgPT09ICdtaScgJiYgbGFzdEdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBsYXN0Q2hpbGQgPSBsYXN0R3JvdXAuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKGxhc3RDaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlICYmIGxhc3RDaGlsZC50ZXh0ID09PSAnXFx1MDMzOCcgJiYgKGdyb3VwLnR5cGUgPT09ICdtbycgfHwgZ3JvdXAudHlwZSA9PT0gJ21pJyB8fCBncm91cC50eXBlID09PSAnbW4nKSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBjaGlsZC50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIE92ZXJsYXkgd2l0aCBjb21iaW5pbmcgY2hhcmFjdGVyIGxvbmcgc29saWR1c1xuICAgICAgICAgICAgY2hpbGQudGV4dCA9IGNoaWxkLnRleHQuc2xpY2UoMCwgMSkgKyBcIlxcdTAzMzhcIiArIGNoaWxkLnRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgICBncm91cHMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgIGxhc3RHcm91cCA9IGdyb3VwO1xuICB9XG5cbiAgcmV0dXJuIGdyb3Vwcztcbn07XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gYnVpbGRFeHByZXNzaW9uLCBidXQgd3JhcHMgdGhlIGVsZW1lbnRzIGluIGFuIDxtcm93PlxuICogaWYgdGhlcmUncyBtb3JlIHRoYW4gb25lLiAgUmV0dXJucyBhIHNpbmdsZSBub2RlIGluc3RlYWQgb2YgYW4gYXJyYXkuXG4gKi9cblxuY29uc3QgYnVpbGRFeHByZXNzaW9uUm93ID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzT3JkZ3JvdXApIHtcbiAgcmV0dXJuIG1ha2VSb3coYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzT3JkZ3JvdXApKTtcbn07XG4vKipcbiAqIFRha2VzIGEgZ3JvdXAgZnJvbSB0aGUgcGFyc2VyIGFuZCBjYWxscyB0aGUgYXBwcm9wcmlhdGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICogb24gaXQgdG8gcHJvZHVjZSBhIE1hdGhNTCBub2RlLlxuICovXG5cbmNvbnN0IGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIik7XG4gIH1cblxuICBpZiAoX21hdGhtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0pIHtcbiAgICAvLyBDYWxsIHRoZSBncm91cEJ1aWxkZXJzIGZ1bmN0aW9uXG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIGNvbnN0IHJlc3VsdCA9IF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICB9XG59O1xuLyoqXG4gKiBUYWtlcyBhIGZ1bGwgcGFyc2UgdHJlZSBhbmQgc2V0dGluZ3MgYW5kIGJ1aWxkcyBhIE1hdGhNTCByZXByZXNlbnRhdGlvbiBvZlxuICogaXQuIEluIHBhcnRpY3VsYXIsIHdlIHB1dCB0aGUgZWxlbWVudHMgZnJvbSBidWlsZGluZyB0aGUgcGFyc2UgdHJlZSBpbnRvIGFcbiAqIDxzZW1hbnRpY3M+IHRhZyBzbyB3ZSBjYW4gYWxzbyBpbmNsdWRlIHRoYXQgVGVYIHNvdXJjZSBhcyBhbiBhbm5vdGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCB3ZSBhY3R1YWxseSByZXR1cm4gYSBkb21UcmVlIGVsZW1lbnQgd2l0aCBhIGA8bWF0aD5gIGluc2lkZSBpdCBzb1xuICogd2UgY2FuIGRvIGFwcHJvcHJpYXRlIHN0eWxpbmcuXG4gKi9cblxuZnVuY3Rpb24gYnVpbGRNYXRoTUwodHJlZSwgdGV4RXhwcmVzc2lvbiwgb3B0aW9ucywgaXNEaXNwbGF5TW9kZSwgZm9yTWF0aG1sT25seSkge1xuICBjb25zdCBleHByZXNzaW9uID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMpOyAvLyBUT0RPOiBNYWtlIGEgcGFzcyB0aHJ1IHRoZSBNYXRoTUwgc2ltaWxhciB0byBidWlsZEhUTUwudHJhdmVyc2VOb25TcGFjZU5vZGVzXG4gIC8vIGFuZCBhZGQgc3BhY2luZyBub2Rlcy4gVGhpcyBpcyBuZWNlc3Nhcnkgb25seSBhZGphY2VudCB0byBtYXRoIG9wZXJhdG9yc1xuICAvLyBsaWtlIFxcc2luIG9yIFxcbGltIG9yIHRvIHN1YnN1cCBlbGVtZW50cyB0aGF0IGNvbnRhaW4gbWF0aCBvcGVyYXRvcnMuXG4gIC8vIE1hdGhNTCB0YWtlcyBjYXJlIG9mIHRoZSBvdGhlciBzcGFjaW5nIGlzc3Vlcy5cbiAgLy8gV3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBpbiBhbiBtcm93IHNvIGl0IGlzIHByZXNlbnRlZCBpbiB0aGUgc2VtYW50aWNzXG4gIC8vIHRhZyBjb3JyZWN0bHksIHVubGVzcyBpdCdzIGEgc2luZ2xlIDxtcm93PiBvciA8bXRhYmxlPi5cblxuICBsZXQgd3JhcHBlcjtcblxuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEgJiYgZXhwcmVzc2lvblswXSBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIHV0aWxzLmNvbnRhaW5zKFtcIm1yb3dcIiwgXCJtdGFibGVcIl0sIGV4cHJlc3Npb25bMF0udHlwZSkpIHtcbiAgICB3cmFwcGVyID0gZXhwcmVzc2lvblswXTtcbiAgfSBlbHNlIHtcbiAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGV4cHJlc3Npb24pO1xuICB9IC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuXG5cbiAgY29uc3QgYW5ub3RhdGlvbiA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcbiAgYW5ub3RhdGlvbi5zZXRBdHRyaWJ1dGUoXCJlbmNvZGluZ1wiLCBcImFwcGxpY2F0aW9uL3gtdGV4XCIpO1xuICBjb25zdCBzZW1hbnRpY3MgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcInNlbWFudGljc1wiLCBbd3JhcHBlciwgYW5ub3RhdGlvbl0pO1xuICBjb25zdCBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFtzZW1hbnRpY3NdKTtcbiAgbWF0aC5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIik7XG5cbiAgaWYgKGlzRGlzcGxheU1vZGUpIHtcbiAgICBtYXRoLnNldEF0dHJpYnV0ZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgfSAvLyBZb3UgY2FuJ3Qgc3R5bGUgPG1hdGg+IG5vZGVzLCBzbyB3ZSB3cmFwIHRoZSBub2RlIGluIGEgc3Bhbi5cbiAgLy8gTk9URTogVGhlIHNwYW4gY2xhc3MgaXMgbm90IHR5cGVkIHRvIGhhdmUgPG1hdGg+IG5vZGVzIGFzIGNoaWxkcmVuLCBhbmRcbiAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZSBjaGlsZHJlbiB0eXBlIG1vcmUgZ2VuZXJpYyBzaW5jZSB0aGUgY2hpbGRyZW5cbiAgLy8gb2Ygc3BhbiBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSBtb3JlIGZpZWxkcyBpbiBgYnVpbGRIdG1sYCBjb250ZXh0cy5cblxuXG4gIGNvbnN0IHdyYXBwZXJDbGFzcyA9IGZvck1hdGhtbE9ubHkgPyBcImthdGV4XCIgOiBcImthdGV4LW1hdGhtbFwiOyAvLyAkRmxvd0ZpeE1lXG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFt3cmFwcGVyQ2xhc3NdLCBbbWF0aF0pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2J1aWxkVHJlZS5qc1xuXG5cblxuXG5cblxuXG5jb25zdCBvcHRpb25zRnJvbVNldHRpbmdzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gIHJldHVybiBuZXcgc3JjX09wdGlvbnMoe1xuICAgIHN0eWxlOiBzZXR0aW5ncy5kaXNwbGF5TW9kZSA/IHNyY19TdHlsZS5ESVNQTEFZIDogc3JjX1N0eWxlLlRFWFQsXG4gICAgbWF4U2l6ZTogc2V0dGluZ3MubWF4U2l6ZSxcbiAgICBtaW5SdWxlVGhpY2tuZXNzOiBzZXR0aW5ncy5taW5SdWxlVGhpY2tuZXNzXG4gIH0pO1xufTtcblxuY29uc3QgZGlzcGxheVdyYXAgPSBmdW5jdGlvbiAobm9kZSwgc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IFtcImthdGV4LWRpc3BsYXlcIl07XG5cbiAgICBpZiAoc2V0dGluZ3MubGVxbm8pIHtcbiAgICAgIGNsYXNzZXMucHVzaChcImxlcW5vXCIpO1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5mbGVxbikge1xuICAgICAgY2xhc3Nlcy5wdXNoKFwiZmxlcW5cIik7XG4gICAgfVxuXG4gICAgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKGNsYXNzZXMsIFtub2RlXSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IGJ1aWxkVHJlZSA9IGZ1bmN0aW9uICh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncykge1xuICBjb25zdCBvcHRpb25zID0gb3B0aW9uc0Zyb21TZXR0aW5ncyhzZXR0aW5ncyk7XG4gIGxldCBrYXRleE5vZGU7XG5cbiAgaWYgKHNldHRpbmdzLm91dHB1dCA9PT0gXCJtYXRobWxcIikge1xuICAgIHJldHVybiBidWlsZE1hdGhNTCh0cmVlLCBleHByZXNzaW9uLCBvcHRpb25zLCBzZXR0aW5ncy5kaXNwbGF5TW9kZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGluZ3Mub3V0cHV0ID09PSBcImh0bWxcIikge1xuICAgIGNvbnN0IGh0bWxOb2RlID0gYnVpbGRIVE1MKHRyZWUsIG9wdGlvbnMpO1xuICAgIGthdGV4Tm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImthdGV4XCJdLCBbaHRtbE5vZGVdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucywgc2V0dGluZ3MuZGlzcGxheU1vZGUsIGZhbHNlKTtcbiAgICBjb25zdCBodG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcbiAgICBrYXRleE5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleFwiXSwgW21hdGhNTE5vZGUsIGh0bWxOb2RlXSk7XG4gIH1cblxuICByZXR1cm4gZGlzcGxheVdyYXAoa2F0ZXhOb2RlLCBzZXR0aW5ncyk7XG59O1xuY29uc3QgYnVpbGRIVE1MVHJlZSA9IGZ1bmN0aW9uICh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncykge1xuICBjb25zdCBvcHRpb25zID0gb3B0aW9uc0Zyb21TZXR0aW5ncyhzZXR0aW5ncyk7XG4gIGNvbnN0IGh0bWxOb2RlID0gYnVpbGRIVE1MKHRyZWUsIG9wdGlvbnMpO1xuICBjb25zdCBrYXRleE5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleFwiXSwgW2h0bWxOb2RlXSk7XG4gIHJldHVybiBkaXNwbGF5V3JhcChrYXRleE5vZGUsIHNldHRpbmdzKTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfYnVpbGRUcmVlID0gKCgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKGJ1aWxkVHJlZSkpKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHJldGNoeS5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgc3VwcG9ydCB0byBidWlsZE1hdGhNTC5qcyBhbmQgYnVpbGRIVE1MLmpzXG4gKiBmb3Igc3RyZXRjaHkgd2lkZSBlbGVtZW50cyByZW5kZXJlZCBmcm9tIFNWRyBmaWxlc1xuICogYW5kIG90aGVyIENTUyB0cmlja2VyeS5cbiAqL1xuXG5cblxuXG5cbmNvbnN0IHN0cmV0Y2h5Q29kZVBvaW50ID0ge1xuICB3aWRlaGF0OiBcIl5cIixcbiAgd2lkZWNoZWNrOiBcIsuHXCIsXG4gIHdpZGV0aWxkZTogXCJ+XCIsXG4gIHV0aWxkZTogXCJ+XCIsXG4gIG92ZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB1bmRlcmxlZnRhcnJvdzogXCJcXHUyMTkwXCIsXG4gIHhsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICBvdmVycmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVycmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHhyaWdodGFycm93OiBcIlxcdTIxOTJcIixcbiAgdW5kZXJicmFjZTogXCJcXHUyM2RmXCIsXG4gIG92ZXJicmFjZTogXCJcXHUyM2RlXCIsXG4gIG92ZXJncm91cDogXCJcXHUyM2UwXCIsXG4gIHVuZGVyZ3JvdXA6IFwiXFx1MjNlMVwiLFxuICBvdmVybGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjE5NFwiLFxuICB1bmRlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgeGxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgT3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjFkMlwiLFxuICB4UmlnaHRhcnJvdzogXCJcXHUyMWQyXCIsXG4gIG92ZXJsZWZ0aGFycG9vbjogXCJcXHUyMWJjXCIsXG4gIHhsZWZ0aGFycG9vbnVwOiBcIlxcdTIxYmNcIixcbiAgb3ZlcnJpZ2h0aGFycG9vbjogXCJcXHUyMWMwXCIsXG4gIHhyaWdodGhhcnBvb251cDogXCJcXHUyMWMwXCIsXG4gIHhMZWZ0YXJyb3c6IFwiXFx1MjFkMFwiLFxuICB4TGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjFkNFwiLFxuICB4aG9va2xlZnRhcnJvdzogXCJcXHUyMWE5XCIsXG4gIHhob29rcmlnaHRhcnJvdzogXCJcXHUyMWFhXCIsXG4gIHhtYXBzdG86IFwiXFx1MjFhNlwiLFxuICB4cmlnaHRoYXJwb29uZG93bjogXCJcXHUyMWMxXCIsXG4gIHhsZWZ0aGFycG9vbmRvd246IFwiXFx1MjFiZFwiLFxuICB4cmlnaHRsZWZ0aGFycG9vbnM6IFwiXFx1MjFjY1wiLFxuICB4bGVmdHJpZ2h0aGFycG9vbnM6IFwiXFx1MjFjYlwiLFxuICB4dHdvaGVhZGxlZnRhcnJvdzogXCJcXHUyMTllXCIsXG4gIHh0d29oZWFkcmlnaHRhcnJvdzogXCJcXHUyMWEwXCIsXG4gIHhsb25nZXF1YWw6IFwiPVwiLFxuICB4dG9mcm9tOiBcIlxcdTIxYzRcIixcbiAgeHJpZ2h0bGVmdGFycm93czogXCJcXHUyMWM0XCIsXG4gIHhyaWdodGVxdWlsaWJyaXVtOiBcIlxcdTIxY2NcIixcbiAgLy8gTm90IGEgcGVyZmVjdCBtYXRjaC5cbiAgeGxlZnRlcXVpbGlicml1bTogXCJcXHUyMWNiXCIsXG4gIC8vIE5vbmUgYmV0dGVyIGF2YWlsYWJsZS5cbiAgXCJcXFxcY2RyaWdodGFycm93XCI6IFwiXFx1MjE5MlwiLFxuICBcIlxcXFxjZGxlZnRhcnJvd1wiOiBcIlxcdTIxOTBcIixcbiAgXCJcXFxcY2Rsb25nZXF1YWxcIjogXCI9XCJcbn07XG5cbmNvbnN0IG1hdGhNTG5vZGUgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHN0cmV0Y2h5Q29kZVBvaW50W2xhYmVsLnJlcGxhY2UoL15cXFxcLywgJycpXSldKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gIHJldHVybiBub2RlO1xufTsgLy8gTWFueSBvZiB0aGUgS2FUZVggU1ZHIGltYWdlcyBoYXZlIGJlZW4gYWRhcHRlZCBmcm9tIGdseXBocyBpbiBLYVRlWCBmb250cy5cbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBEZXNpZ24gU2NpZW5jZSwgSW5jLiAoPHd3dy5tYXRoamF4Lm9yZz4pXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNyBLaGFuIEFjYWRlbXkgKDx3d3cua2hhbmFjYWRlbXkub3JnPilcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBTSUwgT3BlbiBGb250IExpY2Vuc2UsIFZlcnNpb24gMS4xLlxuLy8gU2VlIFxcbmh0dHA6Ly9zY3JpcHRzLnNpbC5vcmcvT0ZMXG4vLyBWZXJ5IExvbmcgU1ZHc1xuLy8gICAgTWFueSBvZiB0aGUgS2FUZVggc3RyZXRjaHkgd2lkZSBlbGVtZW50cyB1c2UgYSBsb25nIFNWRyBpbWFnZSBhbmQgYW5cbi8vICAgIG92ZXJmbG93OiBoaWRkZW4gdGFjdGljIHRvIGFjaGlldmUgYSBzdHJldGNoeSBpbWFnZSB3aGlsZSBhdm9pZGluZ1xuLy8gICAgZGlzdG9ydGlvbiBvZiBhcnJvd2hlYWRzIG9yIGJyYWNlIGNvcm5lcnMuXG4vLyAgICBUaGUgU1ZHIHR5cGljYWxseSBjb250YWlucyBhIHZlcnkgbG9uZyAoNDAwIGVtKSBhcnJvdy5cbi8vICAgIFRoZSBTVkcgaXMgaW4gYSBjb250YWluZXIgc3BhbiB0aGF0IGhhcyBvdmVyZmxvdzogaGlkZGVuLCBzbyB0aGUgc3BhblxuLy8gICAgYWN0cyBsaWtlIGEgd2luZG93IHRoYXQgZXhwb3NlcyBvbmx5IHBhcnQgb2YgdGhlICBTVkcuXG4vLyAgICBUaGUgU1ZHIGFsd2F5cyBoYXMgYSBsb25nZXIsIHRoaW5uZXIgYXNwZWN0IHJhdGlvIHRoYW4gdGhlIGNvbnRhaW5lciBzcGFuLlxuLy8gICAgQWZ0ZXIgdGhlIFNWRyBmaWxscyAxMDAlIG9mIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciBzcGFuLFxuLy8gICAgdGhlcmUgaXMgYSBsb25nIGFycm93IHNoYWZ0IGxlZnQgb3Zlci4gVGhhdCBsZWZ0LW92ZXIgc2hhZnQgaXMgbm90IHNob3duLlxuLy8gICAgSW5zdGVhZCwgaXQgaXMgc2xpY2VkIG9mZiBiZWNhdXNlIHRoZSBzcGFuJ3MgQ1NTIGhhcyBvdmVyZmxvdzogaGlkZGVuLlxuLy8gICAgVGh1cywgdGhlIHJlYWRlciBzZWVzIGFuIGFycm93IHRoYXQgbWF0Y2hlcyB0aGUgc3ViamVjdCBtYXR0ZXIgd2lkdGhcbi8vICAgIHdpdGhvdXQgZGlzdG9ydGlvbi5cbi8vICAgIFNvbWUgZnVuY3Rpb25zLCBzdWNoIGFzIFxcY2FuY2VsLCBuZWVkIHRvIHZhcnkgdGhlaXIgYXNwZWN0IHJhdGlvLiBUaGVzZVxuLy8gICAgZnVuY3Rpb25zIGRvIG5vdCBnZXQgdGhlIG92ZXJmbG93IFNWRyB0cmVhdG1lbnQuXG4vLyBTZWNvbmQgQnJ1c2ggU3Ryb2tlXG4vLyAgICBMb3cgcmVzb2x1dGlvbiBtb25pdG9ycyBzdHJ1Z2dsZSB0byBkaXNwbGF5IGltYWdlcyBpbiBmaW5lIGRldGFpbC5cbi8vICAgIFNvIGJyb3dzZXJzIGFwcGx5IGFudGktYWxpYXNpbmcuIEEgbG9uZyBzdHJhaWdodCBhcnJvdyBzaGFmdCB0aGVyZWZvcmVcbi8vICAgIHdpbGwgc29tZXRpbWVzIGFwcGVhciBhcyBpZiBpdCBoYXMgYSBibHVycmVkIGVkZ2UuXG4vLyAgICBUbyBtaXRpZ2F0ZSB0aGlzLCB0aGVzZSBTVkcgZmlsZXMgY29udGFpbiBhIHNlY29uZCBcImJydXNoLXN0cm9rZVwiIG9uIHRoZVxuLy8gICAgYXJyb3cgc2hhZnRzLiBUaGF0IGlzLCBhIHNlY29uZCBsb25nIHRoaW4gcmVjdGFuZ3VsYXIgU1ZHIHBhdGggaGFzIGJlZW5cbi8vICAgIHdyaXR0ZW4gZGlyZWN0bHkgb24gdG9wIG9mIGVhY2ggYXJyb3cgc2hhZnQuIFRoaXMgcmVpbmZvcmNlbWVudCBjYXVzZXNcbi8vICAgIHNvbWUgb2YgdGhlIHNjcmVlbiBwaXhlbHMgdG8gZGlzcGxheSBhcyBibGFjayBpbnN0ZWFkIG9mIHRoZSBhbnRpLWFsaWFzZWRcbi8vICAgIGdyYXkgcGl4ZWwgdGhhdCBhICBzaW5nbGUgcGF0aCB3b3VsZCBnZW5lcmF0ZS4gU28gd2UgZ2V0IGFycm93IHNoYWZ0c1xuLy8gICAgd2hvc2UgZWRnZXMgYXBwZWFyIHRvIGJlIHNoYXJwZXIuXG4vLyBJbiB0aGUga2F0ZXhJbWFnZXNEYXRhIG9iamVjdCBqdXN0IGJlbG93LCB0aGUgZGltZW5zaW9ucyBhbGxcbi8vIGNvcnJlc3BvbmQgdG8gcGF0aCBnZW9tZXRyeSBpbnNpZGUgdGhlIHJlbGV2YW50IFNWRy5cbi8vIEZvciBleGFtcGxlLCBcXG92ZXJyaWdodGFycm93IHVzZXMgdGhlIHNhbWUgYXJyb3doZWFkIGFzIGdseXBoIFUrMjE5MlxuLy8gZnJvbSB0aGUgS2FUZVggTWFpbiBmb250LiBUaGUgc2NhbGluZyBmYWN0b3IgaXMgMTAwMC5cbi8vIFRoYXQgaXMsIGluc2lkZSB0aGUgZm9udCwgdGhhdCBhcnJvd2hlYWQgaXMgNTIyIHVuaXRzIHRhbGwsIHdoaWNoXG4vLyBjb3JyZXNwb25kcyB0byAwLjUyMiBlbSBpbnNpZGUgdGhlIGRvY3VtZW50LlxuXG5cbmNvbnN0IGthdGV4SW1hZ2VzRGF0YSA9IHtcbiAgLy8gICBwYXRoKHMpLCBtaW5XaWR0aCwgaGVpZ2h0LCBhbGlnblxuICBvdmVycmlnaHRhcnJvdzogW1tcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIG92ZXJsZWZ0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIHVuZGVycmlnaHRhcnJvdzogW1tcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHVuZGVybGVmdGFycm93OiBbW1wibGVmdGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB4cmlnaHRhcnJvdzogW1tcInJpZ2h0YXJyb3dcIl0sIDEuNDY5LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIFwiXFxcXGNkcmlnaHRhcnJvd1wiOiBbW1wicmlnaHRhcnJvd1wiXSwgMy4wLCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIC8vIENEIG1pbnd3aWR0aDIuNXBjXG4gIHhsZWZ0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIl0sIDEuNDY5LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIFwiXFxcXGNkbGVmdGFycm93XCI6IFtbXCJsZWZ0YXJyb3dcIl0sIDMuMCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICBPdmVycmlnaHRhcnJvdzogW1tcImRvdWJsZXJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1NjAsIFwieE1heFlNaW5cIl0sXG4gIHhSaWdodGFycm93OiBbW1wiZG91YmxlcmlnaHRhcnJvd1wiXSwgMS41MjYsIDU2MCwgXCJ4TWF4WU1pblwiXSxcbiAgeExlZnRhcnJvdzogW1tcImRvdWJsZWxlZnRhcnJvd1wiXSwgMS41MjYsIDU2MCwgXCJ4TWluWU1pblwiXSxcbiAgb3ZlcmxlZnRoYXJwb29uOiBbW1wibGVmdGhhcnBvb25cIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIHhsZWZ0aGFycG9vbnVwOiBbW1wibGVmdGhhcnBvb25cIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIHhsZWZ0aGFycG9vbmRvd246IFtbXCJsZWZ0aGFycG9vbmRvd25cIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIG92ZXJyaWdodGhhcnBvb246IFtbXCJyaWdodGhhcnBvb25cIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHhyaWdodGhhcnBvb251cDogW1tcInJpZ2h0aGFycG9vblwiXSwgMC44ODgsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgeHJpZ2h0aGFycG9vbmRvd246IFtbXCJyaWdodGhhcnBvb25kb3duXCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB4bG9uZ2VxdWFsOiBbW1wibG9uZ2VxdWFsXCJdLCAwLjg4OCwgMzM0LCBcInhNaW5ZTWluXCJdLFxuICBcIlxcXFxjZGxvbmdlcXVhbFwiOiBbW1wibG9uZ2VxdWFsXCJdLCAzLjAsIDMzNCwgXCJ4TWluWU1pblwiXSxcbiAgeHR3b2hlYWRsZWZ0YXJyb3c6IFtbXCJ0d29oZWFkbGVmdGFycm93XCJdLCAwLjg4OCwgMzM0LCBcInhNaW5ZTWluXCJdLFxuICB4dHdvaGVhZHJpZ2h0YXJyb3c6IFtbXCJ0d29oZWFkcmlnaHRhcnJvd1wiXSwgMC44ODgsIDMzNCwgXCJ4TWF4WU1pblwiXSxcbiAgb3ZlcmxlZnRyaWdodGFycm93OiBbW1wibGVmdGFycm93XCIsIFwicmlnaHRhcnJvd1wiXSwgMC44ODgsIDUyMl0sXG4gIG92ZXJicmFjZTogW1tcImxlZnRicmFjZVwiLCBcIm1pZGJyYWNlXCIsIFwicmlnaHRicmFjZVwiXSwgMS42LCA1NDhdLFxuICB1bmRlcmJyYWNlOiBbW1wibGVmdGJyYWNldW5kZXJcIiwgXCJtaWRicmFjZXVuZGVyXCIsIFwicmlnaHRicmFjZXVuZGVyXCJdLCAxLjYsIDU0OF0sXG4gIHVuZGVybGVmdHJpZ2h0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIiwgXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyXSxcbiAgeGxlZnRyaWdodGFycm93OiBbW1wibGVmdGFycm93XCIsIFwicmlnaHRhcnJvd1wiXSwgMS43NSwgNTIyXSxcbiAgeExlZnRyaWdodGFycm93OiBbW1wiZG91YmxlbGVmdGFycm93XCIsIFwiZG91YmxlcmlnaHRhcnJvd1wiXSwgMS43NSwgNTYwXSxcbiAgeHJpZ2h0bGVmdGhhcnBvb25zOiBbW1wibGVmdGhhcnBvb25kb3ducGx1c1wiLCBcInJpZ2h0aGFycG9vbnBsdXNcIl0sIDEuNzUsIDcxNl0sXG4gIHhsZWZ0cmlnaHRoYXJwb29uczogW1tcImxlZnRoYXJwb29ucGx1c1wiLCBcInJpZ2h0aGFycG9vbmRvd25wbHVzXCJdLCAxLjc1LCA3MTZdLFxuICB4aG9va2xlZnRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0aG9va1wiXSwgMS4wOCwgNTIyXSxcbiAgeGhvb2tyaWdodGFycm93OiBbW1wibGVmdGhvb2tcIiwgXCJyaWdodGFycm93XCJdLCAxLjA4LCA1MjJdLFxuICBvdmVybGluZXNlZ21lbnQ6IFtbXCJsZWZ0bGluZXNlZ21lbnRcIiwgXCJyaWdodGxpbmVzZWdtZW50XCJdLCAwLjg4OCwgNTIyXSxcbiAgdW5kZXJsaW5lc2VnbWVudDogW1tcImxlZnRsaW5lc2VnbWVudFwiLCBcInJpZ2h0bGluZXNlZ21lbnRcIl0sIDAuODg4LCA1MjJdLFxuICBvdmVyZ3JvdXA6IFtbXCJsZWZ0Z3JvdXBcIiwgXCJyaWdodGdyb3VwXCJdLCAwLjg4OCwgMzQyXSxcbiAgdW5kZXJncm91cDogW1tcImxlZnRncm91cHVuZGVyXCIsIFwicmlnaHRncm91cHVuZGVyXCJdLCAwLjg4OCwgMzQyXSxcbiAgeG1hcHN0bzogW1tcImxlZnRtYXBzdG9cIiwgXCJyaWdodGFycm93XCJdLCAxLjUsIDUyMl0sXG4gIHh0b2Zyb206IFtbXCJsZWZ0VG9Gcm9tXCIsIFwicmlnaHRUb0Zyb21cIl0sIDEuNzUsIDUyOF0sXG4gIC8vIFRoZSBuZXh0IHRocmVlIGFycm93cyBhcmUgZnJvbSB0aGUgbWhjaGVtIHBhY2thZ2UuXG4gIC8vIEluIG1oY2hlbS5zdHksIG1pbi1sZW5ndGggaXMgMi4wZW0uIEJ1dCB0aGVzZSBhcnJvd3MgbWlnaHQgYXBwZWFyIGluIHRoZVxuICAvLyBkb2N1bWVudCBhcyBcXHhyaWdodGFycm93IG9yIFxceHJpZ2h0bGVmdGhhcnBvb25zLiBUaG9zZSBoYXZlXG4gIC8vIG1pbi1sZW5ndGggPSAxLjc1ZW0sIHNvIHdlIHNldCBtaW4tbGVuZ3RoIG9uIHRoZXNlIG5leHQgdGhyZWUgdG8gbWF0Y2guXG4gIHhyaWdodGxlZnRhcnJvd3M6IFtbXCJiYXJhYm92ZWxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dhYm92ZWJhclwiXSwgMS43NSwgOTAxXSxcbiAgeHJpZ2h0ZXF1aWxpYnJpdW06IFtbXCJiYXJhYm92ZXNob3J0bGVmdGhhcnBvb25cIiwgXCJyaWdodGhhcnBvb25hYm92ZXNob3J0YmFyXCJdLCAxLjc1LCA3MTZdLFxuICB4bGVmdGVxdWlsaWJyaXVtOiBbW1wic2hvcnRiYXJhYm92ZWxlZnRoYXJwb29uXCIsIFwic2hvcnRyaWdodGhhcnBvb25hYm92ZWJhclwiXSwgMS43NSwgNzE2XVxufTtcblxuY29uc3QgZ3JvdXBMZW5ndGggPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmIChhcmcudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgcmV0dXJuIGFyZy5ib2R5Lmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufTtcblxuY29uc3Qgc3ZnU3BhbiA9IGZ1bmN0aW9uIChncm91cCwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGVsZW1lbnQuXG4gIGZ1bmN0aW9uIGJ1aWxkU3ZnU3Bhbl8oKSB7XG4gICAgbGV0IHZpZXdCb3hXaWR0aCA9IDQwMDAwMDsgLy8gZGVmYXVsdFxuXG4gICAgY29uc3QgbGFiZWwgPSBncm91cC5sYWJlbC5zbGljZSgxKTtcblxuICAgIGlmICh1dGlscy5jb250YWlucyhbXCJ3aWRlaGF0XCIsIFwid2lkZWNoZWNrXCIsIFwid2lkZXRpbGRlXCIsIFwidXRpbGRlXCJdLCBsYWJlbCkpIHtcbiAgICAgIC8vIEVhY2ggdHlwZSBpbiB0aGUgYGlmYCBzdGF0ZW1lbnQgY29ycmVzcG9uZHMgdG8gb25lIG9mIHRoZSBQYXJzZU5vZGVcbiAgICAgIC8vIHR5cGVzIGJlbG93LiBUaGlzIG5hcnJvd2luZyBpcyByZXF1aXJlZCB0byBhY2Nlc3MgYGdycC5iYXNlYC5cbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGNvbnN0IGdycCA9IGdyb3VwOyAvLyBUaGVyZSBhcmUgZm91ciBTVkcgaW1hZ2VzIGF2YWlsYWJsZSBmb3IgZWFjaCBmdW5jdGlvbi5cbiAgICAgIC8vIENob29zZSBhIHRhbGxlciBpbWFnZSB3aGVuIHRoZXJlIGFyZSBtb3JlIGNoYXJhY3RlcnMuXG5cbiAgICAgIGNvbnN0IG51bUNoYXJzID0gZ3JvdXBMZW5ndGgoZ3JwLmJhc2UpO1xuICAgICAgbGV0IHZpZXdCb3hIZWlnaHQ7XG4gICAgICBsZXQgcGF0aE5hbWU7XG4gICAgICBsZXQgaGVpZ2h0O1xuXG4gICAgICBpZiAobnVtQ2hhcnMgPiA1KSB7XG4gICAgICAgIGlmIChsYWJlbCA9PT0gXCJ3aWRlaGF0XCIgfHwgbGFiZWwgPT09IFwid2lkZWNoZWNrXCIpIHtcbiAgICAgICAgICB2aWV3Qm94SGVpZ2h0ID0gNDIwO1xuICAgICAgICAgIHZpZXdCb3hXaWR0aCA9IDIzNjQ7XG4gICAgICAgICAgaGVpZ2h0ID0gMC40MjtcbiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgXCI0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld0JveEhlaWdodCA9IDMxMjtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSAyMzQwO1xuICAgICAgICAgIGhlaWdodCA9IDAuMzQ7XG4gICAgICAgICAgcGF0aE5hbWUgPSBcInRpbGRlNFwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbWdJbmRleCA9IFsxLCAxLCAyLCAyLCAzLCAzXVtudW1DaGFyc107XG5cbiAgICAgICAgaWYgKGxhYmVsID09PSBcIndpZGVoYXRcIiB8fCBsYWJlbCA9PT0gXCJ3aWRlY2hlY2tcIikge1xuICAgICAgICAgIHZpZXdCb3hXaWR0aCA9IFswLCAxMDYyLCAyMzY0LCAyMzY0LCAyMzY0XVtpbWdJbmRleF07XG4gICAgICAgICAgdmlld0JveEhlaWdodCA9IFswLCAyMzksIDMwMCwgMzYwLCA0MjBdW2ltZ0luZGV4XTtcbiAgICAgICAgICBoZWlnaHQgPSBbMCwgMC4yNCwgMC4zLCAwLjMsIDAuMzYsIDAuNDJdW2ltZ0luZGV4XTtcbiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgaW1nSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gWzAsIDYwMCwgMTAzMywgMjMzOSwgMjM0MF1baW1nSW5kZXhdO1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSBbMCwgMjYwLCAyODYsIDMwNiwgMzEyXVtpbWdJbmRleF07XG4gICAgICAgICAgaGVpZ2h0ID0gWzAsIDAuMjYsIDAuMjg2LCAwLjMsIDAuMzA2LCAwLjM0XVtpbWdJbmRleF07XG4gICAgICAgICAgcGF0aE5hbWUgPSBcInRpbGRlXCIgKyBpbWdJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXRoID0gbmV3IFBhdGhOb2RlKHBhdGhOYW1lKTtcbiAgICAgIGNvbnN0IHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJoZWlnaHRcIjogbWFrZUVtKGhlaWdodCksXG4gICAgICAgIFwidmlld0JveFwiOiBcIjAgMCBcIiArIHZpZXdCb3hXaWR0aCArIFwiIFwiICsgdmlld0JveEhlaWdodCxcbiAgICAgICAgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCI6IFwibm9uZVwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNwYW46IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpLFxuICAgICAgICBtaW5XaWR0aDogMCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzcGFucyA9IFtdO1xuICAgICAgY29uc3QgZGF0YSA9IGthdGV4SW1hZ2VzRGF0YVtsYWJlbF07XG4gICAgICBjb25zdCBbcGF0aHMsIG1pbldpZHRoLCB2aWV3Qm94SGVpZ2h0XSA9IGRhdGE7XG4gICAgICBjb25zdCBoZWlnaHQgPSB2aWV3Qm94SGVpZ2h0IC8gMTAwMDtcbiAgICAgIGNvbnN0IG51bVN2Z0NoaWxkcmVuID0gcGF0aHMubGVuZ3RoO1xuICAgICAgbGV0IHdpZHRoQ2xhc3NlcztcbiAgICAgIGxldCBhbGlnbnM7XG5cbiAgICAgIGlmIChudW1TdmdDaGlsZHJlbiA9PT0gMSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lOiBBbGwgdGhlc2UgY2FzZXMgbXVzdCBiZSBvZiB0aGUgNC10dXBsZSB0eXBlLlxuICAgICAgICBjb25zdCBhbGlnbjEgPSBkYXRhWzNdO1xuICAgICAgICB3aWR0aENsYXNzZXMgPSBbXCJoaWRlLXRhaWxcIl07XG4gICAgICAgIGFsaWducyA9IFthbGlnbjFdO1xuICAgICAgfSBlbHNlIGlmIChudW1TdmdDaGlsZHJlbiA9PT0gMikge1xuICAgICAgICB3aWR0aENsYXNzZXMgPSBbXCJoYWxmYXJyb3ctbGVmdFwiLCBcImhhbGZhcnJvdy1yaWdodFwiXTtcbiAgICAgICAgYWxpZ25zID0gW1wieE1pbllNaW5cIiwgXCJ4TWF4WU1pblwiXTtcbiAgICAgIH0gZWxzZSBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDMpIHtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiYnJhY2UtbGVmdFwiLCBcImJyYWNlLWNlbnRlclwiLCBcImJyYWNlLXJpZ2h0XCJdO1xuICAgICAgICBhbGlnbnMgPSBbXCJ4TWluWU1pblwiLCBcInhNaWRZTWluXCIsIFwieE1heFlNaW5cIl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JyZWN0IGthdGV4SW1hZ2VzRGF0YSBvciB1cGRhdGUgY29kZSBoZXJlIHRvIHN1cHBvcnRcXG4gICAgICAgICAgICAgICAgICAgIFwiICsgbnVtU3ZnQ2hpbGRyZW4gKyBcIiBjaGlsZHJlbi5cIik7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3ZnQ2hpbGRyZW47IGkrKykge1xuICAgICAgICBjb25zdCBwYXRoID0gbmV3IFBhdGhOb2RlKHBhdGhzW2ldKTtcbiAgICAgICAgY29uc3Qgc3ZnTm9kZSA9IG5ldyBTdmdOb2RlKFtwYXRoXSwge1xuICAgICAgICAgIFwid2lkdGhcIjogXCI0MDBlbVwiLFxuICAgICAgICAgIFwiaGVpZ2h0XCI6IG1ha2VFbShoZWlnaHQpLFxuICAgICAgICAgIFwidmlld0JveFwiOiBcIjAgMCBcIiArIHZpZXdCb3hXaWR0aCArIFwiIFwiICsgdmlld0JveEhlaWdodCxcbiAgICAgICAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogYWxpZ25zW2ldICsgXCIgc2xpY2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFt3aWR0aENsYXNzZXNbaV1dLCBbc3ZnTm9kZV0sIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChudW1TdmdDaGlsZHJlbiA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgbWluV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7XG4gICAgICAgICAgc3BhbnMucHVzaChzcGFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcGFuOiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJzdHJldGNoeVwiXSwgc3BhbnMsIG9wdGlvbnMpLFxuICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBidWlsZFN2Z1NwYW5fKClcblxuXG4gIGNvbnN0IHtcbiAgICBzcGFuLFxuICAgIG1pbldpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gYnVpbGRTdmdTcGFuXygpOyAvLyBOb3RlIHRoYXQgd2UgYXJlIHJldHVybmluZyBzcGFuLmRlcHRoID0gMC5cbiAgLy8gQW55IGFkanVzdG1lbnRzIHJlbGF0aXZlIHRvIHRoZSBiYXNlbGluZSBtdXN0IGJlIGRvbmUgaW4gYnVpbGRIVE1MLlxuXG4gIHNwYW4uaGVpZ2h0ID0gaGVpZ2h0O1xuICBzcGFuLnN0eWxlLmhlaWdodCA9IG1ha2VFbShoZWlnaHQpO1xuXG4gIGlmIChtaW5XaWR0aCA+IDApIHtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gbWFrZUVtKG1pbldpZHRoKTtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufTtcblxuY29uc3QgZW5jbG9zZVNwYW4gPSBmdW5jdGlvbiAoaW5uZXIsIGxhYmVsLCB0b3BQYWQsIGJvdHRvbVBhZCwgb3B0aW9ucykge1xuICAvLyBSZXR1cm4gYW4gaW1hZ2Ugc3BhbiBmb3IgXFxjYW5jZWwsIFxcYmNhbmNlbCwgXFx4Y2FuY2VsLCBcXGZib3gsIG9yIFxcYW5nbFxuICBsZXQgaW1nO1xuICBjb25zdCB0b3RhbEhlaWdodCA9IGlubmVyLmhlaWdodCArIGlubmVyLmRlcHRoICsgdG9wUGFkICsgYm90dG9tUGFkO1xuXG4gIGlmICgvZmJveHxjb2xvcnxhbmdsLy50ZXN0KGxhYmVsKSkge1xuICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInN0cmV0Y2h5XCIsIGxhYmVsXSwgW10sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGxhYmVsID09PSBcImZib3hcIikge1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yICYmIG9wdGlvbnMuZ2V0Q29sb3IoKTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGltZy5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBcXGNhbmNlbCwgXFxiY2FuY2VsLCBvciBcXHhjYW5jZWxcbiAgICAvLyBTaW5jZSBcXGNhbmNlbCdzIFNWRyBpcyBpbmxpbmUgYW5kIGl0IG9taXRzIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSxcbiAgICAvLyBpdHMgc3Ryb2tlLXdpZHRoIHdpbGwgbm90IHZhcnkgd2l0aCBzcGFuIGFyZWEuXG4gICAgY29uc3QgbGluZXMgPSBbXTtcblxuICAgIGlmICgvXltieF1jYW5jZWwkLy50ZXN0KGxhYmVsKSkge1xuICAgICAgbGluZXMucHVzaChuZXcgTGluZU5vZGUoe1xuICAgICAgICBcIngxXCI6IFwiMFwiLFxuICAgICAgICBcInkxXCI6IFwiMFwiLFxuICAgICAgICBcIngyXCI6IFwiMTAwJVwiLFxuICAgICAgICBcInkyXCI6IFwiMTAwJVwiLFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBcIjAuMDQ2ZW1cIlxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGlmICgvXng/Y2FuY2VsJC8udGVzdChsYWJlbCkpIHtcbiAgICAgIGxpbmVzLnB1c2gobmV3IExpbmVOb2RlKHtcbiAgICAgICAgXCJ4MVwiOiBcIjBcIixcbiAgICAgICAgXCJ5MVwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJ4MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJ5MlwiOiBcIjBcIixcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwLjA0NmVtXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdmdOb2RlID0gbmV3IFN2Z05vZGUobGluZXMsIHtcbiAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXG4gICAgICBcImhlaWdodFwiOiBtYWtlRW0odG90YWxIZWlnaHQpXG4gICAgfSk7XG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVN2Z1NwYW4oW10sIFtzdmdOb2RlXSwgb3B0aW9ucyk7XG4gIH1cblxuICBpbWcuaGVpZ2h0ID0gdG90YWxIZWlnaHQ7XG4gIGltZy5zdHlsZS5oZWlnaHQgPSBtYWtlRW0odG90YWxIZWlnaHQpO1xuICByZXR1cm4gaW1nO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3RyZXRjaHkgPSAoe1xuICBlbmNsb3NlU3BhbixcbiAgbWF0aE1Mbm9kZSxcbiAgc3ZnU3BhblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGFyc2VOb2RlLmpzXG5cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIG5vZGUgaXMgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIHJldHVybnMgaXQgd2l0aCBzdHJpY3RlclxuICogdHlwaW5nLiBUaHJvd3MgaWYgdGhlIG5vZGUncyB0eXBlIGRvZXMgbm90IG1hdGNoLlxuICovXG5mdW5jdGlvbiBhc3NlcnROb2RlVHlwZShub2RlLCB0eXBlKSB7XG4gIGlmICghbm9kZSB8fCBub2RlLnR5cGUgIT09IHR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub2RlIG9mIHR5cGUgXCIgKyB0eXBlICsgXCIsIGJ1dCBnb3QgXCIgKyAobm9kZSA/IFwibm9kZSBvZiB0eXBlIFwiICsgbm9kZS50eXBlIDogU3RyaW5nKG5vZGUpKSk7XG4gIH0gLy8gJEZsb3dGaXhNZSwgPj0wLjEyNVxuXG5cbiAgcmV0dXJuIG5vZGU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgbW9yZSBzdHJpY3RseSB0eXBlZCBpZmYgaXQgaXMgb2YgdGhlIGdpdmVuIHR5cGUuIE90aGVyd2lzZSxcbiAqIHJldHVybnMgbnVsbC5cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRTeW1ib2xOb2RlVHlwZShub2RlKSB7XG4gIGNvbnN0IHR5cGVkTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSk7XG5cbiAgaWYgKCF0eXBlZE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub2RlIG9mIHN5bWJvbCBncm91cCB0eXBlLCBidXQgZ290IFwiICsgKG5vZGUgPyBcIm5vZGUgb2YgdHlwZSBcIiArIG5vZGUudHlwZSA6IFN0cmluZyhub2RlKSkpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVkTm9kZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5cbmZ1bmN0aW9uIGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSBcImF0b21cIiB8fCBOT05fQVRPTVMuaGFzT3duUHJvcGVydHkobm9kZS50eXBlKSkpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvYWNjZW50LmpzXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIE5PVEU6IFVubGlrZSBtb3N0IGBodG1sQnVpbGRlcmBzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwiYWNjZW50XCIsIGJ1dFxuLy8gYWxzbyBcInN1cHN1YlwiIHNpbmNlIGFuIGFjY2VudCBjYW4gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cbmNvbnN0IGh0bWxCdWlsZGVyID0gKGdycCwgb3B0aW9ucykgPT4ge1xuICAvLyBBY2NlbnRzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIHJ1bGUgMTIuXG4gIGxldCBiYXNlO1xuICBsZXQgZ3JvdXA7XG4gIGxldCBzdXBTdWJHcm91cDtcblxuICBpZiAoZ3JwICYmIGdycC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgLy8gSWYgb3VyIGJhc2UgaXMgYSBjaGFyYWN0ZXIgYm94LCBhbmQgd2UgaGF2ZSBzdXBlcnNjcmlwdHMgYW5kXG4gICAgLy8gc3Vic2NyaXB0cywgdGhlIHN1cHN1YiB3aWxsIGRlZmVyIHRvIHVzLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YW50XG4gICAgLy8gdG8gYXR0YWNoIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgdG8gdGhlIGlubmVyIGJvZHkgKHNvXG4gICAgLy8gdGhhdCB0aGUgcG9zaXRpb24gb2YgdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cyB3b24ndCBiZVxuICAgIC8vIGFmZmVjdGVkIGJ5IHRoZSBoZWlnaHQgb2YgdGhlIGFjY2VudCkuIFdlIGFjY29tcGxpc2ggdGhpcyBieVxuICAgIC8vIHN0aWNraW5nIHRoZSBiYXNlIG9mIHRoZSBhY2NlbnQgaW50byB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViLCBhbmRcbiAgICAvLyByZW5kZXJpbmcgdGhhdCwgd2hpbGUga2VlcGluZyB0cmFjayBvZiB3aGVyZSB0aGUgYWNjZW50IGlzLlxuICAgIC8vIFRoZSByZWFsIGFjY2VudCBncm91cCBpcyB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViIGdyb3VwXG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAuYmFzZSwgXCJhY2NlbnRcIik7IC8vIFRoZSBjaGFyYWN0ZXIgYm94IGlzIHRoZSBiYXNlIG9mIHRoZSBhY2NlbnQgZ3JvdXBcblxuICAgIGJhc2UgPSBncm91cC5iYXNlOyAvLyBTdGljayB0aGUgY2hhcmFjdGVyIGJveCBpbnRvIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIgZ3JvdXBcblxuICAgIGdycC5iYXNlID0gYmFzZTsgLy8gUmVyZW5kZXIgdGhlIHN1cHN1YiBncm91cCB3aXRoIGl0cyBuZXcgYmFzZSwgYW5kIHN0b3JlIHRoYXRcbiAgICAvLyByZXN1bHQuXG5cbiAgICBzdXBTdWJHcm91cCA9IGFzc2VydFNwYW4oYnVpbGRHcm91cChncnAsIG9wdGlvbnMpKTsgLy8gcmVzZXQgb3JpZ2luYWwgYmFzZVxuXG4gICAgZ3JwLmJhc2UgPSBncm91cDtcbiAgfSBlbHNlIHtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycCwgXCJhY2NlbnRcIik7XG4gICAgYmFzZSA9IGdyb3VwLmJhc2U7XG4gIH0gLy8gQnVpbGQgdGhlIGJhc2UgZ3JvdXBcblxuXG4gIGNvbnN0IGJvZHkgPSBidWlsZEdyb3VwKGJhc2UsIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpOyAvLyBEb2VzIHRoZSBhY2NlbnQgbmVlZCB0byBzaGlmdCBmb3IgdGhlIHNrZXcgb2YgYSBjaGFyYWN0ZXI/XG5cbiAgY29uc3QgbXVzdFNoaWZ0ID0gZ3JvdXAuaXNTaGlmdHkgJiYgdXRpbHMuaXNDaGFyYWN0ZXJCb3goYmFzZSk7IC8vIENhbGN1bGF0ZSB0aGUgc2tldyBvZiB0aGUgYWNjZW50LiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBsaW5lIFwiSWYgdGhlXG4gIC8vIG51Y2xldXMgaXMgbm90IGEgc2luZ2xlIGNoYXJhY3RlciwgbGV0IHMgPSAwOyBvdGhlcndpc2Ugc2V0IHMgdG8gdGhlXG4gIC8vIGtlcm4gYW1vdW50IGZvciB0aGUgbnVjbGV1cyBmb2xsb3dlZCBieSB0aGUgXFxza2V3Y2hhciBvZiBpdHMgZm9udC5cIlxuICAvLyBOb3RlIHRoYXQgb3VyIHNrZXcgbWV0cmljcyBhcmUganVzdCB0aGUga2VybiBiZXR3ZWVuIGVhY2ggY2hhcmFjdGVyXG4gIC8vIGFuZCB0aGUgc2tld2NoYXIuXG5cbiAgbGV0IHNrZXcgPSAwO1xuXG4gIGlmIChtdXN0U2hpZnQpIHtcbiAgICAvLyBJZiB0aGUgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIHRoZW4gd2Ugd2FudCB0aGUgc2tldyBvZiB0aGVcbiAgICAvLyBpbm5lcm1vc3QgY2hhcmFjdGVyLiBUbyBkbyB0aGF0LCB3ZSBmaW5kIHRoZSBpbm5lcm1vc3QgY2hhcmFjdGVyOlxuICAgIGNvbnN0IGJhc2VDaGFyID0gdXRpbHMuZ2V0QmFzZUVsZW0oYmFzZSk7IC8vIFRoZW4sIHdlIHJlbmRlciBpdHMgZ3JvdXAgdG8gZ2V0IHRoZSBzeW1ib2wgaW5zaWRlIGl0XG5cbiAgICBjb25zdCBiYXNlR3JvdXAgPSBidWlsZEdyb3VwKGJhc2VDaGFyLCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gRmluYWxseSwgd2UgcHVsbCB0aGUgc2tldyBvZmYgb2YgdGhlIHN5bWJvbC5cblxuICAgIHNrZXcgPSBhc3NlcnRTeW1ib2xEb21Ob2RlKGJhc2VHcm91cCkuc2tldzsgLy8gTm90ZSB0aGF0IHdlIG5vdyB0aHJvdyBhd2F5IGJhc2VHcm91cCwgYmVjYXVzZSB0aGUgbGF5ZXJzIHdlXG4gICAgLy8gcmVtb3ZlZCB3aXRoIGdldEJhc2VFbGVtIG1pZ2h0IGNvbnRhaW4gdGhpbmdzIGxpa2UgXFxjb2xvciB3aGljaFxuICAgIC8vIHdlIGNhbid0IGdldCByaWQgb2YuXG4gICAgLy8gVE9ETyhlbWlseSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGdldCB0aGUgc2tld1xuICB9XG5cbiAgY29uc3QgYWNjZW50QmVsb3cgPSBncm91cC5sYWJlbCA9PT0gXCJcXFxcY1wiOyAvLyBjYWxjdWxhdGUgdGhlIGFtb3VudCBvZiBzcGFjZSBiZXR3ZWVuIHRoZSBib2R5IGFuZCB0aGUgYWNjZW50XG5cbiAgbGV0IGNsZWFyYW5jZSA9IGFjY2VudEJlbG93ID8gYm9keS5oZWlnaHQgKyBib2R5LmRlcHRoIDogTWF0aC5taW4oYm9keS5oZWlnaHQsIG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0KTsgLy8gQnVpbGQgdGhlIGFjY2VudFxuXG4gIGxldCBhY2NlbnRCb2R5O1xuXG4gIGlmICghZ3JvdXAuaXNTdHJldGNoeSkge1xuICAgIGxldCBhY2NlbnQ7XG4gICAgbGV0IHdpZHRoO1xuXG4gICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFx2ZWNcIikge1xuICAgICAgLy8gQmVmb3JlIHZlcnNpb24gMC45LCBcXHZlYyB1c2VkIHRoZSBjb21iaW5pbmcgZm9udCBnbHlwaCBVKzIwRDcuXG4gICAgICAvLyBCdXQgYnJvd3NlcnMsIGVzcGVjaWFsbHkgU2FmYXJpLCBhcmUgbm90IGNvbnNpc3RlbnQgaW4gaG93IHRoZXlcbiAgICAgIC8vIHJlbmRlciBjb21iaW5pbmcgY2hhcmFjdGVycyB3aGVuIG5vdCBwcmVjZWRlZCBieSBhIGNoYXJhY3Rlci5cbiAgICAgIC8vIFNvIG5vdyB3ZSB1c2UgYW4gU1ZHLlxuICAgICAgLy8gSWYgU2FmYXJpIHJlZm9ybXMsIHdlIHNob3VsZCBjb25zaWRlciByZXZlcnRpbmcgdG8gdGhlIGdseXBoLlxuICAgICAgYWNjZW50ID0gYnVpbGRDb21tb24uc3RhdGljU3ZnKFwidmVjXCIsIG9wdGlvbnMpO1xuICAgICAgd2lkdGggPSBidWlsZENvbW1vbi5zdmdEYXRhLnZlY1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjZW50ID0gYnVpbGRDb21tb24ubWFrZU9yZCh7XG4gICAgICAgIG1vZGU6IGdyb3VwLm1vZGUsXG4gICAgICAgIHRleHQ6IGdyb3VwLmxhYmVsXG4gICAgICB9LCBvcHRpb25zLCBcInRleHRvcmRcIik7XG4gICAgICBhY2NlbnQgPSBhc3NlcnRTeW1ib2xEb21Ob2RlKGFjY2VudCk7IC8vIFJlbW92ZSB0aGUgaXRhbGljIGNvcnJlY3Rpb24gb2YgdGhlIGFjY2VudCwgYmVjYXVzZSBpdCBvbmx5IHNlcnZlcyB0b1xuICAgICAgLy8gc2hpZnQgdGhlIGFjY2VudCBvdmVyIHRvIGEgcGxhY2Ugd2UgZG9uJ3Qgd2FudC5cblxuICAgICAgYWNjZW50Lml0YWxpYyA9IDA7XG4gICAgICB3aWR0aCA9IGFjY2VudC53aWR0aDtcblxuICAgICAgaWYgKGFjY2VudEJlbG93KSB7XG4gICAgICAgIGNsZWFyYW5jZSArPSBhY2NlbnQuZGVwdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWNjZW50Qm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImFjY2VudC1ib2R5XCJdLCBbYWNjZW50XSk7IC8vIFwiRnVsbFwiIGFjY2VudHMgZXhwYW5kIHRoZSB3aWR0aCBvZiB0aGUgcmVzdWx0aW5nIHN5bWJvbCB0byBiZVxuICAgIC8vIGF0IGxlYXN0IHRoZSB3aWR0aCBvZiB0aGUgYWNjZW50LCBhbmQgb3ZlcmxhcCBkaXJlY3RseSBvbnRvIHRoZVxuICAgIC8vIGNoYXJhY3RlciB3aXRob3V0IGFueSB2ZXJ0aWNhbCBvZmZzZXQuXG5cbiAgICBjb25zdCBhY2NlbnRGdWxsID0gZ3JvdXAubGFiZWwgPT09IFwiXFxcXHRleHRjaXJjbGVkXCI7XG5cbiAgICBpZiAoYWNjZW50RnVsbCkge1xuICAgICAgYWNjZW50Qm9keS5jbGFzc2VzLnB1c2goJ2FjY2VudC1mdWxsJyk7XG4gICAgICBjbGVhcmFuY2UgPSBib2R5LmhlaWdodDtcbiAgICB9IC8vIFNoaWZ0IHRoZSBhY2NlbnQgb3ZlciBieSB0aGUgc2tldy5cblxuXG4gICAgbGV0IGxlZnQgPSBza2V3OyAvLyBDU1MgZGVmaW5lcyBgLmthdGV4IC5hY2NlbnQgLmFjY2VudC1ib2R5Om5vdCguYWNjZW50LWZ1bGwpIHsgd2lkdGg6IDAgfWBcbiAgICAvLyBzbyB0aGF0IHRoZSBhY2NlbnQgZG9lc24ndCBjb250cmlidXRlIHRvIHRoZSBib3VuZGluZyBib3guXG4gICAgLy8gV2UgbmVlZCB0byBzaGlmdCB0aGUgY2hhcmFjdGVyIGJ5IGl0cyB3aWR0aCAoZWZmZWN0aXZlbHkgaGFsZlxuICAgIC8vIGl0cyB3aWR0aCkgdG8gY29tcGVuc2F0ZS5cblxuICAgIGlmICghYWNjZW50RnVsbCkge1xuICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgfVxuXG4gICAgYWNjZW50Qm9keS5zdHlsZS5sZWZ0ID0gbWFrZUVtKGxlZnQpOyAvLyBcXHRleHRjaXJjbGVkIHVzZXMgdGhlIFxcYmlnY2lyYyBnbHlwaCwgc28gaXQgbmVlZHMgc29tZVxuICAgIC8vIHZlcnRpY2FsIGFkanVzdG1lbnQgdG8gbWF0Y2ggTGFUZVguXG5cbiAgICBpZiAoZ3JvdXAubGFiZWwgPT09IFwiXFxcXHRleHRjaXJjbGVkXCIpIHtcbiAgICAgIGFjY2VudEJvZHkuc3R5bGUudG9wID0gXCIuMmVtXCI7XG4gICAgfVxuXG4gICAgYWNjZW50Qm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBib2R5XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAtY2xlYXJhbmNlXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBhY2NlbnRCb2R5XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGFjY2VudEJvZHkgPSBzdHJldGNoeS5zdmdTcGFuKGdyb3VwLCBvcHRpb25zKTtcbiAgICBhY2NlbnRCb2R5ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGFjY2VudEJvZHksXG4gICAgICAgIHdyYXBwZXJDbGFzc2VzOiBbXCJzdmctYWxpZ25cIl0sXG4gICAgICAgIHdyYXBwZXJTdHlsZTogc2tldyA+IDAgPyB7XG4gICAgICAgICAgd2lkdGg6IFwiY2FsYygxMDAlIC0gXCIgKyBtYWtlRW0oMiAqIHNrZXcpICsgXCIpXCIsXG4gICAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKDIgKiBza2V3KVxuICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgYWNjZW50V3JhcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJhY2NlbnRcIl0sIFthY2NlbnRCb2R5XSwgb3B0aW9ucyk7XG5cbiAgaWYgKHN1cFN1Ykdyb3VwKSB7XG4gICAgLy8gSGVyZSwgd2UgcmVwbGFjZSB0aGUgXCJiYXNlXCIgY2hpbGQgb2YgdGhlIHN1cHN1YiB3aXRoIG91ciBuZXdseVxuICAgIC8vIGdlbmVyYXRlZCBhY2NlbnQuXG4gICAgc3VwU3ViR3JvdXAuY2hpbGRyZW5bMF0gPSBhY2NlbnRXcmFwOyAvLyBTaW5jZSB3ZSBkb24ndCByZXJ1biB0aGUgaGVpZ2h0IGNhbGN1bGF0aW9uIGFmdGVyIHJlcGxhY2luZyB0aGVcbiAgICAvLyBhY2NlbnQsIHdlIG1hbnVhbGx5IHJlY2FsY3VsYXRlIGhlaWdodC5cblxuICAgIHN1cFN1Ykdyb3VwLmhlaWdodCA9IE1hdGgubWF4KGFjY2VudFdyYXAuaGVpZ2h0LCBzdXBTdWJHcm91cC5oZWlnaHQpOyAvLyBBY2NlbnRzIHNob3VsZCBhbHdheXMgYmUgb3JkcywgZXZlbiB3aGVuIHRoZWlyIGlubmFyZHMgYXJlIG5vdC5cblxuICAgIHN1cFN1Ykdyb3VwLmNsYXNzZXNbMF0gPSBcIm1vcmRcIjtcbiAgICByZXR1cm4gc3VwU3ViR3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFjY2VudFdyYXA7XG4gIH1cbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgYWNjZW50Tm9kZSA9IGdyb3VwLmlzU3RyZXRjaHkgPyBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKSA6IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLmxhYmVsLCBncm91cC5tb2RlKV0pO1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zKSwgYWNjZW50Tm9kZV0pO1xuICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG4gIHJldHVybiBub2RlO1xufTtcblxuY29uc3QgTk9OX1NUUkVUQ0hZX0FDQ0VOVF9SRUdFWCA9IG5ldyBSZWdFeHAoW1wiXFxcXGFjdXRlXCIsIFwiXFxcXGdyYXZlXCIsIFwiXFxcXGRkb3RcIiwgXCJcXFxcdGlsZGVcIiwgXCJcXFxcYmFyXCIsIFwiXFxcXGJyZXZlXCIsIFwiXFxcXGNoZWNrXCIsIFwiXFxcXGhhdFwiLCBcIlxcXFx2ZWNcIiwgXCJcXFxcZG90XCIsIFwiXFxcXG1hdGhyaW5nXCJdLm1hcChhY2NlbnQgPT4gXCJcXFxcXCIgKyBhY2NlbnQpLmpvaW4oXCJ8XCIpKTsgLy8gQWNjZW50c1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYWN1dGVcIiwgXCJcXFxcZ3JhdmVcIiwgXCJcXFxcZGRvdFwiLCBcIlxcXFx0aWxkZVwiLCBcIlxcXFxiYXJcIiwgXCJcXFxcYnJldmVcIiwgXCJcXFxcY2hlY2tcIiwgXCJcXFxcaGF0XCIsIFwiXFxcXHZlY1wiLCBcIlxcXFxkb3RcIiwgXCJcXFxcbWF0aHJpbmdcIiwgXCJcXFxcd2lkZWNoZWNrXCIsIFwiXFxcXHdpZGVoYXRcIiwgXCJcXFxcd2lkZXRpbGRlXCIsIFwiXFxcXG92ZXJyaWdodGFycm93XCIsIFwiXFxcXG92ZXJsZWZ0YXJyb3dcIiwgXCJcXFxcT3ZlcnJpZ2h0YXJyb3dcIiwgXCJcXFxcb3ZlcmxlZnRyaWdodGFycm93XCIsIFwiXFxcXG92ZXJncm91cFwiLCBcIlxcXFxvdmVybGluZXNlZ21lbnRcIiwgXCJcXFxcb3ZlcmxlZnRoYXJwb29uXCIsIFwiXFxcXG92ZXJyaWdodGhhcnBvb25cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcbiAgICBjb25zdCBpc1N0cmV0Y2h5ID0gIU5PTl9TVFJFVENIWV9BQ0NFTlRfUkVHRVgudGVzdChjb250ZXh0LmZ1bmNOYW1lKTtcbiAgICBjb25zdCBpc1NoaWZ0eSA9ICFpc1N0cmV0Y2h5IHx8IGNvbnRleHQuZnVuY05hbWUgPT09IFwiXFxcXHdpZGVoYXRcIiB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRldGlsZGVcIiB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRlY2hlY2tcIjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgIGlzU3RyZXRjaHk6IGlzU3RyZXRjaHksXG4gICAgICBpc1NoaWZ0eTogaXNTaGlmdHksXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXJcbn0pOyAvLyBUZXh0LW1vZGUgYWNjZW50c1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcJ1wiLCBcIlxcXFxgXCIsIFwiXFxcXF5cIiwgXCJcXFxcflwiLCBcIlxcXFw9XCIsIFwiXFxcXHVcIiwgXCJcXFxcLlwiLCAnXFxcXFwiJywgXCJcXFxcY1wiLCBcIlxcXFxyXCIsIFwiXFxcXEhcIiwgXCJcXFxcdlwiLCBcIlxcXFx0ZXh0Y2lyY2xlZFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZSxcbiAgICAvLyB1bmxlc3MgaW4gc3RyaWN0IG1vZGVcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYmFzZSA9IGFyZ3NbMF07XG4gICAgbGV0IG1vZGUgPSBjb250ZXh0LnBhcnNlci5tb2RlO1xuXG4gICAgaWYgKG1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJtYXRoVnNUZXh0QWNjZW50c1wiLCBcIkxhVGVYJ3MgYWNjZW50IFwiICsgY29udGV4dC5mdW5jTmFtZSArIFwiIHdvcmtzIG9ubHkgaW4gdGV4dCBtb2RlXCIpO1xuICAgICAgbW9kZSA9IFwidGV4dFwiO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGxhYmVsOiBjb250ZXh0LmZ1bmNOYW1lLFxuICAgICAgaXNTdHJldGNoeTogZmFsc2UsXG4gICAgICBpc1NoaWZ0eTogdHJ1ZSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlclxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2FjY2VudHVuZGVyLmpzXG4vLyBIb3Jpem9udGFsIG92ZXJsYXAgZnVuY3Rpb25zXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50VW5kZXJcIixcbiAgbmFtZXM6IFtcIlxcXFx1bmRlcmxlZnRhcnJvd1wiLCBcIlxcXFx1bmRlcnJpZ2h0YXJyb3dcIiwgXCJcXFxcdW5kZXJsZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFx1bmRlcmdyb3VwXCIsIFwiXFxcXHVuZGVybGluZXNlZ21lbnRcIiwgXCJcXFxcdXRpbGRlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBiYXNlID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRVbmRlclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIFRyZWF0IHVuZGVyIGFjY2VudHMgbXVjaCBsaWtlIHVuZGVybGluZXMuXG4gICAgY29uc3QgaW5uZXJHcm91cCA9IGJ1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgYWNjZW50Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGtlcm4gPSBncm91cC5sYWJlbCA9PT0gXCJcXFxcdXRpbGRlXCIgPyAwLjEyIDogMDsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuXG4gICAgY29uc3Qgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcInRvcFwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBpbm5lckdyb3VwLmhlaWdodCxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYWNjZW50Qm9keSxcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFtcInN2Zy1hbGlnblwiXVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZToga2VyblxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXJHcm91cFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcImFjY2VudHVuZGVyXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zKSwgYWNjZW50Tm9kZV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYWNjZW50dW5kZXJcIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvYXJyb3cuanNcblxuXG5cblxuXG5cblxuLy8gSGVscGVyIGZ1bmN0aW9uXG5jb25zdCBwYWRkZWROb2RlID0gZ3JvdXAgPT4ge1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIGdyb3VwID8gW2dyb3VwXSA6IFtdKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIiswLjZlbVwiKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjNlbVwiKTtcbiAgcmV0dXJuIG5vZGU7XG59OyAvLyBTdHJldGNoeSBhcnJvd3Mgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudFxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ4QXJyb3dcIixcbiAgbmFtZXM6IFtcIlxcXFx4bGVmdGFycm93XCIsIFwiXFxcXHhyaWdodGFycm93XCIsIFwiXFxcXHhMZWZ0YXJyb3dcIiwgXCJcXFxceFJpZ2h0YXJyb3dcIiwgXCJcXFxceGxlZnRyaWdodGFycm93XCIsIFwiXFxcXHhMZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFx4aG9va2xlZnRhcnJvd1wiLCBcIlxcXFx4aG9va3JpZ2h0YXJyb3dcIiwgXCJcXFxceG1hcHN0b1wiLCBcIlxcXFx4cmlnaHRoYXJwb29uZG93blwiLCBcIlxcXFx4cmlnaHRoYXJwb29udXBcIiwgXCJcXFxceGxlZnRoYXJwb29uZG93blwiLCBcIlxcXFx4bGVmdGhhcnBvb251cFwiLCBcIlxcXFx4cmlnaHRsZWZ0aGFycG9vbnNcIiwgXCJcXFxceGxlZnRyaWdodGhhcnBvb25zXCIsIFwiXFxcXHhsb25nZXF1YWxcIiwgXCJcXFxceHR3b2hlYWRyaWdodGFycm93XCIsIFwiXFxcXHh0d29oZWFkbGVmdGFycm93XCIsIFwiXFxcXHh0b2Zyb21cIiwgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgdG8gc3VwcG9ydCB0aGUgbWhjaGVtIGV4dGVuc2lvbi5cbiAgLy8gRGlyZWN0IHVzZSBvZiB0aGVzZSBmdW5jdGlvbnMgaXMgZGlzY291cmFnZWQgYW5kIG1heSBicmVhayBzb21lZGF5LlxuICBcIlxcXFx4cmlnaHRsZWZ0YXJyb3dzXCIsIFwiXFxcXHhyaWdodGVxdWlsaWJyaXVtXCIsIFwiXFxcXHhsZWZ0ZXF1aWxpYnJpdW1cIiwgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgb25seSB0byBzdXBwb3J0IHRoZSB7Q0R9IGVudmlyb25tZW50LlxuICBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIsIFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiLCBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ4QXJyb3dcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keTogYXJnc1swXSxcbiAgICAgIGJlbG93OiBvcHRBcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICAvLyBGbG93IGlzIHVuYWJsZSB0byBjb3JyZWN0bHkgaW5mZXIgdGhlIHR5cGUgb2YgYGdyb3VwYCwgZXZlbiB0aG91Z2ggaXQnc1xuICAvLyB1bmFtYmlndW91c2x5IGRldGVybWluZWQgZnJvbSB0aGUgcGFzc2VkLWluIGB0eXBlYCBhYm92ZS5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7IC8vIEJ1aWxkIHRoZSBhcmd1bWVudCBncm91cHMgaW4gdGhlIGFwcHJvcHJpYXRlIHN0eWxlLlxuICAgIC8vIFJlZjogYW1zbWF0aC5kdHg6ICAgXFxoYm94eyRcXHNjcmlwdHN0eWxlXFxta2VybiMzbXV7IzZ9XFxta2VybiM0bXUkfSVcbiAgICAvLyBTb21lIGdyb3VwcyBjYW4gcmV0dXJuIGRvY3VtZW50IGZyYWdtZW50cy4gIEhhbmRsZSB0aG9zZSBieSB3cmFwcGluZ1xuICAgIC8vIHRoZW0gaW4gYSBzcGFuLlxuXG4gICAgbGV0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1cCgpKTtcbiAgICBjb25zdCB1cHBlckdyb3VwID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IGFycm93UHJlZml4ID0gZ3JvdXAubGFiZWwuc2xpY2UoMCwgMikgPT09IFwiXFxcXHhcIiA/IFwieFwiIDogXCJjZFwiO1xuICAgIHVwcGVyR3JvdXAuY2xhc3Nlcy5wdXNoKGFycm93UHJlZml4ICsgXCItYXJyb3ctcGFkXCIpO1xuICAgIGxldCBsb3dlckdyb3VwO1xuXG4gICAgaWYgKGdyb3VwLmJlbG93KSB7XG4gICAgICAvLyBCdWlsZCB0aGUgbG93ZXIgZ3JvdXBcbiAgICAgIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1YigpKTtcbiAgICAgIGxvd2VyR3JvdXAgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRHcm91cChncm91cC5iZWxvdywgbmV3T3B0aW9ucywgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgbG93ZXJHcm91cC5jbGFzc2VzLnB1c2goYXJyb3dQcmVmaXggKyBcIi1hcnJvdy1wYWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYXJyb3dCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7IC8vIFJlIHNoaWZ0OiBOb3RlIHRoYXQgc3RyZXRjaHkuc3ZnU3BhbiByZXR1cm5lZCBhcnJvd0JvZHkuZGVwdGggPSAwLlxuICAgIC8vIFRoZSBwb2ludCB3ZSB3YW50IG9uIHRoZSBtYXRoIGF4aXMgaXMgYXQgMC41ICogYXJyb3dCb2R5LmhlaWdodC5cblxuICAgIGNvbnN0IGFycm93U2hpZnQgPSAtb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKyAwLjUgKiBhcnJvd0JvZHkuaGVpZ2h0OyAvLyAyIG11IGtlcm4uIFJlZjogYW1zbWF0aC5kdHg6ICM3XFxpZjAjMlxcZWxzZVxcbWtlcm4jMm11XFxmaVxuXG4gICAgbGV0IHVwcGVyU2hpZnQgPSAtb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgLSAwLjUgKiBhcnJvd0JvZHkuaGVpZ2h0IC0gMC4xMTE7IC8vIDAuMTExIGVtID0gMiBtdVxuXG4gICAgaWYgKHVwcGVyR3JvdXAuZGVwdGggPiAwLjI1IHx8IGdyb3VwLmxhYmVsID09PSBcIlxcXFx4bGVmdGVxdWlsaWJyaXVtXCIpIHtcbiAgICAgIHVwcGVyU2hpZnQgLT0gdXBwZXJHcm91cC5kZXB0aDsgLy8gc2hpZnQgdXAgaWYgZGVwdGggZW5jcm9hY2hlc1xuICAgIH0gLy8gR2VuZXJhdGUgdGhlIHZsaXN0XG5cblxuICAgIGxldCB2bGlzdDtcblxuICAgIGlmIChsb3dlckdyb3VwKSB7XG4gICAgICBjb25zdCBsb3dlclNoaWZ0ID0gLW9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0ICsgbG93ZXJHcm91cC5oZWlnaHQgKyAwLjUgKiBhcnJvd0JvZHkuaGVpZ2h0ICsgMC4xMTE7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdXBwZXJHcm91cCxcbiAgICAgICAgICBzaGlmdDogdXBwZXJTaGlmdFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogYXJyb3dCb2R5LFxuICAgICAgICAgIHNoaWZ0OiBhcnJvd1NoaWZ0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBsb3dlckdyb3VwLFxuICAgICAgICAgIHNoaWZ0OiBsb3dlclNoaWZ0XG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHVwcGVyR3JvdXAsXG4gICAgICAgICAgc2hpZnQ6IHVwcGVyU2hpZnRcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGFycm93Qm9keSxcbiAgICAgICAgICBzaGlmdDogYXJyb3dTaGlmdFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSAvLyAkRmxvd0ZpeE1lOiBSZXBsYWNlIHRoaXMgd2l0aCBwYXNzaW5nIFwic3ZnLWFsaWduXCIgaW50byBtYWtlVkxpc3QuXG5cblxuICAgIHZsaXN0LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLmNsYXNzZXMucHVzaChcInN2Zy1hbGlnblwiKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXJlbFwiLCBcIngtYXJyb3dcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhcnJvd05vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKTtcbiAgICBhcnJvd05vZGUuc2V0QXR0cmlidXRlKFwibWluc2l6ZVwiLCBncm91cC5sYWJlbC5jaGFyQXQoMCkgPT09IFwieFwiID8gXCIxLjc1ZW1cIiA6IFwiMy4wZW1cIik7XG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAuYm9keSkge1xuICAgICAgY29uc3QgdXBwZXJOb2RlID0gcGFkZGVkTm9kZShidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpKTtcblxuICAgICAgaWYgKGdyb3VwLmJlbG93KSB7XG4gICAgICAgIGNvbnN0IGxvd2VyTm9kZSA9IHBhZGRlZE5vZGUoYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iZWxvdywgb3B0aW9ucykpO1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJvdmVyXCIsIFthcnJvd05vZGUsIGxvd2VyTm9kZSwgdXBwZXJOb2RlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYXJyb3dOb2RlLCB1cHBlck5vZGVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmJlbG93KSB7XG4gICAgICBjb25zdCBsb3dlck5vZGUgPSBwYWRkZWROb2RlKGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmVsb3csIG9wdGlvbnMpKTtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbYXJyb3dOb2RlLCBsb3dlck5vZGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgLy8gUGFyc2VyLmpzIHRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyBubyBhcmd1bWVudC5cbiAgICAgIG5vZGUgPSBwYWRkZWROb2RlKCk7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYXJyb3dOb2RlLCBub2RlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL21jbGFzcy5qc1xuXG5cblxuXG5cblxuY29uc3QgbWNsYXNzX21ha2VTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW47XG5cbmZ1bmN0aW9uIG1jbGFzc19odG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICBjb25zdCBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLCB0cnVlKTtcbiAgcmV0dXJuIG1jbGFzc19tYWtlU3BhbihbZ3JvdXAubWNsYXNzXSwgZWxlbWVudHMsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBtY2xhc3NfbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICBsZXQgbm9kZTtcbiAgY29uc3QgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgaW5uZXIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3JkXCIpIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibWlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgaW5uZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibW9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgaW5uZXIpO1xuICAgIH0gLy8gU2V0IHNwYWNpbmcgYmFzZWQgb24gd2hhdCBpcyB0aGUgbW9zdCBsaWtlbHkgYWRqYWNlbnQgYXRvbSB0eXBlLlxuICAgIC8vIFNlZSBUZVhib29rIHAxNzAuXG5cblxuICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibWJpblwiKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjIyZW1cIjsgLy8gbWVkaXVtIHNwYWNlXG5cbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMjJlbVwiO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1wdW5jdFwiKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMTdlbVwiOyAvLyB0aGluc3BhY2VcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMC4wNTU2ZW1cIjsgLy8gMSBtdSBpcyB0aGUgbW9zdCBsaWtlbHkgb3B0aW9uXG5cbiAgICAgIG5vZGUuYXR0cmlidXRlcy53aWR0aCA9IFwiKzAuMTExMWVtXCI7XG4gICAgfSAvLyBNYXRoTUwgPG1vPiBkZWZhdWx0IHNwYWNlIGlzIDUvMTggZW0sIHNvIDxtcmVsPiBuZWVkcyBubyBhY3Rpb24uXG4gICAgLy8gUmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9NYXRoTUwvRWxlbWVudC9tb1xuXG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aG9yZFwiLCBcIlxcXFxtYXRoYmluXCIsIFwiXFxcXG1hdGhyZWxcIiwgXCJcXFxcbWF0aG9wZW5cIiwgXCJcXFxcbWF0aGNsb3NlXCIsIFwiXFxcXG1hdGhwdW5jdFwiLCBcIlxcXFxtYXRoaW5uZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzOiBcIm1cIiArIGZ1bmNOYW1lLnNsaWNlKDUpLFxuICAgICAgLy8gVE9ETyhrZXZpbmIpOiBkb24ndCBwcmVmaXggd2l0aCAnbSdcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgaXNDaGFyYWN0ZXJCb3g6IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGJvZHkpXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogbWNsYXNzX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBtY2xhc3NfbWF0aG1sQnVpbGRlclxufSk7XG5jb25zdCBiaW5yZWxDbGFzcyA9IGFyZyA9PiB7XG4gIC8vIFxcYmlucmVsQCBzcGFjaW5nIHZhcmllcyB3aXRoIChiaW58cmVsfG9yZCkgb2YgdGhlIGF0b20gaW4gdGhlIGFyZ3VtZW50LlxuICAvLyAoYnkgcmVuZGVyaW5nIHNlcGFyYXRlbHkgYW5kIHdpdGgge31zIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZCBtZWFzdXJpbmdcbiAgLy8gdGhlIGNoYW5nZSBpbiBzcGFjaW5nKS4gIFdlJ2xsIGRvIHJvdWdobHkgdGhlIHNhbWUgYnkgZGV0ZWN0aW5nIHRoZVxuICAvLyBhdG9tIHR5cGUgZGlyZWN0bHkuXG4gIGNvbnN0IGF0b20gPSBhcmcudHlwZSA9PT0gXCJvcmRncm91cFwiICYmIGFyZy5ib2R5Lmxlbmd0aCA/IGFyZy5ib2R5WzBdIDogYXJnO1xuXG4gIGlmIChhdG9tLnR5cGUgPT09IFwiYXRvbVwiICYmIChhdG9tLmZhbWlseSA9PT0gXCJiaW5cIiB8fCBhdG9tLmZhbWlseSA9PT0gXCJyZWxcIikpIHtcbiAgICByZXR1cm4gXCJtXCIgKyBhdG9tLmZhbWlseTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJtb3JkXCI7XG4gIH1cbn07IC8vIFxcQGJpbnJlbHt4fXt5fSByZW5kZXJzIGxpa2UgeSBidXQgYXMgbWJpbi9tcmVsL21vcmQgaWYgeCBpcyBtYmluL21yZWwvbW9yZC5cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCB0byBcXGJpbnJlbEB7eH1cXGJpbnJlbEBAe3l9IGluIEFNU1RlWC5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXEBiaW5yZWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGFyZ3NbMF0pLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1sxXSksXG4gICAgICBpc0NoYXJhY3RlckJveDogdXRpbHMuaXNDaGFyYWN0ZXJCb3goYXJnc1sxXSlcbiAgICB9O1xuICB9XG5cbn0pOyAvLyBCdWlsZCBhIHJlbGF0aW9uIG9yIHN0YWNrZWQgb3AgYnkgcGxhY2luZyBvbmUgc3ltYm9sIG9uIHRvcCBvZiBhbm90aGVyXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxzdGFja3JlbFwiLCBcIlxcXFxvdmVyc2V0XCIsIFwiXFxcXHVuZGVyc2V0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYzO1xuICAgIGNvbnN0IGJhc2VBcmcgPSBhcmdzWzFdO1xuICAgIGNvbnN0IHNoaWZ0ZWRBcmcgPSBhcmdzWzBdO1xuICAgIGxldCBtY2xhc3M7XG5cbiAgICBpZiAoZnVuY05hbWUgIT09IFwiXFxcXHN0YWNrcmVsXCIpIHtcbiAgICAgIC8vIExhVGVYIGFwcGxpZXMgXFxiaW5yZWwgc3BhY2luZyB0byBcXG92ZXJzZXQgYW5kIFxcdW5kZXJzZXQuXG4gICAgICBtY2xhc3MgPSBiaW5yZWxDbGFzcyhiYXNlQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWNsYXNzID0gXCJtcmVsXCI7IC8vIGZvciBcXHN0YWNrcmVsXG4gICAgfVxuXG4gICAgY29uc3QgYmFzZU9wID0ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogYmFzZUFyZy5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgYWx3YXlzSGFuZGxlU3VwU3ViOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzQmFzZVNoaWZ0OiBmdW5jTmFtZSAhPT0gXCJcXFxcc3RhY2tyZWxcIixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJhc2VBcmcpXG4gICAgfTtcbiAgICBjb25zdCBzdXBzdWIgPSB7XG4gICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgbW9kZTogc2hpZnRlZEFyZy5tb2RlLFxuICAgICAgYmFzZTogYmFzZU9wLFxuICAgICAgc3VwOiBmdW5jTmFtZSA9PT0gXCJcXFxcdW5kZXJzZXRcIiA/IG51bGwgOiBzaGlmdGVkQXJnLFxuICAgICAgc3ViOiBmdW5jTmFtZSA9PT0gXCJcXFxcdW5kZXJzZXRcIiA/IHNoaWZ0ZWRBcmcgOiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzLFxuICAgICAgYm9keTogW3N1cHN1Yl0sXG4gICAgICBpc0NoYXJhY3RlckJveDogdXRpbHMuaXNDaGFyYWN0ZXJCb3goc3Vwc3ViKVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IG1jbGFzc19odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogbWNsYXNzX21hdGhtbEJ1aWxkZXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9wbWIuanNcblxuXG5cblxuXG5cbi8vIFxccG1iIGlzIGEgc2ltdWxhdGlvbiBvZiBib2xkIGZvbnQuXG4vLyBUaGUgdmVyc2lvbiBvZiBcXHBtYiBpbiBhbWJzeS5zdHkgd29ya3MgYnkgdHlwZXNldHRpbmcgdGhyZWUgY29waWVzXG4vLyB3aXRoIHNtYWxsIG9mZnNldHMuIFdlIHVzZSBDU1MgdGV4dC1zaGFkb3cuXG4vLyBJdCdzIGEgaGFjay4gTm90IGFzIGdvb2QgYXMgYSByZWFsIGJvbGQgZm9udC4gQmV0dGVyIHRoYW4gbm90aGluZy5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJwbWJcIixcbiAgbmFtZXM6IFtcIlxcXFxwbWJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInBtYlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGFyZ3NbMF0pLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1swXSlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgY29uc3Qgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtncm91cC5tY2xhc3NdLCBlbGVtZW50cywgb3B0aW9ucyk7XG4gICAgbm9kZS5zdHlsZS50ZXh0U2hhZG93ID0gXCIwLjAyZW0gMC4wMWVtIDAuMDRweFwiO1xuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUpOyAvLyBXcmFwIHdpdGggYW4gPG1zdHlsZT4gZWxlbWVudC5cblxuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInRleHQtc2hhZG93OiAwLjAyZW0gMC4wMWVtIDAuMDRweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9lbnZpcm9ubWVudHMvY2QuanNcblxuXG5cblxuXG5cblxuXG5jb25zdCBjZEFycm93RnVuY3Rpb25OYW1lID0ge1xuICBcIj5cIjogXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiLFxuICBcIjxcIjogXCJcXFxcXFxcXGNkbGVmdGFycm93XCIsXG4gIFwiPVwiOiBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIixcbiAgXCJBXCI6IFwiXFxcXHVwYXJyb3dcIixcbiAgXCJWXCI6IFwiXFxcXGRvd25hcnJvd1wiLFxuICBcInxcIjogXCJcXFxcVmVydFwiLFxuICBcIi5cIjogXCJubyBhcnJvd1wiXG59O1xuXG5jb25zdCBuZXdDZWxsID0gKCkgPT4ge1xuICAvLyBDcmVhdGUgYW4gZW1wdHkgY2VsbCwgdG8gYmUgZmlsbGVkIGJlbG93IHdpdGggcGFyc2Ugbm9kZXMuXG4gIC8vIFRoZSBwYXJzZVRyZWUgZnJvbSB0aGlzIG1vZHVsZSBtdXN0IGJlIGNvbnN0cnVjdGVkIGxpa2UgdGhlXG4gIC8vIG9uZSBjcmVhdGVkIGJ5IHBhcnNlQXJyYXkoKSwgc28gYW4gZW1wdHkgQ0QgY2VsbCBtdXN0XG4gIC8vIGJlIGEgUGFyc2VOb2RlPFwic3R5bGluZ1wiPi4gQW5kIENEIGlzIGFsd2F5cyBkaXNwbGF5c3R5bGUuXG4gIC8vIFNvIHRoZXNlIHZhbHVlcyBhcmUgZml4ZWQgYW5kIGZsb3cgY2FuIGRvIGltcGxpY2l0IHR5cGluZy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICBib2R5OiBbXSxcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBzdHlsZTogXCJkaXNwbGF5XCJcbiAgfTtcbn07XG5cbmNvbnN0IGlzU3RhcnRPZkFycm93ID0gbm9kZSA9PiB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwidGV4dG9yZFwiICYmIG5vZGUudGV4dCA9PT0gXCJAXCI7XG59O1xuXG5jb25zdCBpc0xhYmVsRW5kID0gKG5vZGUsIGVuZENoYXIpID0+IHtcbiAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8IG5vZGUudHlwZSA9PT0gXCJhdG9tXCIpICYmIG5vZGUudGV4dCA9PT0gZW5kQ2hhcjtcbn07XG5cbmZ1bmN0aW9uIGNkQXJyb3coYXJyb3dDaGFyLCBsYWJlbHMsIHBhcnNlcikge1xuICAvLyBSZXR1cm4gYSBwYXJzZSB0cmVlIG9mIGFuIGFycm93IGFuZCBpdHMgbGFiZWxzLlxuICAvLyBUaGlzIGFjdHMgaW4gYSB3YXkgc2ltaWxhciB0byBhIG1hY3JvIGV4cGFuc2lvbi5cbiAgY29uc3QgZnVuY05hbWUgPSBjZEFycm93RnVuY3Rpb25OYW1lW2Fycm93Q2hhcl07XG5cbiAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgIGNhc2UgXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiOlxuICAgIGNhc2UgXCJcXFxcXFxcXGNkbGVmdGFycm93XCI6XG4gICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW2xhYmVsc1swXV0sIFtsYWJlbHNbMV1dKTtcblxuICAgIGNhc2UgXCJcXFxcdXBhcnJvd1wiOlxuICAgIGNhc2UgXCJcXFxcZG93bmFycm93XCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGxlZnRMYWJlbCA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkbGVmdFwiLCBbbGFiZWxzWzBdXSwgW10pO1xuICAgICAgICBjb25zdCBiYXJlQXJyb3cgPSB7XG4gICAgICAgICAgdHlwZTogXCJhdG9tXCIsXG4gICAgICAgICAgdGV4dDogZnVuY05hbWUsXG4gICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgZmFtaWx5OiBcInJlbFwiXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNpemVkQXJyb3cgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXEJpZ1wiLCBbYmFyZUFycm93XSwgW10pO1xuICAgICAgICBjb25zdCByaWdodExhYmVsID0gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxcXFxcY2RyaWdodFwiLCBbbGFiZWxzWzFdXSwgW10pO1xuICAgICAgICBjb25zdCBhcnJvd0dyb3VwID0ge1xuICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICBib2R5OiBbbGVmdExhYmVsLCBzaXplZEFycm93LCByaWdodExhYmVsXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxcXFxcY2RwYXJlbnRcIiwgW2Fycm93R3JvdXBdLCBbXSk7XG4gICAgICB9XG5cbiAgICBjYXNlIFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiOlxuICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCIsIFtdLCBbXSk7XG5cbiAgICBjYXNlIFwiXFxcXFZlcnRcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYXJyb3cgPSB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgdGV4dDogXCJcXFxcVmVydFwiLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXEJpZ1wiLCBbYXJyb3ddLCBbXSk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIHRleHQ6IFwiIFwiLFxuICAgICAgICBtb2RlOiBcIm1hdGhcIlxuICAgICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUNEKHBhcnNlcikge1xuICAvLyBHZXQgdGhlIGFycmF5J3MgcGFyc2Ugbm9kZXMgd2l0aCBcXFxcIHRlbXBvcmFyaWx5IG1hcHBlZCB0byBcXGNyLlxuICBjb25zdCBwYXJzZWRSb3dzID0gW107XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY3JcIiwgXCJcXFxcXFxcXFxcXFxyZWxheFwiKTtcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIC8vIEdldCB0aGUgcGFyc2Ugbm9kZXMgZm9yIHRoZSBuZXh0IHJvdy5cbiAgICBwYXJzZWRSb3dzLnB1c2gocGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJcXFxcXFxcXFwiKSk7XG4gICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuXG4gICAgaWYgKG5leHQgPT09IFwiJlwiIHx8IG5leHQgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXGVuZFwiKSB7XG4gICAgICBpZiAocGFyc2VkUm93c1twYXJzZWRSb3dzLmxlbmd0aCAtIDFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwYXJzZWRSb3dzLnBvcCgpOyAvLyBmaW5hbCByb3cgZW5kZWQgaW4gXFxcXFxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgXFxcXFxcXFwgb3IgXFxcXGNyIG9yIFxcXFxlbmRcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJvdyA9IFtdO1xuICBjb25zdCBib2R5ID0gW3Jvd107IC8vIExvb3AgdGhydSB0aGUgcGFyc2Ugbm9kZXMuIENvbGxlY3QgdGhlbSBpbnRvIGNlbGxzIGFuZCBhcnJvd3MuXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gU3RhcnQgYSBuZXcgcm93LlxuICAgIGNvbnN0IHJvd05vZGVzID0gcGFyc2VkUm93c1tpXTsgLy8gQ3JlYXRlIHRoZSBmaXJzdCBjZWxsLlxuXG4gICAgbGV0IGNlbGwgPSBuZXdDZWxsKCk7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd05vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoIWlzU3RhcnRPZkFycm93KHJvd05vZGVzW2pdKSkge1xuICAgICAgICAvLyBJZiBhIHBhcnNlTm9kZSBpcyBub3QgYW4gYXJyb3csIGl0IGdvZXMgaW50byBhIGNlbGwuXG4gICAgICAgIGNlbGwuYm9keS5wdXNoKHJvd05vZGVzW2pdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcnNlIG5vZGUgaiBpcyBhbiBcIkBcIiwgdGhlIHN0YXJ0IG9mIGFuIGFycm93LlxuICAgICAgICAvLyBCZWZvcmUgc3RhcnRpbmcgb24gdGhlIGFycm93LCBwdXNoIHRoZSBjZWxsIGludG8gYHJvd2AuXG4gICAgICAgIHJvdy5wdXNoKGNlbGwpOyAvLyBOb3cgY29sbGVjdCBwYXJzZU5vZGVzIGludG8gYW4gYXJyb3cuXG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYWZ0ZXIgXCJAXCIgZGVmaW5lcyB0aGUgYXJyb3cgdHlwZS5cblxuICAgICAgICBqICs9IDE7XG4gICAgICAgIGNvbnN0IGFycm93Q2hhciA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKHJvd05vZGVzW2pdKS50ZXh0OyAvLyBDcmVhdGUgdHdvIGVtcHR5IGxhYmVsIG5vZGVzLiBXZSBtYXkgb3IgbWF5IG5vdCB1c2UgdGhlbS5cblxuICAgICAgICBjb25zdCBsYWJlbHMgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIGxhYmVsc1swXSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgYm9keTogW11cbiAgICAgICAgfTtcbiAgICAgICAgbGFiZWxzWzFdID0ge1xuICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICBib2R5OiBbXVxuICAgICAgICB9OyAvLyBQcm9jZXNzIHRoZSBhcnJvdy5cblxuICAgICAgICBpZiAoXCI9fC5cIi5pbmRleE9mKGFycm93Q2hhcikgPiAtMSkgey8vIFRocmVlIFwiYXJyb3dzXCIsIGBgQD1gLCBgQHxgLCBhbmQgYEAuYCwgZG8gbm90IHRha2UgbGFiZWxzLlxuICAgICAgICAgIC8vIERvIG5vdGhpbmcgaGVyZS5cbiAgICAgICAgfSBlbHNlIGlmIChcIjw+QVZcIi5pbmRleE9mKGFycm93Q2hhcikgPiAtMSkge1xuICAgICAgICAgIC8vIEZvdXIgYXJyb3dzLCBgQD4+PmAsIGBAPDw8YCwgYEBBQUFgLCBhbmQgYEBWVlZgLCBlYWNoIHRha2VcbiAgICAgICAgICAvLyB0d28gb3B0aW9uYWwgbGFiZWxzLiBFLmcuIHRoZSByaWdodC1wb2ludCBhcnJvdyBzeW50YXggaXNcbiAgICAgICAgICAvLyByZWFsbHk6ICBAPntvcHRpb25hbCBsYWJlbH0+e29wdGlvbmFsIGxhYmVsfT5cbiAgICAgICAgICAvLyBDb2xsZWN0IHBhcnNlTm9kZXMgaW50byBsYWJlbHMuXG4gICAgICAgICAgZm9yIChsZXQgbGFiZWxOdW0gPSAwOyBsYWJlbE51bSA8IDI7IGxhYmVsTnVtKyspIHtcbiAgICAgICAgICAgIGxldCBpbkxhYmVsID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgayA9IGogKyAxOyBrIDwgcm93Tm9kZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKGlzTGFiZWxFbmQocm93Tm9kZXNba10sIGFycm93Q2hhcikpIHtcbiAgICAgICAgICAgICAgICBpbkxhYmVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaiA9IGs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNTdGFydE9mQXJyb3cocm93Tm9kZXNba10pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTWlzc2luZyBhIFwiICsgYXJyb3dDaGFyICsgXCIgY2hhcmFjdGVyIHRvIGNvbXBsZXRlIGEgQ0QgYXJyb3cuXCIsIHJvd05vZGVzW2tdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxhYmVsc1tsYWJlbE51bV0uYm9keS5wdXNoKHJvd05vZGVzW2tdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluTGFiZWwpIHtcbiAgICAgICAgICAgICAgLy8gaXNMYWJlbEVuZCBuZXZlciByZXR1cm5lZCBhIHRydWUuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk1pc3NpbmcgYSBcIiArIGFycm93Q2hhciArIFwiIGNoYXJhY3RlciB0byBjb21wbGV0ZSBhIENEIGFycm93LlwiLCByb3dOb2Rlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkIG9uZSBvZiBcXFwiPD5BVj18LlxcXCIgYWZ0ZXIgQFwiLCByb3dOb2Rlc1tqXSk7XG4gICAgICAgIH0gLy8gTm93IGpvaW4gdGhlIGFycm93IHRvIGl0cyBsYWJlbHMuXG5cblxuICAgICAgICBjb25zdCBhcnJvdyA9IGNkQXJyb3coYXJyb3dDaGFyLCBsYWJlbHMsIHBhcnNlcik7IC8vIFdyYXAgdGhlIGFycm93IGluICBQYXJzZU5vZGU8XCJzdHlsaW5nXCI+LlxuICAgICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gbWF0Y2ggcGFyc2VBcnJheSgpIGJlaGF2aW9yLlxuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRBcnJvdyA9IHtcbiAgICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgICBib2R5OiBbYXJyb3ddLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgIHN0eWxlOiBcImRpc3BsYXlcIiAvLyBDRCBpcyBhbHdheXMgZGlzcGxheXN0eWxlLlxuXG4gICAgICAgIH07XG4gICAgICAgIHJvdy5wdXNoKHdyYXBwZWRBcnJvdyk7IC8vIEluIENEJ3Mgc3ludGF4LCBjZWxscyBhcmUgaW1wbGljaXQuIFRoYXQgaXMsIGV2ZXJ5dGhpbmcgdGhhdFxuICAgICAgICAvLyBpcyBub3QgYW4gYXJyb3cgZ2V0cyBjb2xsZWN0ZWQgaW50byBhIGNlbGwuIFNvIGNyZWF0ZSBhbiBlbXB0eVxuICAgICAgICAvLyBjZWxsIG5vdy4gSXQgd2lsbCBjb2xsZWN0IHVwY29taW5nIHBhcnNlTm9kZXMuXG5cbiAgICAgICAgY2VsbCA9IG5ld0NlbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgIC8vIEV2ZW4tbnVtYmVyZWQgcm93cyBjb25zaXN0IG9mOiBjZWxsLCBhcnJvdywgY2VsbCwgYXJyb3csIC4uLiBjZWxsXG4gICAgICAvLyBUaGUgbGFzdCBjZWxsIGlzIG5vdCB5ZXQgcHVzaGVkIGludG8gYHJvd2AsIHNvOlxuICAgICAgcm93LnB1c2goY2VsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9kZC1udW1iZXJlZCByb3dzIGNvbnNpc3Qgb2Y6IHZlcnQgYXJyb3csIGVtcHR5IGNlbGwsIC4uLiB2ZXJ0IGFycm93XG4gICAgICAvLyBSZW1vdmUgdGhlIGVtcHR5IGNlbGwgdGhhdCB3YXMgcGxhY2VkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYHJvd2AuXG4gICAgICByb3cuc2hpZnQoKTtcbiAgICB9XG5cbiAgICByb3cgPSBbXTtcbiAgICBib2R5LnB1c2gocm93KTtcbiAgfSAvLyBFbmQgcm93IGdyb3VwXG5cblxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7IC8vIEVuZCBhcnJheSBncm91cCBkZWZpbmluZyBcXFxcXG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOyAvLyBkZWZpbmUgY29sdW1uIHNlcGFyYXRpb24uXG5cbiAgY29uc3QgY29scyA9IG5ldyBBcnJheShib2R5WzBdLmxlbmd0aCkuZmlsbCh7XG4gICAgdHlwZTogXCJhbGlnblwiLFxuICAgIGFsaWduOiBcImNcIixcbiAgICBwcmVnYXA6IDAuMjUsXG4gICAgLy8gQ0QgcGFja2FnZSBzZXRzIFxcZW5za2lwIGJldHdlZW4gY29sdW1ucy5cbiAgICBwb3N0Z2FwOiAwLjI1IC8vIFNvIHByZSBhbmQgcG9zdCBlYWNoIGdldCBoYWxmIGFuIFxcZW5za2lwLCBpLmUuIDAuMjVlbS5cblxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgYm9keSxcbiAgICBhcnJheXN0cmV0Y2g6IDEsXG4gICAgYWRkSm90OiB0cnVlLFxuICAgIHJvd0dhcHM6IFtudWxsXSxcbiAgICBjb2xzLFxuICAgIGNvbFNlcGFyYXRpb25UeXBlOiBcIkNEXCIsXG4gICAgaExpbmVzQmVmb3JlUm93OiBuZXcgQXJyYXkoYm9keS5sZW5ndGggKyAxKS5maWxsKFtdKVxuICB9O1xufSAvLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBub3QgYXZhaWxhYmxlIGZvciBnZW5lcmFsIHVzZS5cbi8vIFRoZXkgYXJlIGhlcmUgb25seSBmb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSB7Q0R9IGVudmlyb25tZW50IGluIHBsYWNpbmcgbGFiZWxzXG4vLyBuZXh0IHRvIHZlcnRpY2FsIGFycm93cy5cbi8vIFdlIGRvbid0IG5lZWQgYW55IHN1Y2ggZnVuY3Rpb25zIGZvciBob3Jpem9udGFsIGFycm93cyBiZWNhdXNlIHdlIGNhbiByZXVzZVxuLy8gdGhlIGZ1bmN0aW9uYWxpdHkgdGhhdCBhbHJlYWR5IGV4aXN0cyBmb3IgZXh0ZW5zaWJsZSBhcnJvd3MuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjZGxhYmVsXCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXGNkbGVmdFwiLCBcIlxcXFxcXFxcY2RyaWdodFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2RsYWJlbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzaWRlOiBmdW5jTmFtZS5zbGljZSg0KSxcbiAgICAgIGxhYmVsOiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUuc3VwKCkpO1xuICAgIGNvbnN0IGxhYmVsID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAoZ3JvdXAubGFiZWwsIG5ld09wdGlvbnMsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICBsYWJlbC5jbGFzc2VzLnB1c2goXCJjZC1sYWJlbC1cIiArIGdyb3VwLnNpZGUpO1xuICAgIGxhYmVsLnN0eWxlLmJvdHRvbSA9IG1ha2VFbSgwLjggLSBsYWJlbC5kZXB0aCk7IC8vIFplcm8gb3V0IGxhYmVsIGhlaWdodCAmIGRlcHRoLCBzbyB2ZXJ0aWNhbCBhbGlnbiBvZiBhcnJvdyBpcyBzZXRcbiAgICAvLyBieSB0aGUgYXJyb3cgaGVpZ2h0LCBub3QgYnkgdGhlIGxhYmVsLlxuXG4gICAgbGFiZWwuaGVpZ2h0ID0gMDtcbiAgICBsYWJlbC5kZXB0aCA9IDA7XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBsZXQgbGFiZWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAubGFiZWwsIG9wdGlvbnMpXSk7XG4gICAgbGFiZWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2xhYmVsXSk7XG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwXCIpO1xuXG4gICAgaWYgKGdyb3VwLnNpZGUgPT09IFwibGVmdFwiKSB7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCItMXdpZHRoXCIpO1xuICAgIH0gLy8gV2UgaGF2ZSB0byBndWVzcyBhdCB2ZXJ0aWNhbCBhbGlnbm1lbnQuIFdlIGtub3cgdGhlIGFycm93IGlzIDEuOGVtIHRhbGwsXG4gICAgLy8gQnV0IHdlIGRvbid0IGtub3cgdGhlIGhlaWdodCBvciBkZXB0aCBvZiB0aGUgbGFiZWwuXG5cblxuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgXCIwLjdlbVwiKTtcbiAgICBsYWJlbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIFtsYWJlbF0pO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBcImZhbHNlXCIpO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMVwiKTtcbiAgICByZXR1cm4gbGFiZWw7XG4gIH1cblxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY2RsYWJlbHBhcmVudFwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxjZHBhcmVudFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2RsYWJlbHBhcmVudFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmcmFnbWVudDogYXJnc1swXVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBXcmFwIHRoZSB2ZXJ0aWNhbCBhcnJvdyBhbmQgaXRzIGxhYmVscy5cbiAgICAvLyBUaGUgcGFyZW50IGdldHMgcG9zaXRpb246IHJlbGF0aXZlLiBUaGUgY2hpbGQgZ2V0cyBwb3NpdGlvbjogYWJzb2x1dGUuXG4gICAgLy8gU28gQ1NTIGNhbiBsb2NhdGUgdGhlIGxhYmVsIGNvcnJlY3RseS5cbiAgICBjb25zdCBwYXJlbnQgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRHcm91cChncm91cC5mcmFnbWVudCwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIHBhcmVudC5jbGFzc2VzLnB1c2goXCJjZC12ZXJ0LWFycm93XCIpO1xuICAgIHJldHVybiBwYXJlbnQ7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuZnJhZ21lbnQsIG9wdGlvbnMpXSk7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2NoYXIuanNcblxuXG4gLy8gXFxAY2hhciBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZ3JvdXBlZCBkZWNpbWFsIGFyZ3VtZW50IGxpa2Vcbi8vIHsxMjN9IGFuZCBjb252ZXJ0cyBpbnRvIHN5bWJvbCB3aXRoIGNvZGUgMTIzLiAgSXQgaXMgdXNlZCBieSB0aGUgKm1hY3JvKlxuLy8gXFxjaGFyIGRlZmluZWQgaW4gbWFjcm9zLmpzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dG9yZFwiLFxuICBuYW1lczogW1wiXFxcXEBjaGFyXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBhcmcgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcIm9yZGdyb3VwXCIpO1xuICAgIGNvbnN0IGdyb3VwID0gYXJnLmJvZHk7XG4gICAgbGV0IG51bWJlciA9IFwiXCI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gYXNzZXJ0Tm9kZVR5cGUoZ3JvdXBbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIG51bWJlciArPSBub2RlLnRleHQ7XG4gICAgfVxuXG4gICAgbGV0IGNvZGUgPSBwYXJzZUludChudW1iZXIpO1xuICAgIGxldCB0ZXh0O1xuXG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcQGNoYXIgaGFzIG5vbi1udW1lcmljIGFyZ3VtZW50IFwiICsgbnVtYmVyKTsgLy8gSWYgd2UgZHJvcCBJRSBzdXBwb3J0LCB0aGUgZm9sbG93aW5nIGNvZGUgY291bGQgYmUgcmVwbGFjZWQgd2l0aFxuICAgICAgLy8gdGV4dCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpXG4gICAgfSBlbHNlIGlmIChjb2RlIDwgMCB8fCBjb2RlID49IDB4MTBmZmZmKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcQGNoYXIgd2l0aCBpbnZhbGlkIGNvZGUgcG9pbnQgXCIgKyBudW1iZXIpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA8PSAweGZmZmYpIHtcbiAgICAgIHRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW50byBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgICB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMHgzZmYpICsgMHhkYzAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHRleHQ6IHRleHRcbiAgICB9O1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9jb2xvci5qc1xuXG5cblxuXG5cblxuXG5jb25zdCBjb2xvcl9odG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLndpdGhDb2xvcihncm91cC5jb2xvciksIGZhbHNlKTsgLy8gXFxjb2xvciBpc24ndCBzdXBwb3NlZCB0byBhZmZlY3QgdGhlIHR5cGUgb2YgdGhlIGVsZW1lbnRzIGl0IGNvbnRhaW5zLlxuICAvLyBUbyBhY2NvbXBsaXNoIHRoaXMsIHdlIHdyYXAgdGhlIHJlc3VsdHMgaW4gYSBmcmFnbWVudCwgc28gdGhlIGlubmVyXG4gIC8vIGVsZW1lbnRzIHdpbGwgYmUgYWJsZSB0byBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZWlyIG5laWdoYm9ycy4gRm9yXG4gIC8vIGV4YW1wbGUsIGBcXGNvbG9ye3JlZH17MiArfSAzYCBoYXMgdGhlIHNhbWUgc3BhY2luZyBhcyBgMiArIDNgXG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG59O1xuXG5jb25zdCBjb2xvcl9tYXRobWxCdWlsZGVyID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMud2l0aENvbG9yKGdyb3VwLmNvbG9yKSk7XG4gIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aGNvbG9yXCIsIGdyb3VwLmNvbG9yKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY29sb3JcIixcbiAgbmFtZXM6IFtcIlxcXFx0ZXh0Y29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJjb2xvclwiLCBcIm9yaWdpbmFsXCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb2xvcixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogY29sb3JfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGNvbG9yX21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNvbG9yXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJjb2xvclwiXVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgYnJlYWtPblRva2VuVGV4dFxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCBjb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7IC8vIFNldCBtYWNybyBcXGN1cnJlbnRAY29sb3IgaW4gY3VycmVudCBuYW1lc3BhY2UgdG8gc3RvcmUgdGhlIGN1cnJlbnRcbiAgICAvLyBjb2xvciwgbWltaWNraW5nIHRoZSBiZWhhdmlvciBvZiBjb2xvci5zdHkuXG4gICAgLy8gVGhpcyBpcyBjdXJyZW50bHkgdXNlZCBqdXN0IHRvIGNvcnJlY3RseSBjb2xvciBhIFxccmlnaHRcbiAgICAvLyB0aGF0IGZvbGxvd3MgYSBcXGNvbG9yIGNvbW1hbmQuXG5cbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY3VycmVudEBjb2xvclwiLCBjb2xvcik7IC8vIFBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keSB0aGF0IHNob3VsZCBiZSBjb2xvcmVkLlxuXG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29sb3IsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogY29sb3JfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGNvbG9yX21hdGhtbEJ1aWxkZXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9jci5qc1xuLy8gUm93IGJyZWFrcyB3aXRoaW4gdGFidWxhciBlbnZpcm9ubWVudHMsIGFuZCBsaW5lIGJyZWFrcyBhdCB0b3AgbGV2ZWxcblxuXG5cblxuIC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXFxcey4uLlxcQHhuZXdsaW5lfVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY3JcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3Qgc2l6ZSA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCA9PT0gXCJbXCIgPyBwYXJzZXIucGFyc2VTaXplR3JvdXAodHJ1ZSkgOiBudWxsO1xuICAgIGNvbnN0IG5ld0xpbmUgPSAhcGFyc2VyLnNldHRpbmdzLmRpc3BsYXlNb2RlIHx8ICFwYXJzZXIuc2V0dGluZ3MudXNlU3RyaWN0QmVoYXZpb3IoXCJuZXdMaW5lSW5EaXNwbGF5TW9kZVwiLCBcIkluIExhVGVYLCBcXFxcXFxcXCBvciBcXFxcbmV3bGluZSBcIiArIFwiZG9lcyBub3RoaW5nIGluIGRpc3BsYXkgbW9kZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuZXdMaW5lLFxuICAgICAgc2l6ZTogc2l6ZSAmJiBhc3NlcnROb2RlVHlwZShzaXplLCBcInNpemVcIikudmFsdWVcbiAgICB9O1xuICB9LFxuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYnVpbGRlcnMgYXJlIGNhbGxlZCBvbmx5IGF0IHRoZSB0b3AgbGV2ZWwsXG4gIC8vIG5vdCB3aXRoaW4gdGFidWxhci9hcnJheSBlbnZpcm9ubWVudHMuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiXSwgW10sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLm5ld0xpbmUpIHtcbiAgICAgIHNwYW4uY2xhc3Nlcy5wdXNoKFwibmV3bGluZVwiKTtcblxuICAgICAgaWYgKGdyb3VwLnNpemUpIHtcbiAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5Ub3AgPSBtYWtlRW0oY2FsY3VsYXRlU2l6ZShncm91cC5zaXplLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW47XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcblxuICAgIGlmIChncm91cC5uZXdMaW5lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmVicmVha1wiLCBcIm5ld2xpbmVcIik7XG5cbiAgICAgIGlmIChncm91cC5zaXplKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIG1ha2VFbShjYWxjdWxhdGVTaXplKGdyb3VwLnNpemUsIG9wdGlvbnMpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2RlZi5qc1xuXG5cblxuY29uc3QgZ2xvYmFsTWFwID0ge1xuICBcIlxcXFxnbG9iYWxcIjogXCJcXFxcZ2xvYmFsXCIsXG4gIFwiXFxcXGxvbmdcIjogXCJcXFxcXFxcXGdsb2JhbGxvbmdcIixcbiAgXCJcXFxcXFxcXGdsb2JhbGxvbmdcIjogXCJcXFxcXFxcXGdsb2JhbGxvbmdcIixcbiAgXCJcXFxcZGVmXCI6IFwiXFxcXGdkZWZcIixcbiAgXCJcXFxcZ2RlZlwiOiBcIlxcXFxnZGVmXCIsXG4gIFwiXFxcXGVkZWZcIjogXCJcXFxceGRlZlwiLFxuICBcIlxcXFx4ZGVmXCI6IFwiXFxcXHhkZWZcIixcbiAgXCJcXFxcbGV0XCI6IFwiXFxcXFxcXFxnbG9iYWxsZXRcIixcbiAgXCJcXFxcZnV0dXJlbGV0XCI6IFwiXFxcXFxcXFxnbG9iYWxmdXR1cmVcIlxufTtcblxuY29uc3QgY2hlY2tDb250cm9sU2VxdWVuY2UgPSB0b2sgPT4ge1xuICBjb25zdCBuYW1lID0gdG9rLnRleHQ7XG5cbiAgaWYgKC9eKD86W1xcXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkIGEgY29udHJvbCBzZXF1ZW5jZVwiLCB0b2spO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG5jb25zdCBnZXRSSFMgPSBwYXJzZXIgPT4ge1xuICBsZXQgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuXG4gIGlmICh0b2sudGV4dCA9PT0gXCI9XCIpIHtcbiAgICAvLyBjb25zdW1lIG9wdGlvbmFsIGVxdWFsc1xuICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcblxuICAgIGlmICh0b2sudGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgIC8vIGNvbnN1bWUgb25lIG9wdGlvbmFsIHNwYWNlXG4gICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvaztcbn07XG5cbmNvbnN0IGxldENvbW1hbmQgPSAocGFyc2VyLCBuYW1lLCB0b2ssIGdsb2JhbCkgPT4ge1xuICBsZXQgbWFjcm8gPSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQodG9rLnRleHQpO1xuXG4gIGlmIChtYWNybyA9PSBudWxsKSB7XG4gICAgLy8gZG9uJ3QgZXhwYW5kIGl0IGxhdGVyIGV2ZW4gaWYgYSBtYWNybyB3aXRoIHRoZSBzYW1lIG5hbWUgaXMgZGVmaW5lZFxuICAgIC8vIGUuZy4sIFxcbGV0XFxmb289XFxmcmFjIFxcZGVmXFxmcmFje1xccmVsYXh9IFxcZnJhYzEyXG4gICAgdG9rLm5vZXhwYW5kID0gdHJ1ZTtcbiAgICBtYWNybyA9IHtcbiAgICAgIHRva2VuczogW3Rva10sXG4gICAgICBudW1BcmdzOiAwLFxuICAgICAgLy8gcmVwcm9kdWNlIHRoZSBzYW1lIGJlaGF2aW9yIGluIGV4cGFuc2lvblxuICAgICAgdW5leHBhbmRhYmxlOiAhcGFyc2VyLmd1bGxldC5pc0V4cGFuZGFibGUodG9rLnRleHQpXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChuYW1lLCBtYWNybywgZ2xvYmFsKTtcbn07IC8vIDxhc3NpZ25tZW50PiAtPiA8bm9uLW1hY3JvIGFzc2lnbm1lbnQ+fDxtYWNybyBhc3NpZ25tZW50PlxuLy8gPG5vbi1tYWNybyBhc3NpZ25tZW50PiAtPiA8c2ltcGxlIGFzc2lnbm1lbnQ+fFxcZ2xvYmFsPG5vbi1tYWNybyBhc3NpZ25tZW50PlxuLy8gPG1hY3JvIGFzc2lnbm1lbnQ+IC0+IDxkZWZpbml0aW9uPnw8cHJlZml4PjxtYWNybyBhc3NpZ25tZW50PlxuLy8gPHByZWZpeD4gLT4gXFxnbG9iYWx8XFxsb25nfFxcb3V0ZXJcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxnbG9iYWxcIiwgXCJcXFxcbG9uZ1wiLCBcIlxcXFxcXFxcZ2xvYmFsbG9uZ1wiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgY29uc3QgdG9rZW4gPSBwYXJzZXIuZmV0Y2goKTtcblxuICAgIGlmIChnbG9iYWxNYXBbdG9rZW4udGV4dF0pIHtcbiAgICAgIC8vIEthVGVYIGRvZXNuJ3QgaGF2ZSBcXHBhciwgc28gaWdub3JlIFxcbG9uZ1xuICAgICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxnbG9iYWxcIiB8fCBmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGdsb2JhbGxvbmdcIikge1xuICAgICAgICB0b2tlbi50ZXh0ID0gZ2xvYmFsTWFwW3Rva2VuLnRleHRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJpbnRlcm5hbFwiKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIHRva2VuIGFmdGVyIG1hY3JvIHByZWZpeFwiLCB0b2tlbik7XG4gIH1cblxufSk7IC8vIEJhc2ljIHN1cHBvcnQgZm9yIG1hY3JvIGRlZmluaXRpb25zOiBcXGRlZiwgXFxnZGVmLCBcXGVkZWYsIFxceGRlZlxuLy8gPGRlZmluaXRpb24+IC0+IDxkZWY+PGNvbnRyb2wgc2VxdWVuY2U+PGRlZmluaXRpb24gdGV4dD5cbi8vIDxkZWY+IC0+IFxcZGVmfFxcZ2RlZnxcXGVkZWZ8XFx4ZGVmXG4vLyA8ZGVmaW5pdGlvbiB0ZXh0PiAtPiA8cGFyYW1ldGVyIHRleHQ+PGxlZnQgYnJhY2U+PGJhbGFuY2VkIHRleHQ+PHJpZ2h0IGJyYWNlPlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxkZWZcIiwgXCJcXFxcZ2RlZlwiLCBcIlxcXFxlZGVmXCIsIFwiXFxcXHhkZWZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjI7XG4gICAgbGV0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBjb25zdCBuYW1lID0gdG9rLnRleHQ7XG5cbiAgICBpZiAoL14oPzpbXFxcXHt9JCYjXl9dfEVPRikkLy50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIGNvbnRyb2wgc2VxdWVuY2VcIiwgdG9rKTtcbiAgICB9XG5cbiAgICBsZXQgbnVtQXJncyA9IDA7XG4gICAgbGV0IGluc2VydDtcbiAgICBjb25zdCBkZWxpbWl0ZXJzID0gW1tdXTsgLy8gPHBhcmFtZXRlciB0ZXh0PiBjb250YWlucyBubyBicmFjZXNcblxuICAgIHdoaWxlIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgIT09IFwie1wiKSB7XG4gICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG5cbiAgICAgIGlmICh0b2sudGV4dCA9PT0gXCIjXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIHZlcnkgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIDxwYXJhbWV0ZXIgdGV4dD4gaXMgIywgc28gdGhhdFxuICAgICAgICAvLyB0aGlzICMgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgeywgVGVYIHdpbGwgYmVoYXZlIGFzIGlmIHRoZSB7XG4gICAgICAgIC8vIGhhZCBiZWVuIGluc2VydGVkIGF0IHRoZSByaWdodCBlbmQgb2YgYm90aCB0aGUgcGFyYW1ldGVyIHRleHRcbiAgICAgICAgLy8gYW5kIHRoZSByZXBsYWNlbWVudCB0ZXh0LlxuICAgICAgICBpZiAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ID09PSBcIntcIikge1xuICAgICAgICAgIGluc2VydCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCk7XG4gICAgICAgICAgZGVsaW1pdGVyc1tudW1BcmdzXS5wdXNoKFwie1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBBIHBhcmFtZXRlciwgdGhlIGZpcnN0IGFwcGVhcmFuY2Ugb2YgIyBtdXN0IGJlIGZvbGxvd2VkIGJ5IDEsXG4gICAgICAgIC8vIHRoZSBuZXh0IGJ5IDIsIGFuZCBzbyBvbjsgdXAgdG8gbmluZSAj4oCZcyBhcmUgYWxsb3dlZFxuXG5cbiAgICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuXG4gICAgICAgIGlmICghL15bMS05XSQvLnRlc3QodG9rLnRleHQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBudW1iZXIgXFxcIlwiICsgdG9rLnRleHQgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VJbnQodG9rLnRleHQpICE9PSBudW1BcmdzICsgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkFyZ3VtZW50IG51bWJlciBcXFwiXCIgKyB0b2sudGV4dCArIFwiXFxcIiBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBudW1BcmdzKys7XG4gICAgICAgIGRlbGltaXRlcnMucHVzaChbXSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkIGEgbWFjcm8gZGVmaW5pdGlvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGltaXRlcnNbbnVtQXJnc10ucHVzaCh0b2sudGV4dCk7XG4gICAgICB9XG4gICAgfSAvLyByZXBsYWNlbWVudCB0ZXh0LCBlbmNsb3NlZCBpbiAneycgYW5kICd9JyBhbmQgcHJvcGVybHkgbmVzdGVkXG5cblxuICAgIGxldCB7XG4gICAgICB0b2tlbnNcbiAgICB9ID0gcGFyc2VyLmd1bGxldC5jb25zdW1lQXJnKCk7XG5cbiAgICBpZiAoaW5zZXJ0KSB7XG4gICAgICB0b2tlbnMudW5zaGlmdChpbnNlcnQpO1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcZWRlZlwiIHx8IGZ1bmNOYW1lID09PSBcIlxcXFx4ZGVmXCIpIHtcbiAgICAgIHRva2VucyA9IHBhcnNlci5ndWxsZXQuZXhwYW5kVG9rZW5zKHRva2Vucyk7XG4gICAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayBvcmRlclxuICAgIH0gLy8gRmluYWwgYXJnIGlzIHRoZSBleHBhbnNpb24gb2YgdGhlIG1hY3JvXG5cblxuICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChuYW1lLCB7XG4gICAgICB0b2tlbnMsXG4gICAgICBudW1BcmdzLFxuICAgICAgZGVsaW1pdGVyc1xuICAgIH0sIGZ1bmNOYW1lID09PSBnbG9iYWxNYXBbZnVuY05hbWVdKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGVcbiAgICB9O1xuICB9XG5cbn0pOyAvLyA8c2ltcGxlIGFzc2lnbm1lbnQ+IC0+IDxsZXQgYXNzaWdubWVudD5cbi8vIDxsZXQgYXNzaWdubWVudD4gLT4gXFxmdXR1cmVsZXQ8Y29udHJvbCBzZXF1ZW5jZT48dG9rZW4+PHRva2VuPlxuLy8gICAgIHwgXFxsZXQ8Y29udHJvbCBzZXF1ZW5jZT48ZXF1YWxzPjxvbmUgb3B0aW9uYWwgc3BhY2U+PHRva2VuPlxuLy8gPGVxdWFscz4gLT4gPG9wdGlvbmFsIHNwYWNlcz58PG9wdGlvbmFsIHNwYWNlcz49XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXGxldFwiLCBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjMpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjM7XG4gICAgY29uc3QgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7XG4gICAgcGFyc2VyLmd1bGxldC5jb25zdW1lU3BhY2VzKCk7XG4gICAgY29uc3QgdG9rID0gZ2V0UkhTKHBhcnNlcik7XG4gICAgbGV0Q29tbWFuZChwYXJzZXIsIG5hbWUsIHRvaywgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxsZXRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxuXG59KTsgLy8gcmVmOiBodHRwczovL3d3dy50dWcub3JnL1RVR2JvYXQvdGIwOS0zL3RiMjJiZWNodG9sc2hlaW0ucGRmXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXGZ1dHVyZWxldFwiLCBcIlxcXFxcXFxcZ2xvYmFsZnV0dXJlXCIgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjQpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjQ7XG4gICAgY29uc3QgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7XG4gICAgY29uc3QgbWlkZGxlID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIGNvbnN0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBsZXRDb21tYW5kKHBhcnNlciwgbmFtZSwgdG9rLCBmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGdsb2JhbGZ1dHVyZVwiKTtcbiAgICBwYXJzZXIuZ3VsbGV0LnB1c2hUb2tlbih0b2spO1xuICAgIHBhcnNlci5ndWxsZXQucHVzaFRva2VuKG1pZGRsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kZWxpbWl0ZXIuanNcbi8qKlxuICogVGhpcyBmaWxlIGRlYWxzIHdpdGggY3JlYXRpbmcgZGVsaW1pdGVycyBvZiB2YXJpb3VzIHNpemVzLiBUaGUgVGVYYm9va1xuICogZGlzY3Vzc2VzIHRoZXNlIHJvdXRpbmVzIG9uIHBhZ2UgNDQxLTQ0MiwgaW4gdGhlIFwiQW5vdGhlciBzdWJyb3V0aW5lIHNldHMgYm94XG4gKiB4IHRvIGEgc3BlY2lmaWVkIHZhcmlhYmxlIGRlbGltaXRlclwiIHBhcmFncmFwaC5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgbWFpbiByb3V0aW5lcyBoZXJlLiBgbWFrZVNtYWxsRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluIHRoZVxuICogbm9ybWFsIGZvbnQsIGJ1dCBpbiBlaXRoZXIgdGV4dCwgc2NyaXB0LCBvciBzY3JpcHRzY3JpcHQgc3R5bGUuXG4gKiBgbWFrZUxhcmdlRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluIHRleHRzdHlsZSwgYnV0IGluIG9uZSBvZiB0aGUgU2l6ZTEsXG4gKiBTaXplMiwgU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBgbWFrZVN0YWNrZWREZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgb3V0IG9mXG4gKiBzbWFsbGVyIHBpZWNlcyB0aGF0IGFyZSBzdGFja2VkIG9uIHRvcCBvZiBvbmUgYW5vdGhlci5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIHRha2UgYSBwYXJhbWV0ZXIgYGNlbnRlcmAsIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIGRlbGltaXRlclxuICogc2hvdWxkIGJlIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcy5cbiAqXG4gKiBUaGVuLCB0aGVyZSBhcmUgdGhyZWUgZXhwb3NlZCBmdW5jdGlvbnMuIGBzaXplZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBpblxuICogb25lIG9mIHRoZSBnaXZlbiBzaXplcy4gVGhpcyBpcyB1c2VkIGZvciB0aGluZ3MgbGlrZSBgXFxiaWdsYC5cbiAqIGBjdXN0b21TaXplZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciB3aXRoIGEgZ2l2ZW4gdG90YWwgaGVpZ2h0K2RlcHRoLiBJdCBpc1xuICogY2FsbGVkIGluIHBsYWNlcyBsaWtlIGBcXHNxcnRgLiBgbGVmdFJpZ2h0RGVsaW1gIG1ha2VzIGFuIGFwcHJvcHJpYXRlXG4gKiBkZWxpbWl0ZXIgd2hpY2ggc3Vycm91bmRzIGFuIGV4cHJlc3Npb24gb2YgYSBnaXZlbiBoZWlnaHQgYW4gZGVwdGguIEl0IGlzXG4gKiB1c2VkIGluIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAuXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIEdldCB0aGUgbWV0cmljcyBmb3IgYSBnaXZlbiBzeW1ib2wgYW5kIGZvbnQsIGFmdGVyIHRyYW5zZm9ybWF0aW9uIChpLmUuXG4gKiBhZnRlciBmb2xsb3dpbmcgcmVwbGFjZW1lbnQgZnJvbSBzeW1ib2xzLmpzKVxuICovXG5jb25zdCBnZXRNZXRyaWNzID0gZnVuY3Rpb24gKHN5bWJvbCwgZm9udCwgbW9kZSkge1xuICBjb25zdCByZXBsYWNlID0gc3JjX3N5bWJvbHMubWF0aFtzeW1ib2xdICYmIHNyY19zeW1ib2xzLm1hdGhbc3ltYm9sXS5yZXBsYWNlO1xuICBjb25zdCBtZXRyaWNzID0gZ2V0Q2hhcmFjdGVyTWV0cmljcyhyZXBsYWNlIHx8IHN5bWJvbCwgZm9udCwgbW9kZSk7XG5cbiAgaWYgKCFtZXRyaWNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc3ltYm9sIFwiICsgc3ltYm9sICsgXCIgYW5kIGZvbnQgc2l6ZSBcIiArIGZvbnQgKyBcIi5cIik7XG4gIH1cblxuICByZXR1cm4gbWV0cmljcztcbn07XG4vKipcbiAqIFB1dHMgYSBkZWxpbWl0ZXIgc3BhbiBpbiBhIGdpdmVuIHN0eWxlLCBhbmQgYWRkcyBhcHByb3ByaWF0ZSBoZWlnaHQsIGRlcHRoLFxuICogYW5kIG1heEZvbnRTaXplcy5cbiAqL1xuXG5cbmNvbnN0IHN0eWxlV3JhcCA9IGZ1bmN0aW9uIChkZWxpbSwgdG9TdHlsZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUodG9TdHlsZSk7XG4gIGNvbnN0IHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBbZGVsaW1dLCBvcHRpb25zKTtcbiAgY29uc3QgZGVsaW1TaXplTXVsdGlwbGllciA9IG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICBzcGFuLmhlaWdodCAqPSBkZWxpbVNpemVNdWx0aXBsaWVyO1xuICBzcGFuLmRlcHRoICo9IGRlbGltU2l6ZU11bHRpcGxpZXI7XG4gIHNwYW4ubWF4Rm9udFNpemUgPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICByZXR1cm4gc3Bhbjtcbn07XG5cbmNvbnN0IGNlbnRlclNwYW4gPSBmdW5jdGlvbiAoc3Bhbiwgb3B0aW9ucywgc3R5bGUpIHtcbiAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVN0eWxlKHN0eWxlKTtcbiAgY29uc3Qgc2hpZnQgPSAoMSAtIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyKSAqIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0O1xuICBzcGFuLmNsYXNzZXMucHVzaChcImRlbGltY2VudGVyXCIpO1xuICBzcGFuLnN0eWxlLnRvcCA9IG1ha2VFbShzaGlmdCk7XG4gIHNwYW4uaGVpZ2h0IC09IHNoaWZ0O1xuICBzcGFuLmRlcHRoICs9IHNoaWZ0O1xufTtcbi8qKlxuICogTWFrZXMgYSBzbWFsbCBkZWxpbWl0ZXIuIFRoaXMgaXMgYSBkZWxpbWl0ZXIgdGhhdCBjb21lcyBpbiB0aGUgTWFpbi1SZWd1bGFyXG4gKiBmb250LCBidXQgaXMgcmVzdHlsZWQgdG8gZWl0aGVyIGJlIGluIHRleHRzdHlsZSwgc2NyaXB0c3R5bGUsIG9yXG4gKiBzY3JpcHRzY3JpcHRzdHlsZS5cbiAqL1xuXG5cbmNvbnN0IG1ha2VTbWFsbERlbGltID0gZnVuY3Rpb24gKGRlbGltLCBzdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gIGNvbnN0IHRleHQgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGRlbGltLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcbiAgY29uc3Qgc3BhbiA9IHN0eWxlV3JhcCh0ZXh0LCBzdHlsZSwgb3B0aW9ucywgY2xhc3Nlcyk7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGNlbnRlclNwYW4oc3Bhbiwgb3B0aW9ucywgc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHNwYW47XG59O1xuLyoqXG4gKiBCdWlsZHMgYSBzeW1ib2wgaW4gdGhlIGdpdmVuIGZvbnQgc2l6ZSAobm90ZSBzaXplIGlzIGFuIGludGVnZXIpXG4gKi9cblxuXG5jb25zdCBtYXRocm1TaXplID0gZnVuY3Rpb24gKHZhbHVlLCBzaXplLCBtb2RlLCBvcHRpb25zKSB7XG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3ltYm9sKHZhbHVlLCBcIlNpemVcIiArIHNpemUgKyBcIi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMpO1xufTtcbi8qKlxuICogTWFrZXMgYSBsYXJnZSBkZWxpbWl0ZXIuIFRoaXMgaXMgYSBkZWxpbWl0ZXIgdGhhdCBjb21lcyBpbiB0aGUgU2l6ZTEsIFNpemUyLFxuICogU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBJdCBpcyBhbHdheXMgcmVuZGVyZWQgaW4gdGV4dHN0eWxlLlxuICovXG5cblxuY29uc3QgbWFrZUxhcmdlRGVsaW0gPSBmdW5jdGlvbiAoZGVsaW0sIHNpemUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICBjb25zdCBpbm5lciA9IG1hdGhybVNpemUoZGVsaW0sIHNpemUsIG1vZGUsIG9wdGlvbnMpO1xuICBjb25zdCBzcGFuID0gc3R5bGVXcmFwKGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImRlbGltc2l6aW5nXCIsIFwic2l6ZVwiICsgc2l6ZV0sIFtpbm5lcl0sIG9wdGlvbnMpLCBzcmNfU3R5bGUuVEVYVCwgb3B0aW9ucywgY2xhc3Nlcyk7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGNlbnRlclNwYW4oc3Bhbiwgb3B0aW9ucywgc3JjX1N0eWxlLlRFWFQpO1xuICB9XG5cbiAgcmV0dXJuIHNwYW47XG59O1xuLyoqXG4gKiBNYWtlIGEgc3BhbiBmcm9tIGEgZm9udCBnbHlwaCB3aXRoIHRoZSBnaXZlbiBvZmZzZXQgYW5kIGluIHRoZSBnaXZlbiBmb250LlxuICogVGhpcyBpcyB1c2VkIGluIG1ha2VTdGFja2VkRGVsaW0gdG8gbWFrZSB0aGUgc3RhY2tpbmcgcGllY2VzIGZvciB0aGUgZGVsaW1pdGVyLlxuICovXG5cblxuY29uc3QgbWFrZUdseXBoU3BhbiA9IGZ1bmN0aW9uIChzeW1ib2wsIGZvbnQsIG1vZGUpIHtcbiAgbGV0IHNpemVDbGFzczsgLy8gQXBwbHkgdGhlIGNvcnJlY3QgQ1NTIGNsYXNzIHRvIGNob29zZSB0aGUgcmlnaHQgZm9udC5cblxuICBpZiAoZm9udCA9PT0gXCJTaXplMS1SZWd1bGFyXCIpIHtcbiAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemUxXCI7XG4gIH0gZWxzZVxuICAgIC8qIGlmIChmb250ID09PSBcIlNpemU0LVJlZ3VsYXJcIikgKi9cbiAgICB7XG4gICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemU0XCI7XG4gICAgfVxuXG4gIGNvbnN0IGNvcm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImRlbGltc2l6aW5naW5uZXJcIiwgc2l6ZUNsYXNzXSwgW2J1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRDb21tb24ubWFrZVN5bWJvbChzeW1ib2wsIGZvbnQsIG1vZGUpXSldKTsgLy8gU2luY2UgdGhpcyB3aWxsIGJlIHBhc3NlZCBpbnRvIGBtYWtlVkxpc3RgIGluIHRoZSBlbmQsIHdyYXAgdGhlIGVsZW1lbnRcbiAgLy8gaW4gdGhlIGFwcHJvcHJpYXRlIHRhZyB0aGF0IFZMaXN0IHVzZXMuXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVsZW1cIixcbiAgICBlbGVtOiBjb3JuZXJcbiAgfTtcbn07XG5cbmNvbnN0IG1ha2VJbm5lciA9IGZ1bmN0aW9uIChjaCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gIC8vIENyZWF0ZSBhIHNwYW4gd2l0aCBpbmxpbmUgU1ZHIGZvciB0aGUgaW5uZXIgcGFydCBvZiBhIHRhbGwgc3RhY2tlZCBkZWxpbWl0ZXIuXG4gIGNvbnN0IHdpZHRoID0gZm9udE1ldHJpY3NEYXRhWydTaXplNC1SZWd1bGFyJ11bY2guY2hhckNvZGVBdCgwKV0gPyBmb250TWV0cmljc0RhdGFbJ1NpemU0LVJlZ3VsYXInXVtjaC5jaGFyQ29kZUF0KDApXVs0XSA6IGZvbnRNZXRyaWNzRGF0YVsnU2l6ZTEtUmVndWxhciddW2NoLmNoYXJDb2RlQXQoMCldWzRdO1xuICBjb25zdCBwYXRoID0gbmV3IFBhdGhOb2RlKFwiaW5uZXJcIiwgaW5uZXJQYXRoKGNoLCBNYXRoLnJvdW5kKDEwMDAgKiBoZWlnaHQpKSk7XG4gIGNvbnN0IHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICBcIndpZHRoXCI6IG1ha2VFbSh3aWR0aCksXG4gICAgXCJoZWlnaHRcIjogbWFrZUVtKGhlaWdodCksXG4gICAgLy8gT3ZlcnJpZGUgQ1NTIHJ1bGUgYC5rYXRleCBzdmcgeyB3aWR0aDogMTAwJSB9YFxuICAgIFwic3R5bGVcIjogXCJ3aWR0aDpcIiArIG1ha2VFbSh3aWR0aCksXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIFwiICsgMTAwMCAqIHdpZHRoICsgXCIgXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBoZWlnaHQpLFxuICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcInhNaW5ZTWluXCJcbiAgfSk7XG4gIGNvbnN0IHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgc3Bhbi5oZWlnaHQgPSBoZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7XG4gIHNwYW4uc3R5bGUud2lkdGggPSBtYWtlRW0od2lkdGgpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgIGVsZW06IHNwYW5cbiAgfTtcbn07IC8vIEhlbHBlcnMgZm9yIG1ha2VTdGFja2VkRGVsaW1cblxuXG5jb25zdCBsYXBJbkVtcyA9IDAuMDA4O1xuY29uc3QgbGFwID0ge1xuICB0eXBlOiBcImtlcm5cIixcbiAgc2l6ZTogLTEgKiBsYXBJbkVtc1xufTtcbmNvbnN0IHZlcnRzID0gW1wifFwiLCBcIlxcXFxsdmVydFwiLCBcIlxcXFxydmVydFwiLCBcIlxcXFx2ZXJ0XCJdO1xuY29uc3QgZG91YmxlVmVydHMgPSBbXCJcXFxcfFwiLCBcIlxcXFxsVmVydFwiLCBcIlxcXFxyVmVydFwiLCBcIlxcXFxWZXJ0XCJdO1xuLyoqXG4gKiBNYWtlIGEgc3RhY2tlZCBkZWxpbWl0ZXIgb3V0IG9mIGEgZ2l2ZW4gZGVsaW1pdGVyLCB3aXRoIHRoZSB0b3RhbCBoZWlnaHQgYXRcbiAqIGxlYXN0IGBoZWlnaHRUb3RhbGAuIFRoaXMgcm91dGluZSBpcyBtZW50aW9uZWQgb24gcGFnZSA0NDIgb2YgdGhlIFRlWGJvb2suXG4gKi9cblxuY29uc3QgbWFrZVN0YWNrZWREZWxpbSA9IGZ1bmN0aW9uIChkZWxpbSwgaGVpZ2h0VG90YWwsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAvLyBUaGVyZSBhcmUgZm91ciBwYXJ0cywgdGhlIHRvcCwgYW4gb3B0aW9uYWwgbWlkZGxlLCBhIHJlcGVhdGVkIHBhcnQsIGFuZCBhXG4gIC8vIGJvdHRvbS5cbiAgbGV0IHRvcDtcbiAgbGV0IG1pZGRsZTtcbiAgbGV0IHJlcGVhdDtcbiAgbGV0IGJvdHRvbTtcbiAgbGV0IHN2Z0xhYmVsID0gXCJcIjtcbiAgbGV0IHZpZXdCb3hXaWR0aCA9IDA7XG4gIHRvcCA9IHJlcGVhdCA9IGJvdHRvbSA9IGRlbGltO1xuICBtaWRkbGUgPSBudWxsOyAvLyBBbHNvIGtlZXAgdHJhY2sgb2Ygd2hhdCBmb250IHRoZSBkZWxpbWl0ZXJzIGFyZSBpblxuXG4gIGxldCBmb250ID0gXCJTaXplMS1SZWd1bGFyXCI7IC8vIFdlIHNldCB0aGUgcGFydHMgYW5kIGZvbnQgYmFzZWQgb24gdGhlIHN5bWJvbC4gTm90ZSB0aGF0IHdlIHVzZVxuICAvLyAnXFx1MjNkMCcgaW5zdGVhZCBvZiAnfCcgYW5kICdcXHUyMDE2JyBpbnN0ZWFkIG9mICdcXFxcfCcgZm9yIHRoZVxuICAvLyByZXBlYXRzIG9mIHRoZSBhcnJvd3NcblxuICBpZiAoZGVsaW0gPT09IFwiXFxcXHVwYXJyb3dcIikge1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNkMFwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxVcGFycm93XCIpIHtcbiAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIwMTZcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcZG93bmFycm93XCIpIHtcbiAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIzZDBcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcRG93bmFycm93XCIpIHtcbiAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBkb3duYXJyb3dcIikge1xuICAgIHRvcCA9IFwiXFxcXHVwYXJyb3dcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzZDBcIjtcbiAgICBib3R0b20gPSBcIlxcXFxkb3duYXJyb3dcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcVXBkb3duYXJyb3dcIikge1xuICAgIHRvcCA9IFwiXFxcXFVwYXJyb3dcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICBib3R0b20gPSBcIlxcXFxEb3duYXJyb3dcIjtcbiAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyh2ZXJ0cywgZGVsaW0pKSB7XG4gICAgcmVwZWF0ID0gXCJcXHUyMjIzXCI7XG4gICAgc3ZnTGFiZWwgPSBcInZlcnRcIjtcbiAgICB2aWV3Qm94V2lkdGggPSAzMzM7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoZG91YmxlVmVydHMsIGRlbGltKSkge1xuICAgIHJlcGVhdCA9IFwiXFx1MjIyNVwiO1xuICAgIHN2Z0xhYmVsID0gXCJkb3VibGV2ZXJ0XCI7XG4gICAgdmlld0JveFdpZHRoID0gNTU2O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIltcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNrXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYTFcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYTJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTNcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcImxicmFja1wiO1xuICAgIHZpZXdCb3hXaWR0aCA9IDY2NztcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJdXCIgfHwgZGVsaW0gPT09IFwiXFxcXHJicmFja1wiKSB7XG4gICAgdG9wID0gXCJcXHUyM2E0XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2E1XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2E2XCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIHN2Z0xhYmVsID0gXCJyYnJhY2tcIjtcbiAgICB2aWV3Qm94V2lkdGggPSA2Njc7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxmbG9vclwiIHx8IGRlbGltID09PSBcIlxcdTIzMGFcIikge1xuICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNhMlwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhM1wiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwibGZsb29yXCI7XG4gICAgdmlld0JveFdpZHRoID0gNjY3O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsY2VpbFwiIHx8IGRlbGltID09PSBcIlxcdTIzMDhcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhMVwiO1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNhMlwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwibGNlaWxcIjtcbiAgICB2aWV3Qm94V2lkdGggPSA2Njc7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJmbG9vclwiIHx8IGRlbGltID09PSBcIlxcdTIzMGJcIikge1xuICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNhNVwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhNlwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwicmZsb29yXCI7XG4gICAgdmlld0JveFdpZHRoID0gNjY3O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxyY2VpbFwiIHx8IGRlbGltID09PSBcIlxcdTIzMDlcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhNFwiO1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNhNVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwicmNlaWxcIjtcbiAgICB2aWV3Qm94V2lkdGggPSA2Njc7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiKFwiIHx8IGRlbGltID09PSBcIlxcXFxscGFyZW5cIikge1xuICAgIHRvcCA9IFwiXFx1MjM5YlwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjM5Y1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjM5ZFwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwibHBhcmVuXCI7XG4gICAgdmlld0JveFdpZHRoID0gODc1O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIilcIiB8fCBkZWxpbSA9PT0gXCJcXFxccnBhcmVuXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzOWVcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzOWZcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTBcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcInJwYXJlblwiO1xuICAgIHZpZXdCb3hXaWR0aCA9IDg3NTtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxce1wiIHx8IGRlbGltID09PSBcIlxcXFxsYnJhY2VcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhN1wiO1xuICAgIG1pZGRsZSA9IFwiXFx1MjNhOFwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhOVwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcfVwiIHx8IGRlbGltID09PSBcIlxcXFxyYnJhY2VcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgIG1pZGRsZSA9IFwiXFx1MjNhY1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhZFwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGdyb3VwXCIgfHwgZGVsaW0gPT09IFwiXFx1MjdlZVwiKSB7XG4gICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2E5XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxyZ3JvdXBcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2VmXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxtb3VzdGFjaGVcIiB8fCBkZWxpbSA9PT0gXCJcXHUyM2IwXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYTdcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJtb3VzdGFjaGVcIiB8fCBkZWxpbSA9PT0gXCJcXHUyM2IxXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTlcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gLy8gR2V0IHRoZSBtZXRyaWNzIG9mIHRoZSBmb3VyIHNlY3Rpb25zXG5cblxuICBjb25zdCB0b3BNZXRyaWNzID0gZ2V0TWV0cmljcyh0b3AsIGZvbnQsIG1vZGUpO1xuICBjb25zdCB0b3BIZWlnaHRUb3RhbCA9IHRvcE1ldHJpY3MuaGVpZ2h0ICsgdG9wTWV0cmljcy5kZXB0aDtcbiAgY29uc3QgcmVwZWF0TWV0cmljcyA9IGdldE1ldHJpY3MocmVwZWF0LCBmb250LCBtb2RlKTtcbiAgY29uc3QgcmVwZWF0SGVpZ2h0VG90YWwgPSByZXBlYXRNZXRyaWNzLmhlaWdodCArIHJlcGVhdE1ldHJpY3MuZGVwdGg7XG4gIGNvbnN0IGJvdHRvbU1ldHJpY3MgPSBnZXRNZXRyaWNzKGJvdHRvbSwgZm9udCwgbW9kZSk7XG4gIGNvbnN0IGJvdHRvbUhlaWdodFRvdGFsID0gYm90dG9tTWV0cmljcy5oZWlnaHQgKyBib3R0b21NZXRyaWNzLmRlcHRoO1xuICBsZXQgbWlkZGxlSGVpZ2h0VG90YWwgPSAwO1xuICBsZXQgbWlkZGxlRmFjdG9yID0gMTtcblxuICBpZiAobWlkZGxlICE9PSBudWxsKSB7XG4gICAgY29uc3QgbWlkZGxlTWV0cmljcyA9IGdldE1ldHJpY3MobWlkZGxlLCBmb250LCBtb2RlKTtcbiAgICBtaWRkbGVIZWlnaHRUb3RhbCA9IG1pZGRsZU1ldHJpY3MuaGVpZ2h0ICsgbWlkZGxlTWV0cmljcy5kZXB0aDtcbiAgICBtaWRkbGVGYWN0b3IgPSAyOyAvLyByZXBlYXQgc3ltbWV0cmljYWxseSBhYm92ZSBhbmQgYmVsb3cgbWlkZGxlXG4gIH0gLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbWFsIGhlaWdodCB0aGF0IHRoZSBkZWxpbWl0ZXIgY2FuIGhhdmUuXG4gIC8vIEl0IGlzIGF0IGxlYXN0IHRoZSBzaXplIG9mIHRoZSB0b3AsIGJvdHRvbSwgYW5kIG9wdGlvbmFsIG1pZGRsZSBjb21iaW5lZC5cblxuXG4gIGNvbnN0IG1pbkhlaWdodCA9IHRvcEhlaWdodFRvdGFsICsgYm90dG9tSGVpZ2h0VG90YWwgKyBtaWRkbGVIZWlnaHRUb3RhbDsgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGNvcGllcyBvZiB0aGUgcmVwZWF0IHN5bWJvbCB3ZSB3aWxsIG5lZWRcblxuICBjb25zdCByZXBlYXRDb3VudCA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoaGVpZ2h0VG90YWwgLSBtaW5IZWlnaHQpIC8gKG1pZGRsZUZhY3RvciAqIHJlcGVhdEhlaWdodFRvdGFsKSkpOyAvLyBDb21wdXRlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRlbGltaXRlciBpbmNsdWRpbmcgYWxsIHRoZSBzeW1ib2xzXG5cbiAgY29uc3QgcmVhbEhlaWdodFRvdGFsID0gbWluSGVpZ2h0ICsgcmVwZWF0Q291bnQgKiBtaWRkbGVGYWN0b3IgKiByZXBlYXRIZWlnaHRUb3RhbDsgLy8gVGhlIGNlbnRlciBvZiB0aGUgZGVsaW1pdGVyIGlzIHBsYWNlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBheGlzLiBOb3RlXG4gIC8vIHRoYXQgaW4gdGhpcyBjb250ZXh0LCBcImNlbnRlclwiIG1lYW5zIHRoYXQgdGhlIGRlbGltaXRlciBzaG91bGQgYmVcbiAgLy8gY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBjdXJyZW50IHN0eWxlLCB3aGlsZSBub3JtYWxseSBpdCBpc1xuICAvLyBjZW50ZXJlZCBhcm91bmQgdGhlIGF4aXMgaW4gdGV4dHN0eWxlLlxuXG4gIGxldCBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGF4aXNIZWlnaHQgKj0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgfSAvLyBDYWxjdWxhdGUgdGhlIGRlcHRoXG5cblxuICBjb25zdCBkZXB0aCA9IHJlYWxIZWlnaHRUb3RhbCAvIDIgLSBheGlzSGVpZ2h0OyAvLyBOb3csIHdlIHN0YXJ0IGJ1aWxkaW5nIHRoZSBwaWVjZXMgdGhhdCB3aWxsIGdvIGludG8gdGhlIHZsaXN0XG4gIC8vIEtlZXAgYSBsaXN0IG9mIHRoZSBwaWVjZXMgb2YgdGhlIHN0YWNrZWQgZGVsaW1pdGVyXG5cbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBpZiAoc3ZnTGFiZWwubGVuZ3RoID4gMCkge1xuICAgIC8vIEluc3RlYWQgb2Ygc3RhY2tpbmcgZ2x5cGhzLCBjcmVhdGUgYSBzaW5nbGUgU1ZHLlxuICAgIC8vIFRoaXMgZXZhZGVzIGJyb3dzZXIgcHJvYmxlbXMgd2l0aCBpbXByZWNpc2UgcG9zaXRpb25pbmcgb2Ygc3BhbnMuXG4gICAgY29uc3QgbWlkSGVpZ2h0ID0gcmVhbEhlaWdodFRvdGFsIC0gdG9wSGVpZ2h0VG90YWwgLSBib3R0b21IZWlnaHRUb3RhbDtcbiAgICBjb25zdCB2aWV3Qm94SGVpZ2h0ID0gTWF0aC5yb3VuZChyZWFsSGVpZ2h0VG90YWwgKiAxMDAwKTtcbiAgICBjb25zdCBwYXRoU3RyID0gdGFsbERlbGltKHN2Z0xhYmVsLCBNYXRoLnJvdW5kKG1pZEhlaWdodCAqIDEwMDApKTtcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGhOb2RlKHN2Z0xhYmVsLCBwYXRoU3RyKTtcbiAgICBjb25zdCB3aWR0aCA9ICh2aWV3Qm94V2lkdGggLyAxMDAwKS50b0ZpeGVkKDMpICsgXCJlbVwiO1xuICAgIGNvbnN0IGhlaWdodCA9ICh2aWV3Qm94SGVpZ2h0IC8gMTAwMCkudG9GaXhlZCgzKSArIFwiZW1cIjtcbiAgICBjb25zdCBzdmcgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICAgIFwid2lkdGhcIjogd2lkdGgsXG4gICAgICBcImhlaWdodFwiOiBoZWlnaHQsXG4gICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIHZpZXdCb3hIZWlnaHRcbiAgICB9KTtcbiAgICBjb25zdCB3cmFwcGVyID0gYnVpbGRDb21tb24ubWFrZVN2Z1NwYW4oW10sIFtzdmddLCBvcHRpb25zKTtcbiAgICB3cmFwcGVyLmhlaWdodCA9IHZpZXdCb3hIZWlnaHQgLyAxMDAwO1xuICAgIHdyYXBwZXIuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICBzdGFjay5wdXNoKHtcbiAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgZWxlbTogd3JhcHBlclxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0YWNrIGdseXBoc1xuICAgIC8vIFN0YXJ0IGJ5IGFkZGluZyB0aGUgYm90dG9tIHN5bWJvbFxuICAgIHN0YWNrLnB1c2gobWFrZUdseXBoU3Bhbihib3R0b20sIGZvbnQsIG1vZGUpKTtcbiAgICBzdGFjay5wdXNoKGxhcCk7IC8vIG92ZXJsYXBcblxuICAgIGlmIChtaWRkbGUgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBtaWRkbGUgc2VjdGlvbiB3aWxsIGJlIGFuIFNWRy4gTWFrZSBpdCBhbiBleHRyYSAwLjAxNmVtIHRhbGwuXG4gICAgICAvLyBXZSdsbCBvdmVybGFwIGJ5IDAuMDA4ZW0gYXQgdG9wIGFuZCBib3R0b20uXG4gICAgICBjb25zdCBpbm5lckhlaWdodCA9IHJlYWxIZWlnaHRUb3RhbCAtIHRvcEhlaWdodFRvdGFsIC0gYm90dG9tSGVpZ2h0VG90YWwgKyAyICogbGFwSW5FbXM7XG4gICAgICBzdGFjay5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIGlubmVySGVpZ2h0LCBvcHRpb25zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYSBtaWRkbGUgYml0LCB3ZSBuZWVkIHRoZSBtaWRkbGUgcGFydCBhbmQgdHdvIHJlcGVhdGVkXG4gICAgICAvLyBzZWN0aW9uc1xuICAgICAgY29uc3QgaW5uZXJIZWlnaHQgPSAocmVhbEhlaWdodFRvdGFsIC0gdG9wSGVpZ2h0VG90YWwgLSBib3R0b21IZWlnaHRUb3RhbCAtIG1pZGRsZUhlaWdodFRvdGFsKSAvIDIgKyAyICogbGFwSW5FbXM7XG4gICAgICBzdGFjay5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIGlubmVySGVpZ2h0LCBvcHRpb25zKSk7IC8vIE5vdyBpbnNlcnQgdGhlIG1pZGRsZSBvZiB0aGUgYnJhY2UuXG5cbiAgICAgIHN0YWNrLnB1c2gobGFwKTtcbiAgICAgIHN0YWNrLnB1c2gobWFrZUdseXBoU3BhbihtaWRkbGUsIGZvbnQsIG1vZGUpKTtcbiAgICAgIHN0YWNrLnB1c2gobGFwKTtcbiAgICAgIHN0YWNrLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgaW5uZXJIZWlnaHQsIG9wdGlvbnMpKTtcbiAgICB9IC8vIEFkZCB0aGUgdG9wIHN5bWJvbFxuXG5cbiAgICBzdGFjay5wdXNoKGxhcCk7XG4gICAgc3RhY2sucHVzaChtYWtlR2x5cGhTcGFuKHRvcCwgZm9udCwgbW9kZSkpO1xuICB9IC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuXG5cbiAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVN0eWxlKHNyY19TdHlsZS5URVhUKTtcbiAgY29uc3QgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICBwb3NpdGlvbkRhdGE6IGRlcHRoLFxuICAgIGNoaWxkcmVuOiBzdGFja1xuICB9LCBuZXdPcHRpb25zKTtcbiAgcmV0dXJuIHN0eWxlV3JhcChidWlsZENvbW1vbi5tYWtlU3BhbihbXCJkZWxpbXNpemluZ1wiLCBcIm11bHRcIl0sIFtpbm5lcl0sIG5ld09wdGlvbnMpLCBzcmNfU3R5bGUuVEVYVCwgb3B0aW9ucywgY2xhc3Nlcyk7XG59OyAvLyBBbGwgc3VyZHMgaGF2ZSAwLjA4ZW0gcGFkZGluZyBhYm92ZSB0aGUgdmluY3VsdW0gaW5zaWRlIHRoZSBTVkcuXG4vLyBUaGF0IGtlZXBzIGJyb3dzZXIgc3BhbiBoZWlnaHQgcm91bmRpbmcgZXJyb3IgZnJvbSBwaW5jaGluZyB0aGUgbGluZS5cblxuXG5jb25zdCB2YlBhZCA9IDgwOyAvLyBwYWRkaW5nIGFib3ZlIHRoZSBzdXJkLCBtZWFzdXJlZCBpbnNpZGUgdGhlIHZpZXdCb3guXG5cbmNvbnN0IGVtUGFkID0gMC4wODsgLy8gcGFkZGluZywgaW4gZW1zLCBtZWFzdXJlZCBpbiB0aGUgZG9jdW1lbnQuXG5cbmNvbnN0IHNxcnRTdmcgPSBmdW5jdGlvbiAoc3FydE5hbWUsIGhlaWdodCwgdmlld0JveEhlaWdodCwgZXh0cmFWaW5jdWx1bSwgb3B0aW9ucykge1xuICBjb25zdCBwYXRoID0gc3FydFBhdGgoc3FydE5hbWUsIGV4dHJhVmluY3VsdW0sIHZpZXdCb3hIZWlnaHQpO1xuICBjb25zdCBwYXRoTm9kZSA9IG5ldyBQYXRoTm9kZShzcXJ0TmFtZSwgcGF0aCk7XG4gIGNvbnN0IHN2ZyA9IG5ldyBTdmdOb2RlKFtwYXRoTm9kZV0sIHtcbiAgICAvLyBOb3RlOiAxMDAwOjEgcmF0aW8gb2Ygdmlld0JveCB0byBkb2N1bWVudCBlbSB3aWR0aC5cbiAgICBcIndpZHRoXCI6IFwiNDAwZW1cIixcbiAgICBcImhlaWdodFwiOiBtYWtlRW0oaGVpZ2h0KSxcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgNDAwMDAwIFwiICsgdmlld0JveEhlaWdodCxcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWluWU1pbiBzbGljZVwiXG4gIH0pO1xuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVN2Z1NwYW4oW1wiaGlkZS10YWlsXCJdLCBbc3ZnXSwgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBNYWtlIGEgc3FydCBpbWFnZSBvZiB0aGUgZ2l2ZW4gaGVpZ2h0LFxuICovXG5cblxuY29uc3QgbWFrZVNxcnRJbWFnZSA9IGZ1bmN0aW9uIChoZWlnaHQsIG9wdGlvbnMpIHtcbiAgLy8gRGVmaW5lIGEgbmV3T3B0aW9ucyB0aGF0IHJlbW92ZXMgdGhlIGVmZmVjdCBvZiBzaXplIGNoYW5nZXMgc3VjaCBhcyBcXEh1Z2UuXG4gIC8vIFdlIGRvbid0IHBpY2sgZGlmZmVyZW50IGEgaGVpZ2h0IHN1cmQgZm9yIFxcSHVnZS4gRm9yIGl0LCB3ZSBzY2FsZSB1cC5cbiAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVNpemluZygpOyAvLyBQaWNrIHRoZSBkZXNpcmVkIHN1cmQgZ2x5cGggZnJvbSBhIHNlcXVlbmNlIG9mIHN1cmRzLlxuXG4gIGNvbnN0IGRlbGltID0gdHJhdmVyc2VTZXF1ZW5jZShcIlxcXFxzdXJkXCIsIGhlaWdodCAqIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIsIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSwgbmV3T3B0aW9ucyk7XG4gIGxldCBzaXplTXVsdGlwbGllciA9IG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIGRlZmF1bHRcbiAgLy8gVGhlIHN0YW5kYXJkIHNxcnQgU1ZHcyBlYWNoIGhhdmUgYSAwLjA0ZW0gdGhpY2sgdmluY3VsdW0uXG4gIC8vIElmIFNldHRpbmdzLm1pblJ1bGVUaGlja25lc3MgaXMgbGFyZ2VyIHRoYW4gdGhhdCwgd2UgYWRkIGV4dHJhVmluY3VsdW0uXG5cbiAgY29uc3QgZXh0cmFWaW5jdWx1bSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAtIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5zcXJ0UnVsZVRoaWNrbmVzcyk7IC8vIENyZWF0ZSBhIHNwYW4gY29udGFpbmluZyBhbiBTVkcgaW1hZ2Ugb2YgYSBzcXJ0IHN5bWJvbC5cblxuICBsZXQgc3BhbjtcbiAgbGV0IHNwYW5IZWlnaHQgPSAwO1xuICBsZXQgdGV4SGVpZ2h0ID0gMDtcbiAgbGV0IHZpZXdCb3hIZWlnaHQgPSAwO1xuICBsZXQgYWR2YW5jZVdpZHRoOyAvLyBXZSBjcmVhdGUgdmlld0JveGVzIHdpdGggODAgdW5pdHMgb2YgXCJwYWRkaW5nXCIgYWJvdmUgZWFjaCBzdXJkLlxuICAvLyBUaGVuIGJyb3dzZXIgcm91bmRpbmcgZXJyb3Igb24gdGhlIHBhcmVudCBzcGFuIGhlaWdodCB3aWxsIG5vdFxuICAvLyBlbmNyb2FjaCBvbiB0aGUgaW5rIG9mIHRoZSB2aW5jdWx1bS4gQnV0IHRoYXQgcGFkZGluZyBpcyBub3RcbiAgLy8gaW5jbHVkZWQgaW4gdGhlIFRlWC1saWtlIGBoZWlnaHRgIHVzZWQgZm9yIGNhbGN1bGF0aW9uIG9mXG4gIC8vIHZlcnRpY2FsIGFsaWdubWVudC4gU28gdGV4SGVpZ2h0ID0gc3Bhbi5oZWlnaHQgPCBzcGFuLnN0eWxlLmhlaWdodC5cblxuICBpZiAoZGVsaW0udHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgLy8gR2V0IGFuIFNWRyB0aGF0IGlzIGRlcml2ZWQgZnJvbSBnbHlwaCBVKzIyMUEgaW4gZm9udCBLYVRlWC1NYWluLlxuICAgIC8vIDEwMDAgdW5pdCBub3JtYWwgZ2x5cGggaGVpZ2h0LlxuICAgIHZpZXdCb3hIZWlnaHQgPSAxMDAwICsgMTAwMCAqIGV4dHJhVmluY3VsdW0gKyB2YlBhZDtcblxuICAgIGlmIChoZWlnaHQgPCAxLjApIHtcbiAgICAgIHNpemVNdWx0aXBsaWVyID0gMS4wOyAvLyBtaW1pYyBhIFxcdGV4dGZvbnQgcmFkaWNhbFxuICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMS40KSB7XG4gICAgICBzaXplTXVsdGlwbGllciA9IDAuNzsgLy8gbWltaWMgYSBcXHNjcmlwdGZvbnQgcmFkaWNhbFxuICAgIH1cblxuICAgIHNwYW5IZWlnaHQgPSAoMS4wICsgZXh0cmFWaW5jdWx1bSArIGVtUGFkKSAvIHNpemVNdWx0aXBsaWVyO1xuICAgIHRleEhlaWdodCA9ICgxLjAwICsgZXh0cmFWaW5jdWx1bSkgLyBzaXplTXVsdGlwbGllcjtcbiAgICBzcGFuID0gc3FydFN2ZyhcInNxcnRNYWluXCIsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluY3VsdW0sIG9wdGlvbnMpO1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBcIjAuODUzZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAwLjgzMyAvIHNpemVNdWx0aXBsaWVyOyAvLyBmcm9tIHRoZSBmb250LlxuICB9IGVsc2UgaWYgKGRlbGltLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgIC8vIFRoZXNlIFNWR3MgY29tZSBmcm9tIGZvbnRzOiBLYVRlWF9TaXplMSwgX1NpemUyLCBldGMuXG4gICAgdmlld0JveEhlaWdodCA9ICgxMDAwICsgdmJQYWQpICogc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdO1xuICAgIHRleEhlaWdodCA9IChzaXplVG9NYXhIZWlnaHRbZGVsaW0uc2l6ZV0gKyBleHRyYVZpbmN1bHVtKSAvIHNpemVNdWx0aXBsaWVyO1xuICAgIHNwYW5IZWlnaHQgPSAoc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdICsgZXh0cmFWaW5jdWx1bSArIGVtUGFkKSAvIHNpemVNdWx0aXBsaWVyO1xuICAgIHNwYW4gPSBzcXJ0U3ZnKFwic3FydFNpemVcIiArIGRlbGltLnNpemUsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluY3VsdW0sIG9wdGlvbnMpO1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBcIjEuMDJlbVwiO1xuICAgIGFkdmFuY2VXaWR0aCA9IDEuMCAvIHNpemVNdWx0aXBsaWVyOyAvLyAxLjAgZnJvbSB0aGUgZm9udC5cbiAgfSBlbHNlIHtcbiAgICAvLyBUYWxsIHNxcnQuIEluIFRlWCwgdGhpcyB3b3VsZCBiZSBzdGFja2VkIHVzaW5nIG11bHRpcGxlIGdseXBocy5cbiAgICAvLyBXZSdsbCB1c2UgYSBzaW5nbGUgU1ZHIHRvIGFjY29tcGxpc2ggdGhlIHNhbWUgdGhpbmcuXG4gICAgc3BhbkhlaWdodCA9IGhlaWdodCArIGV4dHJhVmluY3VsdW0gKyBlbVBhZDtcbiAgICB0ZXhIZWlnaHQgPSBoZWlnaHQgKyBleHRyYVZpbmN1bHVtO1xuICAgIHZpZXdCb3hIZWlnaHQgPSBNYXRoLmZsb29yKDEwMDAgKiBoZWlnaHQgKyBleHRyYVZpbmN1bHVtKSArIHZiUGFkO1xuICAgIHNwYW4gPSBzcXJ0U3ZnKFwic3FydFRhbGxcIiwgc3BhbkhlaWdodCwgdmlld0JveEhlaWdodCwgZXh0cmFWaW5jdWx1bSwgb3B0aW9ucyk7XG4gICAgc3Bhbi5zdHlsZS5taW5XaWR0aCA9IFwiMC43NDJlbVwiO1xuICAgIGFkdmFuY2VXaWR0aCA9IDEuMDU2O1xuICB9XG5cbiAgc3Bhbi5oZWlnaHQgPSB0ZXhIZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKHNwYW5IZWlnaHQpO1xuICByZXR1cm4ge1xuICAgIHNwYW4sXG4gICAgYWR2YW5jZVdpZHRoLFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYWN0dWFsIGxpbmUgd2lkdGguXG4gICAgLy8gVGhpcyBhY3R1YWxseSBzaG91bGQgZGVwZW5kIG9uIHRoZSBjaG9zZW4gZm9udCAtLSBlLmcuIFxcYm9sZG1hdGhcbiAgICAvLyBzaG91bGQgdXNlIHRoZSB0aGlja2VyIHN1cmQgc3ltYm9scyBmcm9tIGUuZy4gS2FUZVhfTWFpbi1Cb2xkLCBhbmRcbiAgICAvLyBoYXZlIHRoaWNrZXIgcnVsZXMuXG4gICAgcnVsZVdpZHRoOiAob3B0aW9ucy5mb250TWV0cmljcygpLnNxcnRSdWxlVGhpY2tuZXNzICsgZXh0cmFWaW5jdWx1bSkgKiBzaXplTXVsdGlwbGllclxuICB9O1xufTsgLy8gVGhlcmUgYXJlIHRocmVlIGtpbmRzIG9mIGRlbGltaXRlcnMsIGRlbGltaXRlcnMgdGhhdCBzdGFjayB3aGVuIHRoZXkgYmVjb21lXG4vLyB0b28gbGFyZ2VcblxuXG5jb25zdCBzdGFja0xhcmdlRGVsaW1pdGVycyA9IFtcIihcIiwgXCJcXFxcbHBhcmVuXCIsIFwiKVwiLCBcIlxcXFxycGFyZW5cIiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsIFwiXFxcXHtcIiwgXCJcXFxcbGJyYWNlXCIsIFwiXFxcXH1cIiwgXCJcXFxccmJyYWNlXCIsIFwiXFxcXGxmbG9vclwiLCBcIlxcXFxyZmxvb3JcIiwgXCJcXHUyMzBhXCIsIFwiXFx1MjMwYlwiLCBcIlxcXFxsY2VpbFwiLCBcIlxcXFxyY2VpbFwiLCBcIlxcdTIzMDhcIiwgXCJcXHUyMzA5XCIsIFwiXFxcXHN1cmRcIl07IC8vIGRlbGltaXRlcnMgdGhhdCBhbHdheXMgc3RhY2tcblxuY29uc3Qgc3RhY2tBbHdheXNEZWxpbWl0ZXJzID0gW1wiXFxcXHVwYXJyb3dcIiwgXCJcXFxcZG93bmFycm93XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIFwifFwiLCBcIlxcXFx8XCIsIFwiXFxcXHZlcnRcIiwgXCJcXFxcVmVydFwiLCBcIlxcXFxsdmVydFwiLCBcIlxcXFxydmVydFwiLCBcIlxcXFxsVmVydFwiLCBcIlxcXFxyVmVydFwiLCBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFx1MjdlZVwiLCBcIlxcdTI3ZWZcIiwgXCJcXFxcbG1vdXN0YWNoZVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIFwiXFx1MjNiMFwiLCBcIlxcdTIzYjFcIl07IC8vIGFuZCBkZWxpbWl0ZXJzIHRoYXQgbmV2ZXIgc3RhY2tcblxuY29uc3Qgc3RhY2tOZXZlckRlbGltaXRlcnMgPSBbXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIl07IC8vIE1ldHJpY3Mgb2YgdGhlIGRpZmZlcmVudCBzaXplcy4gRm91bmQgYnkgbG9va2luZyBhdCBUZVgncyBvdXRwdXQgb2Zcbi8vICRcXGJpZ2x8IC8vIFxcQmlnbHwgXFxiaWdnbHwgXFxCaWdnbHwgXFxzaG93bGlzdHMkXG4vLyBVc2VkIHRvIGNyZWF0ZSBzdGFja2VkIGRlbGltaXRlcnMgb2YgYXBwcm9wcmlhdGUgc2l6ZXMgaW4gbWFrZVNpemVkRGVsaW0uXG5cbmNvbnN0IHNpemVUb01heEhlaWdodCA9IFswLCAxLjIsIDEuOCwgMi40LCAzLjBdO1xuLyoqXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiBhIHNwZWNpZmljIHNpemUsIHdoZXJlIGBzaXplYCBpcyAxLCAyLCAzLCBvciA0LlxuICovXG5cbmNvbnN0IG1ha2VTaXplZERlbGltID0gZnVuY3Rpb24gKGRlbGltLCBzaXplLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gIC8vIDwgYW5kID4gdHVybiBpbnRvIFxcbGFuZ2xlIGFuZCBcXHJhbmdsZSBpbiBkZWxpbWl0ZXJzXG4gIGlmIChkZWxpbSA9PT0gXCI8XCIgfHwgZGVsaW0gPT09IFwiXFxcXGx0XCIgfHwgZGVsaW0gPT09IFwiXFx1MjdlOFwiKSB7XG4gICAgZGVsaW0gPSBcIlxcXFxsYW5nbGVcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCI+XCIgfHwgZGVsaW0gPT09IFwiXFxcXGd0XCIgfHwgZGVsaW0gPT09IFwiXFx1MjdlOVwiKSB7XG4gICAgZGVsaW0gPSBcIlxcXFxyYW5nbGVcIjtcbiAgfSAvLyBTaXplZCBkZWxpbWl0ZXJzIGFyZSBuZXZlciBjZW50ZXJlZC5cblxuXG4gIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pIHx8IHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIHNpemUsIGZhbHNlLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdGFja0Fsd2F5c0RlbGltaXRlcnMsIGRlbGltKSkge1xuICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKGRlbGltLCBzaXplVG9NYXhIZWlnaHRbc2l6ZV0sIGZhbHNlLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbGxlZ2FsIGRlbGltaXRlcjogJ1wiICsgZGVsaW0gKyBcIidcIik7XG4gIH1cbn07XG4vKipcbiAqIFRoZXJlIGFyZSB0aHJlZSBkaWZmZXJlbnQgc2VxdWVuY2VzIG9mIGRlbGltaXRlciBzaXplcyB0aGF0IHRoZSBkZWxpbWl0ZXJzXG4gKiBmb2xsb3cgZGVwZW5kaW5nIG9uIHRoZSBraW5kIG9mIGRlbGltaXRlci4gVGhpcyBpcyB1c2VkIHdoZW4gY3JlYXRpbmcgY3VzdG9tXG4gKiBzaXplZCBkZWxpbWl0ZXJzIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGNyZWF0ZSBhIHNtYWxsLCBsYXJnZSwgb3Igc3RhY2tlZFxuICogZGVsaW1pdGVyLlxuICpcbiAqIEluIHJlYWwgVGVYLCB0aGVzZSBzZXF1ZW5jZXMgYXJlbid0IGV4cGxpY2l0bHkgZGVmaW5lZCwgYnV0IGFyZSBpbnN0ZWFkXG4gKiBkZWZpbmVkIGluc2lkZSB0aGUgZm9udCBtZXRyaWNzLiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZSBzZXF1ZW5jZXMgdGhhdFxuICogYXJlIHBvc3NpYmxlIGZvciB0aGUgZGVsaW1pdGVycyB0aGF0IFRlWCBkZWZpbmVzLCBpdCBpcyBlYXNpZXIgdG8ganVzdCBlbmNvZGVcbiAqIHRoZW0gZXhwbGljaXRseSBoZXJlLlxuICovXG5cblxuLy8gRGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrIHRyeSBzbWFsbCBkZWxpbWl0ZXJzIGFuZCBsYXJnZSBkZWxpbWl0ZXJzIG9ubHlcbmNvbnN0IHN0YWNrTmV2ZXJEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuVEVYVFxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDFcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAyXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogM1xufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDRcbn1dOyAvLyBEZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrIHRyeSB0aGUgc21hbGwgZGVsaW1pdGVycyBmaXJzdCwgdGhlbiBzdGFja1xuXG5jb25zdCBzdGFja0Fsd2F5c0RlbGltaXRlclNlcXVlbmNlID0gW3tcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuU0NSSVBUXG59LCB7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5URVhUXG59LCB7XG4gIHR5cGU6IFwic3RhY2tcIlxufV07IC8vIERlbGltaXRlcnMgdGhhdCBzdGFjayB3aGVuIGxhcmdlIHRyeSB0aGUgc21hbGwgYW5kIHRoZW4gbGFyZ2UgZGVsaW1pdGVycywgYW5kXG4vLyBzdGFjayBhZnRlcndhcmRzXG5cbmNvbnN0IHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuVEVYVFxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDFcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAyXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogM1xufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDRcbn0sIHtcbiAgdHlwZTogXCJzdGFja1wiXG59XTtcbi8qKlxuICogR2V0IHRoZSBmb250IHVzZWQgaW4gYSBkZWxpbWl0ZXIgYmFzZWQgb24gd2hhdCBraW5kIG9mIGRlbGltaXRlciBpdCBpcy5cbiAqIFRPRE8oIzk2MykgVXNlIG1vcmUgc3BlY2lmaWMgZm9udCBmYW1pbHkgcmV0dXJuIHR5cGUgb25jZSB0aGF0IGlzIGludHJvZHVjZWQuXG4gKi9cblxuY29uc3QgZGVsaW1UeXBlVG9Gb250ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHR5cGUudHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgcmV0dXJuIFwiTWFpbi1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAodHlwZS50eXBlID09PSBcImxhcmdlXCIpIHtcbiAgICByZXR1cm4gXCJTaXplXCIgKyB0eXBlLnNpemUgKyBcIi1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAodHlwZS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICByZXR1cm4gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWRkIHN1cHBvcnQgZm9yIGRlbGltIHR5cGUgJ1wiICsgdHlwZS50eXBlICsgXCInIGhlcmUuXCIpO1xuICB9XG59O1xuLyoqXG4gKiBUcmF2ZXJzZSBhIHNlcXVlbmNlIG9mIHR5cGVzIG9mIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoYXQga2luZCBvZiBkZWxpbWl0ZXJcbiAqIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0K2RlcHRoLlxuICovXG5cblxuY29uc3QgdHJhdmVyc2VTZXF1ZW5jZSA9IGZ1bmN0aW9uIChkZWxpbSwgaGVpZ2h0LCBzZXF1ZW5jZSwgb3B0aW9ucykge1xuICAvLyBIZXJlLCB3ZSBjaG9vc2UgdGhlIGluZGV4IHdlIHNob3VsZCBzdGFydCBhdCBpbiB0aGUgc2VxdWVuY2VzLiBJbiBzbWFsbGVyXG4gIC8vIHNpemVzICh3aGljaCBjb3JyZXNwb25kIHRvIGxhcmdlciBudW1iZXJzIGluIHN0eWxlLnNpemUpIHdlIHN0YXJ0IGVhcmxpZXJcbiAgLy8gaW4gdGhlIHNlcXVlbmNlLiBUaHVzLCBzY3JpcHRzY3JpcHQgc3RhcnRzIGF0IGluZGV4IDMtMz0wLCBzY3JpcHQgc3RhcnRzXG4gIC8vIGF0IGluZGV4IDMtMj0xLCB0ZXh0IHN0YXJ0cyBhdCAzLTE9MiwgYW5kIGRpc3BsYXkgc3RhcnRzIGF0IG1pbigyLDMtMCk9MlxuICBjb25zdCBzdGFydCA9IE1hdGgubWluKDIsIDMgLSBvcHRpb25zLnN0eWxlLnNpemUpO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNlcXVlbmNlW2ldLnR5cGUgPT09IFwic3RhY2tcIikge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgdGhlIGxhc3QgZGVsaW1pdGVyLCBzbyB3ZSBqdXN0IGJyZWFrIHRoZSBsb29wIG5vdy5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldHJpY3MgPSBnZXRNZXRyaWNzKGRlbGltLCBkZWxpbVR5cGVUb0ZvbnQoc2VxdWVuY2VbaV0pLCBcIm1hdGhcIik7XG4gICAgbGV0IGhlaWdodERlcHRoID0gbWV0cmljcy5oZWlnaHQgKyBtZXRyaWNzLmRlcHRoOyAvLyBTbWFsbCBkZWxpbWl0ZXJzIGFyZSBzY2FsZWQgZG93biB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBmb250LCBzbyB3ZVxuICAgIC8vIGFjY291bnQgZm9yIHRoZSBzdHlsZSBjaGFuZ2Ugc2l6ZS5cblxuICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzZXF1ZW5jZVtpXS5zdHlsZSk7XG4gICAgICBoZWlnaHREZXB0aCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIH0gLy8gQ2hlY2sgaWYgdGhlIGRlbGltaXRlciBhdCB0aGlzIHNpemUgd29ya3MgZm9yIHRoZSBnaXZlbiBoZWlnaHQuXG5cblxuICAgIGlmIChoZWlnaHREZXB0aCA+IGhlaWdodCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlW2ldO1xuICAgIH1cbiAgfSAvLyBJZiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCByZXR1cm4gdGhlIGxhc3Qgc2VxdWVuY2UgZWxlbWVudC5cblxuXG4gIHJldHVybiBzZXF1ZW5jZVtzZXF1ZW5jZS5sZW5ndGggLSAxXTtcbn07XG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgb2YgYSBnaXZlbiBoZWlnaHQrZGVwdGgsIHdpdGggb3B0aW9uYWwgY2VudGVyaW5nLiBIZXJlLCB3ZVxuICogdHJhdmVyc2UgdGhlIHNlcXVlbmNlcywgYW5kIGNyZWF0ZSBhIGRlbGltaXRlciB0aGF0IHRoZSBzZXF1ZW5jZSB0ZWxscyB1cyB0by5cbiAqL1xuXG5cbmNvbnN0IG1ha2VDdXN0b21TaXplZERlbGltID0gZnVuY3Rpb24gKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICBpZiAoZGVsaW0gPT09IFwiPFwiIHx8IGRlbGltID09PSBcIlxcXFxsdFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZThcIikge1xuICAgIGRlbGltID0gXCJcXFxcbGFuZ2xlXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiPlwiIHx8IGRlbGltID09PSBcIlxcXFxndFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZTlcIikge1xuICAgIGRlbGltID0gXCJcXFxccmFuZ2xlXCI7XG4gIH0gLy8gRGVjaWRlIHdoYXQgc2VxdWVuY2UgdG8gdXNlXG5cblxuICBsZXQgc2VxdWVuY2U7XG5cbiAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICBzZXF1ZW5jZSA9IHN0YWNrTmV2ZXJEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgc2VxdWVuY2UgPSBzdGFja0xhcmdlRGVsaW1pdGVyU2VxdWVuY2U7XG4gIH0gZWxzZSB7XG4gICAgc2VxdWVuY2UgPSBzdGFja0Fsd2F5c0RlbGltaXRlclNlcXVlbmNlO1xuICB9IC8vIExvb2sgdGhyb3VnaCB0aGUgc2VxdWVuY2VcblxuXG4gIGNvbnN0IGRlbGltVHlwZSA9IHRyYXZlcnNlU2VxdWVuY2UoZGVsaW0sIGhlaWdodCwgc2VxdWVuY2UsIG9wdGlvbnMpOyAvLyBHZXQgdGhlIGRlbGltaXRlciBmcm9tIGZvbnQgZ2x5cGhzLlxuICAvLyBEZXBlbmRpbmcgb24gdGhlIHNlcXVlbmNlIGVsZW1lbnQgd2UgZGVjaWRlZCBvbiwgY2FsbCB0aGVcbiAgLy8gYXBwcm9wcmlhdGUgZnVuY3Rpb24uXG5cbiAgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICByZXR1cm4gbWFrZVNtYWxsRGVsaW0oZGVsaW0sIGRlbGltVHlwZS5zdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJsYXJnZVwiKSB7XG4gICAgcmV0dXJuIG1ha2VMYXJnZURlbGltKGRlbGltLCBkZWxpbVR5cGUuc2l6ZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlXG4gICAgLyogaWYgKGRlbGltVHlwZS50eXBlID09PSBcInN0YWNrXCIpICovXG4gICAge1xuICAgICAgcmV0dXJuIG1ha2VTdGFja2VkRGVsaW0oZGVsaW0sIGhlaWdodCwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9XG59O1xuLyoqXG4gKiBNYWtlIGEgZGVsaW1pdGVyIGZvciB1c2Ugd2l0aCBgXFxsZWZ0YCBhbmQgYFxccmlnaHRgLCBnaXZlbiBhIGhlaWdodCBhbmQgZGVwdGhcbiAqIG9mIGFuIGV4cHJlc3Npb24gdGhhdCB0aGUgZGVsaW1pdGVycyBzdXJyb3VuZC5cbiAqL1xuXG5cbmNvbnN0IG1ha2VMZWZ0UmlnaHREZWxpbSA9IGZ1bmN0aW9uIChkZWxpbSwgaGVpZ2h0LCBkZXB0aCwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAvLyBXZSBhbHdheXMgY2VudGVyIFxcbGVmdC9cXHJpZ2h0IGRlbGltaXRlcnMsIHNvIHRoZSBheGlzIGlzIGFsd2F5cyBzaGlmdGVkXG4gIGNvbnN0IGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodCAqIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIFRha2VuIGZyb20gVGVYIHNvdXJjZSwgdGV4LndlYiwgZnVuY3Rpb24gbWFrZV9sZWZ0X3JpZ2h0XG5cbiAgY29uc3QgZGVsaW1pdGVyRmFjdG9yID0gOTAxO1xuICBjb25zdCBkZWxpbWl0ZXJFeHRlbmQgPSA1LjAgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgY29uc3QgbWF4RGlzdEZyb21BeGlzID0gTWF0aC5tYXgoaGVpZ2h0IC0gYXhpc0hlaWdodCwgZGVwdGggKyBheGlzSGVpZ2h0KTtcbiAgY29uc3QgdG90YWxIZWlnaHQgPSBNYXRoLm1heCggLy8gSW4gcmVhbCBUZVgsIGNhbGN1bGF0aW9ucyBhcmUgZG9uZSB1c2luZyBpbnRlZ3JhbCB2YWx1ZXMgd2hpY2ggYXJlXG4gIC8vIDY1NTM2IHBlciBwdCwgb3IgNjU1MzYwIHBlciBlbS4gU28sIHRoZSBkaXZpc2lvbiBoZXJlIHRydW5jYXRlcyBpblxuICAvLyBUZVggYnV0IGRvZXNuJ3QgaGVyZSwgcHJvZHVjaW5nIGRpZmZlcmVudCByZXN1bHRzLiBJZiB3ZSB3YW50ZWQgdG9cbiAgLy8gZXhhY3RseSBtYXRjaCBUZVgncyBjYWxjdWxhdGlvbiwgd2UgY291bGQgZG9cbiAgLy8gICBNYXRoLmZsb29yKDY1NTM2MCAqIG1heERpc3RGcm9tQXhpcyAvIDUwMCkgKlxuICAvLyAgICBkZWxpbWl0ZXJGYWN0b3IgLyA2NTUzNjBcbiAgLy8gKFRvIHNlZSB0aGUgZGlmZmVyZW5jZSwgY29tcGFyZVxuICAvLyAgICB4Xnt4XntcXGxlZnQoXFxydWxlezAuMWVtfXswLjY4ZW19XFxyaWdodCl9fVxuICAvLyBpbiBUZVggYW5kIEthVGVYKVxuICBtYXhEaXN0RnJvbUF4aXMgLyA1MDAgKiBkZWxpbWl0ZXJGYWN0b3IsIDIgKiBtYXhEaXN0RnJvbUF4aXMgLSBkZWxpbWl0ZXJFeHRlbmQpOyAvLyBGaW5hbGx5LCB3ZSBkZWZlciB0byBgbWFrZUN1c3RvbVNpemVkRGVsaW1gIHdpdGggb3VyIGNhbGN1bGF0ZWQgdG90YWxcbiAgLy8gaGVpZ2h0XG5cbiAgcmV0dXJuIG1ha2VDdXN0b21TaXplZERlbGltKGRlbGltLCB0b3RhbEhlaWdodCwgdHJ1ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWxpbWl0ZXIgPSAoe1xuICBzcXJ0SW1hZ2U6IG1ha2VTcXJ0SW1hZ2UsXG4gIHNpemVkRGVsaW06IG1ha2VTaXplZERlbGltLFxuICBzaXplVG9NYXhIZWlnaHQ6IHNpemVUb01heEhlaWdodCxcbiAgY3VzdG9tU2l6ZWREZWxpbTogbWFrZUN1c3RvbVNpemVkRGVsaW0sXG4gIGxlZnRSaWdodERlbGltOiBtYWtlTGVmdFJpZ2h0RGVsaW1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9kZWxpbXNpemluZy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG4vLyBFeHRyYSBkYXRhIG5lZWRlZCBmb3IgdGhlIGRlbGltaXRlciBoYW5kbGVyIGRvd24gYmVsb3dcbmNvbnN0IGRlbGltaXRlclNpemVzID0ge1xuICBcIlxcXFxiaWdsXCI6IHtcbiAgICBtY2xhc3M6IFwibW9wZW5cIixcbiAgICBzaXplOiAxXG4gIH0sXG4gIFwiXFxcXEJpZ2xcIjoge1xuICAgIG1jbGFzczogXCJtb3BlblwiLFxuICAgIHNpemU6IDJcbiAgfSxcbiAgXCJcXFxcYmlnZ2xcIjoge1xuICAgIG1jbGFzczogXCJtb3BlblwiLFxuICAgIHNpemU6IDNcbiAgfSxcbiAgXCJcXFxcQmlnZ2xcIjoge1xuICAgIG1jbGFzczogXCJtb3BlblwiLFxuICAgIHNpemU6IDRcbiAgfSxcbiAgXCJcXFxcYmlnclwiOiB7XG4gICAgbWNsYXNzOiBcIm1jbG9zZVwiLFxuICAgIHNpemU6IDFcbiAgfSxcbiAgXCJcXFxcQmlnclwiOiB7XG4gICAgbWNsYXNzOiBcIm1jbG9zZVwiLFxuICAgIHNpemU6IDJcbiAgfSxcbiAgXCJcXFxcYmlnZ3JcIjoge1xuICAgIG1jbGFzczogXCJtY2xvc2VcIixcbiAgICBzaXplOiAzXG4gIH0sXG4gIFwiXFxcXEJpZ2dyXCI6IHtcbiAgICBtY2xhc3M6IFwibWNsb3NlXCIsXG4gICAgc2l6ZTogNFxuICB9LFxuICBcIlxcXFxiaWdtXCI6IHtcbiAgICBtY2xhc3M6IFwibXJlbFwiLFxuICAgIHNpemU6IDFcbiAgfSxcbiAgXCJcXFxcQmlnbVwiOiB7XG4gICAgbWNsYXNzOiBcIm1yZWxcIixcbiAgICBzaXplOiAyXG4gIH0sXG4gIFwiXFxcXGJpZ2dtXCI6IHtcbiAgICBtY2xhc3M6IFwibXJlbFwiLFxuICAgIHNpemU6IDNcbiAgfSxcbiAgXCJcXFxcQmlnZ21cIjoge1xuICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgc2l6ZTogNFxuICB9LFxuICBcIlxcXFxiaWdcIjoge1xuICAgIG1jbGFzczogXCJtb3JkXCIsXG4gICAgc2l6ZTogMVxuICB9LFxuICBcIlxcXFxCaWdcIjoge1xuICAgIG1jbGFzczogXCJtb3JkXCIsXG4gICAgc2l6ZTogMlxuICB9LFxuICBcIlxcXFxiaWdnXCI6IHtcbiAgICBtY2xhc3M6IFwibW9yZFwiLFxuICAgIHNpemU6IDNcbiAgfSxcbiAgXCJcXFxcQmlnZ1wiOiB7XG4gICAgbWNsYXNzOiBcIm1vcmRcIixcbiAgICBzaXplOiA0XG4gIH1cbn07XG5jb25zdCBkZWxpbWl0ZXJzID0gW1wiKFwiLCBcIlxcXFxscGFyZW5cIiwgXCIpXCIsIFwiXFxcXHJwYXJlblwiLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIiwgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcdTIzMGFcIiwgXCJcXHUyMzBiXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsIFwiXFx1MjMwOFwiLCBcIlxcdTIzMDlcIiwgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXHUyN2U4XCIsIFwiXFxcXHJhbmdsZVwiLCBcIlxcdTI3ZTlcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIiwgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIiwgXCJcXFxcbGdyb3VwXCIsIFwiXFxcXHJncm91cFwiLCBcIlxcdTI3ZWVcIiwgXCJcXHUyN2VmXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiLCBcIlxcdTIzYjBcIiwgXCJcXHUyM2IxXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJ8XCIsIFwiXFxcXHZlcnRcIiwgXCJcXFxcfFwiLCBcIlxcXFxWZXJ0XCIsIFwiXFxcXHVwYXJyb3dcIiwgXCJcXFxcVXBhcnJvd1wiLCBcIlxcXFxkb3duYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIFwiLlwiXTtcblxuLy8gRGVsaW1pdGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gY2hlY2tEZWxpbWl0ZXIoZGVsaW0sIGNvbnRleHQpIHtcbiAgY29uc3Qgc3ltRGVsaW0gPSBjaGVja1N5bWJvbE5vZGVUeXBlKGRlbGltKTtcblxuICBpZiAoc3ltRGVsaW0gJiYgdXRpbHMuY29udGFpbnMoZGVsaW1pdGVycywgc3ltRGVsaW0udGV4dCkpIHtcbiAgICByZXR1cm4gc3ltRGVsaW07XG4gIH0gZWxzZSBpZiAoc3ltRGVsaW0pIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGRlbGltaXRlciAnXCIgKyBzeW1EZWxpbS50ZXh0ICsgXCInIGFmdGVyICdcIiArIGNvbnRleHQuZnVuY05hbWUgKyBcIidcIiwgZGVsaW0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgZGVsaW1pdGVyIHR5cGUgJ1wiICsgZGVsaW0udHlwZSArIFwiJ1wiLCBkZWxpbSk7XG4gIH1cbn1cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gIG5hbWVzOiBbXCJcXFxcYmlnbFwiLCBcIlxcXFxCaWdsXCIsIFwiXFxcXGJpZ2dsXCIsIFwiXFxcXEJpZ2dsXCIsIFwiXFxcXGJpZ3JcIiwgXCJcXFxcQmlnclwiLCBcIlxcXFxiaWdnclwiLCBcIlxcXFxCaWdnclwiLCBcIlxcXFxiaWdtXCIsIFwiXFxcXEJpZ21cIiwgXCJcXFxcYmlnZ21cIiwgXCJcXFxcQmlnZ21cIiwgXCJcXFxcYmlnXCIsIFwiXFxcXEJpZ1wiLCBcIlxcXFxiaWdnXCIsIFwiXFxcXEJpZ2dcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkZWxpbXNpemluZ1wiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsXG4gICAgICBtY2xhc3M6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLm1jbGFzcyxcbiAgICAgIGRlbGltOiBkZWxpbS50ZXh0XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGlmIChncm91cC5kZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgIC8vIEVtcHR5IGRlbGltaXRlcnMgc3RpbGwgY291bnQgYXMgZWxlbWVudHMsIGV2ZW4gdGhvdWdoIHRoZXkgZG9uJ3RcbiAgICAgIC8vIHNob3cgYW55dGhpbmcuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW2dyb3VwLm1jbGFzc10pO1xuICAgIH0gLy8gVXNlIGRlbGltaXRlci5zaXplZERlbGltIHRvIGdlbmVyYXRlIHRoZSBkZWxpbWl0ZXIuXG5cblxuICAgIHJldHVybiBkZWxpbWl0ZXIuc2l6ZWREZWxpbShncm91cC5kZWxpbSwgZ3JvdXAuc2l6ZSwgb3B0aW9ucywgZ3JvdXAubW9kZSwgW2dyb3VwLm1jbGFzc10pO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBncm91cCA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChncm91cC5kZWxpbSAhPT0gXCIuXCIpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRleHQoZ3JvdXAuZGVsaW0sIGdyb3VwLm1vZGUpKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBjaGlsZHJlbik7XG5cbiAgICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1vcGVuXCIgfHwgZ3JvdXAubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAvLyBPbmx5IHNvbWUgb2YgdGhlIGRlbGltc2l6aW5nIGZ1bmN0aW9ucyBhY3QgYXMgZmVuY2VzLCBhbmQgdGhleVxuICAgICAgLy8gcmV0dXJuIFwibW9wZW5cIiBvciBcIm1jbG9zZVwiIG1jbGFzcy5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IGRpc2FibGUgZmVuY2luZyBpZiBpdCdzIG5vdCBhIGZlbmNlLCB0byBvdmVycmlkZSB0aGVcbiAgICAgIC8vIGRlZmF1bHRzLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIGNvbnN0IHNpemUgPSBtYWtlRW0oZGVsaW1pdGVyLnNpemVUb01heEhlaWdodFtncm91cC5zaXplXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtaW5zaXplXCIsIHNpemUpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF4c2l6ZVwiLCBzaXplKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGFzc2VydFBhcnNlZChncm91cCkge1xuICBpZiAoIWdyb3VwLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWc6IFRoZSBsZWZ0cmlnaHQgUGFyc2VOb2RlIHdhc24ndCBmdWxseSBwYXJzZWQuXCIpO1xuICB9XG59XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsZWZ0cmlnaHQtcmlnaHRcIixcbiAgbmFtZXM6IFtcIlxcXFxyaWdodFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIC8vIFxcbGVmdCBjYXNlIGJlbG93IHRyaWdnZXJzIHBhcnNpbmcgb2YgXFxyaWdodCBpblxuICAgIC8vICAgYGNvbnN0IHJpZ2h0ID0gcGFyc2VyLnBhcnNlRnVuY3Rpb24oKTtgXG4gICAgLy8gdXNlcyB0aGlzIHJldHVybiB2YWx1ZS5cbiAgICBjb25zdCBjb2xvciA9IGNvbnRleHQucGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGN1cnJlbnRAY29sb3JcIik7XG5cbiAgICBpZiAoY29sb3IgJiYgdHlwZW9mIGNvbG9yICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcY3VycmVudEBjb2xvciBzZXQgdG8gbm9uLXN0cmluZyBpbiBcXFxccmlnaHRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0LXJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgZGVsaW06IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpLnRleHQsXG4gICAgICBjb2xvciAvLyB1bmRlZmluZWQgaWYgbm90IHNldCB2aWEgXFxjb2xvclxuXG4gICAgfTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gIG5hbWVzOiBbXCJcXFxcbGVmdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG4gICAgY29uc3QgcGFyc2VyID0gY29udGV4dC5wYXJzZXI7IC8vIFBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keVxuXG4gICAgKytwYXJzZXIubGVmdHJpZ2h0RGVwdGg7IC8vIHBhcnNlRXhwcmVzc2lvbiBzdG9wcyBiZWZvcmUgJ1xcXFxyaWdodCdcblxuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAtLXBhcnNlci5sZWZ0cmlnaHREZXB0aDsgLy8gQ2hlY2sgdGhlIG5leHQgdG9rZW5cblxuICAgIHBhcnNlci5leHBlY3QoXCJcXFxccmlnaHRcIiwgZmFsc2UpO1xuICAgIGNvbnN0IHJpZ2h0ID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJsZWZ0cmlnaHQtcmlnaHRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBsZWZ0OiBkZWxpbS50ZXh0LFxuICAgICAgcmlnaHQ6IHJpZ2h0LmRlbGltLFxuICAgICAgcmlnaHRDb2xvcjogcmlnaHQuY29sb3JcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgYXNzZXJ0UGFyc2VkKGdyb3VwKTsgLy8gQnVpbGQgdGhlIGlubmVyIGV4cHJlc3Npb25cblxuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUsIFtcIm1vcGVuXCIsIFwibWNsb3NlXCJdKTtcbiAgICBsZXQgaW5uZXJIZWlnaHQgPSAwO1xuICAgIGxldCBpbm5lckRlcHRoID0gMDtcbiAgICBsZXQgaGFkTWlkZGxlID0gZmFsc2U7IC8vIENhbGN1bGF0ZSBpdHMgaGVpZ2h0IGFuZCBkZXB0aFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIFNlZSBjb21tZW50IGluXG4gICAgICAvLyBcIm1pZGRsZVwiJ3MgaHRtbEJ1aWxkZXIuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBpZiAoaW5uZXJbaV0uaXNNaWRkbGUpIHtcbiAgICAgICAgaGFkTWlkZGxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaW5uZXJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7XG4gICAgICAgIGlubmVyRGVwdGggPSBNYXRoLm1heChpbm5lcltpXS5kZXB0aCwgaW5uZXJEZXB0aCk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgc2l6ZSBvZiBkZWxpbWl0ZXJzIGlzIHRoZSBzYW1lLCByZWdhcmRsZXNzIG9mIHdoYXQgc3R5bGUgd2UgYXJlXG4gICAgLy8gaW4uIFRodXMsIHRvIGNvcnJlY3RseSBjYWxjdWxhdGUgdGhlIHNpemUgb2YgZGVsaW1pdGVyIHdlIG5lZWQgYXJvdW5kXG4gICAgLy8gYSBncm91cCwgd2Ugc2NhbGUgZG93biB0aGUgaW5uZXIgc2l6ZSBiYXNlZCBvbiB0aGUgc2l6ZS5cblxuXG4gICAgaW5uZXJIZWlnaHQgKj0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICBpbm5lckRlcHRoICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgbGV0IGxlZnREZWxpbTtcblxuICAgIGlmIChncm91cC5sZWZ0ID09PSBcIi5cIikge1xuICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBpbiBcXGxlZnQgYW5kIFxccmlnaHQgbWFrZSBudWxsIGRlbGltaXRlciBzcGFjZXMuXG4gICAgICBsZWZ0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtb3BlblwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxlZnRSaWdodERlbGltIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHNpemVkXG4gICAgICAvLyBkZWxpbWl0ZXIuXG4gICAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oZ3JvdXAubGVmdCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtcIm1vcGVuXCJdKTtcbiAgICB9IC8vIEFkZCBpdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleHByZXNzaW9uXG5cblxuICAgIGlubmVyLnVuc2hpZnQobGVmdERlbGltKTsgLy8gSGFuZGxlIG1pZGRsZSBkZWxpbWl0ZXJzXG5cbiAgICBpZiAoaGFkTWlkZGxlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZURlbGltID0gaW5uZXJbaV07IC8vIFByb3BlcnR5IGBpc01pZGRsZWAgbm90IGRlZmluZWQgb24gYHNwYW5gLiBTZWUgY29tbWVudCBpblxuICAgICAgICAvLyBcIm1pZGRsZVwiJ3MgaHRtbEJ1aWxkZXIuXG4gICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICBjb25zdCBpc01pZGRsZSA9IG1pZGRsZURlbGltLmlzTWlkZGxlO1xuXG4gICAgICAgIGlmIChpc01pZGRsZSkge1xuICAgICAgICAgIC8vIEFwcGx5IHRoZSBvcHRpb25zIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiBcXG1pZGRsZSB3YXMgY2FsbGVkXG4gICAgICAgICAgaW5uZXJbaV0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oaXNNaWRkbGUuZGVsaW0sIGlubmVySGVpZ2h0LCBpbm5lckRlcHRoLCBpc01pZGRsZS5vcHRpb25zLCBncm91cC5tb2RlLCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmlnaHREZWxpbTsgLy8gU2FtZSBmb3IgdGhlIHJpZ2h0IGRlbGltaXRlciwgYnV0IHVzaW5nIGNvbG9yIHNwZWNpZmllZCBieSBcXGNvbG9yXG5cbiAgICBpZiAoZ3JvdXAucmlnaHQgPT09IFwiLlwiKSB7XG4gICAgICByaWdodERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibWNsb3NlXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29sb3JPcHRpb25zID0gZ3JvdXAucmlnaHRDb2xvciA/IG9wdGlvbnMud2l0aENvbG9yKGdyb3VwLnJpZ2h0Q29sb3IpIDogb3B0aW9ucztcbiAgICAgIHJpZ2h0RGVsaW0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oZ3JvdXAucmlnaHQsIGlubmVySGVpZ2h0LCBpbm5lckRlcHRoLCBjb2xvck9wdGlvbnMsIGdyb3VwLm1vZGUsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSAvLyBBZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvbi5cblxuXG4gICAgaW5uZXIucHVzaChyaWdodERlbGltKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibWlubmVyXCJdLCBpbm5lciwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZ3JvdXAubGVmdCAhPT0gXCIuXCIpIHtcbiAgICAgIGNvbnN0IGxlZnROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAubGVmdCwgZ3JvdXAubW9kZSldKTtcbiAgICAgIGxlZnROb2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGlubmVyLnVuc2hpZnQobGVmdE5vZGUpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5yaWdodCAhPT0gXCIuXCIpIHtcbiAgICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnJpZ2h0LCBncm91cC5tb2RlKV0pO1xuICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcblxuICAgICAgaWYgKGdyb3VwLnJpZ2h0Q29sb3IpIHtcbiAgICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBncm91cC5yaWdodENvbG9yKTtcbiAgICAgIH1cblxuICAgICAgaW5uZXIucHVzaChyaWdodE5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlUm93KGlubmVyKTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWlkZGxlXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWlkZGxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcblxuICAgIGlmICghY29udGV4dC5wYXJzZXIubGVmdHJpZ2h0RGVwdGgpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxtaWRkbGUgd2l0aG91dCBwcmVjZWRpbmcgXFxcXGxlZnRcIiwgZGVsaW0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1pZGRsZVwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGRlbGltOiBkZWxpbS50ZXh0XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGxldCBtaWRkbGVEZWxpbTtcblxuICAgIGlmIChncm91cC5kZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgIG1pZGRsZURlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGVEZWxpbSA9IGRlbGltaXRlci5zaXplZERlbGltKGdyb3VwLmRlbGltLCAxLCBvcHRpb25zLCBncm91cC5tb2RlLCBbXSk7XG4gICAgICBjb25zdCBpc01pZGRsZSA9IHtcbiAgICAgICAgZGVsaW06IGdyb3VwLmRlbGltLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9OyAvLyBQcm9wZXJ0eSBgaXNNaWRkbGVgIG5vdCBkZWZpbmVkIG9uIGBzcGFuYC4gSXQgaXMgb25seSB1c2VkIGluXG4gICAgICAvLyB0aGlzIGZpbGUgYWJvdmUuXG4gICAgICAvLyBUT0RPOiBGaXggdGhpcyB2aW9sYXRpb24gb2YgdGhlIGBzcGFuYCB0eXBlIGFuZCBwb3NzaWJseSByZW5hbWVcbiAgICAgIC8vIHRoaW5ncyBzaW5jZSBgaXNNaWRkbGVgIHNvdW5kcyBsaWtlIGEgYm9vbGVhbiwgYnV0IGlzIGEgc3RydWN0LlxuICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBtaWRkbGVEZWxpbS5pc01pZGRsZSA9IGlzTWlkZGxlO1xuICAgIH1cblxuICAgIHJldHVybiBtaWRkbGVEZWxpbTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gQSBGaXJlZm94IFxcbWlkZGxlIHdpbGwgc3RyZXRjaCBhIGNoYXJhY3RlciB2ZXJ0aWNhbGx5IG9ubHkgaWYgaXRcbiAgICAvLyBpcyBpbiB0aGUgZmVuY2UgcGFydCBvZiB0aGUgb3BlcmF0b3IgZGljdGlvbmFyeSBhdDpcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvTWF0aE1MMy9hcHBlbmRpeGMuaHRtbC5cbiAgICAvLyBTbyB3ZSBuZWVkIHRvIGF2b2lkIFUrMjIyMyBhbmQgdXNlIHBsYWluIFwifFwiIGluc3RlYWQuXG4gICAgY29uc3QgdGV4dE5vZGUgPSBncm91cC5kZWxpbSA9PT0gXCJcXFxcdmVydFwiIHx8IGdyb3VwLmRlbGltID09PSBcInxcIiA/IG1ha2VUZXh0KFwifFwiLCBcInRleHRcIikgOiBtYWtlVGV4dChncm91cC5kZWxpbSwgZ3JvdXAubW9kZSk7XG4gICAgY29uc3QgbWlkZGxlTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHROb2RlXSk7XG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7IC8vIE1hdGhNTCBnaXZlcyA1LzE4ZW0gc3BhY2luZyB0byBlYWNoIDxtbz4gZWxlbWVudC5cbiAgICAvLyBcXG1pZGRsZSBzaG91bGQgZ2V0IGRlbGltaXRlciBzcGFjaW5nIGluc3RlYWQuXG5cbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICByZXR1cm4gbWlkZGxlTm9kZTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2VuY2xvc2UuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IGVuY2xvc2VfaHRtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgLy8gXFxjYW5jZWwsIFxcYmNhbmNlbCwgXFx4Y2FuY2VsLCBcXHNvdXQsIFxcZmJveCwgXFxjb2xvcmJveCwgXFxmY29sb3Jib3gsIFxccGhhc2VcbiAgLy8gU29tZSBncm91cHMgY2FuIHJldHVybiBkb2N1bWVudCBmcmFnbWVudHMuICBIYW5kbGUgdGhvc2UgYnkgd3JhcHBpbmdcbiAgLy8gdGhlbSBpbiBhIHNwYW4uXG4gIGNvbnN0IGlubmVyID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICBjb25zdCBsYWJlbCA9IGdyb3VwLmxhYmVsLnNsaWNlKDEpO1xuICBsZXQgc2NhbGUgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICBsZXQgaW1nO1xuICBsZXQgaW1nU2hpZnQgPSAwOyAvLyBJbiB0aGUgTGFUZVggY2FuY2VsIHBhY2thZ2UsIGxpbmUgZ2VvbWV0cnkgaXMgc2xpZ2h0bHkgZGlmZmVyZW50XG4gIC8vIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBzdWJqZWN0IGlzIHdpZGVyIHRoYW4gaXQgaXMgdGFsbCwgb3IgdmljZSB2ZXJzYS5cbiAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgd2lkdGggb2YgYSBncm91cCwgc28gYXMgYSBwcm94eSwgd2UgdGVzdCBpZlxuICAvLyB0aGUgc3ViamVjdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuIFRoaXMgY2FwdHVyZXMgbW9zdCBvZiB0aGVcbiAgLy8gc3ViamVjdHMgdGhhdCBzaG91bGQgZ2V0IHRoZSBcInRhbGxcIiB0cmVhdG1lbnQuXG5cbiAgY29uc3QgaXNTaW5nbGVDaGFyID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goZ3JvdXAuYm9keSk7XG5cbiAgaWYgKGxhYmVsID09PSBcInNvdXRcIikge1xuICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInN0cmV0Y2h5XCIsIFwic291dFwiXSk7XG4gICAgaW1nLmhlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvIHNjYWxlO1xuICAgIGltZ1NoaWZ0ID0gLTAuNSAqIG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0O1xuICB9IGVsc2UgaWYgKGxhYmVsID09PSBcInBoYXNlXCIpIHtcbiAgICAvLyBTZXQgYSBjb3VwbGUgb2YgZGltZW5zaW9ucyBmcm9tIHRoZSBzdGVpbm1ldHogcGFja2FnZS5cbiAgICBjb25zdCBsaW5lV2VpZ2h0ID0gY2FsY3VsYXRlU2l6ZSh7XG4gICAgICBudW1iZXI6IDAuNixcbiAgICAgIHVuaXQ6IFwicHRcIlxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNsZWFyYW5jZSA9IGNhbGN1bGF0ZVNpemUoe1xuICAgICAgbnVtYmVyOiAwLjM1LFxuICAgICAgdW5pdDogXCJleFwiXG4gICAgfSwgb3B0aW9ucyk7IC8vIFByZXZlbnQgc2l6ZSBjaGFuZ2VzIGxpa2UgXFxIdWdlIGZyb20gYWZmZWN0aW5nIGxpbmUgdGhpY2tuZXNzXG5cbiAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU2l6aW5nKCk7XG4gICAgc2NhbGUgPSBzY2FsZSAvIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgY29uc3QgYW5nbGVIZWlnaHQgPSBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIGxpbmVXZWlnaHQgKyBjbGVhcmFuY2U7IC8vIFJlc2VydmUgYSBsZWZ0IHBhZCBmb3IgdGhlIGFuZ2xlLlxuXG4gICAgaW5uZXIuc3R5bGUucGFkZGluZ0xlZnQgPSBtYWtlRW0oYW5nbGVIZWlnaHQgLyAyICsgbGluZVdlaWdodCk7IC8vIENyZWF0ZSBhbiBTVkdcblxuICAgIGNvbnN0IHZpZXdCb3hIZWlnaHQgPSBNYXRoLmZsb29yKDEwMDAgKiBhbmdsZUhlaWdodCAqIHNjYWxlKTtcbiAgICBjb25zdCBwYXRoID0gcGhhc2VQYXRoKHZpZXdCb3hIZWlnaHQpO1xuICAgIGNvbnN0IHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbbmV3IFBhdGhOb2RlKFwicGhhc2VcIiwgcGF0aCldLCB7XG4gICAgICBcIndpZHRoXCI6IFwiNDAwZW1cIixcbiAgICAgIFwiaGVpZ2h0XCI6IG1ha2VFbSh2aWV3Qm94SGVpZ2h0IC8gMTAwMCksXG4gICAgICBcInZpZXdCb3hcIjogXCIwIDAgNDAwMDAwIFwiICsgdmlld0JveEhlaWdodCxcbiAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcInhNaW5ZTWluIHNsaWNlXCJcbiAgICB9KTsgLy8gV3JhcCBpdCBpbiBhIHNwYW4gd2l0aCBvdmVyZmxvdzogaGlkZGVuLlxuXG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVN2Z1NwYW4oW1wiaGlkZS10YWlsXCJdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpO1xuICAgIGltZy5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oYW5nbGVIZWlnaHQpO1xuICAgIGltZ1NoaWZ0ID0gaW5uZXIuZGVwdGggKyBsaW5lV2VpZ2h0ICsgY2xlYXJhbmNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEFkZCBob3Jpem9udGFsIHBhZGRpbmdcbiAgICBpZiAoL2NhbmNlbC8udGVzdChsYWJlbCkpIHtcbiAgICAgIGlmICghaXNTaW5nbGVDaGFyKSB7XG4gICAgICAgIGlubmVyLmNsYXNzZXMucHVzaChcImNhbmNlbC1wYWRcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsYWJlbCA9PT0gXCJhbmdsXCIpIHtcbiAgICAgIGlubmVyLmNsYXNzZXMucHVzaChcImFuZ2xwYWRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlubmVyLmNsYXNzZXMucHVzaChcImJveHBhZFwiKTtcbiAgICB9IC8vIEFkZCB2ZXJ0aWNhbCBwYWRkaW5nXG5cblxuICAgIGxldCB0b3BQYWQgPSAwO1xuICAgIGxldCBib3R0b21QYWQgPSAwO1xuICAgIGxldCBydWxlVGhpY2tuZXNzID0gMDsgLy8gcmVmOiBjYW5jZWwgcGFja2FnZTogXFxhZHZhbmNlXFx0b3RhbGhlaWdodDJcXHBAICUgXCIrMlwiXG5cbiAgICBpZiAoL2JveC8udGVzdChsYWJlbCkpIHtcbiAgICAgIHJ1bGVUaGlja25lc3MgPSBNYXRoLm1heChvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHJ1bGUsIC8vIGRlZmF1bHRcbiAgICAgIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAvLyBVc2VyIG92ZXJyaWRlLlxuICAgICAgKTtcbiAgICAgIHRvcFBhZCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5mYm94c2VwICsgKGxhYmVsID09PSBcImNvbG9yYm94XCIgPyAwIDogcnVsZVRoaWNrbmVzcyk7XG4gICAgICBib3R0b21QYWQgPSB0b3BQYWQ7XG4gICAgfSBlbHNlIGlmIChsYWJlbCA9PT0gXCJhbmdsXCIpIHtcbiAgICAgIHJ1bGVUaGlja25lc3MgPSBNYXRoLm1heChvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3MsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyk7XG4gICAgICB0b3BQYWQgPSA0ICogcnVsZVRoaWNrbmVzczsgLy8gZ2FwID0gMyDDlyBsaW5lLCBwbHVzIHRoZSBsaW5lIGl0c2VsZi5cblxuICAgICAgYm90dG9tUGFkID0gTWF0aC5tYXgoMCwgMC4yNSAtIGlubmVyLmRlcHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wUGFkID0gaXNTaW5nbGVDaGFyID8gMC4yIDogMDtcbiAgICAgIGJvdHRvbVBhZCA9IHRvcFBhZDtcbiAgICB9XG5cbiAgICBpbWcgPSBzdHJldGNoeS5lbmNsb3NlU3Bhbihpbm5lciwgbGFiZWwsIHRvcFBhZCwgYm90dG9tUGFkLCBvcHRpb25zKTtcblxuICAgIGlmICgvZmJveHxib3hlZHxmY29sb3Jib3gvLnRlc3QobGFiZWwpKSB7XG4gICAgICBpbWcuc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICBpbWcuc3R5bGUuYm9yZGVyV2lkdGggPSBtYWtlRW0ocnVsZVRoaWNrbmVzcyk7XG4gICAgfSBlbHNlIGlmIChsYWJlbCA9PT0gXCJhbmdsXCIgJiYgcnVsZVRoaWNrbmVzcyAhPT0gMC4wNDkpIHtcbiAgICAgIGltZy5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IG1ha2VFbShydWxlVGhpY2tuZXNzKTtcbiAgICAgIGltZy5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gbWFrZUVtKHJ1bGVUaGlja25lc3MpO1xuICAgIH1cblxuICAgIGltZ1NoaWZ0ID0gaW5uZXIuZGVwdGggKyBib3R0b21QYWQ7XG5cbiAgICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBpbWcuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3JvdXAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICBpZiAoZ3JvdXAuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgaW1nLnN0eWxlLmJvcmRlckNvbG9yID0gZ3JvdXAuYm9yZGVyQ29sb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHZsaXN0O1xuXG4gIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogWy8vIFB1dCB0aGUgY29sb3IgYmFja2dyb3VuZCBiZWhpbmQgaW5uZXI7XG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbWcsXG4gICAgICAgIHNoaWZ0OiBpbWdTaGlmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXIsXG4gICAgICAgIHNoaWZ0OiAwXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNsYXNzZXMgPSAvY2FuY2VsfHBoYXNlLy50ZXN0KGxhYmVsKSA/IFtcInN2Zy1hbGlnblwiXSA6IFtdO1xuICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiBbLy8gV3JpdGUgdGhlIFxcY2FuY2VsIHN0cm9rZSBvbiB0b3Agb2YgaW5uZXIuXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lcixcbiAgICAgICAgc2hpZnQ6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGltZyxcbiAgICAgICAgc2hpZnQ6IGltZ1NoaWZ0LFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogY2xhc3Nlc1xuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICgvY2FuY2VsLy50ZXN0KGxhYmVsKSkge1xuICAgIC8vIFRoZSBjYW5jZWwgcGFja2FnZSBkb2N1bWVudGF0aW9uIHNheXMgdGhhdCBjYW5jZWwgbGluZXMgYWRkIHRoZWlyIGhlaWdodFxuICAgIC8vIHRvIHRoZSBleHByZXNzaW9uLCBidXQgdGVzdHMgc2hvdyB0aGF0IGlzbid0IGhvdyBpdCBhY3R1YWxseSB3b3Jrcy5cbiAgICB2bGlzdC5oZWlnaHQgPSBpbm5lci5oZWlnaHQ7XG4gICAgdmxpc3QuZGVwdGggPSBpbm5lci5kZXB0aDtcbiAgfVxuXG4gIGlmICgvY2FuY2VsLy50ZXN0KGxhYmVsKSAmJiAhaXNTaW5nbGVDaGFyKSB7XG4gICAgLy8gY2FuY2VsIGRvZXMgbm90IGNyZWF0ZSBob3JpeiBzcGFjZSBmb3IgaXRzIGxpbmUgZXh0ZW5zaW9uLlxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwiY2FuY2VsLWxhcFwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9XG59O1xuXG5jb25zdCBlbmNsb3NlX21hdGhtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgbGV0IGZib3hzZXAgPSAwO1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoZ3JvdXAubGFiZWwuaW5kZXhPZihcImNvbG9yYm94XCIpID4gLTEgPyBcIm1wYWRkZWRcIiA6IFwibWVuY2xvc2VcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTtcblxuICBzd2l0Y2ggKGdyb3VwLmxhYmVsKSB7XG4gICAgY2FzZSBcIlxcXFxjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJ1cGRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXGJjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxccGhhc2VcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJwaGFzb3JhbmdsZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxzb3V0XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiaG9yaXpvbnRhbHN0cmlrZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxmYm94XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYm94XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXGFuZ2xcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJhY3R1YXJpYWxcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxcZmNvbG9yYm94XCI6XG4gICAgY2FzZSBcIlxcXFxjb2xvcmJveFwiOlxuICAgICAgLy8gPG1lbmNsb3NlPiBkb2Vzbid0IGhhdmUgYSBnb29kIG5vdGF0aW9uIG9wdGlvbi4gU28gdXNlIDxtcGFkZGVkPlxuICAgICAgLy8gaW5zdGVhZC4gU2V0IHNvbWUgYXR0cmlidXRlcyB0aGF0IGNvbWUgaW5jbHVkZWQgd2l0aCA8bWVuY2xvc2U+LlxuICAgICAgZmJveHNlcCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5mYm94c2VwICogb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiK1wiICsgMiAqIGZib3hzZXAgKyBcInB0XCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIrXCIgKyAyICogZmJveHNlcCArIFwicHRcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBmYm94c2VwICsgXCJwdFwiKTsgLy9cblxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIGZib3hzZXAgKyBcInB0XCIpO1xuXG4gICAgICBpZiAoZ3JvdXAubGFiZWwgPT09IFwiXFxcXGZjb2xvcmJveFwiKSB7XG4gICAgICAgIGNvbnN0IHRoayA9IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5mYm94cnVsZSwgLy8gZGVmYXVsdFxuICAgICAgICBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MgLy8gdXNlciBvdmVycmlkZVxuICAgICAgICApO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiYm9yZGVyOiBcIiArIHRoayArIFwiZW0gc29saWQgXCIgKyBTdHJpbmcoZ3JvdXAuYm9yZGVyQ29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXHhjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJ1cGRpYWdvbmFsc3RyaWtlIGRvd25kaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKGdyb3VwLmJhY2tncm91bmRDb2xvcikge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aGJhY2tncm91bmRcIiwgZ3JvdXAuYmFja2dyb3VuZENvbG9yKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxjb2xvcmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCIsIFwidGV4dFwiXVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogZW5jbG9zZV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZW5jbG9zZV9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcZmNvbG9yYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDMsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJjb2xvclwiLCBcInRleHRcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWYyLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IGJvcmRlckNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcImNvbG9yLXRva2VuXCIpLmNvbG9yO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogZW5jbG9zZV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZW5jbG9zZV9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcZmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmMztcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBcIlxcXFxmYm94XCIsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcY2FuY2VsXCIsIFwiXFxcXGJjYW5jZWxcIiwgXCJcXFxceGNhbmNlbFwiLCBcIlxcXFxzb3V0XCIsIFwiXFxcXHBoYXNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY0LCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY0O1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGVuY2xvc2VfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGVuY2xvc2VfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGFuZ2xcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjUsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY1O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IFwiXFxcXGFuZ2xcIixcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RlZmluZUVudmlyb25tZW50LmpzXG5cblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBlbnZpcm9ubWVudHMuXG4gKiBgZW52aXJvbm1lbnRzLmpzYCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkgdmlhIGBlbnZpcm9ubWVudHMuanNgLlxuICovXG5jb25zdCBfZW52aXJvbm1lbnRzID0ge307XG5mdW5jdGlvbiBkZWZpbmVFbnZpcm9ubWVudChfcmVmKSB7XG4gIGxldCB7XG4gICAgdHlwZSxcbiAgICBuYW1lcyxcbiAgICBwcm9wcyxcbiAgICBoYW5kbGVyLFxuICAgIGh0bWxCdWlsZGVyLFxuICAgIG1hdGhtbEJ1aWxkZXJcbiAgfSA9IF9yZWY7XG4gIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBlbnZpcm9ubWVudHMuXG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdHlwZSxcbiAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzIHx8IDAsXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2UsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAwLFxuICAgIGhhbmRsZXJcbiAgfTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gVE9ETzogVGhlIHZhbHVlIHR5cGUgb2YgX2Vudmlyb25tZW50cyBzaG91bGQgYmUgYSB0eXBlIHVuaW9uIG9mIGFsbFxuICAgIC8vIHBvc3NpYmxlIGBFbnZTcGVjPD5gIHBvc3NpYmlsaXRpZXMgaW5zdGVhZCBvZiBgRW52U3BlYzwqPmAsIHdoaWNoIGlzXG4gICAgLy8gYW4gZXhpc3RlbnRpYWwgdHlwZS5cbiAgICBfZW52aXJvbm1lbnRzW25hbWVzW2ldXSA9IGRhdGE7XG4gIH1cblxuICBpZiAoaHRtbEJ1aWxkZXIpIHtcbiAgICBfaHRtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBodG1sQnVpbGRlcjtcbiAgfVxuXG4gIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGVmaW5lTWFjcm8uanNcblxuXG4vKipcbiAqIEFsbCByZWdpc3RlcmVkIGdsb2JhbC9idWlsdC1pbiBtYWNyb3MuXG4gKiBgbWFjcm9zLmpzYCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkgdmlhIGBtYWNyb3MuanNgLlxuICovXG5jb25zdCBfbWFjcm9zID0ge307IC8vIFRoaXMgZnVuY3Rpb24gbWlnaHQgb25lIGRheSBhY2NlcHQgYW4gYWRkaXRpb25hbCBhcmd1bWVudCBhbmQgZG8gbW9yZSB0aGluZ3MuXG5cbmZ1bmN0aW9uIGRlZmluZU1hY3JvKG5hbWUsIGJvZHkpIHtcbiAgX21hY3Jvc1tuYW1lXSA9IGJvZHk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvU291cmNlTG9jYXRpb24uanNcbi8qKlxuICogTGV4aW5nIG9yIHBhcnNpbmcgcG9zaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgZXJyb3IgcmVwb3J0aW5nLlxuICogVGhpcyBvYmplY3QgaXMgaW1tdXRhYmxlLlxuICovXG5jbGFzcyBTb3VyY2VMb2NhdGlvbiB7XG4gIC8vIFRoZSArIHByZWZpeCBpbmRpY2F0ZXMgdGhhdCB0aGVzZSBmaWVsZHMgYXJlbid0IHdyaXRlYWJsZVxuICAvLyBMZXhlciBob2xkaW5nIHRoZSBpbnB1dCBzdHJpbmcuXG4gIC8vIFN0YXJ0IG9mZnNldCwgemVyby1iYXNlZCBpbmNsdXNpdmUuXG4gIC8vIEVuZCBvZmZzZXQsIHplcm8tYmFzZWQgZXhjbHVzaXZlLlxuICBjb25zdHJ1Y3RvcihsZXhlciwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMubGV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmxleGVyID0gbGV4ZXI7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZXMgdHdvIGBTb3VyY2VMb2NhdGlvbmBzIGZyb20gbG9jYXRpb24gcHJvdmlkZXJzLCBnaXZlbiB0aGV5IGFyZVxuICAgKiBwcm92aWRlZCBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLlxuICAgKiAtIFJldHVybnMgdGhlIGZpcnN0IG9uZSdzIGxvY2F0aW9uIGlmIG9ubHkgdGhlIGZpcnN0IGlzIHByb3ZpZGVkLlxuICAgKiAtIFJldHVybnMgYSBtZXJnZWQgcmFuZ2Ugb2YgdGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBpZiBib3RoIGFyZSBwcm92aWRlZFxuICAgKiAgIGFuZCB0aGVpciBsZXhlcnMgbWF0Y2guXG4gICAqIC0gT3RoZXJ3aXNlLCByZXR1cm5zIG51bGwuXG4gICAqL1xuXG5cbiAgc3RhdGljIHJhbmdlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoIXNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmxvYztcbiAgICB9IGVsc2UgaWYgKCFmaXJzdCB8fCAhZmlyc3QubG9jIHx8ICFzZWNvbmQubG9jIHx8IGZpcnN0LmxvYy5sZXhlciAhPT0gc2Vjb25kLmxvYy5sZXhlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgU291cmNlTG9jYXRpb24oZmlyc3QubG9jLmxleGVyLCBmaXJzdC5sb2Muc3RhcnQsIHNlY29uZC5sb2MuZW5kKTtcbiAgICB9XG4gIH1cblxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1Rva2VuLmpzXG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcXVpcmVkIHRvIGJyZWFrIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBUb2tlbiwgTGV4ZXIsIGFuZFxuICogUGFyc2VFcnJvci5cbiAqL1xuXG4vKipcbiAqIFRoZSByZXN1bHRpbmcgdG9rZW4gcmV0dXJuZWQgZnJvbSBgbGV4YC5cbiAqXG4gKiBJdCBjb25zaXN0cyBvZiB0aGUgdG9rZW4gdGV4dCBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gKiBUaGUgcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgZXNzZW50aWFsbHkgYSByYW5nZSBpbiBhbiBpbnB1dCBzdHJpbmcsXG4gKiBidXQgaW5zdGVhZCBvZiByZWZlcmVuY2luZyB0aGUgYmFyZSBpbnB1dCBzdHJpbmcsIHdlIHJlZmVyIHRvIHRoZSBsZXhlci5cbiAqIFRoYXQgd2F5IGl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBleHRyYSBtZXRhZGF0YSB0byB0aGUgaW5wdXQgc3RyaW5nLFxuICogbGlrZSBmb3IgZXhhbXBsZSBhIGZpbGUgbmFtZSBvciBzaW1pbGFyLlxuICpcbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBvcHRpb25hbCwgc28gaXQgaXMgT0sgdG8gY29uc3RydWN0IHN5bnRoZXRpY1xuICogdG9rZW5zIGlmIGFwcHJvcHJpYXRlLiBOb3QgcHJvdmlkaW5nIGF2YWlsYWJsZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBtYXlcbiAqIGxlYWQgdG8gZGVncmFkZWQgZXJyb3IgcmVwb3J0aW5nLCB0aG91Z2guXG4gKi9cbmNsYXNzIFRva2VuIHtcbiAgLy8gZG9uJ3QgZXhwYW5kIHRoZSB0b2tlblxuICAvLyB1c2VkIGluIFxcbm9leHBhbmRcbiAgY29uc3RydWN0b3IodGV4dCwgLy8gdGhlIHRleHQgb2YgdGhpcyB0b2tlblxuICBsb2MpIHtcbiAgICB0aGlzLnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2MgPSB2b2lkIDA7XG4gICAgdGhpcy5ub2V4cGFuZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyZWF0QXNSZWxheCA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMubG9jID0gbG9jO1xuICB9XG4gIC8qKlxuICAgKiBHaXZlbiBhIHBhaXIgb2YgdG9rZW5zICh0aGlzIGFuZCBlbmRUb2tlbiksIGNvbXB1dGUgYSBgVG9rZW5gIGVuY29tcGFzc2luZ1xuICAgKiB0aGUgd2hvbGUgaW5wdXQgcmFuZ2UgZW5jbG9zZWQgYnkgdGhlc2UgdHdvLlxuICAgKi9cblxuXG4gIHJhbmdlKGVuZFRva2VuLCAvLyBsYXN0IHRva2VuIG9mIHRoZSByYW5nZSwgaW5jbHVzaXZlXG4gIHRleHQgLy8gdGhlIHRleHQgb2YgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHRva2VuXG4gICkge1xuICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCwgU291cmNlTG9jYXRpb24ucmFuZ2UodGhpcywgZW5kVG9rZW4pKTtcbiAgfVxuXG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZW52aXJvbm1lbnRzL2FycmF5LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGdldEhMaW5lcyhwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGFuIGFycmF5LiBUaGUgYXJyYXkgbGVuZ3RoID0gbnVtYmVyIG9mIGhsaW5lcy5cbiAgLy8gRWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB0ZWxscyBpZiB0aGUgbGluZSBpcyBkYXNoZWQuXG4gIGNvbnN0IGhsaW5lSW5mbyA9IFtdO1xuICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICBsZXQgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcblxuICBpZiAobnh0ID09PSBcIlxcXFxyZWxheFwiKSB7XG4gICAgLy8gXFxyZWxheCBpcyBhbiBhcnRpZmFjdCBvZiB0aGUgXFxjciBtYWNybyBiZWxvd1xuICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICBueHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICB9XG5cbiAgd2hpbGUgKG54dCA9PT0gXCJcXFxcaGxpbmVcIiB8fCBueHQgPT09IFwiXFxcXGhkYXNobGluZVwiKSB7XG4gICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICBobGluZUluZm8ucHVzaChueHQgPT09IFwiXFxcXGhkYXNobGluZVwiKTtcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gaGxpbmVJbmZvO1xufVxuXG5jb25zdCB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dCA9IGNvbnRleHQgPT4ge1xuICBjb25zdCBzZXR0aW5ncyA9IGNvbnRleHQucGFyc2VyLnNldHRpbmdzO1xuXG4gIGlmICghc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJ7XCIgKyBjb250ZXh0LmVudk5hbWUgKyBcIn0gY2FuIGJlIHVzZWQgb25seSBpblwiICsgXCIgZGlzcGxheSBtb2RlLlwiKTtcbiAgfVxufTsgLy8gYXV0b1RhZyAoYW4gYXJndW1lbnQgdG8gcGFyc2VBcnJheSkgY2FuIGJlIG9uZSBvZiB0aHJlZSB2YWx1ZXM6XG4vLyAqIHVuZGVmaW5lZDogUmVndWxhciAobm90LXRvcC1sZXZlbCkgYXJyYXk7IG5vIHRhZ3Mgb24gZWFjaCByb3dcbi8vICogdHJ1ZTogQXV0b21hdGljIGVxdWF0aW9uIG51bWJlcmluZywgb3ZlcnJpZGFibGUgYnkgXFx0YWdcbi8vICogZmFsc2U6IFRhZ3MgYWxsb3dlZCBvbiBlYWNoIHJvdywgYnV0IG5vIGF1dG9tYXRpYyBudW1iZXJpbmdcbi8vIFRoaXMgZnVuY3Rpb24gKmRvZXNuJ3QqIHdvcmsgd2l0aCB0aGUgXCJzcGxpdFwiIGVudmlyb25tZW50IG5hbWUuXG5cblxuZnVuY3Rpb24gZ2V0QXV0b1RhZyhuYW1lKSB7XG4gIGlmIChuYW1lLmluZGV4T2YoXCJlZFwiKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gbmFtZS5pbmRleE9mKFwiKlwiKSA9PT0gLTE7XG4gIH0gLy8gcmV0dXJuIHVuZGVmaW5lZDtcblxufVxuLyoqXG4gKiBQYXJzZSB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQsIHdpdGggcm93cyBkZWxpbWl0ZWQgYnkgXFxcXCBhbmRcbiAqIGNvbHVtbnMgZGVsaW1pdGVkIGJ5ICYsIGFuZCBjcmVhdGUgYSBuZXN0ZWQgbGlzdCBpbiByb3ctbWFqb3Igb3JkZXJcbiAqIHdpdGggb25lIGdyb3VwIHBlciBjZWxsLiAgSWYgZ2l2ZW4gYW4gb3B0aW9uYWwgYXJndW1lbnQgc3R5bGVcbiAqIChcInRleHRcIiwgXCJkaXNwbGF5XCIsIGV0Yy4pLCB0aGVuIGVhY2ggY2VsbCBpcyBjYXN0IGludG8gdGhhdCBzdHlsZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlQXJyYXkocGFyc2VyLCBfcmVmLCBzdHlsZSkge1xuICBsZXQge1xuICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXIsXG4gICAgYWRkSm90LFxuICAgIGNvbHMsXG4gICAgYXJyYXlzdHJldGNoLFxuICAgIGNvbFNlcGFyYXRpb25UeXBlLFxuICAgIGF1dG9UYWcsXG4gICAgc2luZ2xlUm93LFxuICAgIGVtcHR5U2luZ2xlUm93LFxuICAgIG1heE51bUNvbHMsXG4gICAgbGVxbm9cbiAgfSA9IF9yZWY7XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuXG4gIGlmICghc2luZ2xlUm93KSB7XG4gICAgLy8gXFxjciBpcyBlcXVpdmFsZW50IHRvIFxcXFwgd2l0aG91dCB0aGUgb3B0aW9uYWwgc2l6ZSBhcmd1bWVudCAoc2VlIGJlbG93KVxuICAgIC8vIFRPRE86IHByb3ZpZGUgaGVscGZ1bCBlcnJvciB3aGVuIFxcY3IgaXMgdXNlZCBvdXRzaWRlIGFycmF5IGVudmlyb25tZW50XG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNyXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG4gIH0gLy8gR2V0IGN1cnJlbnQgYXJyYXlzdHJldGNoIGlmIGl0J3Mgbm90IHNldCBieSB0aGUgZW52aXJvbm1lbnRcblxuXG4gIGlmICghYXJyYXlzdHJldGNoKSB7XG4gICAgY29uc3Qgc3RyZXRjaCA9IHBhcnNlci5ndWxsZXQuZXhwYW5kTWFjcm9Bc1RleHQoXCJcXFxcYXJyYXlzdHJldGNoXCIpO1xuXG4gICAgaWYgKHN0cmV0Y2ggPT0gbnVsbCkge1xuICAgICAgLy8gRGVmYXVsdCBcXGFycmF5c3RyZXRjaCBmcm9tIGx0dGFiLmR0eFxuICAgICAgYXJyYXlzdHJldGNoID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXlzdHJldGNoID0gcGFyc2VGbG9hdChzdHJldGNoKTtcblxuICAgICAgaWYgKCFhcnJheXN0cmV0Y2ggfHwgYXJyYXlzdHJldGNoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIFxcXFxhcnJheXN0cmV0Y2g6IFwiICsgc3RyZXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFN0YXJ0IGdyb3VwIGZvciBmaXJzdCBjZWxsXG5cblxuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgbGV0IHJvdyA9IFtdO1xuICBjb25zdCBib2R5ID0gW3Jvd107XG4gIGNvbnN0IHJvd0dhcHMgPSBbXTtcbiAgY29uc3QgaExpbmVzQmVmb3JlUm93ID0gW107XG4gIGNvbnN0IHRhZ3MgPSBhdXRvVGFnICE9IG51bGwgPyBbXSA6IHVuZGVmaW5lZDsgLy8gYW1zbWF0aCB1c2VzIFxcZ2xvYmFsXFxAZXFuc3d0cnVlIGFuZCBcXGdsb2JhbFxcQGVxbnN3ZmFsc2UgdG8gcmVwcmVzZW50XG4gIC8vIHdoZXRoZXIgdGhpcyByb3cgc2hvdWxkIGhhdmUgYW4gZXF1YXRpb24gbnVtYmVyLiAgU2ltdWxhdGUgdGhpcyB3aXRoXG4gIC8vIGEgXFxAZXFuc3cgbWFjcm8gc2V0IHRvIDEgb3IgMC5cblxuICBmdW5jdGlvbiBiZWdpblJvdygpIHtcbiAgICBpZiAoYXV0b1RhZykge1xuICAgICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXEBlcW5zd1wiLCBcIjFcIiwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUm93KCkge1xuICAgIGlmICh0YWdzKSB7XG4gICAgICBpZiAocGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgICAgICB0YWdzLnB1c2gocGFyc2VyLnN1YnBhcnNlKFtuZXcgVG9rZW4oXCJcXFxcZGZAdGFnXCIpXSkpO1xuICAgICAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcZGZAdGFnXCIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdzLnB1c2goQm9vbGVhbihhdXRvVGFnKSAmJiBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcQGVxbnN3XCIpID09PSBcIjFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmVnaW5Sb3coKTsgLy8gVGVzdCBmb3IgXFxobGluZSBhdCB0aGUgdG9wIG9mIHRoZSBhcnJheS5cblxuICBoTGluZXNCZWZvcmVSb3cucHVzaChnZXRITGluZXMocGFyc2VyKSk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIC8vIFBhcnNlIGVhY2ggY2VsbCBpbiBpdHMgb3duIGdyb3VwIChuYW1lc3BhY2UpXG4gICAgbGV0IGNlbGwgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBzaW5nbGVSb3cgPyBcIlxcXFxlbmRcIiA6IFwiXFxcXFxcXFxcIik7XG4gICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNlbGwgPSB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGNlbGxcbiAgICB9O1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjZWxsID0ge1xuICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBib2R5OiBbY2VsbF1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcm93LnB1c2goY2VsbCk7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG5cbiAgICBpZiAobmV4dCA9PT0gXCImXCIpIHtcbiAgICAgIGlmIChtYXhOdW1Db2xzICYmIHJvdy5sZW5ndGggPT09IG1heE51bUNvbHMpIHtcbiAgICAgICAgaWYgKHNpbmdsZVJvdyB8fCBjb2xTZXBhcmF0aW9uVHlwZSkge1xuICAgICAgICAgIC8vIHtlcXVhdGlvbn0gb3Ige3NwbGl0fVxuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlRvbyBtYW55IHRhYiBjaGFyYWN0ZXJzOiAmXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHthcnJheX0gZW52aXJvbm1lbnRcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidGV4dEVudlwiLCBcIlRvbyBmZXcgY29sdW1ucyBcIiArIFwic3BlY2lmaWVkIGluIHRoZSB7YXJyYXl9IGNvbHVtbiBhcmd1bWVudC5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXGVuZFwiKSB7XG4gICAgICBlbmRSb3coKTsgLy8gQXJyYXlzIHRlcm1pbmF0ZSBuZXdsaW5lcyB3aXRoIGBcXGNyY3JgIHdoaWNoIGNvbnN1bWVzIGEgYFxcY3JgIGlmXG4gICAgICAvLyB0aGUgbGFzdCBsaW5lIGlzIGVtcHR5LiAgSG93ZXZlciwgQU1TIGVudmlyb25tZW50cyBrZWVwIHRoZVxuICAgICAgLy8gZW1wdHkgcm93IGlmIGl0J3MgdGhlIG9ubHkgb25lLlxuICAgICAgLy8gTk9URTogQ3VycmVudGx5LCBgY2VsbGAgaXMgdGhlIGxhc3QgaXRlbSBhZGRlZCBpbnRvIGByb3dgLlxuXG4gICAgICBpZiAocm93Lmxlbmd0aCA9PT0gMSAmJiBjZWxsLnR5cGUgPT09IFwic3R5bGluZ1wiICYmIGNlbGwuYm9keVswXS5ib2R5Lmxlbmd0aCA9PT0gMCAmJiAoYm9keS5sZW5ndGggPiAxIHx8ICFlbXB0eVNpbmdsZVJvdykpIHtcbiAgICAgICAgYm9keS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhMaW5lc0JlZm9yZVJvdy5sZW5ndGggPCBib2R5Lmxlbmd0aCArIDEpIHtcbiAgICAgICAgaExpbmVzQmVmb3JlUm93LnB1c2goW10pO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgIGxldCBzaXplOyAvLyBcXGRlZlxcTGV0QHtcXGxldFxcXFxcXG1hdGhAY3J9XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjcnsuLi5cXG1hdGhAY3JAfVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAe1xcbmV3QGlmbmV4dGNoYXJbXFxtYXRoQGNyQEB7XFxtYXRoQGNyQEBbXFx6QF19fVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAQFsjMV17Li4uXFxtYXRoQGNyQEBALi4ufVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAQEB7XFxjcn1cblxuICAgICAgaWYgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCIgXCIpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlci5wYXJzZVNpemVHcm91cCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcm93R2Fwcy5wdXNoKHNpemUgPyBzaXplLnZhbHVlIDogbnVsbCk7XG4gICAgICBlbmRSb3coKTsgLy8gY2hlY2sgZm9yIFxcaGxpbmUocykgZm9sbG93aW5nIHRoZSByb3cgc2VwYXJhdG9yXG5cbiAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKGdldEhMaW5lcyhwYXJzZXIpKTtcbiAgICAgIHJvdyA9IFtdO1xuICAgICAgYm9keS5wdXNoKHJvdyk7XG4gICAgICBiZWdpblJvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCAmIG9yIFxcXFxcXFxcIG9yIFxcXFxjciBvciBcXFxcZW5kXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgIH1cbiAgfSAvLyBFbmQgY2VsbCBncm91cFxuXG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOyAvLyBFbmQgYXJyYXkgZ3JvdXAgZGVmaW5pbmcgXFxjclxuXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgYWRkSm90LFxuICAgIGFycmF5c3RyZXRjaCxcbiAgICBib2R5LFxuICAgIGNvbHMsXG4gICAgcm93R2FwcyxcbiAgICBoc2tpcEJlZm9yZUFuZEFmdGVyLFxuICAgIGhMaW5lc0JlZm9yZVJvdyxcbiAgICBjb2xTZXBhcmF0aW9uVHlwZSxcbiAgICB0YWdzLFxuICAgIGxlcW5vXG4gIH07XG59IC8vIERlY2lkZXMgb24gYSBzdHlsZSBmb3IgY2VsbHMgaW4gYW4gYXJyYXkgYWNjb3JkaW5nIHRvIHdoZXRoZXIgdGhlIGdpdmVuXG4vLyBlbnZpcm9ubWVudCBuYW1lIHN0YXJ0cyB3aXRoIHRoZSBsZXR0ZXIgJ2QnLlxuXG5cbmZ1bmN0aW9uIGRDZWxsU3R5bGUoZW52TmFtZSkge1xuICBpZiAoZW52TmFtZS5zbGljZSgwLCAxKSA9PT0gXCJkXCIpIHtcbiAgICByZXR1cm4gXCJkaXNwbGF5XCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwidGV4dFwiO1xuICB9XG59XG5cbmNvbnN0IGFycmF5X2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gKGdyb3VwLCBvcHRpb25zKSB7XG4gIGxldCByO1xuICBsZXQgYztcbiAgY29uc3QgbnIgPSBncm91cC5ib2R5Lmxlbmd0aDtcbiAgY29uc3QgaExpbmVzQmVmb3JlUm93ID0gZ3JvdXAuaExpbmVzQmVmb3JlUm93O1xuICBsZXQgbmMgPSAwO1xuICBsZXQgYm9keSA9IG5ldyBBcnJheShucik7XG4gIGNvbnN0IGhsaW5lcyA9IFtdO1xuICBjb25zdCBydWxlVGhpY2tuZXNzID0gTWF0aC5tYXgoIC8vIEZyb20gTGFUZVggXFxzaG93dGhlXFxhcnJheXJ1bGV3aWR0aC4gRXF1YWxzIDAuMDQgZW0uXG4gIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5hcnJheVJ1bGVXaWR0aCwgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzIC8vIFVzZXIgb3ZlcnJpZGUuXG4gICk7IC8vIEhvcml6b250YWwgc3BhY2luZ1xuXG4gIGNvbnN0IHB0ID0gMSAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICBsZXQgYXJyYXljb2xzZXAgPSA1ICogcHQ7IC8vIGRlZmF1bHQgdmFsdWUsIGkuZS4gXFxhcnJheWNvbHNlcCBpbiBhcnRpY2xlLmNsc1xuXG4gIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSAmJiBncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgLy8gV2UncmUgaW4gYSB7c21hbGxtYXRyaXh9LiBEZWZhdWx0IGNvbHVtbiBzcGFjZSBpcyBcXHRoaWNrc3BhY2UsXG4gICAgLy8gaS5lLiA1LzE4ZW0gPSAwLjI3NzhlbSwgcGVyIGFtc21hdGguZHR4IGZvciB7c21hbGxtYXRyaXh9LlxuICAgIC8vIEJ1dCB0aGF0IG5lZWRzIGFkanVzdG1lbnQgYmVjYXVzZSBMYVRlWCBhcHBsaWVzIFxcc2NyaXB0c3R5bGUgdG8gdGhlXG4gICAgLy8gZW50aXJlIGFycmF5LCBpbmNsdWRpbmcgdGhlIGNvbHNwYWNlLCBidXQgdGhpcyBmdW5jdGlvbiBhcHBsaWVzXG4gICAgLy8gXFxzY3JpcHRzdHlsZSBvbmx5IGluc2lkZSBlYWNoIGVsZW1lbnQuXG4gICAgY29uc3QgbG9jYWxNdWx0aXBsaWVyID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzcmNfU3R5bGUuU0NSSVBUKS5zaXplTXVsdGlwbGllcjtcbiAgICBhcnJheWNvbHNlcCA9IDAuMjc3OCAqIChsb2NhbE11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyKTtcbiAgfSAvLyBWZXJ0aWNhbCBzcGFjaW5nXG5cblxuICBjb25zdCBiYXNlbGluZXNraXAgPSBncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJDRFwiID8gY2FsY3VsYXRlU2l6ZSh7XG4gICAgbnVtYmVyOiAzLFxuICAgIHVuaXQ6IFwiZXhcIlxuICB9LCBvcHRpb25zKSA6IDEyICogcHQ7IC8vIHNlZSBzaXplMTAuY2xvXG4gIC8vIERlZmF1bHQgXFxqb3QgZnJvbSBsdG1hdGguZHR4XG4gIC8vIFRPRE8oZWRlbWFpbmUpOiBhbGxvdyBvdmVycmlkaW5nIFxcam90IHZpYSBcXHNldGxlbmd0aCAoIzY4NylcblxuICBjb25zdCBqb3QgPSAzICogcHQ7XG4gIGNvbnN0IGFycmF5c2tpcCA9IGdyb3VwLmFycmF5c3RyZXRjaCAqIGJhc2VsaW5lc2tpcDtcbiAgY29uc3QgYXJzdHJ1dEhlaWdodCA9IDAuNyAqIGFycmF5c2tpcDsgLy8gXFxzdHJ1dGJveCBpbiBsdGZzc3RyYy5kdHggYW5kXG5cbiAgY29uc3QgYXJzdHJ1dERlcHRoID0gMC4zICogYXJyYXlza2lwOyAvLyBcXEBhcnN0cnV0Ym94IGluIGx0dGFiLmR0eFxuXG4gIGxldCB0b3RhbEhlaWdodCA9IDA7IC8vIFNldCBhIHBvc2l0aW9uIGZvciBcXGhsaW5lKHMpIGF0IHRoZSB0b3Agb2YgdGhlIGFycmF5LCBpZiBhbnkuXG5cbiAgZnVuY3Rpb24gc2V0SExpbmVQb3MoaGxpbmVzSW5HYXApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhsaW5lc0luR2FwLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gMC4yNTtcbiAgICAgIH1cblxuICAgICAgaGxpbmVzLnB1c2goe1xuICAgICAgICBwb3M6IHRvdGFsSGVpZ2h0LFxuICAgICAgICBpc0Rhc2hlZDogaGxpbmVzSW5HYXBbaV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNldEhMaW5lUG9zKGhMaW5lc0JlZm9yZVJvd1swXSk7XG5cbiAgZm9yIChyID0gMDsgciA8IGdyb3VwLmJvZHkubGVuZ3RoOyArK3IpIHtcbiAgICBjb25zdCBpbnJvdyA9IGdyb3VwLmJvZHlbcl07XG4gICAgbGV0IGhlaWdodCA9IGFyc3RydXRIZWlnaHQ7IC8vIFxcQGFycmF5IGFkZHMgYW4gXFxAYXJzdHJ1dFxuXG4gICAgbGV0IGRlcHRoID0gYXJzdHJ1dERlcHRoOyAvLyB0byBlYWNoIHRvdyAodmlhIHRoZSB0ZW1wbGF0ZSlcblxuICAgIGlmIChuYyA8IGlucm93Lmxlbmd0aCkge1xuICAgICAgbmMgPSBpbnJvdy5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cm93ID0gbmV3IEFycmF5KGlucm93Lmxlbmd0aCk7XG5cbiAgICBmb3IgKGMgPSAwOyBjIDwgaW5yb3cubGVuZ3RoOyArK2MpIHtcbiAgICAgIGNvbnN0IGVsdCA9IGJ1aWxkR3JvdXAoaW5yb3dbY10sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoZGVwdGggPCBlbHQuZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSBlbHQuZGVwdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHQgPCBlbHQuaGVpZ2h0KSB7XG4gICAgICAgIGhlaWdodCA9IGVsdC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIG91dHJvd1tjXSA9IGVsdDtcbiAgICB9XG5cbiAgICBjb25zdCByb3dHYXAgPSBncm91cC5yb3dHYXBzW3JdO1xuICAgIGxldCBnYXAgPSAwO1xuXG4gICAgaWYgKHJvd0dhcCkge1xuICAgICAgZ2FwID0gY2FsY3VsYXRlU2l6ZShyb3dHYXAsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoZ2FwID4gMCkge1xuICAgICAgICAvLyBcXEBhcmdhcnJheWNyXG4gICAgICAgIGdhcCArPSBhcnN0cnV0RGVwdGg7XG5cbiAgICAgICAgaWYgKGRlcHRoIDwgZ2FwKSB7XG4gICAgICAgICAgZGVwdGggPSBnYXA7IC8vIFxcQHhhcmdhcnJheWNyXG4gICAgICAgIH1cblxuICAgICAgICBnYXAgPSAwO1xuICAgICAgfVxuICAgIH0gLy8gSW4gQU1TIG11bHRpbGluZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBhbGlnbmVkIGFuZCBnYXRoZXJlZCwgcm93c1xuICAgIC8vIGNvcnJlc3BvbmQgdG8gbGluZXMgdGhhdCBoYXZlIGFkZGl0aW9uYWwgXFxqb3QgYWRkZWQgdG8gdGhlXG4gICAgLy8gXFxiYXNlbGluZXNraXAgdmlhIFxcb3BlbnVwLlxuXG5cbiAgICBpZiAoZ3JvdXAuYWRkSm90KSB7XG4gICAgICBkZXB0aCArPSBqb3Q7XG4gICAgfVxuXG4gICAgb3V0cm93LmhlaWdodCA9IGhlaWdodDtcbiAgICBvdXRyb3cuZGVwdGggPSBkZXB0aDtcbiAgICB0b3RhbEhlaWdodCArPSBoZWlnaHQ7XG4gICAgb3V0cm93LnBvcyA9IHRvdGFsSGVpZ2h0O1xuICAgIHRvdGFsSGVpZ2h0ICs9IGRlcHRoICsgZ2FwOyAvLyBcXEB5YXJnYXJyYXljclxuXG4gICAgYm9keVtyXSA9IG91dHJvdzsgLy8gU2V0IGEgcG9zaXRpb24gZm9yIFxcaGxpbmUocyksIGlmIGFueS5cblxuICAgIHNldEhMaW5lUG9zKGhMaW5lc0JlZm9yZVJvd1tyICsgMV0pO1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gdG90YWxIZWlnaHQgLyAyICsgb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7XG4gIGNvbnN0IGNvbERlc2NyaXB0aW9ucyA9IGdyb3VwLmNvbHMgfHwgW107XG4gIGNvbnN0IGNvbHMgPSBbXTtcbiAgbGV0IGNvbFNlcDtcbiAgbGV0IGNvbERlc2NyTnVtO1xuICBjb25zdCB0YWdTcGFucyA9IFtdO1xuXG4gIGlmIChncm91cC50YWdzICYmIGdyb3VwLnRhZ3Muc29tZSh0YWcgPT4gdGFnKSkge1xuICAgIC8vIEFuIGVudmlyb25tZW50IHdpdGggbWFudWFsIHRhZ3MgYW5kL29yIGF1dG9tYXRpYyBlcXVhdGlvbiBudW1iZXJzLlxuICAgIC8vIENyZWF0ZSBub2RlKHMpLCB0aGUgbGF0dGVyIG9mIHdoaWNoIHRyaWdnZXIgQ1NTIGNvdW50ZXIgaW5jcmVtZW50LlxuICAgIGZvciAociA9IDA7IHIgPCBucjsgKytyKSB7XG4gICAgICBjb25zdCBydyA9IGJvZHlbcl07XG4gICAgICBjb25zdCBzaGlmdCA9IHJ3LnBvcyAtIG9mZnNldDtcbiAgICAgIGNvbnN0IHRhZyA9IGdyb3VwLnRhZ3Nbcl07XG4gICAgICBsZXQgdGFnU3BhbjtcblxuICAgICAgaWYgKHRhZyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBhdXRvbWF0aWMgbnVtYmVyaW5nXG4gICAgICAgIHRhZ1NwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJlcW4tbnVtXCJdLCBbXSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gXFxub251bWJlci9cXG5vdGFnIG9yIHN0YXJyZWQgZW52aXJvbm1lbnRcbiAgICAgICAgdGFnU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbXSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtYW51YWwgXFx0YWdcbiAgICAgICAgdGFnU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBidWlsZEV4cHJlc3Npb24odGFnLCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRhZ1NwYW4uZGVwdGggPSBydy5kZXB0aDtcbiAgICAgIHRhZ1NwYW4uaGVpZ2h0ID0gcncuaGVpZ2h0O1xuICAgICAgdGFnU3BhbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiB0YWdTcGFuLFxuICAgICAgICBzaGlmdFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjID0gMCwgY29sRGVzY3JOdW0gPSAwOyAvLyBDb250aW51ZSB3aGlsZSBlaXRoZXIgdGhlcmUgYXJlIG1vcmUgY29sdW1ucyBvciBtb3JlIGNvbHVtblxuICAvLyBkZXNjcmlwdGlvbnMsIHNvIHRyYWlsaW5nIHNlcGFyYXRvcnMgZG9uJ3QgZ2V0IGxvc3QuXG4gIGMgPCBuYyB8fCBjb2xEZXNjck51bSA8IGNvbERlc2NyaXB0aW9ucy5sZW5ndGg7ICsrYywgKytjb2xEZXNjck51bSkge1xuICAgIGxldCBjb2xEZXNjciA9IGNvbERlc2NyaXB0aW9uc1tjb2xEZXNjck51bV0gfHwge307XG4gICAgbGV0IGZpcnN0U2VwYXJhdG9yID0gdHJ1ZTtcblxuICAgIHdoaWxlIChjb2xEZXNjci50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHNlcGFyYXRvciBpbiBhIHJvdywgYWRkIGEgc3BhY2VcbiAgICAgIC8vIGJldHdlZW4gdGhlbS5cbiAgICAgIGlmICghZmlyc3RTZXBhcmF0b3IpIHtcbiAgICAgICAgY29sU2VwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gbWFrZUVtKG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kb3VibGVSdWxlU2VwKTtcbiAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xEZXNjci5zZXBhcmF0b3IgPT09IFwifFwiIHx8IGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCI6XCIpIHtcbiAgICAgICAgY29uc3QgbGluZVR5cGUgPSBjb2xEZXNjci5zZXBhcmF0b3IgPT09IFwifFwiID8gXCJzb2xpZFwiIDogXCJkYXNoZWRcIjtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1widmVydGljYWwtc2VwYXJhdG9yXCJdLCBbXSwgb3B0aW9ucyk7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5oZWlnaHQgPSBtYWtlRW0odG90YWxIZWlnaHQpO1xuICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IG1ha2VFbShydWxlVGhpY2tuZXNzKTtcbiAgICAgICAgc2VwYXJhdG9yLnN0eWxlLmJvcmRlclJpZ2h0U3R5bGUgPSBsaW5lVHlwZTtcbiAgICAgICAgc2VwYXJhdG9yLnN0eWxlLm1hcmdpbiA9IFwiMCBcIiArIG1ha2VFbSgtcnVsZVRoaWNrbmVzcyAvIDIpO1xuICAgICAgICBjb25zdCBzaGlmdCA9IHRvdGFsSGVpZ2h0IC0gb2Zmc2V0O1xuXG4gICAgICAgIGlmIChzaGlmdCkge1xuICAgICAgICAgIHNlcGFyYXRvci5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1zaGlmdCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xzLnB1c2goc2VwYXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgc2VwYXJhdG9yIHR5cGU6IFwiICsgY29sRGVzY3Iuc2VwYXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgY29sRGVzY3JOdW0rKztcbiAgICAgIGNvbERlc2NyID0gY29sRGVzY3JpcHRpb25zW2NvbERlc2NyTnVtXSB8fCB7fTtcbiAgICAgIGZpcnN0U2VwYXJhdG9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGMgPj0gbmMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBzZXB3aWR0aDtcblxuICAgIGlmIChjID4gMCB8fCBncm91cC5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnByZWdhcCwgYXJyYXljb2xzZXApO1xuXG4gICAgICBpZiAoc2Vwd2lkdGggIT09IDApIHtcbiAgICAgICAgY29sU2VwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gbWFrZUVtKHNlcHdpZHRoKTtcbiAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGNvbCA9IFtdO1xuXG4gICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHtcbiAgICAgIGNvbnN0IHJvdyA9IGJvZHlbcl07XG4gICAgICBjb25zdCBlbGVtID0gcm93W2NdO1xuXG4gICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNoaWZ0ID0gcm93LnBvcyAtIG9mZnNldDtcbiAgICAgIGVsZW0uZGVwdGggPSByb3cuZGVwdGg7XG4gICAgICBlbGVtLmhlaWdodCA9IHJvdy5oZWlnaHQ7XG4gICAgICBjb2wucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICBzaGlmdDogc2hpZnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogY29sXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgY29sID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiY29sLWFsaWduLVwiICsgKGNvbERlc2NyLmFsaWduIHx8IFwiY1wiKV0sIFtjb2xdKTtcbiAgICBjb2xzLnB1c2goY29sKTtcblxuICAgIGlmIChjIDwgbmMgLSAxIHx8IGdyb3VwLmhza2lwQmVmb3JlQW5kQWZ0ZXIpIHtcbiAgICAgIHNlcHdpZHRoID0gdXRpbHMuZGVmbHQoY29sRGVzY3IucG9zdGdhcCwgYXJyYXljb2xzZXApO1xuXG4gICAgICBpZiAoc2Vwd2lkdGggIT09IDApIHtcbiAgICAgICAgY29sU2VwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gbWFrZUVtKHNlcHdpZHRoKTtcbiAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm10YWJsZVwiXSwgY29scyk7IC8vIEFkZCBcXGhsaW5lKHMpLCBpZiBhbnkuXG5cbiAgaWYgKGhsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGluZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImhsaW5lXCIsIG9wdGlvbnMsIHJ1bGVUaGlja25lc3MpO1xuICAgIGNvbnN0IGRhc2hlcyA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImhkYXNobGluZVwiLCBvcHRpb25zLCBydWxlVGhpY2tuZXNzKTtcbiAgICBjb25zdCB2TGlzdEVsZW1zID0gW3tcbiAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgZWxlbTogYm9keSxcbiAgICAgIHNoaWZ0OiAwXG4gICAgfV07XG5cbiAgICB3aGlsZSAoaGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGhsaW5lID0gaGxpbmVzLnBvcCgpO1xuICAgICAgY29uc3QgbGluZVNoaWZ0ID0gaGxpbmUucG9zIC0gb2Zmc2V0O1xuXG4gICAgICBpZiAoaGxpbmUuaXNEYXNoZWQpIHtcbiAgICAgICAgdkxpc3RFbGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBkYXNoZXMsXG4gICAgICAgICAgc2hpZnQ6IGxpbmVTaGlmdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZMaXN0RWxlbXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogbGluZSxcbiAgICAgICAgICBzaGlmdDogbGluZVNoaWZ0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IHZMaXN0RWxlbXNcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh0YWdTcGFucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgW2JvZHldLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZXFuTnVtQ29sID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiB0YWdTcGFuc1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGVxbk51bUNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInRhZ1wiXSwgW2Vxbk51bUNvbF0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoW2JvZHksIGVxbk51bUNvbF0pO1xuICB9XG59O1xuXG5jb25zdCBhbGlnbk1hcCA9IHtcbiAgYzogXCJjZW50ZXIgXCIsXG4gIGw6IFwibGVmdCBcIixcbiAgcjogXCJyaWdodCBcIlxufTtcblxuY29uc3QgYXJyYXlfbWF0aG1sQnVpbGRlciA9IGZ1bmN0aW9uIChncm91cCwgb3B0aW9ucykge1xuICBjb25zdCB0YmwgPSBbXTtcbiAgY29uc3QgZ2x1ZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdLCBbXCJtdHItZ2x1ZVwiXSk7XG4gIGNvbnN0IHRhZyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdLCBbXCJtbWwtZXFuLW51bVwiXSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcncgPSBncm91cC5ib2R5W2ldO1xuICAgIGNvbnN0IHJvdyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBydy5sZW5ndGg7IGorKykge1xuICAgICAgcm93LnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAocndbal0sIG9wdGlvbnMpXSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC50YWdzICYmIGdyb3VwLnRhZ3NbaV0pIHtcbiAgICAgIHJvdy51bnNoaWZ0KGdsdWUpO1xuICAgICAgcm93LnB1c2goZ2x1ZSk7XG5cbiAgICAgIGlmIChncm91cC5sZXFubykge1xuICAgICAgICByb3cudW5zaGlmdCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93LnB1c2godGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YmwucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCByb3cpKTtcbiAgfVxuXG4gIGxldCB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIHRibCk7IC8vIFNldCBjb2x1bW4gYWxpZ25tZW50LCByb3cgc3BhY2luZywgY29sdW1uIHNwYWNpbmcsIGFuZFxuICAvLyBhcnJheSBsaW5lcyBieSBzZXR0aW5nIGF0dHJpYnV0ZXMgb24gdGhlIHRhYmxlIGVsZW1lbnQuXG4gIC8vIFNldCB0aGUgcm93IHNwYWNpbmcuIEluIE1hdGhNTCwgd2Ugc3BlY2lmeSBhIGdhcCBkaXN0YW5jZS5cbiAgLy8gV2UgZG8gbm90IHVzZSByb3dHYXBbXSBiZWNhdXNlIE1hdGhNTCBhdXRvbWF0aWNhbGx5IGluY3JlYXNlc1xuICAvLyBjZWxsIGhlaWdodCB3aXRoIHRoZSBoZWlnaHQvZGVwdGggb2YgdGhlIGVsZW1lbnQgY29udGVudC5cbiAgLy8gTGFUZVggXFxhcnJheXN0cmV0Y2ggbXVsdGlwbGllcyB0aGUgcm93IGJhc2VsaW5lLXRvLWJhc2VsaW5lIGRpc3RhbmNlLlxuICAvLyBXZSBzaW11bGF0ZSB0aGlzIGJ5IGFkZGluZyAoYXJyYXlzdHJldGNoIC0gMSllbSB0byB0aGUgZ2FwLiBUaGlzXG4gIC8vIGRvZXMgYSByZWFzb25hYmxlIGpvYiBvZiBhZGp1c3RpbmcgYXJyYXlzIGNvbnRhaW5pbmcgMSBlbSB0YWxsIGNvbnRlbnQuXG4gIC8vIFRoZSAwLjE2IGFuZCAwLjA5IHZhbHVlcyBhcmUgZm91bmQgZW1waXJpY2FsbHkuIFRoZXkgcHJvZHVjZSBhbiBhcnJheVxuICAvLyBzaW1pbGFyIHRvIExhVGVYIGFuZCBpbiB3aGljaCBjb250ZW50IGRvZXMgbm90IGludGVyZmVyZSB3aXRoIFxcaGxpbmVzLlxuXG4gIGNvbnN0IGdhcCA9IGdyb3VwLmFycmF5c3RyZXRjaCA9PT0gMC41ID8gMC4xIC8vIHtzbWFsbG1hdHJpeH0sIHtzdWJhcnJheX1cbiAgOiAwLjE2ICsgZ3JvdXAuYXJyYXlzdHJldGNoIC0gMSArIChncm91cC5hZGRKb3QgPyAwLjA5IDogMCk7XG4gIHRhYmxlLnNldEF0dHJpYnV0ZShcInJvd3NwYWNpbmdcIiwgbWFrZUVtKGdhcCkpOyAvLyBNYXRoTUwgdGFibGUgbGluZXMgZ28gb25seSBiZXR3ZWVuIGNlbGxzLlxuICAvLyBUbyBwbGFjZSBhIGxpbmUgb24gYW4gZWRnZSB3ZSdsbCB1c2UgPG1lbmNsb3NlPiwgaWYgbmVjZXNzYXJ5LlxuXG4gIGxldCBtZW5jbG9zZSA9IFwiXCI7XG4gIGxldCBhbGlnbiA9IFwiXCI7XG5cbiAgaWYgKGdyb3VwLmNvbHMgJiYgZ3JvdXAuY29scy5sZW5ndGggPiAwKSB7XG4gICAgLy8gRmluZCBjb2x1bW4gYWxpZ25tZW50LCBjb2x1bW4gc3BhY2luZywgYW5kICB2ZXJ0aWNhbCBsaW5lcy5cbiAgICBjb25zdCBjb2xzID0gZ3JvdXAuY29scztcbiAgICBsZXQgY29sdW1uTGluZXMgPSBcIlwiO1xuICAgIGxldCBwcmV2VHlwZVdhc0FsaWduID0gZmFsc2U7XG4gICAgbGV0IGlTdGFydCA9IDA7XG4gICAgbGV0IGlFbmQgPSBjb2xzLmxlbmd0aDtcblxuICAgIGlmIChjb2xzWzBdLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgIG1lbmNsb3NlICs9IFwidG9wIFwiO1xuICAgICAgaVN0YXJ0ID0gMTtcbiAgICB9XG5cbiAgICBpZiAoY29sc1tjb2xzLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgIG1lbmNsb3NlICs9IFwiYm90dG9tIFwiO1xuICAgICAgaUVuZCAtPSAxO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBpU3RhcnQ7IGkgPCBpRW5kOyBpKyspIHtcbiAgICAgIGlmIChjb2xzW2ldLnR5cGUgPT09IFwiYWxpZ25cIikge1xuICAgICAgICBhbGlnbiArPSBhbGlnbk1hcFtjb2xzW2ldLmFsaWduXTtcblxuICAgICAgICBpZiAocHJldlR5cGVXYXNBbGlnbikge1xuICAgICAgICAgIGNvbHVtbkxpbmVzICs9IFwibm9uZSBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjb2xzW2ldLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgICAgLy8gTWF0aE1MIGFjY2VwdHMgb25seSBzaW5nbGUgbGluZXMgYmV0d2VlbiBjZWxscy5cbiAgICAgICAgLy8gU28gd2UgcmVhZCBvbmx5IHRoZSBmaXJzdCBvZiBjb25zZWN1dGl2ZSBzZXBhcmF0b3JzLlxuICAgICAgICBpZiAocHJldlR5cGVXYXNBbGlnbikge1xuICAgICAgICAgIGNvbHVtbkxpbmVzICs9IGNvbHNbaV0uc2VwYXJhdG9yID09PSBcInxcIiA/IFwic29saWQgXCIgOiBcImRhc2hlZCBcIjtcbiAgICAgICAgICBwcmV2VHlwZVdhc0FsaWduID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5hbGlnblwiLCBhbGlnbi50cmltKCkpO1xuXG4gICAgaWYgKC9bc2RdLy50ZXN0KGNvbHVtbkxpbmVzKSkge1xuICAgICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1ubGluZXNcIiwgY29sdW1uTGluZXMudHJpbSgpKTtcbiAgICB9XG4gIH0gLy8gU2V0IGNvbHVtbiBzcGFjaW5nLlxuXG5cbiAgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSBcImFsaWduXCIpIHtcbiAgICBjb25zdCBjb2xzID0gZ3JvdXAuY29scyB8fCBbXTtcbiAgICBsZXQgc3BhY2luZyA9IFwiXCI7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNwYWNpbmcgKz0gaSAlIDIgPyBcIjBlbSBcIiA6IFwiMWVtIFwiO1xuICAgIH1cblxuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgc3BhY2luZy50cmltKCkpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSBcImFsaWduYXRcIiB8fCBncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJnYXRoZXJcIikge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIwZW1cIik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwic21hbGxcIikge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIwLjI3NzhlbVwiKTtcbiAgfSBlbHNlIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJDRFwiKSB7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uc3BhY2luZ1wiLCBcIjAuNWVtXCIpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIxZW1cIik7XG4gIH0gLy8gQWRkcmVzcyBcXGhsaW5lIGFuZCBcXGhkYXNobGluZVxuXG5cbiAgbGV0IHJvd0xpbmVzID0gXCJcIjtcbiAgY29uc3QgaGxpbmVzID0gZ3JvdXAuaExpbmVzQmVmb3JlUm93O1xuICBtZW5jbG9zZSArPSBobGluZXNbMF0ubGVuZ3RoID4gMCA/IFwibGVmdCBcIiA6IFwiXCI7XG4gIG1lbmNsb3NlICs9IGhsaW5lc1tobGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoID4gMCA/IFwicmlnaHQgXCIgOiBcIlwiO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaGxpbmVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHJvd0xpbmVzICs9IGhsaW5lc1tpXS5sZW5ndGggPT09IDAgPyBcIm5vbmUgXCIgLy8gTWF0aE1MIGFjY2VwdHMgb25seSBhIHNpbmdsZSBsaW5lIGJldHdlZW4gcm93cy4gUmVhZCBvbmUgZWxlbWVudC5cbiAgICA6IGhsaW5lc1tpXVswXSA/IFwiZGFzaGVkIFwiIDogXCJzb2xpZCBcIjtcbiAgfVxuXG4gIGlmICgvW3NkXS8udGVzdChyb3dMaW5lcykpIHtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJyb3dsaW5lc1wiLCByb3dMaW5lcy50cmltKCkpO1xuICB9XG5cbiAgaWYgKG1lbmNsb3NlICE9PSBcIlwiKSB7XG4gICAgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1lbmNsb3NlXCIsIFt0YWJsZV0pO1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIG1lbmNsb3NlLnRyaW0oKSk7XG4gIH1cblxuICBpZiAoZ3JvdXAuYXJyYXlzdHJldGNoICYmIGdyb3VwLmFycmF5c3RyZXRjaCA8IDEpIHtcbiAgICAvLyBBIHNtYWxsIGFycmF5LiBXcmFwIGluIHNjcmlwdHN0eWxlIHNvIHJvdyBnYXAgaXMgbm90IHRvbyBsYXJnZS5cbiAgICB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIFt0YWJsZV0pO1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMVwiKTtcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn07IC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBhbGlnbiwgYWxpZ24qLCBhbGlnbmVkLCBhbGlnbmF0LCBhbGlnbmF0KiwgYWxpZ25lZGF0LlxuXG5cbmNvbnN0IGFsaWduZWRIYW5kbGVyID0gZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHtcbiAgaWYgKGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiZWRcIikgPT09IC0xKSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBjb25zdCBjb2xzID0gW107XG4gIGNvbnN0IHNlcGFyYXRpb25UeXBlID0gY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJhdFwiKSA+IC0xID8gXCJhbGlnbmF0XCIgOiBcImFsaWduXCI7XG4gIGNvbnN0IGlzU3BsaXQgPSBjb250ZXh0LmVudk5hbWUgPT09IFwic3BsaXRcIjtcbiAgY29uc3QgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwge1xuICAgIGNvbHMsXG4gICAgYWRkSm90OiB0cnVlLFxuICAgIGF1dG9UYWc6IGlzU3BsaXQgPyB1bmRlZmluZWQgOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgY29sU2VwYXJhdGlvblR5cGU6IHNlcGFyYXRpb25UeXBlLFxuICAgIG1heE51bUNvbHM6IGlzU3BsaXQgPyAyIDogdW5kZWZpbmVkLFxuICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICB9LCBcImRpc3BsYXlcIik7IC8vIERldGVybWluaW5nIG51bWJlciBvZiBjb2x1bW5zLlxuICAvLyAxLiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ2l2ZW4sIHdlIHVzZSBpdCBhcyBhIG51bWJlciBvZiBjb2x1bW5zLFxuICAvLyAgICBhbmQgbWFrZXMgc3VyZSB0aGF0IGVhY2ggcm93IGRvZXNuJ3QgZXhjZWVkIHRoYXQgbnVtYmVyLlxuICAvLyAyLiBPdGhlcndpc2UsIGp1c3QgY291bnQgbnVtYmVyIG9mIGNvbHVtbnMgPSBtYXhpbXVtIG51bWJlclxuICAvLyAgICBvZiBjZWxscyBpbiBlYWNoIHJvdyAoXCJhbGlnbmVkXCIgbW9kZSAtLSBpc0FsaWduZWQgd2lsbCBiZSB0cnVlKS5cbiAgLy9cbiAgLy8gQXQgdGhlIHNhbWUgdGltZSwgcHJlcGVuZCBlbXB0eSBncm91cCB7fSBhdCBiZWdpbm5pbmcgb2YgZXZlcnkgc2Vjb25kXG4gIC8vIGNlbGwgaW4gZWFjaCByb3cgKHN0YXJ0aW5nIHdpdGggc2Vjb25kIGNlbGwpIHNvIHRoYXQgb3BlcmF0b3JzIGJlY29tZVxuICAvLyBiaW5hcnkuICBUaGlzIGJlaGF2aW9yIGlzIGltcGxlbWVudGVkIGluIGFtc21hdGgncyBcXHN0YXJ0QGFsaWduZWQuXG5cbiAgbGV0IG51bU1hdGhzO1xuICBsZXQgbnVtQ29scyA9IDA7XG4gIGNvbnN0IGVtcHR5R3JvdXAgPSB7XG4gICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgIG1vZGU6IGNvbnRleHQubW9kZSxcbiAgICBib2R5OiBbXVxuICB9O1xuXG4gIGlmIChhcmdzWzBdICYmIGFyZ3NbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgbGV0IGFyZzAgPSBcIlwiO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzWzBdLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHRvcmQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLmJvZHlbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIGFyZzAgKz0gdGV4dG9yZC50ZXh0O1xuICAgIH1cblxuICAgIG51bU1hdGhzID0gTnVtYmVyKGFyZzApO1xuICAgIG51bUNvbHMgPSBudW1NYXRocyAqIDI7XG4gIH1cblxuICBjb25zdCBpc0FsaWduZWQgPSAhbnVtQ29scztcbiAgcmVzLmJvZHkuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3cubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIC8vIE1vZGlmeSBvcmRncm91cCBub2RlIHdpdGhpbiBzdHlsaW5nIG5vZGVcbiAgICAgIGNvbnN0IHN0eWxpbmcgPSBhc3NlcnROb2RlVHlwZShyb3dbaV0sIFwic3R5bGluZ1wiKTtcbiAgICAgIGNvbnN0IG9yZGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoc3R5bGluZy5ib2R5WzBdLCBcIm9yZGdyb3VwXCIpO1xuICAgICAgb3JkZ3JvdXAuYm9keS51bnNoaWZ0KGVtcHR5R3JvdXApO1xuICAgIH1cblxuICAgIGlmICghaXNBbGlnbmVkKSB7XG4gICAgICAvLyBDYXNlIDFcbiAgICAgIGNvbnN0IGN1ck1hdGhzID0gcm93Lmxlbmd0aCAvIDI7XG5cbiAgICAgIGlmIChudW1NYXRocyA8IGN1ck1hdGhzKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlRvbyBtYW55IG1hdGggaW4gYSByb3c6IFwiICsgKFwiZXhwZWN0ZWQgXCIgKyBudW1NYXRocyArIFwiLCBidXQgZ290IFwiICsgY3VyTWF0aHMpLCByb3dbMF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnVtQ29scyA8IHJvdy5sZW5ndGgpIHtcbiAgICAgIC8vIENhc2UgMlxuICAgICAgbnVtQ29scyA9IHJvdy5sZW5ndGg7XG4gICAgfVxuICB9KTsgLy8gQWRqdXN0aW5nIGFsaWdubWVudC5cbiAgLy8gSW4gYWxpZ25lZCBtb2RlLCB3ZSBhZGQgb25lIFxccXF1YWQgYmV0d2VlbiBjb2x1bW5zO1xuICAvLyBvdGhlcndpc2Ugd2UgYWRkIG5vdGhpbmcuXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2xzOyArK2kpIHtcbiAgICBsZXQgYWxpZ24gPSBcInJcIjtcbiAgICBsZXQgcHJlZ2FwID0gMDtcblxuICAgIGlmIChpICUgMiA9PT0gMSkge1xuICAgICAgYWxpZ24gPSBcImxcIjtcbiAgICB9IGVsc2UgaWYgKGkgPiAwICYmIGlzQWxpZ25lZCkge1xuICAgICAgLy8gXCJhbGlnbmVkXCIgbW9kZS5cbiAgICAgIHByZWdhcCA9IDE7IC8vIGFkZCBvbmUgXFxxdWFkXG4gICAgfVxuXG4gICAgY29sc1tpXSA9IHtcbiAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgIHByZWdhcDogcHJlZ2FwLFxuICAgICAgcG9zdGdhcDogMFxuICAgIH07XG4gIH1cblxuICByZXMuY29sU2VwYXJhdGlvblR5cGUgPSBpc0FsaWduZWQgPyBcImFsaWduXCIgOiBcImFsaWduYXRcIjtcbiAgcmV0dXJuIHJlcztcbn07IC8vIEFycmF5cyBhcmUgcGFydCBvZiBMYVRlWCwgZGVmaW5lZCBpbiBsdHRhYi5kdHggc28gaXRzIGRvY3VtZW50YXRpb25cbi8vIGlzIHBhcnQgb2YgdGhlIHNvdXJjZTJlLnBkZiBmaWxlIG9mIExhVGVYMmUgc291cmNlIGRvY3VtZW50YXRpb24uXG4vLyB7ZGFycmF5fSBpcyBhbiB7YXJyYXl9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG5jY21hdGguc3R5LlxuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYXJyYXlcIiwgXCJkYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIC8vIFNpbmNlIG5vIHR5cGVzIGFyZSBzcGVjaWZpZWQgYWJvdmUsIHRoZSB0d28gcG9zc2liaWxpdGllcyBhcmVcbiAgICAvLyAtIFRoZSBhcmd1bWVudCBpcyB3cmFwcGVkIGluIHt9IG9yIFtdLCBpbiB3aGljaCBjYXNlIFBhcnNlcidzXG4gICAgLy8gICBwYXJzZUdyb3VwKCkgcmV0dXJucyBhbiBcIm9yZGdyb3VwXCIgd3JhcHBpbmcgc29tZSBzeW1ib2wgbm9kZS5cbiAgICAvLyAtIFRoZSBhcmd1bWVudCBpcyBhIGJhcmUgc3ltYm9sIG5vZGUuXG4gICAgY29uc3Qgc3ltTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoYXJnc1swXSk7XG4gICAgY29uc3QgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIGNvbnN0IGNvbHMgPSBjb2xhbGlnbi5tYXAoZnVuY3Rpb24gKG5kZSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKG5kZSk7XG4gICAgICBjb25zdCBjYSA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjYSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInNlcGFyYXRvclwiLFxuICAgICAgICAgIHNlcGFyYXRvcjogXCJ8XCJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwiOlwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwiOlwiXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gY29sdW1uIGFsaWdubWVudDogXCIgKyBjYSwgbmRlKTtcbiAgICB9KTtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBjb2xzLFxuICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogdHJ1ZSxcbiAgICAgIC8vIFxcQHByZWFtYmxlIGluIGx0dGFiLmR0eFxuICAgICAgbWF4TnVtQ29sczogY29scy5sZW5ndGhcbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGFycmF5X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBhcnJheV9tYXRobWxCdWlsZGVyXG59KTsgLy8gVGhlIG1hdHJpeCBlbnZpcm9ubWVudHMgb2YgYW1zbWF0aCBidWlsZHMgb24gdGhlIGFycmF5IGVudmlyb25tZW50XG4vLyBvZiBMYVRlWCwgd2hpY2ggaXMgZGlzY3Vzc2VkIGFib3ZlLlxuLy8gVGhlIG1hdGh0b29scyBwYWNrYWdlIGFkZHMgc3RhcnJlZCB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBlbnZpcm9ubWVudHMuXG4vLyBUaGVzZSBoYXZlIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGNob29zZSBsZWZ0fGNlbnRlcnxyaWdodCBqdXN0aWZpY2F0aW9uLlxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcIm1hdHJpeFwiLCBcInBtYXRyaXhcIiwgXCJibWF0cml4XCIsIFwiQm1hdHJpeFwiLCBcInZtYXRyaXhcIiwgXCJWbWF0cml4XCIsIFwibWF0cml4KlwiLCBcInBtYXRyaXgqXCIsIFwiYm1hdHJpeCpcIiwgXCJCbWF0cml4KlwiLCBcInZtYXRyaXgqXCIsIFwiVm1hdHJpeCpcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGNvbnN0IGRlbGltaXRlcnMgPSB7XG4gICAgICBcIm1hdHJpeFwiOiBudWxsLFxuICAgICAgXCJwbWF0cml4XCI6IFtcIihcIiwgXCIpXCJdLFxuICAgICAgXCJibWF0cml4XCI6IFtcIltcIiwgXCJdXCJdLFxuICAgICAgXCJCbWF0cml4XCI6IFtcIlxcXFx7XCIsIFwiXFxcXH1cIl0sXG4gICAgICBcInZtYXRyaXhcIjogW1wifFwiLCBcInxcIl0sXG4gICAgICBcIlZtYXRyaXhcIjogW1wiXFxcXFZlcnRcIiwgXCJcXFxcVmVydFwiXVxuICAgIH1bY29udGV4dC5lbnZOYW1lLnJlcGxhY2UoXCIqXCIsIFwiXCIpXTsgLy8gXFxoc2tpcCAtXFxhcnJheWNvbHNlcCBpbiBhbXNtYXRoXG5cbiAgICBsZXQgY29sQWxpZ24gPSBcImNcIjtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogZmFsc2UsXG4gICAgICBjb2xzOiBbe1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBjb2xBbGlnblxuICAgICAgfV1cbiAgICB9O1xuXG4gICAgaWYgKGNvbnRleHQuZW52TmFtZS5jaGFyQXQoY29udGV4dC5lbnZOYW1lLmxlbmd0aCAtIDEpID09PSBcIipcIikge1xuICAgICAgLy8gSXQncyBvbmUgb2YgdGhlIG1hdGh0b29scyBzdGFycmVkIGZ1bmN0aW9ucy5cbiAgICAgIC8vIFBhcnNlIHRoZSBvcHRpb25hbCBhbGlnbm1lbnQgYXJndW1lbnQuXG4gICAgICBjb25zdCBwYXJzZXIgPSBjb250ZXh0LnBhcnNlcjtcbiAgICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG5cbiAgICAgIGlmIChwYXJzZXIuZmV0Y2goKS50ZXh0ID09PSBcIltcIikge1xuICAgICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgICBjb2xBbGlnbiA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG5cbiAgICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjb2xBbGlnbikgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgbCBvciBjIG9yIHJcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgICBwYXJzZXIuZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGF5bG9hZC5jb2xzID0gW3tcbiAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgYWxpZ246IGNvbEFsaWduXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7IC8vIFBvcHVsYXRlIGNvbHMgd2l0aCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1uIGFsaWdubWVudCBzcGVjcy5cblxuICAgIGNvbnN0IG51bUNvbHMgPSBNYXRoLm1heCgwLCAuLi5yZXMuYm9keS5tYXAocm93ID0+IHJvdy5sZW5ndGgpKTtcbiAgICByZXMuY29scyA9IG5ldyBBcnJheShudW1Db2xzKS5maWxsKHtcbiAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgIGFsaWduOiBjb2xBbGlnblxuICAgIH0pO1xuICAgIHJldHVybiBkZWxpbWl0ZXJzID8ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQubW9kZSxcbiAgICAgIGJvZHk6IFtyZXNdLFxuICAgICAgbGVmdDogZGVsaW1pdGVyc1swXSxcbiAgICAgIHJpZ2h0OiBkZWxpbWl0ZXJzWzFdLFxuICAgICAgcmlnaHRDb2xvcjogdW5kZWZpbmVkIC8vIFxccmlnaHQgdW5pbmZsdWVuY2VkIGJ5IFxcY29sb3IgaW4gYXJyYXlcblxuICAgIH0gOiByZXM7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGFycmF5X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBhcnJheV9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic21hbGxtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBhcnJheXN0cmV0Y2g6IDAuNVxuICAgIH07XG4gICAgY29uc3QgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgXCJzY3JpcHRcIik7XG4gICAgcmVzLmNvbFNlcGFyYXRpb25UeXBlID0gXCJzbWFsbFwiO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGFycmF5X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBhcnJheV9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic3ViYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIC8vIFBhcnNpbmcgb2Yge3N1YmFycmF5fSBpcyBzaW1pbGFyIHRvIHthcnJheX1cbiAgICBjb25zdCBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTtcbiAgICBjb25zdCBjb2xhbGlnbiA9IHN5bU5vZGUgPyBbYXJnc1swXV0gOiBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcIm9yZGdyb3VwXCIpLmJvZHk7XG4gICAgY29uc3QgY29scyA9IGNvbGFsaWduLm1hcChmdW5jdGlvbiAobmRlKSB7XG4gICAgICBjb25zdCBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIGNvbnN0IGNhID0gbm9kZS50ZXh0OyAvLyB7c3ViYXJyYXl9IG9ubHkgcmVjb2duaXplcyBcImxcIiAmIFwiY1wiXG5cbiAgICAgIGlmIChcImxjXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjYVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmtub3duIGNvbHVtbiBhbGlnbm1lbnQ6IFwiICsgY2EsIG5kZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoY29scy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJ7c3ViYXJyYXl9IGNhbiBjb250YWluIG9ubHkgb25lIGNvbHVtblwiKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzID0ge1xuICAgICAgY29scyxcbiAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IGZhbHNlLFxuICAgICAgYXJyYXlzdHJldGNoOiAwLjVcbiAgICB9O1xuICAgIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJzY3JpcHRcIik7XG5cbiAgICBpZiAocmVzLmJvZHkubGVuZ3RoID4gMCAmJiByZXMuYm9keVswXS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJ7c3ViYXJyYXl9IGNhbiBjb250YWluIG9ubHkgb25lIGNvbHVtblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIEEgY2FzZXMgZW52aXJvbm1lbnQgKGluIGFtc21hdGguc3R5KSBpcyBhbG1vc3QgZXF1aXZhbGVudCB0b1xuLy8gXFxkZWZcXGFycmF5c3RyZXRjaHsxLjJ9JVxuLy8gXFxsZWZ0XFx7XFxiZWdpbnthcnJheX17QHt9bEB7XFxxdWFkfWxAe319IOKApiBcXGVuZHthcnJheX1cXHJpZ2h0LlxuLy8ge2RjYXNlc30gaXMgYSB7Y2FzZXN9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG1hdGh0b29scy5zdHkuXG4vLyB7cmNhc2VzfSBpcyBhbm90aGVyIG1hdGh0b29scyBlbnZpcm9ubWVudC4gSXQncyBicmFjZSBpcyBvbiB0aGUgcmlnaHQgc2lkZS5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJjYXNlc1wiLCBcImRjYXNlc1wiLCBcInJjYXNlc1wiLCBcImRyY2FzZXNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBhcnJheXN0cmV0Y2g6IDEuMixcbiAgICAgIGNvbHM6IFt7XG4gICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgYWxpZ246IFwibFwiLFxuICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgIC8vIFRPRE8oa2V2aW5iKSBnZXQgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAgICAgIC8vIEZvciBub3cgd2UgdXNlIHRoZSBtZXRyaWNzIGZvciBURVhUIHN0eWxlIHdoaWNoIGlzIHdoYXQgd2Ugd2VyZVxuICAgICAgICAvLyBkb2luZyBiZWZvcmUuICBCZWZvcmUgYXR0ZW1wdGluZyB0byBnZXQgdGhlIGN1cnJlbnQgc3R5bGUgd2VcbiAgICAgICAgLy8gc2hvdWxkIGxvb2sgYXQgVGVYJ3MgYmVoYXZpb3IgZXNwZWNpYWxseSBmb3IgXFxvdmVyIGFuZCBtYXRyaWNlcy5cbiAgICAgICAgcG9zdGdhcDogMS4wXG4gICAgICAgIC8qIDFlbSBxdWFkICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgIHByZWdhcDogMCxcbiAgICAgICAgcG9zdGdhcDogMFxuICAgICAgfV1cbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0Lm1vZGUsXG4gICAgICBib2R5OiBbcmVzXSxcbiAgICAgIGxlZnQ6IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiclwiKSA+IC0xID8gXCIuXCIgOiBcIlxcXFx7XCIsXG4gICAgICByaWdodDogY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJyXCIpID4gLTEgPyBcIlxcXFx9XCIgOiBcIi5cIixcbiAgICAgIHJpZ2h0Q29sb3I6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGFycmF5X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBhcnJheV9tYXRobWxCdWlsZGVyXG59KTsgLy8gSW4gdGhlIGFsaWduIGVudmlyb25tZW50LCBvbmUgdXNlcyBhbXBlcnNhbmRzLCAmLCB0byBzcGVjaWZ5IG51bWJlciBvZlxuLy8gY29sdW1ucyBpbiBlYWNoIHJvdywgYW5kIHRvIGxvY2F0ZSBzcGFjaW5nIGJldHdlZW4gZWFjaCBjb2x1bW4uXG4vLyBhbGlnbiBnZXRzIGF1dG9tYXRpYyBudW1iZXJpbmcuIGFsaWduKiBhbmQgYWxpZ25lZCBkbyBub3QuXG4vLyBUaGUgYWxpZ25lZGF0IGVudmlyb25tZW50IGNhbiBiZSB1c2VkIGluIG1hdGggbW9kZS5cbi8vIE5vdGUgdGhhdCB3ZSBhc3N1bWUgXFxub21hbGxpbmVza2lwbGltaXQgdG8gYmUgemVybyxcbi8vIHNvIHRoYXQgXFxzdHJ1dEAgaXMgdGhlIHNhbWUgYXMgXFxzdHJ1dC5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnblwiLCBcImFsaWduKlwiLCBcImFsaWduZWRcIiwgXCJzcGxpdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGFsaWduZWRIYW5kbGVyLFxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBBIGdhdGhlcmVkIGVudmlyb25tZW50IGlzIGxpa2UgYW4gYXJyYXkgZW52aXJvbm1lbnQgd2l0aCBvbmUgY2VudGVyZWRcbi8vIGNvbHVtbiwgYnV0IHdoZXJlIHJvd3MgYXJlIGNvbnNpZGVyZWQgbGluZXMgc28gZ2V0IFxcam90IGxpbmUgc3BhY2luZ1xuLy8gYW5kIGNvbnRlbnRzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiZ2F0aGVyZWRcIiwgXCJnYXRoZXJcIiwgXCJnYXRoZXIqXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBpZiAodXRpbHMuY29udGFpbnMoW1wiZ2F0aGVyXCIsIFwiZ2F0aGVyKlwiXSwgY29udGV4dC5lbnZOYW1lKSkge1xuICAgICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgY29sczogW3tcbiAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICBhbGlnbjogXCJjXCJcbiAgICAgIH1dLFxuICAgICAgYWRkSm90OiB0cnVlLFxuICAgICAgY29sU2VwYXJhdGlvblR5cGU6IFwiZ2F0aGVyXCIsXG4gICAgICBhdXRvVGFnOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgICBlbXB0eVNpbmdsZVJvdzogdHJ1ZSxcbiAgICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJkaXNwbGF5XCIpO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIGFsaWduYXQgZW52aXJvbm1lbnQgaXMgbGlrZSBhbiBhbGlnbiBlbnZpcm9ubWVudCwgYnV0IG9uZSBtdXN0IGV4cGxpY2l0bHlcbi8vIHNwZWNpZnkgbWF4aW11bSBudW1iZXIgb2YgY29sdW1ucyBpbiBlYWNoIHJvdywgYW5kIGNhbiBhZGp1c3Qgc3BhY2luZyBiZXR3ZWVuXG4vLyBlYWNoIGNvbHVtbnMuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYWxpZ25hdFwiLCBcImFsaWduYXQqXCIsIFwiYWxpZ25lZGF0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogYWxpZ25lZEhhbmRsZXIsXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImVxdWF0aW9uXCIsIFwiZXF1YXRpb24qXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBhdXRvVGFnOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgICBlbXB0eVNpbmdsZVJvdzogdHJ1ZSxcbiAgICAgIHNpbmdsZVJvdzogdHJ1ZSxcbiAgICAgIG1heE51bUNvbHM6IDEsXG4gICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwiZGlzcGxheVwiKTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJDRFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG5cbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlQ0QoY29udGV4dC5wYXJzZXIpO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxub251bWJlclwiLCBcIlxcXFxnZGVmXFxcXEBlcW5zd3swfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vdGFnXCIsIFwiXFxcXG5vbnVtYmVyXCIpOyAvLyBDYXRjaCBcXGhsaW5lIG91dHNpZGUgYXJyYXkgZW52aXJvbm1lbnRcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXGhsaW5lXCIsIFwiXFxcXGhkYXNobGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihjb250ZXh0LmZ1bmNOYW1lICsgXCIgdmFsaWQgb25seSB3aXRoaW4gYXJyYXkgZW52aXJvbm1lbnRcIik7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZW52aXJvbm1lbnRzLmpzXG5cbmNvbnN0IGVudmlyb25tZW50cyA9IF9lbnZpcm9ubWVudHM7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfZW52aXJvbm1lbnRzID0gKGVudmlyb25tZW50cyk7IC8vIEFsbCBlbnZpcm9ubWVudCBkZWZpbml0aW9ucyBzaG91bGQgYmUgaW1wb3J0ZWQgYmVsb3dcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2Vudmlyb25tZW50LmpzXG5cblxuXG4gLy8gRW52aXJvbm1lbnQgZGVsaW1pdGVycy4gSFRNTC9NYXRoTUwgcmVuZGVyaW5nIGlzIGRlZmluZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmdcbi8vIGRlZmluZUVudmlyb25tZW50IGRlZmluaXRpb25zLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW52aXJvbm1lbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxiZWdpblwiLCBcIlxcXFxlbmRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IG5hbWVHcm91cCA9IGFyZ3NbMF07XG5cbiAgICBpZiAobmFtZUdyb3VwLnR5cGUgIT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBlbnZpcm9ubWVudCBuYW1lXCIsIG5hbWVHcm91cCk7XG4gICAgfVxuXG4gICAgbGV0IGVudk5hbWUgPSBcIlwiO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lR3JvdXAuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgZW52TmFtZSArPSBhc3NlcnROb2RlVHlwZShuYW1lR3JvdXAuYm9keVtpXSwgXCJ0ZXh0b3JkXCIpLnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxiZWdpblwiKSB7XG4gICAgICAvLyBiZWdpbi4uLmVuZCBpcyBzaW1pbGFyIHRvIGxlZnQuLi5yaWdodFxuICAgICAgaWYgKCFzcmNfZW52aXJvbm1lbnRzLmhhc093blByb3BlcnR5KGVudk5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk5vIHN1Y2ggZW52aXJvbm1lbnQ6IFwiICsgZW52TmFtZSwgbmFtZUdyb3VwKTtcbiAgICAgIH0gLy8gQnVpbGQgdGhlIGVudmlyb25tZW50IG9iamVjdC4gQXJndW1lbnRzIGFuZCBvdGhlciBpbmZvcm1hdGlvbiB3aWxsXG4gICAgICAvLyBiZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYmVnaW4gYW5kIGVuZCBtZXRob2RzIHVzaW5nIHByb3BlcnRpZXMuXG5cblxuICAgICAgY29uc3QgZW52ID0gc3JjX2Vudmlyb25tZW50c1tlbnZOYW1lXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgb3B0QXJnc1xuICAgICAgfSA9IHBhcnNlci5wYXJzZUFyZ3VtZW50cyhcIlxcXFxiZWdpbntcIiArIGVudk5hbWUgKyBcIn1cIiwgZW52KTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBlbnZOYW1lLFxuICAgICAgICBwYXJzZXJcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBlbnYuaGFuZGxlcihjb250ZXh0LCBhcmdzLCBvcHRBcmdzKTtcbiAgICAgIHBhcnNlci5leHBlY3QoXCJcXFxcZW5kXCIsIGZhbHNlKTtcbiAgICAgIGNvbnN0IGVuZE5hbWVUb2tlbiA9IHBhcnNlci5uZXh0VG9rZW47XG4gICAgICBjb25zdCBlbmQgPSBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImVudmlyb25tZW50XCIpO1xuXG4gICAgICBpZiAoZW5kLm5hbWUgIT09IGVudk5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTWlzbWF0Y2g6IFxcXFxiZWdpbntcIiArIGVudk5hbWUgKyBcIn0gbWF0Y2hlZCBieSBcXFxcZW5ke1wiICsgZW5kLm5hbWUgKyBcIn1cIiwgZW5kTmFtZVRva2VuKTtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZSwgXCJlbnZpcm9ubWVudFwiIGhhbmRsZXIgcmV0dXJucyBhbiBlbnZpcm9ubWVudCBQYXJzZU5vZGVcblxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5hbWU6IGVudk5hbWUsXG4gICAgICBuYW1lR3JvdXBcbiAgICB9O1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9mb250LmpzXG4vLyBUT0RPKGtldmluYik6IGltcGxlbWVudCBcXFxcc2wgYW5kIFxcXFxzY1xuXG5cblxuXG5cblxuY29uc3QgZm9udF9odG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBmb250ID0gZ3JvdXAuZm9udDtcbiAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZm9udCk7XG4gIHJldHVybiBidWlsZEdyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xufTtcblxuY29uc3QgZm9udF9tYXRobWxCdWlsZGVyID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZvbnQgPSBncm91cC5mb250O1xuICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoRm9udChmb250KTtcbiAgcmV0dXJuIGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucyk7XG59O1xuXG5jb25zdCBmb250QWxpYXNlcyA9IHtcbiAgXCJcXFxcQmJiXCI6IFwiXFxcXG1hdGhiYlwiLFxuICBcIlxcXFxib2xkXCI6IFwiXFxcXG1hdGhiZlwiLFxuICBcIlxcXFxmcmFrXCI6IFwiXFxcXG1hdGhmcmFrXCIsXG4gIFwiXFxcXGJtXCI6IFwiXFxcXGJvbGRzeW1ib2xcIlxufTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJmb250XCIsXG4gIG5hbWVzOiBbLy8gc3R5bGVzLCBleGNlcHQgXFxib2xkc3ltYm9sIGRlZmluZWQgYmVsb3dcbiAgXCJcXFxcbWF0aHJtXCIsIFwiXFxcXG1hdGhpdFwiLCBcIlxcXFxtYXRoYmZcIiwgXCJcXFxcbWF0aG5vcm1hbFwiLCBcIlxcXFxtYXRoc2ZpdFwiLCAvLyBmYW1pbGllc1xuICBcIlxcXFxtYXRoYmJcIiwgXCJcXFxcbWF0aGNhbFwiLCBcIlxcXFxtYXRoZnJha1wiLCBcIlxcXFxtYXRoc2NyXCIsIFwiXFxcXG1hdGhzZlwiLCBcIlxcXFxtYXRodHRcIiwgLy8gYWxpYXNlcywgZXhjZXB0IFxcYm0gZGVmaW5lZCBiZWxvd1xuICBcIlxcXFxCYmJcIiwgXCJcXFxcYm9sZFwiLCBcIlxcXFxmcmFrXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBib2R5ID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgbGV0IGZ1bmMgPSBmdW5jTmFtZTtcblxuICAgIGlmIChmdW5jIGluIGZvbnRBbGlhc2VzKSB7XG4gICAgICBmdW5jID0gZm9udEFsaWFzZXNbZnVuY107XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBmdW5jLnNsaWNlKDEpLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmb250X2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBmb250X21hdGhtbEJ1aWxkZXJcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXGJvbGRzeW1ib2xcIiwgXCJcXFxcYm1cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjIsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGlzQ2hhcmFjdGVyQm94ID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goYm9keSk7IC8vIGFtc2JzeS5zdHkncyBcXGJvbGRzeW1ib2wgdXNlcyBcXGJpbnJlbCBzcGFjaW5nIHRvIGluaGVyaXQgdGhlXG4gICAgLy8gYXJndW1lbnQncyBiaW58cmVsfG9yZCBzdGF0dXNcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGJvZHkpLFxuICAgICAgYm9keTogW3tcbiAgICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBmb250OiBcImJvbGRzeW1ib2xcIixcbiAgICAgICAgYm9keVxuICAgICAgfV0sXG4gICAgICBpc0NoYXJhY3RlckJveDogaXNDaGFyYWN0ZXJCb3hcbiAgICB9O1xuICB9XG59KTsgLy8gT2xkIGZvbnQgY2hhbmdpbmcgZnVuY3Rpb25zXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJmb250XCIsXG4gIG5hbWVzOiBbXCJcXFxccm1cIiwgXCJcXFxcc2ZcIiwgXCJcXFxcdHRcIiwgXCJcXFxcYmZcIiwgXCJcXFxcaXRcIiwgXCJcXFxcY2FsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjMsIGFyZ3MpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWUsXG4gICAgICBicmVha09uVG9rZW5UZXh0XG4gICAgfSA9IF9yZWYzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGVcbiAgICB9ID0gcGFyc2VyO1xuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKHRydWUsIGJyZWFrT25Ub2tlblRleHQpO1xuICAgIGNvbnN0IHN0eWxlID0gXCJtYXRoXCIgKyBmdW5jTmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgZm9udDogc3R5bGUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGJvZHlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZm9udF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZm9udF9tYXRobWxCdWlsZGVyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvZ2VuZnJhYy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IGFkanVzdFN0eWxlID0gKHNpemUsIG9yaWdpbmFsU3R5bGUpID0+IHtcbiAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHRoaXMgZnJhY3Rpb24gc2hvdWxkIGJlIGluIGJhc2VkIG9uIHRoZVxuICAvLyBmdW5jdGlvbiB1c2VkXG4gIGxldCBzdHlsZSA9IG9yaWdpbmFsU3R5bGU7XG5cbiAgaWYgKHNpemUgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgLy8gR2V0IGRpc3BsYXkgc3R5bGUgYXMgYSBkZWZhdWx0LlxuICAgIC8vIElmIGluY29taW5nIHN0eWxlIGlzIHN1Yi9zdXAsIHVzZSBzdHlsZS50ZXh0KCkgdG8gZ2V0IGNvcnJlY3Qgc2l6ZS5cbiAgICBzdHlsZSA9IHN0eWxlLmlkID49IHNyY19TdHlsZS5TQ1JJUFQuaWQgPyBzdHlsZS50ZXh0KCkgOiBzcmNfU3R5bGUuRElTUExBWTtcbiAgfSBlbHNlIGlmIChzaXplID09PSBcInRleHRcIiAmJiBzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgLy8gV2UncmUgaW4gYSBcXHRmcmFjIGJ1dCBpbmNvbWluZyBzdHlsZSBpcyBkaXNwbGF5c3R5bGUsIHNvOlxuICAgIHN0eWxlID0gc3JjX1N0eWxlLlRFWFQ7XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gXCJzY3JpcHRcIikge1xuICAgIHN0eWxlID0gc3JjX1N0eWxlLlNDUklQVDtcbiAgfSBlbHNlIGlmIChzaXplID09PSBcInNjcmlwdHNjcmlwdFwiKSB7XG4gICAgc3R5bGUgPSBzcmNfU3R5bGUuU0NSSVBUU0NSSVBUO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuY29uc3QgZ2VuZnJhY19odG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAvLyBGcmFjdGlvbnMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGFnZXMgNDQ0LTQ0NSwgcnVsZXMgMTUoYS1lKS5cbiAgY29uc3Qgc3R5bGUgPSBhZGp1c3RTdHlsZShncm91cC5zaXplLCBvcHRpb25zLnN0eWxlKTtcbiAgY29uc3QgbnN0eWxlID0gc3R5bGUuZnJhY051bSgpO1xuICBjb25zdCBkc3R5bGUgPSBzdHlsZS5mcmFjRGVuKCk7XG4gIGxldCBuZXdPcHRpb25zO1xuICBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuc3R5bGUpO1xuICBjb25zdCBudW1lcm0gPSBidWlsZEdyb3VwKGdyb3VwLm51bWVyLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcblxuICBpZiAoZ3JvdXAuY29udGludWVkKSB7XG4gICAgLy8gXFxjZnJhYyBpbnNlcnRzIGEgXFxzdHJ1dCBpbnRvIHRoZSBudW1lcmF0b3IuXG4gICAgLy8gR2V0IFxcc3RydXQgZGltZW5zaW9ucyBmcm9tIFRlWGJvb2sgcGFnZSAzNTMuXG4gICAgY29uc3QgaFN0cnV0ID0gOC41IC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gICAgY29uc3QgZFN0cnV0ID0gMy41IC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gICAgbnVtZXJtLmhlaWdodCA9IG51bWVybS5oZWlnaHQgPCBoU3RydXQgPyBoU3RydXQgOiBudW1lcm0uaGVpZ2h0O1xuICAgIG51bWVybS5kZXB0aCA9IG51bWVybS5kZXB0aCA8IGRTdHJ1dCA/IGRTdHJ1dCA6IG51bWVybS5kZXB0aDtcbiAgfVxuXG4gIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKGRzdHlsZSk7XG4gIGNvbnN0IGRlbm9tbSA9IGJ1aWxkR3JvdXAoZ3JvdXAuZGVub20sIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuICBsZXQgcnVsZTtcbiAgbGV0IHJ1bGVXaWR0aDtcbiAgbGV0IHJ1bGVTcGFjaW5nO1xuXG4gIGlmIChncm91cC5oYXNCYXJMaW5lKSB7XG4gICAgaWYgKGdyb3VwLmJhclNpemUpIHtcbiAgICAgIHJ1bGVXaWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuYmFyU2l6ZSwgb3B0aW9ucyk7XG4gICAgICBydWxlID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwiZnJhYy1saW5lXCIsIG9wdGlvbnMsIHJ1bGVXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bGUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJmcmFjLWxpbmVcIiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcnVsZVdpZHRoID0gcnVsZS5oZWlnaHQ7XG4gICAgcnVsZVNwYWNpbmcgPSBydWxlLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBydWxlID0gbnVsbDtcbiAgICBydWxlV2lkdGggPSAwO1xuICAgIHJ1bGVTcGFjaW5nID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICB9IC8vIFJ1bGUgMTViXG5cblxuICBsZXQgbnVtU2hpZnQ7XG4gIGxldCBjbGVhcmFuY2U7XG4gIGxldCBkZW5vbVNoaWZ0O1xuXG4gIGlmIChzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplIHx8IGdyb3VwLnNpemUgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMTtcblxuICAgIGlmIChydWxlV2lkdGggPiAwKSB7XG4gICAgICBjbGVhcmFuY2UgPSAzICogcnVsZVNwYWNpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyYW5jZSA9IDcgKiBydWxlU3BhY2luZztcbiAgICB9XG5cbiAgICBkZW5vbVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbm9tMTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMjtcbiAgICAgIGNsZWFyYW5jZSA9IHJ1bGVTcGFjaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TaGlmdCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5udW0zO1xuICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVTcGFjaW5nO1xuICAgIH1cblxuICAgIGRlbm9tU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVub20yO1xuICB9XG5cbiAgbGV0IGZyYWM7XG5cbiAgaWYgKCFydWxlKSB7XG4gICAgLy8gUnVsZSAxNWNcbiAgICBjb25zdCBjYW5kaWRhdGVDbGVhcmFuY2UgPSBudW1TaGlmdCAtIG51bWVybS5kZXB0aCAtIChkZW5vbW0uaGVpZ2h0IC0gZGVub21TaGlmdCk7XG5cbiAgICBpZiAoY2FuZGlkYXRlQ2xlYXJhbmNlIDwgY2xlYXJhbmNlKSB7XG4gICAgICBudW1TaGlmdCArPSAwLjUgKiAoY2xlYXJhbmNlIC0gY2FuZGlkYXRlQ2xlYXJhbmNlKTtcbiAgICAgIGRlbm9tU2hpZnQgKz0gMC41ICogKGNsZWFyYW5jZSAtIGNhbmRpZGF0ZUNsZWFyYW5jZSk7XG4gICAgfVxuXG4gICAgZnJhYyA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGRlbm9tbSxcbiAgICAgICAgc2hpZnQ6IGRlbm9tU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG51bWVybSxcbiAgICAgICAgc2hpZnQ6IC1udW1TaGlmdFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSdWxlIDE1ZFxuICAgIGNvbnN0IGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcblxuICAgIGlmIChudW1TaGlmdCAtIG51bWVybS5kZXB0aCAtIChheGlzSGVpZ2h0ICsgMC41ICogcnVsZVdpZHRoKSA8IGNsZWFyYW5jZSkge1xuICAgICAgbnVtU2hpZnQgKz0gY2xlYXJhbmNlIC0gKG51bVNoaWZ0IC0gbnVtZXJtLmRlcHRoIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpKTtcbiAgICB9XG5cbiAgICBpZiAoYXhpc0hlaWdodCAtIDAuNSAqIHJ1bGVXaWR0aCAtIChkZW5vbW0uaGVpZ2h0IC0gZGVub21TaGlmdCkgPCBjbGVhcmFuY2UpIHtcbiAgICAgIGRlbm9tU2hpZnQgKz0gY2xlYXJhbmNlIC0gKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGggLSAoZGVub21tLmhlaWdodCAtIGRlbm9tU2hpZnQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBtaWRTaGlmdCA9IC0oYXhpc0hlaWdodCAtIDAuNSAqIHJ1bGVXaWR0aCk7XG4gICAgZnJhYyA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGRlbm9tbSxcbiAgICAgICAgc2hpZnQ6IGRlbm9tU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHJ1bGUsXG4gICAgICAgIHNoaWZ0OiBtaWRTaGlmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbnVtZXJtLFxuICAgICAgICBzaGlmdDogLW51bVNoaWZ0XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IC8vIFNpbmNlIHdlIG1hbnVhbGx5IGNoYW5nZSB0aGUgc3R5bGUgc29tZXRpbWVzICh3aXRoIFxcZGZyYWMgb3IgXFx0ZnJhYyksXG4gIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJsZSBzaXplIGNoYW5nZSBoZXJlLlxuXG5cbiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUpO1xuICBmcmFjLmhlaWdodCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgZnJhYy5kZXB0aCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gUnVsZSAxNWVcblxuICBsZXQgZGVsaW1TaXplO1xuXG4gIGlmIChzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgZGVsaW1TaXplID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbGltMTtcbiAgfSBlbHNlIGlmIChzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuU0NSSVBUU0NSSVBULnNpemUpIHtcbiAgICBkZWxpbVNpemUgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHNyY19TdHlsZS5TQ1JJUFQpLmZvbnRNZXRyaWNzKCkuZGVsaW0yO1xuICB9IGVsc2Uge1xuICAgIGRlbGltU2l6ZSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWxpbTI7XG4gIH1cblxuICBsZXQgbGVmdERlbGltO1xuICBsZXQgcmlnaHREZWxpbTtcblxuICBpZiAoZ3JvdXAubGVmdERlbGltID09IG51bGwpIHtcbiAgICBsZWZ0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtb3BlblwiXSk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmN1c3RvbVNpemVkRGVsaW0oZ3JvdXAubGVmdERlbGltLCBkZWxpbVNpemUsIHRydWUsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gIH1cblxuICBpZiAoZ3JvdXAuY29udGludWVkKSB7XG4gICAgcmlnaHREZWxpbSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdKTsgLy8gemVybyB3aWR0aCBmb3IgXFxjZnJhY1xuICB9IGVsc2UgaWYgKGdyb3VwLnJpZ2h0RGVsaW0gPT0gbnVsbCkge1xuICAgIHJpZ2h0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtY2xvc2VcIl0pO1xuICB9IGVsc2Uge1xuICAgIHJpZ2h0RGVsaW0gPSBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShncm91cC5yaWdodERlbGltLCBkZWxpbVNpemUsIHRydWUsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtY2xvc2VcIl0pO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0uY29uY2F0KG5ld09wdGlvbnMuc2l6aW5nQ2xhc3NlcyhvcHRpb25zKSksIFtsZWZ0RGVsaW0sIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1mcmFjXCJdLCBbZnJhY10pLCByaWdodERlbGltXSwgb3B0aW9ucyk7XG59O1xuXG5jb25zdCBnZW5mcmFjX21hdGhtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1mcmFjXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLm51bWVyLCBvcHRpb25zKSwgYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5kZW5vbSwgb3B0aW9ucyldKTtcblxuICBpZiAoIWdyb3VwLmhhc0JhckxpbmUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmV0aGlja25lc3NcIiwgXCIwcHhcIik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAuYmFyU2l6ZSkge1xuICAgIGNvbnN0IHJ1bGVXaWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuYmFyU2l6ZSwgb3B0aW9ucyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIG1ha2VFbShydWxlV2lkdGgpKTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gYWRqdXN0U3R5bGUoZ3JvdXAuc2l6ZSwgb3B0aW9ucy5zdHlsZSk7XG5cbiAgaWYgKHN0eWxlLnNpemUgIT09IG9wdGlvbnMuc3R5bGUuc2l6ZSkge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbbm9kZV0pO1xuICAgIGNvbnN0IGlzRGlzcGxheSA9IHN0eWxlLnNpemUgPT09IHNyY19TdHlsZS5ESVNQTEFZLnNpemUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBpc0Rpc3BsYXkpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIwXCIpO1xuICB9XG5cbiAgaWYgKGdyb3VwLmxlZnREZWxpbSAhPSBudWxsIHx8IGdyb3VwLnJpZ2h0RGVsaW0gIT0gbnVsbCkge1xuICAgIGNvbnN0IHdpdGhEZWxpbXMgPSBbXTtcblxuICAgIGlmIChncm91cC5sZWZ0RGVsaW0gIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGVmdE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAubGVmdERlbGltLnJlcGxhY2UoXCJcXFxcXCIsIFwiXCIpKV0pO1xuICAgICAgbGVmdE9wLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHdpdGhEZWxpbXMucHVzaChsZWZ0T3ApO1xuICAgIH1cblxuICAgIHdpdGhEZWxpbXMucHVzaChub2RlKTtcblxuICAgIGlmIChncm91cC5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJpZ2h0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5yaWdodERlbGltLnJlcGxhY2UoXCJcXFxcXCIsIFwiXCIpKV0pO1xuICAgICAgcmlnaHRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICB3aXRoRGVsaW1zLnB1c2gocmlnaHRPcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VSb3cod2l0aERlbGltcyk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGZyYWNcIiwgXCJcXFxcZnJhY1wiLCBcIlxcXFx0ZnJhY1wiLCBcIlxcXFxkYmlub21cIiwgXCJcXFxcYmlub21cIiwgXCJcXFxcdGJpbm9tXCIsIFwiXFxcXFxcXFxhdG9wZnJhY1wiLCAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXCJcXFxcXFxcXGJyYWNlZnJhY1wiLCBcIlxcXFxcXFxcYnJhY2tmcmFjXCIgLy8gZGl0dG9cbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgbnVtZXIgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGRlbm9tID0gYXJnc1sxXTtcbiAgICBsZXQgaGFzQmFyTGluZTtcbiAgICBsZXQgbGVmdERlbGltID0gbnVsbDtcbiAgICBsZXQgcmlnaHREZWxpbSA9IG51bGw7XG4gICAgbGV0IHNpemUgPSBcImF1dG9cIjtcblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcZGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcXFxcXGF0b3BmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcZGJpbm9tXCI6XG4gICAgICBjYXNlIFwiXFxcXGJpbm9tXCI6XG4gICAgICBjYXNlIFwiXFxcXHRiaW5vbVwiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGxlZnREZWxpbSA9IFwiKFwiO1xuICAgICAgICByaWdodERlbGltID0gXCIpXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXFxcXFxicmFjZWZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgICAgICBsZWZ0RGVsaW0gPSBcIlxcXFx7XCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIlxcXFx9XCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXFxcXFxicmFja2ZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgICAgICBsZWZ0RGVsaW0gPSBcIltcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiXVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICBzaXplID0gXCJkaXNwbGF5XCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXHRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXHRiaW5vbVwiOlxuICAgICAgICBzaXplID0gXCJ0ZXh0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29udGludWVkOiBmYWxzZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBoYXNCYXJMaW5lLFxuICAgICAgbGVmdERlbGltLFxuICAgICAgcmlnaHREZWxpbSxcbiAgICAgIHNpemUsXG4gICAgICBiYXJTaXplOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGdlbmZyYWNfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGdlbmZyYWNfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXGNmcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYyLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IG51bWVyID0gYXJnc1swXTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb250aW51ZWQ6IHRydWUsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgaGFzQmFyTGluZTogdHJ1ZSxcbiAgICAgIGxlZnREZWxpbTogbnVsbCxcbiAgICAgIHJpZ2h0RGVsaW06IG51bGwsXG4gICAgICBzaXplOiBcImRpc3BsYXlcIixcbiAgICAgIGJhclNpemU6IG51bGxcbiAgICB9O1xuICB9XG59KTsgLy8gSW5maXggZ2VuZXJhbGl6ZWQgZnJhY3Rpb25zIC0tIHRoZXNlIGFyZSBub3QgcmVuZGVyZWQgZGlyZWN0bHksIGJ1dCByZXBsYWNlZFxuLy8gaW1tZWRpYXRlbHkgYnkgb25lIG9mIHRoZSB2YXJpYW50cyBhYm92ZS5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlclwiLCBcIlxcXFxjaG9vc2VcIiwgXCJcXFxcYXRvcFwiLCBcIlxcXFxicmFjZVwiLCBcIlxcXFxicmFja1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHRva2VuXG4gICAgfSA9IF9yZWYzO1xuICAgIGxldCByZXBsYWNlV2l0aDtcblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcb3ZlclwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcY2hvb3NlXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcYmlub21cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYXRvcFwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxhdG9wZnJhY1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxicmFjZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxicmFjZWZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYnJhY2tcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYnJhY2tmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoLFxuICAgICAgdG9rZW5cbiAgICB9O1xuICB9XG5cbn0pO1xuY29uc3Qgc3R5bEFycmF5ID0gW1wiZGlzcGxheVwiLCBcInRleHRcIiwgXCJzY3JpcHRcIiwgXCJzY3JpcHRzY3JpcHRcIl07XG5cbmNvbnN0IGRlbGltRnJvbVZhbHVlID0gZnVuY3Rpb24gKGRlbGltU3RyaW5nKSB7XG4gIGxldCBkZWxpbSA9IG51bGw7XG5cbiAgaWYgKGRlbGltU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBkZWxpbSA9IGRlbGltU3RyaW5nO1xuICAgIGRlbGltID0gZGVsaW0gPT09IFwiLlwiID8gbnVsbCA6IGRlbGltO1xuICB9XG5cbiAgcmV0dXJuIGRlbGltO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxnZW5mcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDYsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcIm1hdGhcIiwgXCJtYXRoXCIsIFwic2l6ZVwiLCBcInRleHRcIiwgXCJtYXRoXCIsIFwibWF0aFwiXVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjQsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY0O1xuICAgIGNvbnN0IG51bWVyID0gYXJnc1s0XTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbNV07IC8vIExvb2sgaW50byB0aGUgcGFyc2Ugbm9kZXMgdG8gZ2V0IHRoZSBkZXNpcmVkIGRlbGltaXRlcnMuXG5cbiAgICBjb25zdCBsZWZ0Tm9kZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgIGNvbnN0IGxlZnREZWxpbSA9IGxlZnROb2RlLnR5cGUgPT09IFwiYXRvbVwiICYmIGxlZnROb2RlLmZhbWlseSA9PT0gXCJvcGVuXCIgPyBkZWxpbUZyb21WYWx1ZShsZWZ0Tm9kZS50ZXh0KSA6IG51bGw7XG4gICAgY29uc3QgcmlnaHROb2RlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1sxXSk7XG4gICAgY29uc3QgcmlnaHREZWxpbSA9IHJpZ2h0Tm9kZS50eXBlID09PSBcImF0b21cIiAmJiByaWdodE5vZGUuZmFtaWx5ID09PSBcImNsb3NlXCIgPyBkZWxpbUZyb21WYWx1ZShyaWdodE5vZGUudGV4dCkgOiBudWxsO1xuICAgIGNvbnN0IGJhck5vZGUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzJdLCBcInNpemVcIik7XG4gICAgbGV0IGhhc0JhckxpbmU7XG4gICAgbGV0IGJhclNpemUgPSBudWxsO1xuXG4gICAgaWYgKGJhck5vZGUuaXNCbGFuaykge1xuICAgICAgLy8gXFxnZW5mcmFjIGFjdHMgZGlmZmVyZW50bHkgdGhhbiBcXGFib3ZlLlxuICAgICAgLy8gXFxnZW5mcmFjIHRyZWF0cyBhbiBlbXB0eSBzaXplIGdyb3VwIGFzIGEgc2lnbmFsIHRvIHVzZSBhXG4gICAgICAvLyBzdGFuZGFyZCBiYXIgc2l6ZS4gXFxhYm92ZSB3b3VsZCBzZWUgc2l6ZSA9IDAgYW5kIG9taXQgdGhlIGJhci5cbiAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJTaXplID0gYmFyTm9kZS52YWx1ZTtcbiAgICAgIGhhc0JhckxpbmUgPSBiYXJTaXplLm51bWJlciA+IDA7XG4gICAgfSAvLyBGaW5kIG91dCBpZiB3ZSB3YW50IGRpc3BsYXlzdHlsZSwgdGV4dHN0eWxlLCBldGMuXG5cblxuICAgIGxldCBzaXplID0gXCJhdXRvXCI7XG4gICAgbGV0IHN0eWwgPSBhcmdzWzNdO1xuXG4gICAgaWYgKHN0eWwudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICBpZiAoc3R5bC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdGV4dE9yZCA9IGFzc2VydE5vZGVUeXBlKHN0eWwuYm9keVswXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgICBzaXplID0gc3R5bEFycmF5W051bWJlcih0ZXh0T3JkLnRleHQpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bCA9IGFzc2VydE5vZGVUeXBlKHN0eWwsIFwidGV4dG9yZFwiKTtcbiAgICAgIHNpemUgPSBzdHlsQXJyYXlbTnVtYmVyKHN0eWwudGV4dCldO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBoYXNCYXJMaW5lLFxuICAgICAgYmFyU2l6ZSxcbiAgICAgIGxlZnREZWxpbSxcbiAgICAgIHJpZ2h0RGVsaW0sXG4gICAgICBzaXplXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogZ2VuZnJhY19odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZ2VuZnJhY19tYXRobWxCdWlsZGVyXG59KTsgLy8gXFxhYm92ZSBpcyBhbiBpbmZpeCBmcmFjdGlvbiB0aGF0IGFsc28gZGVmaW5lcyBhIGZyYWN0aW9uIGJhciBzaXplLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW5maXhcIixcbiAgbmFtZXM6IFtcIlxcXFxhYm92ZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCJdLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmNSwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHRva2VuXG4gICAgfSA9IF9yZWY1O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoOiBcIlxcXFxcXFxcYWJvdmVmcmFjXCIsXG4gICAgICBzaXplOiBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWUsXG4gICAgICB0b2tlblxuICAgIH07XG4gIH1cblxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXFxcXFxhYm92ZWZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMyxcbiAgICBhcmdUeXBlczogW1wibWF0aFwiLCBcInNpemVcIiwgXCJtYXRoXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmNiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmNjtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbMF07XG4gICAgY29uc3QgYmFyU2l6ZSA9IGFzc2VydChhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcImluZml4XCIpLnNpemUpO1xuICAgIGNvbnN0IGRlbm9tID0gYXJnc1syXTtcbiAgICBjb25zdCBoYXNCYXJMaW5lID0gYmFyU2l6ZS5udW1iZXIgPiAwO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBoYXNCYXJMaW5lLFxuICAgICAgYmFyU2l6ZSxcbiAgICAgIGxlZnREZWxpbTogbnVsbCxcbiAgICAgIHJpZ2h0RGVsaW06IG51bGwsXG4gICAgICBzaXplOiBcImF1dG9cIlxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBnZW5mcmFjX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBnZW5mcmFjX21hdGhtbEJ1aWxkZXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9ob3JpekJyYWNlLmpzXG5cblxuXG5cblxuXG5cblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJob3JpekJyYWNlXCIsIGJ1dFxuLy8gYWxzbyBcInN1cHN1YlwiIHNpbmNlIGFuIG92ZXIvdW5kZXJicmFjZSBjYW4gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cbmNvbnN0IGhvcml6QnJhY2VfaHRtbEJ1aWxkZXIgPSAoZ3JwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5zdHlsZTsgLy8gUHVsbCBvdXQgdGhlIGBQYXJzZU5vZGU8XCJob3JpekJyYWNlXCI+YCBpZiBgZ3JwYCBpcyBhIFwic3Vwc3ViXCIgbm9kZS5cblxuICBsZXQgc3VwU3ViR3JvdXA7XG4gIGxldCBncm91cDtcblxuICBpZiAoZ3JwLnR5cGUgPT09IFwic3Vwc3ViXCIpIHtcbiAgICAvLyBSZWY6IExhVGVYIHNvdXJjZTJlOiB9fX19XFxsaW1pdHN9XG4gICAgLy8gaS5lLiBMYVRlWCB0cmVhdHMgdGhlIGJyYWNlIHNpbWlsYXIgdG8gYW4gb3AgYW5kIHBhc3NlcyBpdFxuICAgIC8vIHdpdGggXFxsaW1pdHMsIHNvIHdlIG5lZWQgdG8gYXNzaWduIHN1cHN1YiBzdHlsZS5cbiAgICBzdXBTdWJHcm91cCA9IGdycC5zdXAgPyBidWlsZEdyb3VwKGdycC5zdXAsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3VwKCkpLCBvcHRpb25zKSA6IGJ1aWxkR3JvdXAoZ3JwLnN1Yiwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdWIoKSksIG9wdGlvbnMpO1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLmJhc2UsIFwiaG9yaXpCcmFjZVwiKTtcbiAgfSBlbHNlIHtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycCwgXCJob3JpekJyYWNlXCIpO1xuICB9IC8vIEJ1aWxkIHRoZSBiYXNlIGdyb3VwXG5cblxuICBjb25zdCBib2R5ID0gYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzcmNfU3R5bGUuRElTUExBWSkpOyAvLyBDcmVhdGUgdGhlIHN0cmV0Y2h5IGVsZW1lbnRcblxuICBjb25zdCBicmFjZUJvZHkgPSBzdHJldGNoeS5zdmdTcGFuKGdyb3VwLCBvcHRpb25zKTsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJucyAgICAgICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTXG4gIC8vIFRoaXMgZmlyc3Qgdmxpc3QgY29udGFpbnMgdGhlIGNvbnRlbnQgYW5kIHRoZSBicmFjZTogICBlcXVhdGlvblxuXG4gIGxldCB2bGlzdDtcblxuICBpZiAoZ3JvdXAuaXNPdmVyKSB7XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogMC4xXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBicmFjZUJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vICRGbG93Rml4TWU6IFJlcGxhY2UgdGhpcyB3aXRoIHBhc3NpbmcgXCJzdmctYWxpZ25cIiBpbnRvIG1ha2VWTGlzdC5cblxuICAgIHZsaXN0LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLmNsYXNzZXMucHVzaChcInN2Zy1hbGlnblwiKTtcbiAgfSBlbHNlIHtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGJvZHkuZGVwdGggKyAwLjEgKyBicmFjZUJvZHkuaGVpZ2h0LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBicmFjZUJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IDAuMVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gJEZsb3dGaXhNZTogUmVwbGFjZSB0aGlzIHdpdGggcGFzc2luZyBcInN2Zy1hbGlnblwiIGludG8gbWFrZVZMaXN0LlxuXG4gICAgdmxpc3QuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2xhc3Nlcy5wdXNoKFwic3ZnLWFsaWduXCIpO1xuICB9XG5cbiAgaWYgKHN1cFN1Ykdyb3VwKSB7XG4gICAgLy8gVG8gd3JpdGUgdGhlIHN1cHN1Yiwgd3JhcCB0aGUgZmlyc3Qgdmxpc3QgaW4gYW5vdGhlciB2bGlzdDpcbiAgICAvLyBUaGV5IGNhbid0IGFsbCBnbyBpbiB0aGUgc2FtZSB2bGlzdCwgYmVjYXVzZSB0aGUgbm90ZSBtaWdodCBiZVxuICAgIC8vIHdpZGVyIHRoYW4gdGhlIGVxdWF0aW9uLiBXZSB3YW50IHRoZSBlcXVhdGlvbiB0byBjb250cm9sIHRoZVxuICAgIC8vIGJyYWNlIHdpZHRoLlxuICAgIC8vICAgICAgbm90ZSAgICAgICAgICBsb25nIG5vdGUgICAgICAgICAgIGxvbmcgbm90ZVxuICAgIC8vICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTICAgb3IgICAg4pSP4pSB4pSB4pSB4pSTICAgICBub3QgICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTXG4gICAgLy8gICAgZXF1YXRpb24gICAgICAgICAgIGVxbiAgICAgICAgICAgICAgICAgZXFuXG4gICAgY29uc3QgdlNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcblxuICAgIGlmIChncm91cC5pc092ZXIpIHtcbiAgICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdlNwYW5cbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICAgIHNpemU6IDAuMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwU3ViR3JvdXBcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiB2U3Bhbi5kZXB0aCArIDAuMiArIHN1cFN1Ykdyb3VwLmhlaWdodCArIHN1cFN1Ykdyb3VwLmRlcHRoLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBzdXBTdWJHcm91cFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgICAgc2l6ZTogMC4yXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiB2U3BhblxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgZ3JvdXAuaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xufTtcblxuY29uc3QgaG9yaXpCcmFjZV9tYXRobWxCdWlsZGVyID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGFjY2VudE5vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKTtcbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpLCBhY2NlbnROb2RlXSk7XG59OyAvLyBIb3Jpem9udGFsIHN0cmV0Y2h5IGJyYWNlc1xuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJob3JpekJyYWNlXCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlcmJyYWNlXCIsIFwiXFxcXHVuZGVyYnJhY2VcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhvcml6QnJhY2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgaXNPdmVyOiAvXlxcXFxvdmVyLy50ZXN0KGZ1bmNOYW1lKSxcbiAgICAgIGJhc2U6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBob3JpekJyYWNlX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBob3JpekJyYWNlX21hdGhtbEJ1aWxkZXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9ocmVmLmpzXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHJlZlwiLFxuICBuYW1lczogW1wiXFxcXGhyZWZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1widXJsXCIsIFwib3JpZ2luYWxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICBjb25zdCBocmVmID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJ1cmxcIikudXJsO1xuXG4gICAgaWYgKCFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgIGNvbW1hbmQ6IFwiXFxcXGhyZWZcIixcbiAgICAgIHVybDogaHJlZlxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLmZvcm1hdFVuc3VwcG9ydGVkQ21kKFwiXFxcXGhyZWZcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBocmVmLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgZmFsc2UpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlQW5jaG9yKGdyb3VwLmhyZWYsIFtdLCBlbGVtZW50cywgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGxldCBtYXRoID0gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKCEobWF0aCBpbnN0YW5jZW9mIE1hdGhOb2RlKSkge1xuICAgICAgbWF0aCA9IG5ldyBNYXRoTm9kZShcIm1yb3dcIiwgW21hdGhdKTtcbiAgICB9XG5cbiAgICBtYXRoLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgZ3JvdXAuaHJlZik7XG4gICAgcmV0dXJuIG1hdGg7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhyZWZcIixcbiAgbmFtZXM6IFtcIlxcXFx1cmxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widXJsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYyLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCBocmVmID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJ1cmxcIikudXJsO1xuXG4gICAgaWYgKCFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgIGNvbW1hbmQ6IFwiXFxcXHVybFwiLFxuICAgICAgdXJsOiBocmVmXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuZm9ybWF0VW5zdXBwb3J0ZWRDbWQoXCJcXFxcdXJsXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhyZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gaHJlZltpXTtcblxuICAgICAgaWYgKGMgPT09IFwiflwiKSB7XG4gICAgICAgIGMgPSBcIlxcXFx0ZXh0YXNjaWl0aWxkZVwiO1xuICAgICAgfVxuXG4gICAgICBjaGFycy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiBjXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZvbnQ6IFwiXFxcXHRleHR0dFwiLFxuICAgICAgYm9keTogY2hhcnNcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhyZWZcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgaHJlZixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2hib3guanNcblxuXG5cblxuIC8vIFxcaGJveCBpcyBwcm92aWRlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIExhVGVYIFxcdmNlbnRlci5cbi8vIEluIExhVGVYLCBcXHZjZW50ZXIgY2FuIGFjdCBvbmx5IG9uIGEgYm94LCBhcyBpblxuLy8gXFx2Y2VudGVye1xcaGJveHskXFxmcmFje2ErYn17XFxkZnJhY3tjfXtkfX0kfX1cbi8vIFRoaXMgZnVuY3Rpb24gYnkgaXRzZWxmIGRvZXNuJ3QgZG8gYW55dGhpbmcgYnV0IHByZXZlbnQgYSBzb2Z0IGxpbmUgYnJlYWsuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJoYm94XCIsXG4gIG5hbWVzOiBbXCJcXFxcaGJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhib3hcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1swXSlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgZmFsc2UpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zKSk7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2h0bWwuanNcblxuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJodG1sXCIsXG4gIG5hbWVzOiBbXCJcXFxcaHRtbENsYXNzXCIsIFwiXFxcXGh0bWxJZFwiLCBcIlxcXFxodG1sU3R5bGVcIiwgXCJcXFxcaHRtbERhdGFcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwib3JpZ2luYWxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHRva2VuXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgdmFsdWUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG5cbiAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcImh0bWxFeHRlbnNpb25cIiwgXCJIVE1MIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCBvbiBzdHJpY3QgbW9kZVwiKTtcbiAgICB9XG5cbiAgICBsZXQgdHJ1c3RDb250ZXh0O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcaHRtbENsYXNzXCI6XG4gICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSB2YWx1ZTtcbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGh0bWxDbGFzc1wiLFxuICAgICAgICAgIGNsYXNzOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxodG1sSWRcIjpcbiAgICAgICAgYXR0cmlidXRlcy5pZCA9IHZhbHVlO1xuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcaHRtbElkXCIsXG4gICAgICAgICAgaWQ6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGh0bWxTdHlsZVwiOlxuICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gdmFsdWU7XG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxodG1sU3R5bGVcIixcbiAgICAgICAgICBzdHlsZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcaHRtbERhdGFcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS5zcGxpdChcIixcIik7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbCA9IGRhdGFbaV0uc3BsaXQoXCI9XCIpO1xuXG4gICAgICAgICAgICBpZiAoa2V5VmFsLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFcnJvciBwYXJzaW5nIGtleS12YWx1ZSBmb3IgXFxcXGh0bWxEYXRhXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRyaWJ1dGVzW1wiZGF0YS1cIiArIGtleVZhbFswXS50cmltKCldID0ga2V5VmFsWzFdLnRyaW0oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgICBjb21tYW5kOiBcIlxcXFxodG1sRGF0YVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGh0bWwgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQodHJ1c3RDb250ZXh0KSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5mb3JtYXRVbnN1cHBvcnRlZENtZChmdW5jTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHRtbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgZmFsc2UpO1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbXCJlbmNsb3NpbmdcIl07XG5cbiAgICBpZiAoZ3JvdXAuYXR0cmlidXRlcy5jbGFzcykge1xuICAgICAgY2xhc3Nlcy5wdXNoKC4uLmdyb3VwLmF0dHJpYnV0ZXMuY2xhc3MudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xuICAgIH1cblxuICAgIGNvbnN0IHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLCBlbGVtZW50cywgb3B0aW9ucyk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gZ3JvdXAuYXR0cmlidXRlcykge1xuICAgICAgaWYgKGF0dHIgIT09IFwiY2xhc3NcIiAmJiBncm91cC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGF0dHIsIGdyb3VwLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvaHRtbG1hdGhtbC5qc1xuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHRtbG1hdGhtbFwiLFxuICBuYW1lczogW1wiXFxcXGh0bWxAbWF0aG1sXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJodG1sbWF0aG1sXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGh0bWw6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pLFxuICAgICAgbWF0aG1sOiBvcmRhcmd1bWVudChhcmdzWzFdKVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5odG1sLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAubWF0aG1sLCBvcHRpb25zKTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2luY2x1ZGVncmFwaGljcy5qc1xuXG5cblxuXG5cblxuXG5jb25zdCBzaXplRGF0YSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKC9eWy0rXT8gKihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKSQvLnRlc3Qoc3RyKSkge1xuICAgIC8vIHN0ciBpcyBhIG51bWJlciB3aXRoIG5vIHVuaXQgc3BlY2lmaWVkLlxuICAgIC8vIGRlZmF1bHQgdW5pdCBpcyBicCwgcGVyIGdyYXBoaXggcGFja2FnZS5cbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyOiArc3RyLFxuICAgICAgdW5pdDogXCJicFwiXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtYXRjaCA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS8uZXhlYyhzdHIpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyBzdHIgKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljc1wiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLFxuICAgICAgLy8gc2lnbiArIG1hZ25pdHVkZSwgY2FzdCB0byBudW1iZXJcbiAgICAgIHVuaXQ6IG1hdGNoWzNdXG4gICAgfTtcblxuICAgIGlmICghdmFsaWRVbml0KGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIGRhdGEudW5pdCArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluY2x1ZGVncmFwaGljc1wiLFxuICBuYW1lczogW1wiXFxcXGluY2x1ZGVncmFwaGljc1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwidXJsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzLCBvcHRBcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGxldCB3aWR0aCA9IHtcbiAgICAgIG51bWJlcjogMCxcbiAgICAgIHVuaXQ6IFwiZW1cIlxuICAgIH07XG4gICAgbGV0IGhlaWdodCA9IHtcbiAgICAgIG51bWJlcjogMC45LFxuICAgICAgdW5pdDogXCJlbVwiXG4gICAgfTsgLy8gc29ydGEgY2hhcmFjdGVyIHNpemVkLlxuXG4gICAgbGV0IHRvdGFsaGVpZ2h0ID0ge1xuICAgICAgbnVtYmVyOiAwLFxuICAgICAgdW5pdDogXCJlbVwiXG4gICAgfTtcbiAgICBsZXQgYWx0ID0gXCJcIjtcblxuICAgIGlmIChvcHRBcmdzWzBdKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVTdHIgPSBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7IC8vIFBhcnNlci5qcyBkb2VzIG5vdCBwYXJzZSBrZXkvdmFsdWUgcGFpcnMuIFdlIGdldCBhIHN0cmluZy5cblxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZVN0ci5zcGxpdChcIixcIik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXlWYWwgPSBhdHRyaWJ1dGVzW2ldLnNwbGl0KFwiPVwiKTtcblxuICAgICAgICBpZiAoa2V5VmFsLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbnN0IHN0ciA9IGtleVZhbFsxXS50cmltKCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGtleVZhbFswXS50cmltKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbHRcIjpcbiAgICAgICAgICAgICAgYWx0ID0gc3RyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICAgIHdpZHRoID0gc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ0b3RhbGhlaWdodFwiOlxuICAgICAgICAgICAgICB0b3RhbGhlaWdodCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGtleTogJ1wiICsga2V5VmFsWzBdICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3MuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNyYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmIChhbHQgPT09IFwiXCIpIHtcbiAgICAgIC8vIE5vIGFsdCBnaXZlbi4gVXNlIHRoZSBmaWxlIG5hbWUuIFN0cmlwIGF3YXkgdGhlIHBhdGguXG4gICAgICBhbHQgPSBzcmM7XG4gICAgICBhbHQgPSBhbHQucmVwbGFjZSgvXi4qW1xcXFwvXS8sICcnKTtcbiAgICAgIGFsdCA9IGFsdC5zdWJzdHJpbmcoMCwgYWx0Lmxhc3RJbmRleE9mKCcuJykpO1xuICAgIH1cblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICBjb21tYW5kOiBcIlxcXFxpbmNsdWRlZ3JhcGhpY3NcIixcbiAgICAgIHVybDogc3JjXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuZm9ybWF0VW5zdXBwb3J0ZWRDbWQoXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluY2x1ZGVncmFwaGljc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbHQ6IGFsdCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdG90YWxoZWlnaHQ6IHRvdGFsaGVpZ2h0LFxuICAgICAgc3JjOiBzcmNcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpO1xuICAgIGxldCBkZXB0aCA9IDA7XG5cbiAgICBpZiAoZ3JvdXAudG90YWxoZWlnaHQubnVtYmVyID4gMCkge1xuICAgICAgZGVwdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLnRvdGFsaGVpZ2h0LCBvcHRpb25zKSAtIGhlaWdodDtcbiAgICB9XG5cbiAgICBsZXQgd2lkdGggPSAwO1xuXG4gICAgaWYgKGdyb3VwLndpZHRoLm51bWJlciA+IDApIHtcbiAgICAgIHdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IG1ha2VFbShoZWlnaHQgKyBkZXB0aClcbiAgICB9O1xuXG4gICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBtYWtlRW0od2lkdGgpO1xuICAgIH1cblxuICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgIHN0eWxlLnZlcnRpY2FsQWxpZ24gPSBtYWtlRW0oLWRlcHRoKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gbmV3IEltZyhncm91cC5zcmMsIGdyb3VwLmFsdCwgc3R5bGUpO1xuICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIG5vZGUuZGVwdGggPSBkZXB0aDtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWdseXBoXCIsIFtdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFsdFwiLCBncm91cC5hbHQpO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcbiAgICBsZXQgZGVwdGggPSAwO1xuXG4gICAgaWYgKGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciA+IDApIHtcbiAgICAgIGRlcHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC50b3RhbGhlaWdodCwgb3B0aW9ucykgLSBoZWlnaHQ7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInZhbGlnblwiLCBtYWtlRW0oLWRlcHRoKSk7XG4gICAgfVxuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgbWFrZUVtKGhlaWdodCArIGRlcHRoKSk7XG5cbiAgICBpZiAoZ3JvdXAud2lkdGgubnVtYmVyID4gMCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgbWFrZUVtKHdpZHRoKSk7XG4gICAgfVxuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgZ3JvdXAuc3JjKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2tlcm4uanNcbi8vIEhvcml6b250YWwgc3BhY2luZyBjb21tYW5kc1xuXG5cblxuXG4gLy8gVE9ETzogXFxoc2tpcCBhbmQgXFxtc2tpcCBzaG91bGQgc3VwcG9ydCBwbHVzIGFuZCBtaW51cyBpbiBsZW5ndGhzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJrZXJuXCIsXG4gIG5hbWVzOiBbXCJcXFxca2VyblwiLCBcIlxcXFxta2VyblwiLCBcIlxcXFxoc2tpcFwiLCBcIlxcXFxtc2tpcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCJdLFxuICAgIHByaW1pdGl2ZTogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3Qgc2l6ZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKTtcblxuICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICBjb25zdCBtYXRoRnVuY3Rpb24gPSBmdW5jTmFtZVsxXSA9PT0gJ20nOyAvLyBcXG1rZXJuLCBcXG1za2lwXG5cbiAgICAgIGNvbnN0IG11VW5pdCA9IHNpemUudmFsdWUudW5pdCA9PT0gJ211JztcblxuICAgICAgaWYgKG1hdGhGdW5jdGlvbikge1xuICAgICAgICBpZiAoIW11VW5pdCkge1xuICAgICAgICAgIHBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJtYXRoVnNUZXh0VW5pdHNcIiwgXCJMYVRlWCdzIFwiICsgZnVuY05hbWUgKyBcIiBzdXBwb3J0cyBvbmx5IG11IHVuaXRzLCBcIiArIChcIm5vdCBcIiArIHNpemUudmFsdWUudW5pdCArIFwiIHVuaXRzXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZXIubW9kZSAhPT0gXCJtYXRoXCIpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dFVuaXRzXCIsIFwiTGFUZVgncyBcIiArIGZ1bmNOYW1lICsgXCIgd29ya3Mgb25seSBpbiBtYXRoIG1vZGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICFtYXRoRnVuY3Rpb25cbiAgICAgICAgaWYgKG11VW5pdCkge1xuICAgICAgICAgIHBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJtYXRoVnNUZXh0VW5pdHNcIiwgXCJMYVRlWCdzIFwiICsgZnVuY05hbWUgKyBcIiBkb2Vzbid0IHN1cHBvcnQgbXUgdW5pdHNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGRpbWVuc2lvbjogc2l6ZS52YWx1ZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUdsdWUoZ3JvdXAuZGltZW5zaW9uLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGltZW5zaW9uID0gY2FsY3VsYXRlU2l6ZShncm91cC5kaW1lbnNpb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5TcGFjZU5vZGUoZGltZW5zaW9uKTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvbGFwLmpzXG4vLyBIb3Jpem9udGFsIG92ZXJsYXAgZnVuY3Rpb25zXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGFwXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGxsYXBcIiwgXCJcXFxcbWF0aHJsYXBcIiwgXCJcXFxcbWF0aGNsYXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGFwXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGFsaWdubWVudDogZnVuY05hbWUuc2xpY2UoNSksXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIG1hdGhsbGFwLCBtYXRocmxhcCwgbWF0aGNsYXBcbiAgICBsZXQgaW5uZXI7XG5cbiAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ID09PSBcImNsYXBcIikge1xuICAgICAgLy8gcmVmOiBodHRwczovL3d3dy5tYXRoLmxzdS5lZHUvfmFwZXJsaXMvcHVibGljYXRpb25zL21hdGhjbGFwL1xuICAgICAgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTsgLy8gd3JhcCwgc2luY2UgQ1NTIHdpbGwgY2VudGVyIGEgLmNsYXAgPiAuaW5uZXIgPiBzcGFuXG5cbiAgICAgIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiaW5uZXJcIl0sIFtpbm5lcl0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImlubmVyXCJdLCBbYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGZpeCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImZpeFwiXSwgW10pO1xuICAgIGxldCBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW2dyb3VwLmFsaWdubWVudF0sIFtpbm5lciwgZml4XSwgb3B0aW9ucyk7IC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgY29ycmVjdGx5IHNldCBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGVcbiAgICAvLyB0d28gaXRlbXMgaW52b2x2ZWQgaW4gdGhlIGxhcC5cbiAgICAvLyBOZXh0LCB1c2UgYSBzdHJ1dCB0byBzZXQgdGhlIGhlaWdodCBvZiB0aGUgSFRNTCBib3VuZGluZyBib3guXG4gICAgLy8gT3RoZXJ3aXNlLCBhIHRhbGwgYXJndW1lbnQgbWF5IGJlIG1pc3BsYWNlZC5cbiAgICAvLyBUaGlzIGNvZGUgcmVzb2x2ZWQgaXNzdWUgIzExNTNcblxuICAgIGNvbnN0IHN0cnV0ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wic3RydXRcIl0pO1xuICAgIHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShub2RlLmhlaWdodCArIG5vZGUuZGVwdGgpO1xuXG4gICAgaWYgKG5vZGUuZGVwdGgpIHtcbiAgICAgIHN0cnV0LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBtYWtlRW0oLW5vZGUuZGVwdGgpO1xuICAgIH1cblxuICAgIG5vZGUuY2hpbGRyZW4udW5zaGlmdChzdHJ1dCk7IC8vIE5leHQsIHByZXZlbnQgdmVydGljYWwgbWlzcGxhY2VtZW50IHdoZW4gbmV4dCB0byBzb21ldGhpbmcgdGFsbC5cbiAgICAvLyBUaGlzIGNvZGUgcmVzb2x2ZXMgaXNzdWUgIzEyMzRcblxuICAgIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJ0aGluYm94XCJdLCBbbm9kZV0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwidmJveFwiXSwgW25vZGVdLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gbWF0aGxsYXAsIG1hdGhybGFwLCBtYXRoY2xhcFxuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTtcblxuICAgIGlmIChncm91cC5hbGlnbm1lbnQgIT09IFwicmxhcFwiKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBncm91cC5hbGlnbm1lbnQgPT09IFwibGxhcFwiID8gXCItMVwiIDogXCItMC41XCI7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBvZmZzZXQgKyBcIndpZHRoXCIpO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9tYXRoLmpzXG5cbiAvLyBTd2l0Y2hpbmcgZnJvbSB0ZXh0IG1vZGUgYmFjayB0byBtYXRoIG1vZGVcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInN0eWxpbmdcIixcbiAgbmFtZXM6IFtcIlxcXFwoXCIsIFwiJFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogZmFsc2VcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgZnVuY05hbWUsXG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBvdXRlck1vZGUgPSBwYXJzZXIubW9kZTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShcIm1hdGhcIik7XG4gICAgY29uc3QgY2xvc2UgPSBmdW5jTmFtZSA9PT0gXCJcXFxcKFwiID8gXCJcXFxcKVwiIDogXCIkXCI7XG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGNsb3NlKTtcbiAgICBwYXJzZXIuZXhwZWN0KGNsb3NlKTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShvdXRlck1vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc3R5bGU6IFwidGV4dFwiLFxuICAgICAgYm9keVxuICAgIH07XG4gIH1cblxufSk7IC8vIENoZWNrIGZvciBleHRyYSBjbG9zaW5nIG1hdGggZGVsaW1pdGVyc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLFxuICAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoaXMgaXMuXG4gIG5hbWVzOiBbXCJcXFxcKVwiLCBcIlxcXFxdXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiBmYWxzZVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk1pc21hdGNoZWQgXCIgKyBjb250ZXh0LmZ1bmNOYW1lKTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvbWF0aGNob2ljZS5qc1xuXG5cblxuXG5cblxuY29uc3QgY2hvb3NlTWF0aFN0eWxlID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIHN3aXRjaCAob3B0aW9ucy5zdHlsZS5zaXplKSB7XG4gICAgY2FzZSBzcmNfU3R5bGUuRElTUExBWS5zaXplOlxuICAgICAgcmV0dXJuIGdyb3VwLmRpc3BsYXk7XG5cbiAgICBjYXNlIHNyY19TdHlsZS5URVhULnNpemU6XG4gICAgICByZXR1cm4gZ3JvdXAudGV4dDtcblxuICAgIGNhc2Ugc3JjX1N0eWxlLlNDUklQVC5zaXplOlxuICAgICAgcmV0dXJuIGdyb3VwLnNjcmlwdDtcblxuICAgIGNhc2Ugc3JjX1N0eWxlLlNDUklQVFNDUklQVC5zaXplOlxuICAgICAgcmV0dXJuIGdyb3VwLnNjcmlwdHNjcmlwdDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ3JvdXAudGV4dDtcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1hdGhjaG9pY2VcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRoY2hvaWNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDQsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1hdGhjaG9pY2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZGlzcGxheTogb3JkYXJndW1lbnQoYXJnc1swXSksXG4gICAgICB0ZXh0OiBvcmRhcmd1bWVudChhcmdzWzFdKSxcbiAgICAgIHNjcmlwdDogb3JkYXJndW1lbnQoYXJnc1syXSksXG4gICAgICBzY3JpcHRzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbM10pXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBjaG9vc2VNYXRoU3R5bGUoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKGJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGNob29zZU1hdGhTdHlsZShncm91cCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhib2R5LCBvcHRpb25zKTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3V0aWxzL2Fzc2VtYmxlU3VwU3ViLmpzXG5cblxuXG4gLy8gRm9yIGFuIG9wZXJhdG9yIHdpdGggbGltaXRzLCBhc3NlbWJsZSB0aGUgYmFzZSwgc3VwLCBhbmQgc3ViIGludG8gYSBzcGFuLlxuXG5jb25zdCBhc3NlbWJsZVN1cFN1YiA9IChiYXNlLCBzdXBHcm91cCwgc3ViR3JvdXAsIG9wdGlvbnMsIHN0eWxlLCBzbGFudCwgYmFzZVNoaWZ0KSA9PiB7XG4gIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2Jhc2VdKTtcbiAgY29uc3Qgc3ViSXNTaW5nbGVDaGFyYWN0ZXIgPSBzdWJHcm91cCAmJiB1dGlscy5pc0NoYXJhY3RlckJveChzdWJHcm91cCk7XG4gIGxldCBzdWI7XG4gIGxldCBzdXA7IC8vIFdlIG1hbnVhbGx5IGhhdmUgdG8gaGFuZGxlIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMuIFRoaXMsXG4gIC8vIGFzaWRlIGZyb20gdGhlIGtlcm4gY2FsY3VsYXRpb25zLCBpcyBjb3BpZWQgZnJvbSBzdXBzdWIuXG5cbiAgaWYgKHN1cEdyb3VwKSB7XG4gICAgY29uc3QgZWxlbSA9IGJ1aWxkR3JvdXAoc3VwR3JvdXAsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3VwKCkpLCBvcHRpb25zKTtcbiAgICBzdXAgPSB7XG4gICAgICBlbGVtLFxuICAgICAga2VybjogTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzEsIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmczIC0gZWxlbS5kZXB0aClcbiAgICB9O1xuICB9XG5cbiAgaWYgKHN1Ykdyb3VwKSB7XG4gICAgY29uc3QgZWxlbSA9IGJ1aWxkR3JvdXAoc3ViR3JvdXAsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3ViKCkpLCBvcHRpb25zKTtcbiAgICBzdWIgPSB7XG4gICAgICBlbGVtLFxuICAgICAga2VybjogTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzIsIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc0IC0gZWxlbS5oZWlnaHQpXG4gICAgfTtcbiAgfSAvLyBCdWlsZCB0aGUgZmluYWwgZ3JvdXAgYXMgYSB2bGlzdCBvZiB0aGUgcG9zc2libGUgc3Vic2NyaXB0LCBiYXNlLFxuICAvLyBhbmQgcG9zc2libGUgc3VwZXJzY3JpcHQuXG5cblxuICBsZXQgZmluYWxHcm91cDtcblxuICBpZiAoc3VwICYmIHN1Yikge1xuICAgIGNvbnN0IGJvdHRvbSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1ICsgc3ViLmVsZW0uaGVpZ2h0ICsgc3ViLmVsZW0uZGVwdGggKyBzdWIua2VybiArIGJhc2UuZGVwdGggKyBiYXNlU2hpZnQ7XG4gICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGJvdHRvbSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1Yi5lbGVtLFxuICAgICAgICBtYXJnaW5MZWZ0OiBtYWtlRW0oLXNsYW50KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogc3ViLmtlcm5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJhc2VcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1cC5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdXAuZWxlbSxcbiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKHNsYW50KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoc3ViKSB7XG4gICAgY29uc3QgdG9wID0gYmFzZS5oZWlnaHQgLSBiYXNlU2hpZnQ7IC8vIFNoaWZ0IHRoZSBsaW1pdHMgYnkgdGhlIHNsYW50IG9mIHRoZSBzeW1ib2wuIE5vdGVcbiAgICAvLyB0aGF0IHdlIGFyZSBzdXBwb3NlZCB0byBzaGlmdCB0aGUgbGltaXRzIGJ5IDEvMiBvZiB0aGUgc2xhbnQsXG4gICAgLy8gYnV0IHNpbmNlIHdlIGFyZSBjZW50ZXJpbmcgdGhlIGxpbWl0cyBhZGRpbmcgYSBmdWxsIHNsYW50IG9mXG4gICAgLy8gbWFyZ2luIHdpbGwgc2hpZnQgYnkgMS8yIHRoYXQuXG5cbiAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJ0b3BcIixcbiAgICAgIHBvc2l0aW9uRGF0YTogdG9wLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3ViLmVsZW0sXG4gICAgICAgIG1hcmdpbkxlZnQ6IG1ha2VFbSgtc2xhbnQpXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBzdWIua2VyblxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYmFzZVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChzdXApIHtcbiAgICBjb25zdCBib3R0b20gPSBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImJvdHRvbVwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBib3R0b20sXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJhc2VcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1cC5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdXAuZWxlbSxcbiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKHNsYW50KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBjYXNlIHByb2JhYmx5IHNob3VsZG4ndCBvY2N1ciAodGhpcyB3b3VsZCBtZWFuIHRoZVxuICAgIC8vIHN1cHN1YiB3YXMgc2VuZGluZyB1cyBhIGdyb3VwIHdpdGggbm8gc3VwZXJzY3JpcHQgb3JcbiAgICAvLyBzdWJzY3JpcHQpIGJ1dCBiZSBzYWZlLlxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgY29uc3QgcGFydHMgPSBbZmluYWxHcm91cF07XG5cbiAgaWYgKHN1YiAmJiBzbGFudCAhPT0gMCAmJiAhc3ViSXNTaW5nbGVDaGFyYWN0ZXIpIHtcbiAgICAvLyBBIG5lZ2F0aXZlIG1hcmdpbi1sZWZ0IHdhcyBhcHBsaWVkIHRvIHRoZSBsb3dlciBsaW1pdC5cbiAgICAvLyBBdm9pZCBhbiBvdmVybGFwIGJ5IHBsYWNpbmcgYSBzcGFjZXIgb24gdGhlIGxlZnQgb24gdGhlIGdyb3VwLlxuICAgIGNvbnN0IHNwYWNlciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiXSwgW10sIG9wdGlvbnMpO1xuICAgIHNwYWNlci5zdHlsZS5tYXJnaW5SaWdodCA9IG1ha2VFbShzbGFudCk7XG4gICAgcGFydHMudW5zaGlmdChzcGFjZXIpO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcFwiLCBcIm9wLWxpbWl0c1wiXSwgcGFydHMsIG9wdGlvbnMpO1xufTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvb3AuanNcbi8vIExpbWl0cywgc3ltYm9sc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIE1vc3Qgb3BlcmF0b3JzIGhhdmUgYSBsYXJnZSBzdWNjZXNzb3Igc3ltYm9sLCBidXQgdGhlc2UgZG9uJ3QuXG5jb25zdCBub1N1Y2Nlc3NvciA9IFtcIlxcXFxzbWFsbGludFwiXTsgLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJvcFwiLCBidXQgYWxzb1xuLy8gXCJzdXBzdWJcIiBzaW5jZSBzb21lIG9mIHRoZW0gKGxpa2UgXFxpbnQpIGNhbiBhZmZlY3Qgc3VwZXIvc3Vic2NyaXB0aW5nLlxuXG5jb25zdCBvcF9odG1sQnVpbGRlciA9IChncnAsIG9wdGlvbnMpID0+IHtcbiAgLy8gT3BlcmF0b3JzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMtNDQ0LCBydWxlIDEzKGEpLlxuICBsZXQgc3VwR3JvdXA7XG4gIGxldCBzdWJHcm91cDtcbiAgbGV0IGhhc0xpbWl0cyA9IGZhbHNlO1xuICBsZXQgZ3JvdXA7XG5cbiAgaWYgKGdycC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBsaW1pdHMsIHN1cHN1YiB3aWxsIHBhc3MgdXMgaXRzIGdyb3VwIHRvIGhhbmRsZS4gUHVsbFxuICAgIC8vIG91dCB0aGUgc3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdCBhbmQgc2V0IHRoZSBncm91cCB0byB0aGUgb3AgaW5cbiAgICAvLyBpdHMgYmFzZS5cbiAgICBzdXBHcm91cCA9IGdycC5zdXA7XG4gICAgc3ViR3JvdXAgPSBncnAuc3ViO1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLmJhc2UsIFwib3BcIik7XG4gICAgaGFzTGltaXRzID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycCwgXCJvcFwiKTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgbGV0IGxhcmdlID0gZmFsc2U7XG5cbiAgaWYgKHN0eWxlLnNpemUgPT09IHNyY19TdHlsZS5ESVNQTEFZLnNpemUgJiYgZ3JvdXAuc3ltYm9sICYmICF1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAubmFtZSkpIHtcbiAgICAvLyBNb3N0IHN5bWJvbCBvcGVyYXRvcnMgZ2V0IGxhcmdlciBpbiBkaXNwbGF5c3R5bGUgKHJ1bGUgMTMpXG4gICAgbGFyZ2UgPSB0cnVlO1xuICB9XG5cbiAgbGV0IGJhc2U7XG5cbiAgaWYgKGdyb3VwLnN5bWJvbCkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBzeW1ib2wsIGNyZWF0ZSB0aGUgc3ltYm9sLlxuICAgIGNvbnN0IGZvbnROYW1lID0gbGFyZ2UgPyBcIlNpemUyLVJlZ3VsYXJcIiA6IFwiU2l6ZTEtUmVndWxhclwiO1xuICAgIGxldCBzdGFzaCA9IFwiXCI7XG5cbiAgICBpZiAoZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpbnRcIiB8fCBncm91cC5uYW1lID09PSBcIlxcXFxvaWlpbnRcIikge1xuICAgICAgLy8gTm8gZm9udCBnbHlwaHMgeWV0LCBzbyB1c2UgYSBnbHlwaCB3L28gdGhlIG92YWwuXG4gICAgICAvLyBUT0RPOiBXaGVuIGZvbnQgZ2x5cGhzIGFyZSBhdmFpbGFibGUsIGRlbGV0ZSB0aGlzIGNvZGUuXG4gICAgICBzdGFzaCA9IGdyb3VwLm5hbWUuc2xpY2UoMSk7XG4gICAgICBncm91cC5uYW1lID0gc3Rhc2ggPT09IFwib2lpbnRcIiA/IFwiXFxcXGlpbnRcIiA6IFwiXFxcXGlpaW50XCI7XG4gICAgfVxuXG4gICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woZ3JvdXAubmFtZSwgZm9udE5hbWUsIFwibWF0aFwiLCBvcHRpb25zLCBbXCJtb3BcIiwgXCJvcC1zeW1ib2xcIiwgbGFyZ2UgPyBcImxhcmdlLW9wXCIgOiBcInNtYWxsLW9wXCJdKTtcblxuICAgIGlmIChzdGFzaC5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBXZSdyZSBpbiBcXG9paW50IG9yIFxcb2lpaW50LiBPdmVybGF5IHRoZSBvdmFsLlxuICAgICAgLy8gVE9ETzogV2hlbiBmb250IGdseXBocyBhcmUgYXZhaWxhYmxlLCBkZWxldGUgdGhpcyBjb2RlLlxuICAgICAgY29uc3QgaXRhbGljID0gYmFzZS5pdGFsaWM7XG4gICAgICBjb25zdCBvdmFsID0gYnVpbGRDb21tb24uc3RhdGljU3ZnKHN0YXNoICsgXCJTaXplXCIgKyAobGFyZ2UgPyBcIjJcIiA6IFwiMVwiKSwgb3B0aW9ucyk7XG4gICAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBiYXNlLFxuICAgICAgICAgIHNoaWZ0OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBvdmFsLFxuICAgICAgICAgIHNoaWZ0OiBsYXJnZSA/IDAuMDggOiAwXG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIGdyb3VwLm5hbWUgPSBcIlxcXFxcIiArIHN0YXNoO1xuICAgICAgYmFzZS5jbGFzc2VzLnVuc2hpZnQoXCJtb3BcIik7IC8vICRGbG93Rml4TWVcblxuICAgICAgYmFzZS5pdGFsaWMgPSBpdGFsaWM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLmJvZHkpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgbGlzdCwgY29tcG9zZSB0aGF0IGxpc3QuXG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICBpZiAoaW5uZXIubGVuZ3RoID09PSAxICYmIGlubmVyWzBdIGluc3RhbmNlb2YgU3ltYm9sTm9kZSkge1xuICAgICAgYmFzZSA9IGlubmVyWzBdO1xuICAgICAgYmFzZS5jbGFzc2VzWzBdID0gXCJtb3BcIjsgLy8gcmVwbGFjZSBvbGQgbWNsYXNzXG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQnVpbGQgdGhlIHRleHQgZnJvbSB0aGVcbiAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGdyb3VwLm5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dC5wdXNoKGJ1aWxkQ29tbW9uLm1hdGhzeW0oZ3JvdXAubmFtZVtpXSwgZ3JvdXAubW9kZSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIG91dHB1dCwgb3B0aW9ucyk7XG4gIH0gLy8gSWYgY29udGVudCBvZiBvcCBpcyBhIHNpbmdsZSBzeW1ib2wsIHNoaWZ0IGl0IHZlcnRpY2FsbHkuXG5cblxuICBsZXQgYmFzZVNoaWZ0ID0gMDtcbiAgbGV0IHNsYW50ID0gMDtcblxuICBpZiAoKGJhc2UgaW5zdGFuY2VvZiBTeW1ib2xOb2RlIHx8IGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paW50XCIgfHwgZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpaW50XCIpICYmICFncm91cC5zdXBwcmVzc0Jhc2VTaGlmdCkge1xuICAgIC8vIFdlIHN1cHByZXNzIHRoZSBzaGlmdCBvZiB0aGUgYmFzZSBvZiBcXG92ZXJzZXQgYW5kIFxcdW5kZXJzZXQuIE90aGVyd2lzZSxcbiAgICAvLyBzaGlmdCB0aGUgc3ltYm9sIHNvIGl0cyBjZW50ZXIgbGllcyBvbiB0aGUgYXhpcyAocnVsZSAxMykuIEl0XG4gICAgLy8gYXBwZWFycyB0aGF0IG91ciBmb250cyBoYXZlIHRoZSBjZW50ZXJzIG9mIHRoZSBzeW1ib2xzIGFscmVhZHlcbiAgICAvLyBhbG1vc3Qgb24gdGhlIGF4aXMsIHNvIHRoZXNlIG51bWJlcnMgYXJlIHZlcnkgc21hbGwuIE5vdGUgd2VcbiAgICAvLyBkb24ndCBhY3R1YWxseSBhcHBseSB0aGlzIGhlcmUsIGJ1dCBpbnN0ZWFkIGl0IGlzIHVzZWQgZWl0aGVyIGluXG4gICAgLy8gdGhlIHZsaXN0IGNyZWF0aW9uIG9yIHNlcGFyYXRlbHkgd2hlbiB0aGVyZSBhcmUgbm8gbGltaXRzLlxuICAgIGJhc2VTaGlmdCA9IChiYXNlLmhlaWdodCAtIGJhc2UuZGVwdGgpIC8gMiAtIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0OyAvLyBUaGUgc2xhbnQgb2YgdGhlIHN5bWJvbCBpcyBqdXN0IGl0cyBpdGFsaWMgY29ycmVjdGlvbi5cbiAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICBzbGFudCA9IGJhc2UuaXRhbGljO1xuICB9XG5cbiAgaWYgKGhhc0xpbWl0cykge1xuICAgIHJldHVybiBhc3NlbWJsZVN1cFN1YihiYXNlLCBzdXBHcm91cCwgc3ViR3JvdXAsIG9wdGlvbnMsIHN0eWxlLCBzbGFudCwgYmFzZVNoaWZ0KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYmFzZVNoaWZ0KSB7XG4gICAgICBiYXNlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgYmFzZS5zdHlsZS50b3AgPSBtYWtlRW0oYmFzZVNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufTtcblxuY29uc3Qgb3BfbWF0aG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICBsZXQgbm9kZTtcblxuICBpZiAoZ3JvdXAuc3ltYm9sKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN5bWJvbC4gSnVzdCBhZGQgdGhlIHN5bWJvbC5cbiAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLm5hbWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICBpZiAodXRpbHMuY29udGFpbnMobm9TdWNjZXNzb3IsIGdyb3VwLm5hbWUpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxhcmdlb3BcIiwgXCJmYWxzZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAuYm9keSkge1xuICAgIC8vIFRoaXMgaXMgYW4gb3BlcmF0b3Igd2l0aCBjaGlsZHJlbi4gQWRkIHRoZW0uXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHRleHQgb3BlcmF0b3IuIEFkZCBhbGwgb2YgdGhlIGNoYXJhY3RlcnMgZnJvbSB0aGVcbiAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1pXCIsIFtuZXcgVGV4dE5vZGUoZ3JvdXAubmFtZS5zbGljZSgxKSldKTsgLy8gQXBwZW5kIGFuIDxtbz4mQXBwbHlGdW5jdGlvbjs8L21vPi5cbiAgICAvLyByZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMtTWF0aE1ML2NoYXAzXzIuaHRtbCNzZWMzLjIuNFxuXG4gICAgY29uc3Qgb3BlcmF0b3IgPSBuZXcgTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuXG4gICAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibXJvd1wiLCBbbm9kZSwgb3BlcmF0b3JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ld0RvY3VtZW50RnJhZ21lbnQoW25vZGUsIG9wZXJhdG9yXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBzaW5nbGVDaGFyQmlnT3BzID0ge1xuICBcIlxcdTIyMEZcIjogXCJcXFxccHJvZFwiLFxuICBcIlxcdTIyMTBcIjogXCJcXFxcY29wcm9kXCIsXG4gIFwiXFx1MjIxMVwiOiBcIlxcXFxzdW1cIixcbiAgXCJcXHUyMmMwXCI6IFwiXFxcXGJpZ3dlZGdlXCIsXG4gIFwiXFx1MjJjMVwiOiBcIlxcXFxiaWd2ZWVcIixcbiAgXCJcXHUyMmMyXCI6IFwiXFxcXGJpZ2NhcFwiLFxuICBcIlxcdTIyYzNcIjogXCJcXFxcYmlnY3VwXCIsXG4gIFwiXFx1MmEwMFwiOiBcIlxcXFxiaWdvZG90XCIsXG4gIFwiXFx1MmEwMVwiOiBcIlxcXFxiaWdvcGx1c1wiLFxuICBcIlxcdTJhMDJcIjogXCJcXFxcYmlnb3RpbWVzXCIsXG4gIFwiXFx1MmEwNFwiOiBcIlxcXFxiaWd1cGx1c1wiLFxuICBcIlxcdTJhMDZcIjogXCJcXFxcYmlnc3FjdXBcIlxufTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGNvcHJvZFwiLCBcIlxcXFxiaWd2ZWVcIiwgXCJcXFxcYmlnd2VkZ2VcIiwgXCJcXFxcYmlndXBsdXNcIiwgXCJcXFxcYmlnY2FwXCIsIFwiXFxcXGJpZ2N1cFwiLCBcIlxcXFxpbnRvcFwiLCBcIlxcXFxwcm9kXCIsIFwiXFxcXHN1bVwiLCBcIlxcXFxiaWdvdGltZXNcIiwgXCJcXFxcYmlnb3BsdXNcIiwgXCJcXFxcYmlnb2RvdFwiLCBcIlxcXFxiaWdzcWN1cFwiLCBcIlxcXFxzbWFsbGludFwiLCBcIlxcdTIyMEZcIiwgXCJcXHUyMjEwXCIsIFwiXFx1MjIxMVwiLCBcIlxcdTIyYzBcIiwgXCJcXHUyMmMxXCIsIFwiXFx1MjJjMlwiLCBcIlxcdTIyYzNcIiwgXCJcXHUyYTAwXCIsIFwiXFx1MmEwMVwiLCBcIlxcdTJhMDJcIiwgXCJcXHUyYTA0XCIsIFwiXFx1MmEwNlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgbGV0IGZOYW1lID0gZnVuY05hbWU7XG5cbiAgICBpZiAoZk5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBmTmFtZSA9IHNpbmdsZUNoYXJCaWdPcHNbZk5hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgIG5hbWU6IGZOYW1lXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IG9wX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcF9tYXRobWxCdWlsZGVyXG59KTsgLy8gTm90ZTogY2FsbGluZyBkZWZpbmVGdW5jdGlvbiB3aXRoIGEgdHlwZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGRlZmluZWQgb25seVxuLy8gd29ya3MgYmVjYXVzZSB0aGUgc2FtZSBodG1sQnVpbGRlciBhbmQgbWF0aG1sQnVpbGRlciBhcmUgYmVpbmcgdXNlZC5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aG9wXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBvcF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BfbWF0aG1sQnVpbGRlclxufSk7IC8vIFRoZXJlIGFyZSAyIGZsYWdzIGZvciBvcGVyYXRvcnM7IHdoZXRoZXIgdGhleSBwcm9kdWNlIGxpbWl0cyBpblxuLy8gZGlzcGxheXN0eWxlLCBhbmQgd2hldGhlciB0aGV5IGFyZSBzeW1ib2xzIGFuZCBzaG91bGQgZ3JvdyBpblxuLy8gZGlzcGxheXN0eWxlLiBUaGVzZSBmb3VyIGdyb3VwcyBjb3ZlciB0aGUgZm91ciBwb3NzaWJsZSBjaG9pY2VzLlxuXG5jb25zdCBzaW5nbGVDaGFySW50ZWdyYWxzID0ge1xuICBcIlxcdTIyMmJcIjogXCJcXFxcaW50XCIsXG4gIFwiXFx1MjIyY1wiOiBcIlxcXFxpaW50XCIsXG4gIFwiXFx1MjIyZFwiOiBcIlxcXFxpaWludFwiLFxuICBcIlxcdTIyMmVcIjogXCJcXFxcb2ludFwiLFxuICBcIlxcdTIyMmZcIjogXCJcXFxcb2lpbnRcIixcbiAgXCJcXHUyMjMwXCI6IFwiXFxcXG9paWludFwiXG59OyAvLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGFyY3NpblwiLCBcIlxcXFxhcmNjb3NcIiwgXCJcXFxcYXJjdGFuXCIsIFwiXFxcXGFyY3RnXCIsIFwiXFxcXGFyY2N0Z1wiLCBcIlxcXFxhcmdcIiwgXCJcXFxcY2hcIiwgXCJcXFxcY29zXCIsIFwiXFxcXGNvc2VjXCIsIFwiXFxcXGNvc2hcIiwgXCJcXFxcY290XCIsIFwiXFxcXGNvdGdcIiwgXCJcXFxcY290aFwiLCBcIlxcXFxjc2NcIiwgXCJcXFxcY3RnXCIsIFwiXFxcXGN0aFwiLCBcIlxcXFxkZWdcIiwgXCJcXFxcZGltXCIsIFwiXFxcXGV4cFwiLCBcIlxcXFxob21cIiwgXCJcXFxca2VyXCIsIFwiXFxcXGxnXCIsIFwiXFxcXGxuXCIsIFwiXFxcXGxvZ1wiLCBcIlxcXFxzZWNcIiwgXCJcXFxcc2luXCIsIFwiXFxcXHNpbmhcIiwgXCJcXFxcc2hcIiwgXCJcXFxcdGFuXCIsIFwiXFxcXHRhbmhcIiwgXCJcXFxcdGdcIiwgXCJcXFxcdGhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjMpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBuYW1lOiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IG9wX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcF9tYXRobWxCdWlsZGVyXG59KTsgLy8gTGltaXRzLCBub3Qgc3ltYm9sc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxkZXRcIiwgXCJcXFxcZ2NkXCIsIFwiXFxcXGluZlwiLCBcIlxcXFxsaW1cIiwgXCJcXFxcbWF4XCIsIFwiXFxcXG1pblwiLCBcIlxcXFxQclwiLCBcIlxcXFxzdXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjQpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogb3BfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG9wX21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBObyBsaW1pdHMsIHN5bWJvbHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcaW50XCIsIFwiXFxcXGlpbnRcIiwgXCJcXFxcaWlpbnRcIiwgXCJcXFxcb2ludFwiLCBcIlxcXFxvaWludFwiLCBcIlxcXFxvaWlpbnRcIiwgXCJcXHUyMjJiXCIsIFwiXFx1MjIyY1wiLCBcIlxcdTIyMmRcIiwgXCJcXHUyMjJlXCIsIFwiXFx1MjIyZlwiLCBcIlxcdTIyMzBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjUpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjU7XG4gICAgbGV0IGZOYW1lID0gZnVuY05hbWU7XG5cbiAgICBpZiAoZk5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBmTmFtZSA9IHNpbmdsZUNoYXJJbnRlZ3JhbHNbZk5hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IHRydWUsXG4gICAgICBuYW1lOiBmTmFtZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IG9wX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcF9tYXRobWxCdWlsZGVyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvb3BlcmF0b3JuYW1lLmpzXG5cblxuXG5cblxuXG5cblxuXG4vLyBOT1RFOiBVbmxpa2UgbW9zdCBgaHRtbEJ1aWxkZXJgcywgdGhpcyBvbmUgaGFuZGxlcyBub3Qgb25seVxuLy8gXCJvcGVyYXRvcm5hbWVcIiwgYnV0IGFsc28gIFwic3Vwc3ViXCIgc2luY2UgXFxvcGVyYXRvcm5hbWUqIGNhblxuLy8gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cbmNvbnN0IG9wZXJhdG9ybmFtZV9odG1sQnVpbGRlciA9IChncnAsIG9wdGlvbnMpID0+IHtcbiAgLy8gT3BlcmF0b3JzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMtNDQ0LCBydWxlIDEzKGEpLlxuICBsZXQgc3VwR3JvdXA7XG4gIGxldCBzdWJHcm91cDtcbiAgbGV0IGhhc0xpbWl0cyA9IGZhbHNlO1xuICBsZXQgZ3JvdXA7XG5cbiAgaWYgKGdycC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBsaW1pdHMsIHN1cHN1YiB3aWxsIHBhc3MgdXMgaXRzIGdyb3VwIHRvIGhhbmRsZS4gUHVsbFxuICAgIC8vIG91dCB0aGUgc3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdCBhbmQgc2V0IHRoZSBncm91cCB0byB0aGUgb3AgaW5cbiAgICAvLyBpdHMgYmFzZS5cbiAgICBzdXBHcm91cCA9IGdycC5zdXA7XG4gICAgc3ViR3JvdXAgPSBncnAuc3ViO1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLmJhc2UsIFwib3BlcmF0b3JuYW1lXCIpO1xuICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwib3BlcmF0b3JuYW1lXCIpO1xuICB9XG5cbiAgbGV0IGJhc2U7XG5cbiAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGJvZHkgPSBncm91cC5ib2R5Lm1hcChjaGlsZCA9PiB7XG4gICAgICAvLyAkRmxvd0ZpeE1lOiBDaGVjayBpZiB0aGUgbm9kZSBoYXMgYSBzdHJpbmcgYHRleHRgIHByb3BlcnR5LlxuICAgICAgY29uc3QgY2hpbGRUZXh0ID0gY2hpbGQudGV4dDtcblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZFRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICBtb2RlOiBjaGlsZC5tb2RlLFxuICAgICAgICAgIHRleHQ6IGNoaWxkVGV4dFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgIH0pOyAvLyBDb25zb2xpZGF0ZSBmdW5jdGlvbiBuYW1lcyBpbnRvIHN5bWJvbCBjaGFyYWN0ZXJzLlxuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbihib2R5LCBvcHRpb25zLndpdGhGb250KFwibWF0aHJtXCIpLCB0cnVlKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBleHByZXNzaW9uW2ldO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBTeW1ib2xOb2RlKSB7XG4gICAgICAgIC8vIFBlciBhbXNvcG4gcGFja2FnZSxcbiAgICAgICAgLy8gY2hhbmdlIG1pbnVzIHRvIGh5cGhlbiBhbmQgXFxhc3QgdG8gYXN0ZXJpc2tcbiAgICAgICAgY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXFx1MjIxMi8sIFwiLVwiKS5yZXBsYWNlKC9cXHUyMjE3LywgXCIqXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIGV4cHJlc3Npb24sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIFtdLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChoYXNMaW1pdHMpIHtcbiAgICByZXR1cm4gYXNzZW1ibGVTdXBTdWIoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBvcHRpb25zLnN0eWxlLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufTtcblxuY29uc3Qgb3BlcmF0b3JuYW1lX21hdGhtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgLy8gVGhlIHN0ZXBzIHRha2VuIGhlcmUgYXJlIHNpbWlsYXIgdG8gdGhlIGh0bWwgdmVyc2lvbi5cbiAgbGV0IGV4cHJlc3Npb24gPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoRm9udChcIm1hdGhybVwiKSk7IC8vIElzIGV4cHJlc3Npb24gYSBzdHJpbmcgb3IgaGFzIGl0IHNvbWV0aGluZyBsaWtlIGEgZnJhY3Rpb24/XG5cbiAgbGV0IGlzQWxsU3RyaW5nID0gdHJ1ZTsgLy8gZGVmYXVsdFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBleHByZXNzaW9uW2ldO1xuXG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLlNwYWNlTm9kZSkgey8vIERvIG5vdGhpbmdcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLk1hdGhOb2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwibWlcIjpcbiAgICAgICAgY2FzZSBcIm1uXCI6XG4gICAgICAgIGNhc2UgXCJtc1wiOlxuICAgICAgICBjYXNlIFwibXNwYWNlXCI6XG4gICAgICAgIGNhc2UgXCJtdGV4dFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBEbyBub3RoaW5nIHlldC5cblxuICAgICAgICBjYXNlIFwibW9cIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZCBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXFx1MjIxMi8sIFwiLVwiKS5yZXBsYWNlKC9cXHUyMjE3LywgXCIqXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNBbGxTdHJpbmcpIHtcbiAgICAvLyBXcml0ZSBhIHNpbmdsZSBUZXh0Tm9kZSBpbnN0ZWFkIG9mIG11bHRpcGxlIG5lc3RlZCB0YWdzLlxuICAgIGNvbnN0IHdvcmQgPSBleHByZXNzaW9uLm1hcChub2RlID0+IG5vZGUudG9UZXh0KCkpLmpvaW4oXCJcIik7XG4gICAgZXhwcmVzc2lvbiA9IFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh3b3JkKV07XG4gIH1cblxuICBjb25zdCBpZGVudGlmaWVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBleHByZXNzaW9uKTtcbiAgaWRlbnRpZmllci5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm5vcm1hbFwiKTsgLy8gXFx1MjA2MSBpcyB0aGUgc2FtZSBhcyAmQXBwbHlGdW5jdGlvbjtcbiAgLy8gcmVmOiBodHRwczovL3d3dy53M3NjaG9vbHMuY29tL2NoYXJzZXRzL3JlZl9odG1sX2VudGl0aWVzX2EuYXNwXG5cbiAgY29uc3Qgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG5cbiAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbaWRlbnRpZmllciwgb3BlcmF0b3JdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KFtpZGVudGlmaWVyLCBvcGVyYXRvcl0pO1xuICB9XG59OyAvLyBcXG9wZXJhdG9ybmFtZVxuLy8gYW1zb3BuLmR0eDogXFxtYXRob3B7IzFcXGtlcm5cXHpAXFxvcGVyYXRvckBmb250IzN9XFxuZXdtY29kZXNAXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wZXJhdG9ybmFtZVwiLFxuICBuYW1lczogW1wiXFxcXG9wZXJhdG9ybmFtZUBcIiwgXCJcXFxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BlcmF0b3JuYW1lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgYWx3YXlzSGFuZGxlU3VwU3ViOiBmdW5jTmFtZSA9PT0gXCJcXFxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1wiLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBvcGVyYXRvcm5hbWVfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG9wZXJhdG9ybmFtZV9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXG9wZXJhdG9ybmFtZVwiLCBcIlxcXFxAaWZzdGFyXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcXFxcb3BlcmF0b3JuYW1lQFwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvb3JkZ3JvdXAuanNcblxuXG5cblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwib3JkZ3JvdXBcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChncm91cC5zZW1pc2ltcGxlKSB7XG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSksIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9vdmVybGluZS5qc1xuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvdmVybGluZVwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3ZlcmxpbmVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBPdmVybGluZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcgNDQzLCBSdWxlIDkuXG4gICAgLy8gQnVpbGQgdGhlIGlubmVyIGdyb3VwIGluIHRoZSBjcmFtcGVkIHN0eWxlLlxuICAgIGNvbnN0IGlubmVyR3JvdXAgPSBidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpOyAvLyBDcmVhdGUgdGhlIGxpbmUgYWJvdmUgdGhlIGJvZHlcblxuICAgIGNvbnN0IGxpbmUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJvdmVybGluZS1saW5lXCIsIG9wdGlvbnMpOyAvLyBHZW5lcmF0ZSB0aGUgdmxpc3QsIHdpdGggdGhlIGFwcHJvcHJpYXRlIGtlcm5zXG5cbiAgICBjb25zdCBkZWZhdWx0UnVsZVRoaWNrbmVzcyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgICBjb25zdCB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAzICogZGVmYXVsdFJ1bGVUaGlja25lc3NcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGxpbmVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwib3ZlcmxpbmVcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzZVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSwgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3BoYW50b20uanNcblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXHBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInBoYW50b21cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpLCBmYWxzZSk7IC8vIFxccGhhbnRvbSBpc24ndCBzdXBwb3NlZCB0byBhZmZlY3QgdGhlIGVsZW1lbnRzIGl0IGNvbnRhaW5zLlxuICAgIC8vIFNlZSBcImNvbG9yXCIgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhwaGFudG9tXCIsXG4gIG5hbWVzOiBbXCJcXFxcaHBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHBoYW50b21cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBsZXQgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zLndpdGhQaGFudG9tKCkpXSk7XG4gICAgbm9kZS5oZWlnaHQgPSAwO1xuICAgIG5vZGUuZGVwdGggPSAwO1xuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmhlaWdodCA9IDA7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5baV0uZGVwdGggPSAwO1xuICAgICAgfVxuICAgIH0gLy8gU2VlIHNtYXNoIGZvciBjb21tZW50IHJlOiB1c2Ugb2YgbWFrZVZMaXN0XG5cblxuICAgIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbm9kZVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gRm9yIHNwYWNpbmcsIFRlWCB0cmVhdHMgXFxzbWFzaCBhcyBhIG1hdGggZ3JvdXAgKHNhbWUgc3BhY2luZyBhcyBvcmQpLlxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFtub2RlXSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKG9yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBvcHRpb25zKTtcbiAgICBjb25zdCBwaGFudG9tID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcGhhbnRvbV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMHB4XCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInZwaGFudG9tXCIsXG4gIG5hbWVzOiBbXCJcXFxcdnBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMywgYXJncykgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjM7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidnBoYW50b21cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImlubmVyXCJdLCBbYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zLndpdGhQaGFudG9tKCkpXSk7XG4gICAgY29uc3QgZml4ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZml4XCJdLCBbXSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJybGFwXCJdLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgb3B0aW9ucyk7XG4gICAgY29uc3QgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3BoYW50b21dKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvcmFpc2Vib3guanNcblxuXG5cblxuXG5cbiAvLyBCb3ggbWFuaXB1bGF0aW9uXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJyYWlzZWJveFwiLFxuICBuYW1lczogW1wiXFxcXHJhaXNlYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIiwgXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgYW1vdW50ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJhaXNlYm94XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGR5OiBhbW91bnQsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJvZHkgPSBidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICAgIGNvbnN0IGR5ID0gY2FsY3VsYXRlU2l6ZShncm91cC5keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgIHBvc2l0aW9uRGF0YTogLWR5LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBib2R5XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgY29uc3QgZHkgPSBncm91cC5keS5udW1iZXIgKyBncm91cC5keS51bml0O1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBkeSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3JlbGF4LmpzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXHJlbGF4XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGVcbiAgICB9O1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9ydWxlLmpzXG5cblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJ1bGVcIixcbiAgbmFtZXM6IFtcIlxcXFxydWxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IHNoaWZ0ID0gb3B0QXJnc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKTtcbiAgICBjb25zdCBoZWlnaHQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcInNpemVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzaGlmdDogc2hpZnQgJiYgYXNzZXJ0Tm9kZVR5cGUoc2hpZnQsIFwic2l6ZVwiKS52YWx1ZSxcbiAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgIGhlaWdodDogaGVpZ2h0LnZhbHVlXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIE1ha2UgYW4gZW1wdHkgc3BhbiBmb3IgdGhlIHJ1bGVcbiAgICBjb25zdCBydWxlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIHRoZSBzaGlmdCwgd2lkdGgsIGFuZCBoZWlnaHQgb2YgdGhlIHJ1bGUsIGFuZCBhY2NvdW50IGZvciB1bml0c1xuXG4gICAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc2hpZnQgPSBncm91cC5zaGlmdCA/IGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2hpZnQsIG9wdGlvbnMpIDogMDsgLy8gU3R5bGUgdGhlIHJ1bGUgdG8gdGhlIHJpZ2h0IHNpemVcblxuICAgIHJ1bGUuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IG1ha2VFbSh3aWR0aCk7XG4gICAgcnVsZS5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IG1ha2VFbShoZWlnaHQpO1xuICAgIHJ1bGUuc3R5bGUuYm90dG9tID0gbWFrZUVtKHNoaWZ0KTsgLy8gUmVjb3JkIHRoZSBoZWlnaHQgYW5kIHdpZHRoXG5cbiAgICBydWxlLndpZHRoID0gd2lkdGg7XG4gICAgcnVsZS5oZWlnaHQgPSBoZWlnaHQgKyBzaGlmdDtcbiAgICBydWxlLmRlcHRoID0gLXNoaWZ0OyAvLyBGb250IHNpemUgaXMgdGhlIG51bWJlciBsYXJnZSBlbm91Z2ggdGhhdCB0aGUgYnJvd3NlciB3aWxsXG4gICAgLy8gcmVzZXJ2ZSBhdCBsZWFzdCBgYWJzSGVpZ2h0YCBzcGFjZSBhYm92ZSB0aGUgYmFzZWxpbmUuXG4gICAgLy8gVGhlIDEuMTI1IGZhY3RvciB3YXMgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxuXG4gICAgcnVsZS5tYXhGb250U2l6ZSA9IGhlaWdodCAqIDEuMTI1ICogb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICByZXR1cm4gcnVsZTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc2hpZnQgPSBncm91cC5zaGlmdCA/IGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2hpZnQsIG9wdGlvbnMpIDogMDtcbiAgICBjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3IgJiYgb3B0aW9ucy5nZXRDb2xvcigpIHx8IFwiYmxhY2tcIjtcbiAgICBjb25zdCBydWxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJtYXRoYmFja2dyb3VuZFwiLCBjb2xvcik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBtYWtlRW0od2lkdGgpKTtcbiAgICBydWxlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oaGVpZ2h0KSk7XG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcnVsZV0pO1xuXG4gICAgaWYgKHNoaWZ0ID49IDApIHtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIG1ha2VFbShzaGlmdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oc2hpZnQpKTtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgbWFrZUVtKC1zaGlmdCkpO1xuICAgIH1cblxuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBtYWtlRW0oc2hpZnQpKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc2l6aW5nLmpzXG5cblxuXG5cblxuXG5mdW5jdGlvbiBzaXppbmdHcm91cCh2YWx1ZSwgb3B0aW9ucywgYmFzZU9wdGlvbnMpIHtcbiAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24odmFsdWUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgY29uc3QgbXVsdGlwbGllciA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBiYXNlT3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gQWRkIHNpemUtcmVzZXR0aW5nIGNsYXNzZXMgdG8gdGhlIGlubmVyIGxpc3QgYW5kIHNldCBtYXhGb250U2l6ZVxuICAvLyBtYW51YWxseS4gSGFuZGxlIG5lc3RlZCBzaXplIGNoYW5nZXMuXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9IGlubmVyW2ldLmNsYXNzZXMuaW5kZXhPZihcInNpemluZ1wiKTtcblxuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbm5lcltpXS5jbGFzc2VzLCBvcHRpb25zLnNpemluZ0NsYXNzZXMoYmFzZU9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGlubmVyW2ldLmNsYXNzZXNbcG9zICsgMV0gPT09IFwicmVzZXQtc2l6ZVwiICsgb3B0aW9ucy5zaXplKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgbmVzdGVkIHNpemUgY2hhbmdlOiBlLmcuLCBpbm5lcltpXSBpcyB0aGUgXCJiXCIgaW5cbiAgICAgIC8vIGBcXEh1Z2UgYSBcXHNtYWxsIGJgLiBPdmVycmlkZSB0aGUgb2xkIHNpemUgKHRoZSBgcmVzZXQtYCBjbGFzcylcbiAgICAgIC8vIGJ1dCBub3QgdGhlIG5ldyBzaXplLlxuICAgICAgaW5uZXJbaV0uY2xhc3Nlc1twb3MgKyAxXSA9IFwicmVzZXQtc2l6ZVwiICsgYmFzZU9wdGlvbnMuc2l6ZTtcbiAgICB9XG5cbiAgICBpbm5lcltpXS5oZWlnaHQgKj0gbXVsdGlwbGllcjtcbiAgICBpbm5lcltpXS5kZXB0aCAqPSBtdWx0aXBsaWVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChpbm5lcik7XG59XG5jb25zdCBzaXplRnVuY3MgPSBbXCJcXFxcdGlueVwiLCBcIlxcXFxzaXhwdHNpemVcIiwgXCJcXFxcc2NyaXB0c2l6ZVwiLCBcIlxcXFxmb290bm90ZXNpemVcIiwgXCJcXFxcc21hbGxcIiwgXCJcXFxcbm9ybWFsc2l6ZVwiLCBcIlxcXFxsYXJnZVwiLCBcIlxcXFxMYXJnZVwiLCBcIlxcXFxMQVJHRVwiLCBcIlxcXFxodWdlXCIsIFwiXFxcXEh1Z2VcIl07XG5jb25zdCBzaXppbmdfaHRtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgLy8gSGFuZGxlIHNpemluZyBvcGVyYXRvcnMgbGlrZSBcXEh1Z2UuIFJlYWwgVGVYIGRvZXNuJ3QgYWN0dWFsbHkgYWxsb3dcbiAgLy8gdGhlc2UgZnVuY3Rpb25zIGluc2lkZSBvZiBtYXRoIGV4cHJlc3Npb25zLCBzbyB3ZSBkbyBzb21lIHNwZWNpYWxcbiAgLy8gaGFuZGxpbmcuXG4gIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1NpemUoZ3JvdXAuc2l6ZSk7XG4gIHJldHVybiBzaXppbmdHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zLCBvcHRpb25zKTtcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic2l6aW5nXCIsXG4gIG5hbWVzOiBzaXplRnVuY3MsXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGJyZWFrT25Ub2tlblRleHQsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBicmVha09uVG9rZW5UZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaXppbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgLy8gRmlndXJlIG91dCB3aGF0IHNpemUgdG8gdXNlIGJhc2VkIG9uIHRoZSBsaXN0IG9mIGZ1bmN0aW9ucyBhYm92ZVxuICAgICAgc2l6ZTogc2l6ZUZ1bmNzLmluZGV4T2YoZnVuY05hbWUpICsgMSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogc2l6aW5nX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKGdyb3VwLnNpemUpO1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7IC8vIFRPRE8oZW1pbHkpOiBUaGlzIGRvZXNuJ3QgcHJvZHVjZSB0aGUgY29ycmVjdCBzaXplIGZvciBuZXN0ZWQgc2l6ZVxuICAgIC8vIGNoYW5nZXMsIGJlY2F1c2Ugd2UgZG9uJ3Qga2VlcCBzdGF0ZSBvZiB3aGF0IHN0eWxlIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIGluLCBzbyB3ZSBjYW4ndCByZXNldCB0aGUgc2l6ZSB0byBub3JtYWwgYmVmb3JlIGNoYW5naW5nIGl0LiAgTm93XG4gICAgLy8gdGhhdCB3ZSdyZSBwYXNzaW5nIGFuIG9wdGlvbnMgcGFyYW1ldGVyIHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpeFxuICAgIC8vIHRoaXMuXG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIG1ha2VFbShuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyKSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zbWFzaC5qc1xuLy8gc21hc2gsIHdpdGggb3B0aW9uYWwgW3RiXSwgYXMgaW4gQU1TXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic21hc2hcIixcbiAgbmFtZXM6IFtcIlxcXFxzbWFzaFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzLCBvcHRBcmdzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIGxldCBzbWFzaEhlaWdodCA9IGZhbHNlO1xuICAgIGxldCBzbWFzaERlcHRoID0gZmFsc2U7XG4gICAgY29uc3QgdGJBcmcgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG5cbiAgICBpZiAodGJBcmcpIHtcbiAgICAgIC8vIE9wdGlvbmFsIFt0Yl0gYXJndW1lbnQgaXMgZW5nYWdlZC5cbiAgICAgIC8vIHJlZjogYW1zbWF0aDogXFxyZW5ld2NvbW1hbmR7XFxzbWFzaH1bMV1bdGJdeyVcbiAgICAgIC8vICAgICAgICAgICAgICAgZGVmXFxtYkB0e1xcaHR9XFxkZWZcXG1iQGJ7XFxkcH1cXGRlZlxcbWJAdGJ7XFxodFxcekBcXHpAXFxkcH0lXG4gICAgICBsZXQgbGV0dGVyID0gXCJcIjtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YkFyZy5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0YkFyZy5ib2R5W2ldOyAvLyAkRmxvd0ZpeE1lOiBOb3QgZXZlcnkgbm9kZSB0eXBlIGhhcyBhIGB0ZXh0YCBwcm9wZXJ0eS5cblxuICAgICAgICBsZXR0ZXIgPSBub2RlLnRleHQ7XG5cbiAgICAgICAgaWYgKGxldHRlciA9PT0gXCJ0XCIpIHtcbiAgICAgICAgICBzbWFzaEhlaWdodCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcImJcIikge1xuICAgICAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNtYXNoXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBzbWFzaEhlaWdodCxcbiAgICAgIHNtYXNoRGVwdGhcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKCFncm91cC5zbWFzaEhlaWdodCAmJiAhZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7XG4gICAgICBub2RlLmhlaWdodCA9IDA7IC8vIEluIG9yZGVyIHRvIGluZmx1ZW5jZSBtYWtlVkxpc3QsIHdlIGhhdmUgdG8gcmVzZXQgdGhlIGNoaWxkcmVuLlxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgbm9kZS5kZXB0aCA9IDA7XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW5baV0uZGVwdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBBdCB0aGlzIHBvaW50LCB3ZSd2ZSByZXNldCB0aGUgVGVYLWxpa2UgaGVpZ2h0IGFuZCBkZXB0aCB2YWx1ZXMuXG4gICAgLy8gQnV0IHRoZSBzcGFuIHN0aWxsIGhhcyBhbiBIVE1MIGxpbmUgaGVpZ2h0LlxuICAgIC8vIG1ha2VWTGlzdCBhcHBsaWVzIFwiZGlzcGxheTogdGFibGUtY2VsbFwiLCB3aGljaCBwcmV2ZW50cyB0aGUgYnJvd3NlclxuICAgIC8vIGZyb20gYWN0aW5nIG9uIHRoYXQgbGluZSBoZWlnaHQuIFNvIHdlJ2xsIGNhbGwgbWFrZVZMaXN0IG5vdy5cblxuXG4gICAgY29uc3Qgc21hc2hlZE5vZGUgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbm9kZVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gRm9yIHNwYWNpbmcsIFRlWCB0cmVhdHMgXFxocGhhbnRvbSBhcyBhIG1hdGggZ3JvdXAgKHNhbWUgc3BhY2luZyBhcyBvcmQpLlxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFtzbWFzaGVkTm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hIZWlnaHQpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zbWFzaERlcHRoKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc3FydC5qc1xuXG5cblxuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzcXJ0XCIsXG4gIG5hbWVzOiBbXCJcXFxcc3FydFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIGxldCB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBpbmRleCA9IG9wdEFyZ3NbMF07XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3FydFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgaW5kZXhcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3F1YXJlIHJvb3RzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIFJ1bGUgMTEuXG4gICAgLy8gRmlyc3QsIHdlIGRvIHRoZSBzYW1lIHN0ZXBzIGFzIGluIG92ZXJsaW5lIHRvIGJ1aWxkIHRoZSBpbm5lciBncm91cFxuICAgIC8vIGFuZCBsaW5lXG4gICAgbGV0IGlubmVyID0gYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTtcblxuICAgIGlmIChpbm5lci5oZWlnaHQgPT09IDApIHtcbiAgICAgIC8vIFJlbmRlciBhIHNtYWxsIHN1cmQuXG4gICAgICBpbm5lci5oZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDtcbiAgICB9IC8vIFNvbWUgZ3JvdXBzIGNhbiByZXR1cm4gZG9jdW1lbnQgZnJhZ21lbnRzLiAgSGFuZGxlIHRob3NlIGJ5IHdyYXBwaW5nXG4gICAgLy8gdGhlbSBpbiBhIHNwYW4uXG5cblxuICAgIGlubmVyID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGlubmVyLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIHNpemUgZm9yIHRoZSBcXHN1cmQgZGVsaW1pdGVyXG5cbiAgICBjb25zdCBtZXRyaWNzID0gb3B0aW9ucy5mb250TWV0cmljcygpO1xuICAgIGNvbnN0IHRoZXRhID0gbWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgICBsZXQgcGhpID0gdGhldGE7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pZCA8IHNyY19TdHlsZS5URVhULmlkKSB7XG4gICAgICBwaGkgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDtcbiAgICB9IC8vIENhbGN1bGF0ZSB0aGUgY2xlYXJhbmNlIGJldHdlZW4gdGhlIGJvZHkgYW5kIGxpbmVcblxuXG4gICAgbGV0IGxpbmVDbGVhcmFuY2UgPSB0aGV0YSArIHBoaSAvIDQ7XG4gICAgY29uc3QgbWluRGVsaW1pdGVySGVpZ2h0ID0gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lQ2xlYXJhbmNlICsgdGhldGE7IC8vIENyZWF0ZSBhIHNxcnQgU1ZHIG9mIHRoZSByZXF1aXJlZCBtaW5pbXVtIHNpemVcblxuICAgIGNvbnN0IHtcbiAgICAgIHNwYW46IGltZyxcbiAgICAgIHJ1bGVXaWR0aCxcbiAgICAgIGFkdmFuY2VXaWR0aFxuICAgIH0gPSBkZWxpbWl0ZXIuc3FydEltYWdlKG1pbkRlbGltaXRlckhlaWdodCwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGVsaW1EZXB0aCA9IGltZy5oZWlnaHQgLSBydWxlV2lkdGg7IC8vIEFkanVzdCB0aGUgY2xlYXJhbmNlIGJhc2VkIG9uIHRoZSBkZWxpbWl0ZXIgc2l6ZVxuXG4gICAgaWYgKGRlbGltRGVwdGggPiBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIGxpbmVDbGVhcmFuY2UpIHtcbiAgICAgIGxpbmVDbGVhcmFuY2UgPSAobGluZUNsZWFyYW5jZSArIGRlbGltRGVwdGggLSBpbm5lci5oZWlnaHQgLSBpbm5lci5kZXB0aCkgLyAyO1xuICAgIH0gLy8gU2hpZnQgdGhlIHNxcnQgaW1hZ2VcblxuXG4gICAgY29uc3QgaW1nU2hpZnQgPSBpbWcuaGVpZ2h0IC0gaW5uZXIuaGVpZ2h0IC0gbGluZUNsZWFyYW5jZSAtIHJ1bGVXaWR0aDtcbiAgICBpbm5lci5zdHlsZS5wYWRkaW5nTGVmdCA9IG1ha2VFbShhZHZhbmNlV2lkdGgpOyAvLyBPdmVybGF5IHRoZSBpbWFnZSBhbmQgdGhlIGFyZ3VtZW50LlxuXG4gICAgY29uc3QgYm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lcixcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFtcInN2Zy1hbGlnblwiXVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogLShpbm5lci5oZWlnaHQgKyBpbWdTaGlmdClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGltZ1xuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogcnVsZVdpZHRoXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFncm91cC5pbmRleCkge1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJzcXJ0XCJdLCBbYm9keV0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgdGhlIG9wdGlvbmFsIHJvb3QgaW5kZXhcbiAgICAgIC8vIFRoZSBpbmRleCBpcyBhbHdheXMgaW4gc2NyaXB0c2NyaXB0IHN0eWxlXG4gICAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzcmNfU3R5bGUuU0NSSVBUU0NSSVBUKTtcbiAgICAgIGNvbnN0IHJvb3RtID0gYnVpbGRHcm91cChncm91cC5pbmRleCwgbmV3T3B0aW9ucywgb3B0aW9ucyk7IC8vIFRoZSBhbW91bnQgdGhlIGluZGV4IGlzIHNoaWZ0ZWQgYnkuIFRoaXMgaXMgdGFrZW4gZnJvbSB0aGUgVGVYXG4gICAgICAvLyBzb3VyY2UsIGluIHRoZSBkZWZpbml0aW9uIG9mIGBcXHJAQHRgLlxuXG4gICAgICBjb25zdCB0b1NoaWZ0ID0gMC42ICogKGJvZHkuaGVpZ2h0IC0gYm9keS5kZXB0aCk7IC8vIEJ1aWxkIGEgVkxpc3Qgd2l0aCB0aGUgc3VwZXJzY3JpcHQgc2hpZnRlZCB1cCBjb3JyZWN0bHlcblxuICAgICAgY29uc3Qgcm9vdFZMaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcInNoaWZ0XCIsXG4gICAgICAgIHBvc2l0aW9uRGF0YTogLXRvU2hpZnQsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHJvb3RtXG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTsgLy8gQWRkIGEgY2xhc3Mgc3Vycm91bmRpbmcgaXQgc28gd2UgY2FuIGFkZCBvbiB0aGUgYXBwcm9wcmlhdGVcbiAgICAgIC8vIGtlcm5pbmdcblxuICAgICAgY29uc3Qgcm9vdFZMaXN0V3JhcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInJvb3RcIl0sIFtyb290Vkxpc3RdKTtcbiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSwgW3Jvb3RWTGlzdFdyYXAsIGJvZHldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGJvZHksXG4gICAgICBpbmRleFxuICAgIH0gPSBncm91cDtcbiAgICByZXR1cm4gaW5kZXggPyBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb290XCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGJvZHksIG9wdGlvbnMpLCBidWlsZE1hdGhNTF9idWlsZEdyb3VwKGluZGV4LCBvcHRpb25zKV0pIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3FydFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChib2R5LCBvcHRpb25zKV0pO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zdHlsaW5nLmpzXG5cblxuXG5cblxuY29uc3Qgc3R5bGluZ19zdHlsZU1hcCA9IHtcbiAgXCJkaXNwbGF5XCI6IHNyY19TdHlsZS5ESVNQTEFZLFxuICBcInRleHRcIjogc3JjX1N0eWxlLlRFWFQsXG4gIFwic2NyaXB0XCI6IHNyY19TdHlsZS5TQ1JJUFQsXG4gIFwic2NyaXB0c2NyaXB0XCI6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3R5bGluZ1wiLFxuICBuYW1lczogW1wiXFxcXGRpc3BsYXlzdHlsZVwiLCBcIlxcXFx0ZXh0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c2NyaXB0c3R5bGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIGxldCB7XG4gICAgICBicmVha09uVG9rZW5UZXh0LFxuICAgICAgZnVuY05hbWUsXG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICAvLyBwYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0KTsgLy8gVE9ETzogUmVmYWN0b3IgdG8gYXZvaWQgZHVwbGljYXRpbmcgc3R5bGVNYXAgaW4gbXVsdGlwbGUgcGxhY2VzIChlLmcuXG4gICAgLy8gaGVyZSBhbmQgaW4gYnVpbGRIVE1MIGFuZCBkZS1kdXBlIHRoZSBlbnVtZXJhdGlvbiBvZiBhbGwgdGhlIHN0eWxlcykuXG4gICAgLy8gJEZsb3dGaXhNZTogVGhlIG5hbWVzIGFib3ZlIGV4YWN0bHkgbWF0Y2ggdGhlIHN0eWxlcy5cblxuICAgIGNvbnN0IHN0eWxlID0gZnVuY05hbWUuc2xpY2UoMSwgZnVuY05hbWUubGVuZ3RoIC0gNSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgdG8gdXNlIGJ5IHB1bGxpbmcgb3V0IHRoZSBzdHlsZSBmcm9tXG4gICAgICAvLyB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgc3R5bGUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFN0eWxlIGNoYW5nZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGcuIDQ0MiwgUnVsZSAzLlxuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGluZ19zdHlsZU1hcFtncm91cC5zdHlsZV07XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUobmV3U3R5bGUpLndpdGhGb250KCcnKTtcbiAgICByZXR1cm4gc2l6aW5nR3JvdXAoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzdHlsZSB3ZSdyZSBjaGFuZ2luZyB0by5cbiAgICBjb25zdCBuZXdTdHlsZSA9IHN0eWxpbmdfc3R5bGVNYXBbZ3JvdXAuc3R5bGVdO1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG5ld1N0eWxlKTtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgaW5uZXIpO1xuICAgIGNvbnN0IHN0eWxlQXR0cmlidXRlcyA9IHtcbiAgICAgIFwiZGlzcGxheVwiOiBbXCIwXCIsIFwidHJ1ZVwiXSxcbiAgICAgIFwidGV4dFwiOiBbXCIwXCIsIFwiZmFsc2VcIl0sXG4gICAgICBcInNjcmlwdFwiOiBbXCIxXCIsIFwiZmFsc2VcIl0sXG4gICAgICBcInNjcmlwdHNjcmlwdFwiOiBbXCIyXCIsIFwiZmFsc2VcIl1cbiAgICB9O1xuICAgIGNvbnN0IGF0dHIgPSBzdHlsZUF0dHJpYnV0ZXNbZ3JvdXAuc3R5bGVdO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3N1cHN1Yi5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG5jb25zdCBodG1sQnVpbGRlckRlbGVnYXRlID0gZnVuY3Rpb24gKGdyb3VwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGJhc2UgPSBncm91cC5iYXNlO1xuXG4gIGlmICghYmFzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJvcFwiKSB7XG4gICAgLy8gT3BlcmF0b3JzIGhhbmRsZSBzdXBzdWJzIGRpZmZlcmVudGx5IHdoZW4gdGhleSBoYXZlIGxpbWl0c1xuICAgIC8vIChlLmcuIGBcXGRpc3BsYXlzdHlsZVxcc3VtXzJeM2ApXG4gICAgY29uc3QgZGVsZWdhdGUgPSBiYXNlLmxpbWl0cyAmJiAob3B0aW9ucy5zdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKTtcbiAgICByZXR1cm4gZGVsZWdhdGUgPyBvcF9odG1sQnVpbGRlciA6IG51bGw7XG4gIH0gZWxzZSBpZiAoYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSB7XG4gICAgY29uc3QgZGVsZWdhdGUgPSBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiAmJiAob3B0aW9ucy5zdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplIHx8IGJhc2UubGltaXRzKTtcbiAgICByZXR1cm4gZGVsZWdhdGUgPyBvcGVyYXRvcm5hbWVfaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJhY2NlbnRcIikge1xuICAgIHJldHVybiB1dGlscy5pc0NoYXJhY3RlckJveChiYXNlLmJhc2UpID8gaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJob3JpekJyYWNlXCIpIHtcbiAgICBjb25zdCBpc1N1cCA9ICFncm91cC5zdWI7XG4gICAgcmV0dXJuIGlzU3VwID09PSBiYXNlLmlzT3ZlciA/IGhvcml6QnJhY2VfaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59OyAvLyBTdXBlciBzY3JpcHRzIGFuZCBzdWJzY3JpcHRzLCB3aG9zZSBwcmVjaXNlIHBsYWNlbWVudCBjYW4gZGVwZW5kIG9uIG90aGVyXG4vLyBmdW5jdGlvbnMgdGhhdCBwcmVjZWRlIHRoZW0uXG5cblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwic3Vwc3ViXCIsXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBTdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0cyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBvbiBwYWdlXG4gICAgLy8gNDQ1LTQ0NiwgcnVsZXMgMTgoYS1mKS5cbiAgICAvLyBIZXJlIGlzIHdoZXJlIHdlIGRlZmVyIHRvIHRoZSBpbm5lciBncm91cCBpZiBpdCBzaG91bGQgaGFuZGxlXG4gICAgLy8gc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGl0c2VsZi5cbiAgICBjb25zdCBidWlsZGVyRGVsZWdhdGUgPSBodG1sQnVpbGRlckRlbGVnYXRlKGdyb3VwLCBvcHRpb25zKTtcblxuICAgIGlmIChidWlsZGVyRGVsZWdhdGUpIHtcbiAgICAgIHJldHVybiBidWlsZGVyRGVsZWdhdGUoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGJhc2U6IHZhbHVlQmFzZSxcbiAgICAgIHN1cDogdmFsdWVTdXAsXG4gICAgICBzdWI6IHZhbHVlU3ViXG4gICAgfSA9IGdyb3VwO1xuICAgIGNvbnN0IGJhc2UgPSBidWlsZEdyb3VwKHZhbHVlQmFzZSwgb3B0aW9ucyk7XG4gICAgbGV0IHN1cG07XG4gICAgbGV0IHN1Ym07XG4gICAgY29uc3QgbWV0cmljcyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKTsgLy8gUnVsZSAxOGFcblxuICAgIGxldCBzdXBTaGlmdCA9IDA7XG4gICAgbGV0IHN1YlNoaWZ0ID0gMDtcbiAgICBjb25zdCBpc0NoYXJhY3RlckJveCA9IHZhbHVlQmFzZSAmJiB1dGlscy5pc0NoYXJhY3RlckJveCh2YWx1ZUJhc2UpO1xuXG4gICAgaWYgKHZhbHVlU3VwKSB7XG4gICAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnN1cCgpKTtcbiAgICAgIHN1cG0gPSBidWlsZEdyb3VwKHZhbHVlU3VwLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFpc0NoYXJhY3RlckJveCkge1xuICAgICAgICBzdXBTaGlmdCA9IGJhc2UuaGVpZ2h0IC0gbmV3T3B0aW9ucy5mb250TWV0cmljcygpLnN1cERyb3AgKiBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWVTdWIpIHtcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUuc3ViKCkpO1xuICAgICAgc3VibSA9IGJ1aWxkR3JvdXAodmFsdWVTdWIsIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIWlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICAgIHN1YlNoaWZ0ID0gYmFzZS5kZXB0aCArIG5ld09wdGlvbnMuZm9udE1ldHJpY3MoKS5zdWJEcm9wICogbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgICB9XG4gICAgfSAvLyBSdWxlIDE4Y1xuXG5cbiAgICBsZXQgbWluU3VwU2hpZnQ7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkpIHtcbiAgICAgIG1pblN1cFNoaWZ0ID0gbWV0cmljcy5zdXAxO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHlsZS5jcmFtcGVkKSB7XG4gICAgICBtaW5TdXBTaGlmdCA9IG1ldHJpY3Muc3VwMztcbiAgICB9IGVsc2Uge1xuICAgICAgbWluU3VwU2hpZnQgPSBtZXRyaWNzLnN1cDI7XG4gICAgfSAvLyBzY3JpcHRzcGFjZSBpcyBhIGZvbnQtc2l6ZS1pbmRlcGVuZGVudCBzaXplLCBzbyBzY2FsZSBpdFxuICAgIC8vIGFwcHJvcHJpYXRlbHkgZm9yIHVzZSBhcyB0aGUgbWFyZ2luUmlnaHQuXG5cblxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIGNvbnN0IG1hcmdpblJpZ2h0ID0gbWFrZUVtKDAuNSAvIG1ldHJpY3MucHRQZXJFbSAvIG11bHRpcGxpZXIpO1xuICAgIGxldCBtYXJnaW5MZWZ0ID0gbnVsbDtcblxuICAgIGlmIChzdWJtKSB7XG4gICAgICAvLyBTdWJzY3JpcHRzIHNob3VsZG4ndCBiZSBzaGlmdGVkIGJ5IHRoZSBiYXNlJ3MgaXRhbGljIGNvcnJlY3Rpb24uXG4gICAgICAvLyBBY2NvdW50IGZvciB0aGF0IGJ5IHNoaWZ0aW5nIHRoZSBzdWJzY3JpcHQgYmFjayB0aGUgYXBwcm9wcmlhdGVcbiAgICAgIC8vIGFtb3VudC4gTm90ZSB3ZSBvbmx5IGRvIHRoaXMgd2hlbiB0aGUgYmFzZSBpcyBhIHNpbmdsZSBzeW1ib2wuXG4gICAgICBjb25zdCBpc09paW50ID0gZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwib3BcIiAmJiBncm91cC5iYXNlLm5hbWUgJiYgKGdyb3VwLmJhc2UubmFtZSA9PT0gXCJcXFxcb2lpbnRcIiB8fCBncm91cC5iYXNlLm5hbWUgPT09IFwiXFxcXG9paWludFwiKTtcblxuICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBTeW1ib2xOb2RlIHx8IGlzT2lpbnQpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBtYXJnaW5MZWZ0ID0gbWFrZUVtKC1iYXNlLml0YWxpYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHN1cHN1YjtcblxuICAgIGlmIChzdXBtICYmIHN1Ym0pIHtcbiAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LCBzdXBtLmRlcHRoICsgMC4yNSAqIG1ldHJpY3MueEhlaWdodCk7XG4gICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KHN1YlNoaWZ0LCBtZXRyaWNzLnN1YjIpO1xuICAgICAgY29uc3QgcnVsZVdpZHRoID0gbWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzczsgLy8gUnVsZSAxOGVcblxuICAgICAgY29uc3QgbWF4V2lkdGggPSA0ICogcnVsZVdpZHRoO1xuXG4gICAgICBpZiAoc3VwU2hpZnQgLSBzdXBtLmRlcHRoIC0gKHN1Ym0uaGVpZ2h0IC0gc3ViU2hpZnQpIDwgbWF4V2lkdGgpIHtcbiAgICAgICAgc3ViU2hpZnQgPSBtYXhXaWR0aCAtIChzdXBTaGlmdCAtIHN1cG0uZGVwdGgpICsgc3VibS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBzaSA9IDAuOCAqIG1ldHJpY3MueEhlaWdodCAtIChzdXBTaGlmdCAtIHN1cG0uZGVwdGgpO1xuXG4gICAgICAgIGlmIChwc2kgPiAwKSB7XG4gICAgICAgICAgc3VwU2hpZnQgKz0gcHNpO1xuICAgICAgICAgIHN1YlNoaWZ0IC09IHBzaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB2bGlzdEVsZW0gPSBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VibSxcbiAgICAgICAgc2hpZnQ6IHN1YlNoaWZ0LFxuICAgICAgICBtYXJnaW5SaWdodCxcbiAgICAgICAgbWFyZ2luTGVmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VwbSxcbiAgICAgICAgc2hpZnQ6IC1zdXBTaGlmdCxcbiAgICAgICAgbWFyZ2luUmlnaHRcbiAgICAgIH1dO1xuICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogdmxpc3RFbGVtXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHN1Ym0pIHtcbiAgICAgIC8vIFJ1bGUgMThiXG4gICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KHN1YlNoaWZ0LCBtZXRyaWNzLnN1YjEsIHN1Ym0uaGVpZ2h0IC0gMC44ICogbWV0cmljcy54SGVpZ2h0KTtcbiAgICAgIGNvbnN0IHZsaXN0RWxlbSA9IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdWJtLFxuICAgICAgICBtYXJnaW5MZWZ0LFxuICAgICAgICBtYXJnaW5SaWdodFxuICAgICAgfV07XG4gICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiBzdWJTaGlmdCxcbiAgICAgICAgY2hpbGRyZW46IHZsaXN0RWxlbVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChzdXBtKSB7XG4gICAgICAvLyBSdWxlIDE4YywgZFxuICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChzdXBTaGlmdCwgbWluU3VwU2hpZnQsIHN1cG0uZGVwdGggKyAwLjI1ICogbWV0cmljcy54SGVpZ2h0KTtcbiAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IC1zdXBTaGlmdCxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwbSxcbiAgICAgICAgICBtYXJnaW5SaWdodFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInN1cHN1YiBtdXN0IGhhdmUgZWl0aGVyIHN1cCBvciBzdWIuXCIpO1xuICAgIH0gLy8gV3JhcCB0aGUgc3Vwc3ViIHZsaXN0IGluIGEgc3Bhbi5tc3Vwc3ViIHRvIHJlc2V0IHRleHQtYWxpZ24uXG5cblxuICAgIGNvbnN0IG1jbGFzcyA9IGdldFR5cGVPZkRvbVRyZWUoYmFzZSwgXCJyaWdodFwiKSB8fCBcIm1vcmRcIjtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW21jbGFzc10sIFtiYXNlLCBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3Vwc3ViXCJdLCBbc3Vwc3ViXSldLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gSXMgdGhlIGlubmVyIGdyb3VwIGEgcmVsZXZhbnQgaG9yaXpvbmFsIGJyYWNlP1xuICAgIGxldCBpc0JyYWNlID0gZmFsc2U7XG4gICAgbGV0IGlzT3ZlcjtcbiAgICBsZXQgaXNTdXA7XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwiaG9yaXpCcmFjZVwiKSB7XG4gICAgICBpc1N1cCA9ICEhZ3JvdXAuc3VwO1xuXG4gICAgICBpZiAoaXNTdXAgPT09IGdyb3VwLmJhc2UuaXNPdmVyKSB7XG4gICAgICAgIGlzQnJhY2UgPSB0cnVlO1xuICAgICAgICBpc092ZXIgPSBncm91cC5iYXNlLmlzT3ZlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiAoZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wXCIgfHwgZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSkge1xuICAgICAgZ3JvdXAuYmFzZS5wYXJlbnRJc1N1cFN1YiA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zKV07XG5cbiAgICBpZiAoZ3JvdXAuc3ViKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuc3ViLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnN1cCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLnN1cCwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGxldCBub2RlVHlwZTtcblxuICAgIGlmIChpc0JyYWNlKSB7XG4gICAgICBub2RlVHlwZSA9IGlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCI7XG4gICAgfSBlbHNlIGlmICghZ3JvdXAuc3ViKSB7XG4gICAgICBjb25zdCBiYXNlID0gZ3JvdXAuYmFzZTtcblxuICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wXCIgJiYgYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiYgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKGJhc2UubGltaXRzIHx8IG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3VwXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZ3JvdXAuc3VwKSB7XG4gICAgICBjb25zdCBiYXNlID0gZ3JvdXAuYmFzZTtcblxuICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wXCIgJiYgYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyXCI7XG4gICAgICB9IGVsc2UgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmIChiYXNlLmxpbWl0cyB8fCBvcHRpb25zLnN0eWxlID09PSBzcmNfU3R5bGUuRElTUExBWSkpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmJhc2U7XG5cbiAgICAgIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJvcFwiICYmIGJhc2UubGltaXRzICYmIG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJvdmVyXCI7XG4gICAgICB9IGVsc2UgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmIChvcHRpb25zLnN0eWxlID09PSBzcmNfU3R5bGUuRElTUExBWSB8fCBiYXNlLmxpbWl0cykpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlcm92ZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3Vic3VwXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKG5vZGVUeXBlLCBjaGlsZHJlbik7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3N5bWJvbHNPcC5qc1xuXG5cblxuIC8vIE9wZXJhdG9yIFBhcnNlTm9kZXMgY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSBzeW1ib2wgR3JvdXBzIGluIHNyYy9zeW1ib2xzLmpzLlxuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJhdG9tXCIsXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWF0aHN5bShncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtXCIgKyBncm91cC5mYW1pbHldKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnRleHQsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcImJpblwiKSB7XG4gICAgICBjb25zdCB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh2YXJpYW50ID09PSBcImJvbGQtaXRhbGljXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJwdW5jdFwiKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInNlcGFyYXRvclwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwib3BlblwiIHx8IGdyb3VwLmZhbWlseSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAvLyBEZWxpbXMgYnVpbHQgaGVyZSBzaG91bGQgbm90IHN0cmV0Y2ggdmVydGljYWxseS5cbiAgICAgIC8vIFNlZSBkZWxpbXNpemluZy5qcyBmb3Igc3RyZXRjaHkgZGVsaW1zLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zeW1ib2xzT3JkLmpzXG5cblxuXG5cbi8vIFwibWF0aG9yZFwiIGFuZCBcInRleHRvcmRcIiBQYXJzZU5vZGVzIGNyZWF0ZWQgaW4gUGFyc2VyLmpzIGZyb20gc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5jb25zdCBkZWZhdWx0VmFyaWFudCA9IHtcbiAgXCJtaVwiOiBcIml0YWxpY1wiLFxuICBcIm1uXCI6IFwibm9ybWFsXCIsXG4gIFwibXRleHRcIjogXCJub3JtYWxcIlxufTtcbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcIm1hdGhvcmRcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlT3JkKGdyb3VwLCBvcHRpb25zLCBcIm1hdGhvcmRcIik7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFttYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0pO1xuICAgIGNvbnN0IHZhcmlhbnQgPSBnZXRWYXJpYW50KGdyb3VwLCBvcHRpb25zKSB8fCBcIml0YWxpY1wiO1xuXG4gICAgaWYgKHZhcmlhbnQgIT09IGRlZmF1bHRWYXJpYW50W25vZGUudHlwZV0pIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJ0ZXh0b3JkXCIsXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0ID0gbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpIHx8IFwibm9ybWFsXCI7XG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAubW9kZSA9PT0gJ3RleHQnKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtblwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudGV4dCA9PT0gXCJcXFxccHJpbWVcIikge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgW3RleHRdKTtcbiAgICB9XG5cbiAgICBpZiAodmFyaWFudCAhPT0gZGVmYXVsdFZhcmlhbnRbbm9kZS50eXBlXSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc3ltYm9sc1NwYWNpbmcuanNcblxuXG5cbiAvLyBBIG1hcCBvZiBDU1MtYmFzZWQgc3BhY2luZyBmdW5jdGlvbnMgdG8gdGhlaXIgQ1NTIGNsYXNzLlxuXG5jb25zdCBjc3NTcGFjZSA9IHtcbiAgXCJcXFxcbm9icmVha1wiOiBcIm5vYnJlYWtcIixcbiAgXCJcXFxcYWxsb3dicmVha1wiOiBcImFsbG93YnJlYWtcIlxufTsgLy8gQSBsb29rdXAgdGFibGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzcGFjaW5nIGZ1bmN0aW9uL3N5bWJvbCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgbGlrZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgSWYgYSBzeW1ib2wgb3IgY29tbWFuZCBpcyBhIGtleVxuLy8gaW4gdGhpcyB0YWJsZSwgdGhlbiBpdCBzaG91bGQgYmUgYSByZWd1bGFyIHNwYWNlIGNoYXJhY3Rlci4gIEZ1cnRoZXJtb3JlLFxuLy8gdGhlIGFzc29jaWF0ZWQgdmFsdWUgbWF5IGhhdmUgYSBgY2xhc3NOYW1lYCBzcGVjaWZ5aW5nIGFuIGV4dHJhIENTUyBjbGFzc1xuLy8gdG8gYWRkIHRvIHRoZSBjcmVhdGVkIGBzcGFuYC5cblxuY29uc3QgcmVndWxhclNwYWNlID0ge1xuICBcIiBcIjoge30sXG4gIFwiXFxcXCBcIjoge30sXG4gIFwiflwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9LFxuICBcIlxcXFxzcGFjZVwiOiB7fSxcbiAgXCJcXFxcbm9icmVha3NwYWNlXCI6IHtcbiAgICBjbGFzc05hbWU6IFwibm9icmVha1wiXG4gIH1cbn07IC8vIFBhcnNlTm9kZTxcInNwYWNpbmdcIj4gY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSB0aGUgXCJzcGFjaW5nXCIgc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInNwYWNpbmdcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHJlZ3VsYXJTcGFjZVtncm91cC50ZXh0XS5jbGFzc05hbWUgfHwgXCJcIjsgLy8gU3BhY2VzIGFyZSBnZW5lcmF0ZWQgYnkgYWRkaW5nIGFuIGFjdHVhbCBzcGFjZS4gRWFjaCBvZiB0aGVzZVxuICAgICAgLy8gdGhpbmdzIGhhcyBhbiBlbnRyeSBpbiB0aGUgc3ltYm9scyB0YWJsZSwgc28gdGhlc2Ugd2lsbCBiZSB0dXJuZWRcbiAgICAgIC8vIGludG8gYXBwcm9wcmlhdGUgb3V0cHV0cy5cblxuICAgICAgaWYgKGdyb3VwLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IG9yZCA9IGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgICAgICAgb3JkLmNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gb3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiLCBjbGFzc05hbWVdLCBbYnVpbGRDb21tb24ubWF0aHN5bShncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3NzU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIC8vIFNwYWNlcyBiYXNlZCBvbiBqdXN0IGEgQ1NTIGNsYXNzLlxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiLCBjc3NTcGFjZVtncm91cC50ZXh0XV0sIFtdLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5rbm93biB0eXBlIG9mIHNwYWNlIFxcXCJcIiArIGdyb3VwLnRleHQgKyBcIlxcXCJcIik7XG4gICAgfVxuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBsZXQgbm9kZTtcblxuICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTAwYTBcIildKTtcbiAgICB9IGVsc2UgaWYgKGNzc1NwYWNlLmhhc093blByb3BlcnR5KGdyb3VwLnRleHQpKSB7XG4gICAgICAvLyBDU1MtYmFzZWQgTWF0aE1MIHNwYWNlcyAoXFxub2JyZWFrLCBcXGFsbG93YnJlYWspIGFyZSBpZ25vcmVkXG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gdHlwZSBvZiBzcGFjZSBcXFwiXCIgKyBncm91cC50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy90YWcuanNcblxuXG5cblxuY29uc3QgcGFkID0gKCkgPT4ge1xuICBjb25zdCBwYWROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10pO1xuICBwYWROb2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiNTAlXCIpO1xuICByZXR1cm4gcGFkTm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInRhZ1wiLFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIFtuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCBbcGFkKCksIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucyldKSwgcGFkKCksIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAudGFnLCBvcHRpb25zKV0pXSldKTtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjEwMCVcIik7XG4gICAgcmV0dXJuIHRhYmxlOyAvLyBUT0RPOiBMZWZ0LWFsaWduZWQgdGFncy5cbiAgICAvLyBDdXJyZW50bHksIHRoZSBncm91cCBhbmQgb3B0aW9ucyBwYXNzZWQgaGVyZSBkbyBub3QgY29udGFpblxuICAgIC8vIGVub3VnaCBpbmZvIHRvIHNldCB0YWcgYWxpZ25tZW50LiBgbGVxbm9gIGlzIGluIFNldHRpbmdzIGJ1dCBpdCBpc1xuICAgIC8vIG5vdCBwYXNzZWQgdG8gT3B0aW9ucy4gT24gdGhlIEhUTUwgc2lkZSwgbGVxbm8gaXNcbiAgICAvLyBzZXQgYnkgYSBDU1MgY2xhc3MgYXBwbGllZCBpbiBidWlsZFRyZWUuanMuIFRoYXQgd291bGQgaGF2ZSB3b3JrZWRcbiAgICAvLyBpbiBNYXRoTUwgaWYgYnJvd3NlcnMgc3VwcG9ydGVkIDxtbGFiZWxlZHRyPi4gU2luY2UgdGhleSBkb24ndCwgd2VcbiAgICAvLyBuZWVkIHRvIHJld3JpdGUgdGhlIHdheSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgfVxuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvdGV4dC5qc1xuXG5cblxuIC8vIE5vbi1tYXRoeSB0ZXh0LCBwb3NzaWJseSBpbiBhIGZvbnRcblxuY29uc3QgdGV4dEZvbnRGYW1pbGllcyA9IHtcbiAgXCJcXFxcdGV4dFwiOiB1bmRlZmluZWQsXG4gIFwiXFxcXHRleHRybVwiOiBcInRleHRybVwiLFxuICBcIlxcXFx0ZXh0c2ZcIjogXCJ0ZXh0c2ZcIixcbiAgXCJcXFxcdGV4dHR0XCI6IFwidGV4dHR0XCIsXG4gIFwiXFxcXHRleHRub3JtYWxcIjogXCJ0ZXh0cm1cIlxufTtcbmNvbnN0IHRleHRGb250V2VpZ2h0cyA9IHtcbiAgXCJcXFxcdGV4dGJmXCI6IFwidGV4dGJmXCIsXG4gIFwiXFxcXHRleHRtZFwiOiBcInRleHRtZFwiXG59O1xuY29uc3QgdGV4dEZvbnRTaGFwZXMgPSB7XG4gIFwiXFxcXHRleHRpdFwiOiBcInRleHRpdFwiLFxuICBcIlxcXFx0ZXh0dXBcIjogXCJ0ZXh0dXBcIlxufTtcblxuY29uc3Qgb3B0aW9uc1dpdGhGb250ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZvbnQgPSBncm91cC5mb250OyAvLyBDaGVja3MgaWYgdGhlIGFyZ3VtZW50IGlzIGEgZm9udCBmYW1pbHkgb3IgYSBmb250IHN0eWxlLlxuXG4gIGlmICghZm9udCkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9IGVsc2UgaWYgKHRleHRGb250RmFtaWxpZXNbZm9udF0pIHtcbiAgICByZXR1cm4gb3B0aW9ucy53aXRoVGV4dEZvbnRGYW1pbHkodGV4dEZvbnRGYW1pbGllc1tmb250XSk7XG4gIH0gZWxzZSBpZiAodGV4dEZvbnRXZWlnaHRzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250V2VpZ2h0KHRleHRGb250V2VpZ2h0c1tmb250XSk7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJcXFxcZW1waFwiKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiID8gb3B0aW9ucy53aXRoVGV4dEZvbnRTaGFwZShcInRleHR1cFwiKSA6IG9wdGlvbnMud2l0aFRleHRGb250U2hhcGUoXCJ0ZXh0aXRcIik7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucy53aXRoVGV4dEZvbnRTaGFwZSh0ZXh0Rm9udFNoYXBlc1tmb250XSk7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLFxuICBuYW1lczogWy8vIEZvbnQgZmFtaWxpZXNcbiAgXCJcXFxcdGV4dFwiLCBcIlxcXFx0ZXh0cm1cIiwgXCJcXFxcdGV4dHNmXCIsIFwiXFxcXHRleHR0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCIsIC8vIEZvbnQgd2VpZ2h0c1xuICBcIlxcXFx0ZXh0YmZcIiwgXCJcXFxcdGV4dG1kXCIsIC8vIEZvbnQgU2hhcGVzXG4gIFwiXFxcXHRleHRpdFwiLCBcIlxcXFx0ZXh0dXBcIiwgXCJcXFxcZW1waFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgZm9udDogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IG9wdGlvbnNXaXRoRm9udChncm91cCwgb3B0aW9ucyk7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgdHJ1ZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ0ZXh0XCJdLCBpbm5lciwgbmV3T3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zV2l0aEZvbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgbmV3T3B0aW9ucyk7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3VuZGVybGluZS5qc1xuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ1bmRlcmxpbmVcIixcbiAgbmFtZXM6IFtcIlxcXFx1bmRlcmxpbmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVuZGVybGluZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFVuZGVybGluZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcgNDQzLCBSdWxlIDEwLlxuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBncm91cC5cbiAgICBjb25zdCBpbm5lckdyb3VwID0gYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKTsgLy8gQ3JlYXRlIHRoZSBsaW5lIHRvIGdvIGJlbG93IHRoZSBib2R5XG5cbiAgICBjb25zdCBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwidW5kZXJsaW5lLWxpbmVcIiwgb3B0aW9ucyk7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcblxuICAgIGNvbnN0IGRlZmF1bHRSdWxlVGhpY2tuZXNzID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgIGNvbnN0IHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJ0b3BcIixcbiAgICAgIHBvc2l0aW9uRGF0YTogaW5uZXJHcm91cC5oZWlnaHQsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBsaW5lXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAzICogZGVmYXVsdFJ1bGVUaGlja25lc3NcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyR3JvdXBcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ1bmRlcmxpbmVcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzZVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyksIG9wZXJhdG9yXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnR1bmRlclwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3ZjZW50ZXIuanNcblxuXG5cblxuIC8vIFxcdmNlbnRlcjogIFZlcnRpY2FsbHkgY2VudGVyIHRoZSBhcmd1bWVudCBncm91cCBvbiB0aGUgbWF0aCBheGlzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidmNlbnRlclwiLFxuICBuYW1lczogW1wiXFxcXHZjZW50ZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wib3JpZ2luYWxcIl0sXG4gICAgLy8gSW4gTGFUZVgsIFxcdmNlbnRlciBjYW4gYWN0IG9ubHkgb24gYSBib3guXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICBsZXQge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidmNlbnRlclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJvZHkgPSBidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICAgIGNvbnN0IGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcbiAgICBjb25zdCBkeSA9IDAuNSAqIChib2R5LmhlaWdodCAtIGF4aXNIZWlnaHQgLSAoYm9keS5kZXB0aCArIGF4aXNIZWlnaHQpKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBkeSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGRvIHRoaXMgaW4gTWF0aE1MLlxuICAgIC8vIFdyaXRlIGEgY2xhc3MgYXMgYSBicmVhZGNydW1iIGluIGNhc2Ugc29tZSBwb3N0LXByb2Nlc3NvciB3YW50c1xuICAgIC8vIHRvIHBlcmZvcm0gYSB2Y2VudGVyIGFkanVzdG1lbnQuXG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0sIFtcInZjZW50ZXJcIl0pO1xuICB9XG5cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy92ZXJiLmpzXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2ZXJiXCIsXG4gIG5hbWVzOiBbXCJcXFxcdmVyYlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICAvLyBcXHZlcmIgYW5kIFxcdmVyYiogYXJlIGRlYWx0IHdpdGggZGlyZWN0bHkgaW4gUGFyc2VyLmpzLlxuICAgIC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdCdzIGJlY2F1c2Ugb2YgYSBmYWlsdXJlIHRvIG1hdGNoIHRoZSB0d28gZGVsaW1pdGVyc1xuICAgIC8vIGluIHRoZSByZWdleCBpbiBMZXhlci5qcy4gIExhVGVYIHJhaXNlcyB0aGUgZm9sbG93aW5nIGVycm9yIHdoZW4gXFx2ZXJiIGlzXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2YgbGluZSAob3IgZmlsZSkuXG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXHZlcmIgZW5kZWQgYnkgZW5kIG9mIGxpbmUgaW5zdGVhZCBvZiBtYXRjaGluZyBkZWxpbWl0ZXJcIik7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0ID0gbWFrZVZlcmIoZ3JvdXApO1xuICAgIGNvbnN0IGJvZHkgPSBbXTsgLy8gXFx2ZXJiIGVudGVycyB0ZXh0IG1vZGUgYW5kIHRoZXJlZm9yZSBpcyBzaXplZCBsaWtlIFxcdGV4dHN0eWxlXG5cbiAgICBjb25zdCBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnRleHQoKSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gdGV4dFtpXTtcblxuICAgICAgaWYgKGMgPT09ICd+Jykge1xuICAgICAgICBjID0gJ1xcXFx0ZXh0YXNjaWl0aWxkZSc7XG4gICAgICB9XG5cbiAgICAgIGJvZHkucHVzaChidWlsZENvbW1vbi5tYWtlU3ltYm9sKGMsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCIsIGdyb3VwLm1vZGUsIG5ld09wdGlvbnMsIFtcIm1vcmRcIiwgXCJ0ZXh0dHRcIl0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInRleHRcIl0uY29uY2F0KG5ld09wdGlvbnMuc2l6aW5nQ2xhc3NlcyhvcHRpb25zKSksIGJ1aWxkQ29tbW9uLnRyeUNvbWJpbmVDaGFycyhib2R5KSwgbmV3T3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShtYWtlVmVyYihncm91cCkpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFt0ZXh0XSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm1vbm9zcGFjZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcbi8qKlxuICogQ29udmVydHMgdmVyYiBncm91cCBpbnRvIGJvZHkgc3RyaW5nLlxuICpcbiAqIFxcdmVyYiogcmVwbGFjZXMgZWFjaCBzcGFjZSB3aXRoIGFuIG9wZW4gYm94IFxcdTI0MjNcbiAqIFxcdmVyYiByZXBsYWNlcyBlYWNoIHNwYWNlIHdpdGggYSBuby1icmVhayBzcGFjZSBcXHhBMFxuICovXG5cbmNvbnN0IG1ha2VWZXJiID0gZ3JvdXAgPT4gZ3JvdXAuYm9keS5yZXBsYWNlKC8gL2csIGdyb3VwLnN0YXIgPyAnXFx1MjQyMycgOiAnXFx4QTAnKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMuanNcbi8qKiBJbmNsdWRlIHRoaXMgdG8gZW5zdXJlIHRoYXQgYWxsIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZC4gKi9cblxuY29uc3QgZnVuY3Rpb25zID0gX2Z1bmN0aW9ucztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19mdW5jdGlvbnMgPSAoZnVuY3Rpb25zKTsgLy8gVE9ETyhrZXZpbmIpOiBoYXZlIGZ1bmN0aW9ucyByZXR1cm4gYW4gb2JqZWN0IGFuZCBjYWxsIGRlZmluZUZ1bmN0aW9uIHdpdGhcbi8vIHRoYXQgb2JqZWN0IGluIHRoaXMgZmlsZSBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gc2lkZS1lZmZlY3RzLlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9MZXhlci5qc1xuLyoqXG4gKiBUaGUgTGV4ZXIgY2xhc3MgaGFuZGxlcyB0b2tlbml6aW5nIHRoZSBpbnB1dCBpbiB2YXJpb3VzIHdheXMuIFNpbmNlIG91clxuICogcGFyc2VyIGV4cGVjdHMgdXMgdG8gYmUgYWJsZSB0byBiYWNrdHJhY2ssIHRoZSBsZXhlciBhbGxvd3MgbGV4aW5nIGZyb20gYW55XG4gKiBnaXZlbiBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBJdHMgbWFpbiBleHBvc2VkIGZ1bmN0aW9uIGlzIHRoZSBgbGV4YCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwb3NpdGlvbiB0b1xuICogbGV4IGZyb20gYW5kIGEgdHlwZSBvZiB0b2tlbiB0byBsZXguIEl0IGRlZmVycyB0byB0aGUgYXBwcm9wcmlhdGUgYF9pbm5lckxleGBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSB2YXJpb3VzIGBfaW5uZXJMZXhgIGZ1bmN0aW9ucyBwZXJmb3JtIHRoZSBhY3R1YWwgbGV4aW5nIG9mIGRpZmZlcmVudFxuICoga2luZHMuXG4gKi9cblxuXG5cblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IGdyb3VwXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVycyB0aGVuIHdoaXRlc3BhY2VcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBhbnkgQk1QIGNoYXJhY3RlclxuICogQ2FwdHVyaW5nIGdyb3VwczpcbiAqICAgWzFdIHJlZ3VsYXIgd2hpdGVzcGFjZVxuICogICBbMl0gYmFja3NsYXNoIGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2VcbiAqICAgWzNdIGFueXRoaW5nIGVsc2UsIHdoaWNoIG1heSBpbmNsdWRlOlxuICogICAgIFs0XSBsZWZ0IGNoYXJhY3RlciBvZiBcXHZlcmIqXG4gKiAgICAgWzVdIGxlZnQgY2hhcmFjdGVyIG9mIFxcdmVyYlxuICogICAgIFs2XSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgd29yZCwgZXhjbHVkaW5nIGFueSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gKiBKdXN0IGJlY2F1c2UgdGhlIExleGVyIG1hdGNoZXMgc29tZXRoaW5nIGRvZXNuJ3QgbWVhbiBpdCdzIHZhbGlkIGlucHV0OlxuICogSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgZnVuY3Rpb24gb3Igc3ltYm9sIGRlZmluaXRpb24sIHRoZSBQYXJzZXIgd2lsbFxuICogc3RpbGwgcmVqZWN0IHRoZSBpbnB1dC5cbiAqL1xuY29uc3Qgc3BhY2VSZWdleFN0cmluZyA9IFwiWyBcXHJcXG5cXHRdXCI7XG5jb25zdCBjb250cm9sV29yZFJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXFthLXpBLVpAXStcIjtcbmNvbnN0IGNvbnRyb2xTeW1ib2xSZWdleFN0cmluZyA9IFwiXFxcXFxcXFxbXlxcdUQ4MDAtXFx1REZGRl1cIjtcbmNvbnN0IGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nID0gXCIoXCIgKyBjb250cm9sV29yZFJlZ2V4U3RyaW5nICsgXCIpXCIgKyBzcGFjZVJlZ2V4U3RyaW5nICsgXCIqXCI7XG5jb25zdCBjb250cm9sU3BhY2VSZWdleFN0cmluZyA9IFwiXFxcXFxcXFwoXFxufFsgXFxyXFx0XStcXG4/KVsgXFxyXFx0XSpcIjtcbmNvbnN0IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyA9IFwiW1xcdTAzMDAtXFx1MDM2Zl1cIjtcbmNvbnN0IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleCA9IG5ldyBSZWdFeHAoY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nICsgXCIrJFwiKTtcbmNvbnN0IHRva2VuUmVnZXhTdHJpbmcgPSBcIihcIiArIHNwYWNlUmVnZXhTdHJpbmcgKyBcIispfFwiICsgKCAvLyB3aGl0ZXNwYWNlXG5jb250cm9sU3BhY2VSZWdleFN0cmluZyArIFwifFwiKSArIC8vIFxcd2hpdGVzcGFjZVxuXCIoWyEtXFxcXFtcXFxcXS1cXHUyMDI3XFx1MjAyQS1cXHVEN0ZGXFx1RjkwMC1cXHVGRkZGXVwiICsgKCAvLyBzaW5nbGUgY29kZXBvaW50XG5jb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmcgKyBcIipcIikgKyAvLyAuLi5wbHVzIGFjY2VudHNcblwifFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl1cIiArICggLy8gc3Vycm9nYXRlIHBhaXJcbmNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyArIFwiKlwiKSArIC8vIC4uLnBsdXMgYWNjZW50c1xuXCJ8XFxcXFxcXFx2ZXJiXFxcXCooW15dKS4qP1xcXFw0XCIgKyAvLyBcXHZlcmIqXG5cInxcXFxcXFxcXHZlcmIoW14qYS16QS1aXSkuKj9cXFxcNVwiICsgKCAvLyBcXHZlcmIgdW5zdGFycmVkXG5cInxcIiArIGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nKSArICggLy8gXFxtYWNyb05hbWUgKyBzcGFjZXNcblwifFwiICsgY29udHJvbFN5bWJvbFJlZ2V4U3RyaW5nICsgXCIpXCIpOyAvLyBcXFxcLCBcXCcsIGV0Yy5cblxuLyoqIE1haW4gTGV4ZXIgY2xhc3MgKi9cblxuY2xhc3MgTGV4ZXIge1xuICAvLyBDYXRlZ29yeSBjb2Rlcy4gVGhlIGxleGVyIG9ubHkgc3VwcG9ydHMgY29tbWVudCBjaGFyYWN0ZXJzICgxNCkgZm9yIG5vdy5cbiAgLy8gTWFjcm9FeHBhbmRlciBhZGRpdGlvbmFsbHkgZGlzdGluZ3Vpc2hlcyBhY3RpdmUgKDEzKS5cbiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzKSB7XG4gICAgdGhpcy5pbnB1dCA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMudG9rZW5SZWdleCA9IHZvaWQgMDtcbiAgICB0aGlzLmNhdGNvZGVzID0gdm9pZCAwO1xuICAgIC8vIFNlcGFyYXRlIGFjY2VudHMgZnJvbSBjaGFyYWN0ZXJzXG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLnRva2VuUmVnZXggPSBuZXcgUmVnRXhwKHRva2VuUmVnZXhTdHJpbmcsICdnJyk7XG4gICAgdGhpcy5jYXRjb2RlcyA9IHtcbiAgICAgIFwiJVwiOiAxNCxcbiAgICAgIC8vIGNvbW1lbnQgY2hhcmFjdGVyXG4gICAgICBcIn5cIjogMTMgLy8gYWN0aXZlIGNoYXJhY3RlclxuXG4gICAgfTtcbiAgfVxuXG4gIHNldENhdGNvZGUoY2hhciwgY29kZSkge1xuICAgIHRoaXMuY2F0Y29kZXNbY2hhcl0gPSBjb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGxleGVzIGEgc2luZ2xlIHRva2VuLlxuICAgKi9cblxuXG4gIGxleCgpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgY29uc3QgcG9zID0gdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleDtcblxuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihcIkVPRlwiLCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCBwb3MpKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IHRoaXMudG9rZW5SZWdleC5leGVjKGlucHV0KTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5pbmRleCAhPT0gcG9zKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogJ1wiICsgaW5wdXRbcG9zXSArIFwiJ1wiLCBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgcG9zICsgMSkpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gbWF0Y2hbNl0gfHwgbWF0Y2hbM10gfHwgKG1hdGNoWzJdID8gXCJcXFxcIFwiIDogXCIgXCIpO1xuXG4gICAgaWYgKHRoaXMuY2F0Y29kZXNbdGV4dF0gPT09IDE0KSB7XG4gICAgICAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgICAgY29uc3QgbmxJbmRleCA9IGlucHV0LmluZGV4T2YoJ1xcbicsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpO1xuXG4gICAgICBpZiAobmxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCA9IGlucHV0Lmxlbmd0aDsgLy8gRU9GXG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJjb21tZW50QXRFbmRcIiwgXCIlIGNvbW1lbnQgaGFzIG5vIHRlcm1pbmF0aW5nIG5ld2xpbmU7IExhVGVYIHdvdWxkIFwiICsgXCJmYWlsIGJlY2F1c2Ugb2YgY29tbWVudGluZyB0aGUgZW5kIG9mIG1hdGggbW9kZSAoZS5nLiAkKVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBubEluZGV4ICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4KSk7XG4gIH1cblxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL05hbWVzcGFjZS5qc1xuLyoqXG4gKiBBIGBOYW1lc3BhY2VgIHJlZmVycyB0byBhIHNwYWNlIG9mIG5hbWVhYmxlIHRoaW5ncyBsaWtlIG1hY3JvcyBvciBsZW5ndGhzLFxuICogd2hpY2ggY2FuIGJlIGBzZXRgIGVpdGhlciBnbG9iYWxseSBvciBsb2NhbCB0byBhIG5lc3RlZCBncm91cCwgdXNpbmcgYW5cbiAqIHVuZG8gc3RhY2sgc2ltaWxhciB0byBob3cgVGVYIGltcGxlbWVudHMgdGhpcyBmdW5jdGlvbmFsaXR5LlxuICogUGVyZm9ybWFuY2Utd2lzZSwgYGdldGAgYW5kIGxvY2FsIGBzZXRgIHRha2UgY29uc3RhbnQgdGltZSwgd2hpbGUgZ2xvYmFsXG4gKiBgc2V0YCB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byB0aGUgZGVwdGggb2YgZ3JvdXAgbmVzdGluZy5cbiAqL1xuXG5jbGFzcyBOYW1lc3BhY2Uge1xuICAvKipcbiAgICogQm90aCBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiAgVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBvZlxuICAgKiBidWlsdC1pbiBtYXBwaW5ncyB3aGljaCBuZXZlciBjaGFuZ2UuICBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiBvZiBpbml0aWFsIChnbG9iYWwtbGV2ZWwpIG1hcHBpbmdzLCB3aGljaCB3aWxsIGNvbnN0YW50bHkgY2hhbmdlXG4gICAqIGFjY29yZGluZyB0byBhbnkgZ2xvYmFsL3RvcC1sZXZlbCBgc2V0YHMgZG9uZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJ1aWx0aW5zLCBnbG9iYWxNYWNyb3MpIHtcbiAgICBpZiAoYnVpbHRpbnMgPT09IHZvaWQgMCkge1xuICAgICAgYnVpbHRpbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsTWFjcm9zID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbE1hY3JvcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1aWx0aW5zID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnQgPSBnbG9iYWxNYWNyb3M7XG4gICAgdGhpcy5idWlsdGlucyA9IGJ1aWx0aW5zO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBuZXN0ZWQgZ3JvdXAsIGFmZmVjdGluZyBmdXR1cmUgbG9jYWwgYHNldGBzLlxuICAgKi9cblxuXG4gIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy51bmRlZlN0YWNrLnB1c2goe30pO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgY3VycmVudCBuZXN0ZWQgZ3JvdXAsIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZSBncm91cCBiZWdhbi5cbiAgICovXG5cblxuICBlbmRHcm91cCgpIHtcbiAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5iYWxhbmNlZCBuYW1lc3BhY2UgZGVzdHJ1Y3Rpb246IGF0dGVtcHQgXCIgKyBcInRvIHBvcCBnbG9iYWwgbmFtZXNwYWNlOyBwbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWdcIik7XG4gICAgfVxuXG4gICAgY29uc3QgdW5kZWZzID0gdGhpcy51bmRlZlN0YWNrLnBvcCgpO1xuXG4gICAgZm9yIChjb25zdCB1bmRlZiBpbiB1bmRlZnMpIHtcbiAgICAgIGlmICh1bmRlZnMuaGFzT3duUHJvcGVydHkodW5kZWYpKSB7XG4gICAgICAgIGlmICh1bmRlZnNbdW5kZWZdID09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50W3VuZGVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRbdW5kZWZdID0gdW5kZWZzW3VuZGVmXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5kcyBhbGwgY3VycmVudGx5IG5lc3RlZCBncm91cHMgKGlmIGFueSksIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZVxuICAgKiBncm91cHMgYmVnYW4uICBVc2VmdWwgaW4gY2FzZSBvZiBhbiBlcnJvciBpbiB0aGUgbWlkZGxlIG9mIHBhcnNpbmcuXG4gICAqL1xuXG5cbiAgZW5kR3JvdXBzKCkge1xuICAgIHdoaWxlICh0aGlzLnVuZGVmU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbmRHcm91cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGV0ZWN0IHdoZXRoZXIgYG5hbWVgIGhhcyBhIGRlZmluaXRpb24uICBFcXVpdmFsZW50IHRvXG4gICAqIGBnZXQobmFtZSkgIT0gbnVsbGAuXG4gICAqL1xuXG5cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Lmhhc093blByb3BlcnR5KG5hbWUpIHx8IHRoaXMuYnVpbHRpbnMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIG5hbWUsIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgKlxuICAgKiBOb3RlOiBEbyBub3QgdXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pKWAgdG8gZGV0ZWN0IHdoZXRoZXIgYSBtYWNyb1xuICAgKiBpcyBkZWZpbmVkLCBhcyB0aGUgZGVmaW5pdGlvbiBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyB3aGljaCBldmFsdWF0ZXNcbiAgICogdG8gYGZhbHNlYCBpbiBKYXZhU2NyaXB0LiAgVXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pICE9IG51bGwpYCBvclxuICAgKiBgaWYgKG5hbWVzcGFjZS5oYXMoLi4uKSlgLlxuICAgKi9cblxuXG4gIGdldChuYW1lKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbHRpbnNbbmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBhbmQgb3B0aW9uYWxseSBzZXQgaXQgZ2xvYmFsbHkgdG9vLlxuICAgKiBMb2NhbCBzZXQoKSBzZXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCAod2hlbiBhcHByb3ByaWF0ZSkgYWRkcyBhbiB1bmRvXG4gICAqIG9wZXJhdGlvbiB0byB0aGUgdW5kbyBzdGFjay4gIEdsb2JhbCBzZXQoKSBtYXkgY2hhbmdlIHRoZSB1bmRvXG4gICAqIG9wZXJhdGlvbiBhdCBldmVyeSBsZXZlbCwgc28gdGFrZXMgdGltZSBsaW5lYXIgaW4gdGhlaXIgbnVtYmVyLlxuICAgKiBBIHZhbHVlIG9mIHVuZGVmaW5lZCBtZWFucyB0byBkZWxldGUgZXhpc3RpbmcgZGVmaW5pdGlvbnMuXG4gICAqL1xuXG5cbiAgc2V0KG5hbWUsIHZhbHVlLCBnbG9iYWwpIHtcbiAgICBpZiAoZ2xvYmFsID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIC8vIEdsb2JhbCBzZXQgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIGluIGFsbCBncm91cHMuICBTaW11bGF0ZSB0aGlzXG4gICAgICAvLyBieSBkZXN0cm95aW5nIGFueSB1bmRvcyBjdXJyZW50bHkgc2NoZWR1bGVkIGZvciB0aGlzIG5hbWUsXG4gICAgICAvLyBhbmQgYWRkaW5nIGFuIHVuZG8gd2l0aCB0aGUgKm5ldyogdmFsdWUgKGluIGNhc2UgaXQgbGF0ZXIgZ2V0c1xuICAgICAgLy8gbG9jYWxseSByZXNldCB3aXRoaW4gdGhpcyBlbnZpcm9ubWVudCkuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudW5kZWZTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhpcy51bmRlZlN0YWNrW2ldW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHRoaXMgc2V0IGF0IGVuZCBvZiB0aGlzIGdyb3VwIChwb3NzaWJseSB0byBgdW5kZWZpbmVkYCksXG4gICAgICAvLyB1bmxlc3MgYW4gdW5kbyBpcyBhbHJlYWR5IGluIHBsYWNlLCBpbiB3aGljaCBjYXNlIHRoYXQgb2xkZXJcbiAgICAgIC8vIHZhbHVlIGlzIHRoZSBjb3JyZWN0IG9uZS5cbiAgICAgIGNvbnN0IHRvcCA9IHRoaXMudW5kZWZTdGFja1t0aGlzLnVuZGVmU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICh0b3AgJiYgIXRvcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0b3BbbmFtZV0gPSB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWFjcm9zLmpzXG4vKipcbiAqIFByZWRlZmluZWQgbWFjcm9zIGZvciBLYVRlWC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHNvbWUgY29tbWFuZHMgaW4gdGVybXMgb2Ygb3RoZXJzLlxuICovXG4vLyBFeHBvcnQgZ2xvYmFsIG1hY3JvcyBvYmplY3QgZnJvbSBkZWZpbmVNYWNyb1xuXG5jb25zdCBtYWNyb3MgPSBfbWFjcm9zO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX21hY3JvcyA9IChtYWNyb3MpO1xuXG5cblxuXG5cbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYWNybyB0b29sc1xuXG5kZWZpbmVNYWNybyhcIlxcXFxub2V4cGFuZFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAvLyBUaGUgZXhwYW5zaW9uIGlzIHRoZSB0b2tlbiBpdHNlbGY7IGJ1dCB0aGF0IHRva2VuIGlzIGludGVycHJldGVkXG4gIC8vIGFzIGlmIGl0cyBtZWFuaW5nIHdlcmUg4oCYXFxyZWxheOKAmSBpZiBpdCBpcyBhIGNvbnRyb2wgc2VxdWVuY2UgdGhhdFxuICAvLyB3b3VsZCBvcmRpbmFyaWx5IGJlIGV4cGFuZGVkIGJ5IFRlWOKAmXMgZXhwYW5zaW9uIHJ1bGVzLlxuICBjb25zdCB0ID0gY29udGV4dC5wb3BUb2tlbigpO1xuXG4gIGlmIChjb250ZXh0LmlzRXhwYW5kYWJsZSh0LnRleHQpKSB7XG4gICAgdC5ub2V4cGFuZCA9IHRydWU7XG4gICAgdC50cmVhdEFzUmVsYXggPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IFt0XSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4cGFuZGFmdGVyXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIFRlWCBmaXJzdCByZWFkcyB0aGUgdG9rZW4gdGhhdCBjb21lcyBpbW1lZGlhdGVseSBhZnRlciBcXGV4cGFuZGFmdGVyLFxuICAvLyB3aXRob3V0IGV4cGFuZGluZyBpdDsgbGV04oCZcyBjYWxsIHRoaXMgdG9rZW4gdC4gVGhlbiBUZVggcmVhZHMgdGhlXG4gIC8vIHRva2VuIHRoYXQgY29tZXMgYWZ0ZXIgdCAoYW5kIHBvc3NpYmx5IG1vcmUgdG9rZW5zLCBpZiB0aGF0IHRva2VuXG4gIC8vIGhhcyBhbiBhcmd1bWVudCksIHJlcGxhY2luZyBpdCBieSBpdHMgZXhwYW5zaW9uLiBGaW5hbGx5IFRlWCBwdXRzXG4gIC8vIHQgYmFjayBpbiBmcm9udCBvZiB0aGF0IGV4cGFuc2lvbi5cbiAgY29uc3QgdCA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgY29udGV4dC5leHBhbmRPbmNlKHRydWUpOyAvLyBleHBhbmQgb25seSBhbiBleHBhbmRhYmxlIHRva2VuXG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IFt0XSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBmaXJzdG9mdHdveyMxfXsjMn0gZXhwYW5kcyB0byAjMSwgc2tpcHBpbmcgIzJcbi8vIFRlWCBzb3VyY2U6IFxcbG9uZ1xcZGVmXFxAZmlyc3RvZnR3byMxIzJ7IzF9XG5cbmRlZmluZU1hY3JvKFwiXFxcXEBmaXJzdG9mdHdvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogYXJnc1swXSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBzZWNvbmRvZnR3b3sjMX17IzJ9IGV4cGFuZHMgdG8gIzIsIHNraXBwaW5nICMxXG4vLyBUZVggc291cmNlOiBcXGxvbmdcXGRlZlxcQHNlY29uZG9mdHdvIzEjMnsjMn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQHNlY29uZG9mdHdvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogYXJnc1sxXSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBpZm5leHRjaGFyeyMxfXsjMn17IzN9IGxvb2tzIGFoZWFkIHRvIHRoZSBuZXh0ICh1bmV4cGFuZGVkKVxuLy8gc3ltYm9sIHRoYXQgaXNuJ3QgYSBzcGFjZSwgY29uc3VtaW5nIGFueSBzcGFjZXMgYnV0IG5vdCBjb25zdW1pbmcgdGhlXG4vLyBmaXJzdCBub25zcGFjZSBjaGFyYWN0ZXIuICBJZiB0aGF0IG5vbnNwYWNlIGNoYXJhY3RlciBtYXRjaGVzICMxLCB0aGVuXG4vLyB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMjsgb3RoZXJ3aXNlLCBpdCBleHBhbmRzIHRvICMzLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxAaWZuZXh0Y2hhclwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygzKTsgLy8gc3ltYm9sLCBpZiwgZWxzZVxuXG4gIGNvbnRleHQuY29uc3VtZVNwYWNlcygpO1xuICBjb25zdCBuZXh0VG9rZW4gPSBjb250ZXh0LmZ1dHVyZSgpO1xuXG4gIGlmIChhcmdzWzBdLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdWzBdLnRleHQgPT09IG5leHRUb2tlbi50ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1sxXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IGFyZ3NbMl0sXG4gICAgICBudW1BcmdzOiAwXG4gICAgfTtcbiAgfVxufSk7IC8vIExhVGVYJ3MgXFxAaWZzdGFyeyMxfXsjMn0gbG9va3MgYWhlYWQgdG8gdGhlIG5leHQgKHVuZXhwYW5kZWQpIHN5bWJvbC5cbi8vIElmIGl0IGlzIGAqYCwgdGhlbiBpdCBjb25zdW1lcyB0aGUgc3ltYm9sLCBhbmQgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzE7XG4vLyBvdGhlcndpc2UsIHRoZSBtYWNybyBleHBhbmRzIHRvICMyICh3aXRob3V0IGNvbnN1bWluZyB0aGUgc3ltYm9sKS5cbi8vIFRlWCBzb3VyY2U6IFxcZGVmXFxAaWZzdGFyIzF7XFxAaWZuZXh0Y2hhciAqe1xcQGZpcnN0b2Z0d297IzF9fX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmc3RhclwiLCBcIlxcXFxAaWZuZXh0Y2hhciAqe1xcXFxAZmlyc3RvZnR3b3sjMX19XCIpOyAvLyBMYVRlWCdzIFxcVGV4dE9yTWF0aHsjMX17IzJ9IGV4cGFuZHMgdG8gIzEgaW4gdGV4dCBtb2RlLCAjMiBpbiBtYXRoIG1vZGVcblxuZGVmaW5lTWFjcm8oXCJcXFxcVGV4dE9yTWF0aFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcblxuICBpZiAoY29udGV4dC5tb2RlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiBhcmdzWzBdLFxuICAgICAgbnVtQXJnczogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1sxXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9XG59KTsgLy8gTG9va3VwIHRhYmxlIGZvciBwYXJzaW5nIG51bWJlcnMgaW4gYmFzZSA4IHRocm91Z2ggMTZcblxuY29uc3QgZGlnaXRUb051bWJlciA9IHtcbiAgXCIwXCI6IDAsXG4gIFwiMVwiOiAxLFxuICBcIjJcIjogMixcbiAgXCIzXCI6IDMsXG4gIFwiNFwiOiA0LFxuICBcIjVcIjogNSxcbiAgXCI2XCI6IDYsXG4gIFwiN1wiOiA3LFxuICBcIjhcIjogOCxcbiAgXCI5XCI6IDksXG4gIFwiYVwiOiAxMCxcbiAgXCJBXCI6IDEwLFxuICBcImJcIjogMTEsXG4gIFwiQlwiOiAxMSxcbiAgXCJjXCI6IDEyLFxuICBcIkNcIjogMTIsXG4gIFwiZFwiOiAxMyxcbiAgXCJEXCI6IDEzLFxuICBcImVcIjogMTQsXG4gIFwiRVwiOiAxNCxcbiAgXCJmXCI6IDE1LFxuICBcIkZcIjogMTVcbn07IC8vIFRlWCBcXGNoYXIgbWFrZXMgYSBsaXRlcmFsIGNoYXJhY3RlciAoY2F0Y29kZSAxMikgdXNpbmcgdGhlIGZvbGxvd2luZyBmb3Jtczpcbi8vIChzZWUgVGhlIFRlWEJvb2ssIHAuIDQzKVxuLy8gICBcXGNoYXIxMjMgIC0tIGRlY2ltYWxcbi8vICAgXFxjaGFyJzEyMyAtLSBvY3RhbFxuLy8gICBcXGNoYXJcIjEyMyAtLSBoZXhcbi8vICAgXFxjaGFyYHggICAtLSBjaGFyYWN0ZXIgdGhhdCBjYW4gYmUgd3JpdHRlbiAoaS5lLiBpc24ndCBhY3RpdmUpXG4vLyAgIFxcY2hhcmBcXHggIC0tIGNoYXJhY3RlciB0aGF0IGNhbm5vdCBiZSB3cml0dGVuIChlLmcuICUpXG4vLyBUaGVzZSBhbGwgcmVmZXIgdG8gY2hhcmFjdGVycyBmcm9tIHRoZSBmb250LCBzbyB3ZSB0dXJuIHRoZW0gaW50byBzcGVjaWFsXG4vLyBjYWxscyB0byBhIGZ1bmN0aW9uIFxcQGNoYXIgZGVhbHQgd2l0aCBpbiB0aGUgUGFyc2VyLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxjaGFyXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGxldCB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgbGV0IGJhc2U7XG4gIGxldCBudW1iZXIgPSAnJztcblxuICBpZiAodG9rZW4udGV4dCA9PT0gXCInXCIpIHtcbiAgICBiYXNlID0gODtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSAnXCInKSB7XG4gICAgYmFzZSA9IDE2O1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09IFwiYFwiKSB7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG5cbiAgICBpZiAodG9rZW4udGV4dFswXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIG51bWJlciA9IHRva2VuLnRleHQuY2hhckNvZGVBdCgxKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxjaGFyYCBtaXNzaW5nIGFyZ3VtZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1iZXIgPSB0b2tlbi50ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2UgPSAxMDtcbiAgfVxuXG4gIGlmIChiYXNlKSB7XG4gICAgLy8gUGFyc2UgYSBudW1iZXIgaW4gdGhlIGdpdmVuIGJhc2UsIHN0YXJ0aW5nIHdpdGggZmlyc3QgYHRva2VuYC5cbiAgICBudW1iZXIgPSBkaWdpdFRvTnVtYmVyW3Rva2VuLnRleHRdO1xuXG4gICAgaWYgKG51bWJlciA9PSBudWxsIHx8IG51bWJlciA+PSBiYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGJhc2UtXCIgKyBiYXNlICsgXCIgZGlnaXQgXCIgKyB0b2tlbi50ZXh0KTtcbiAgICB9XG5cbiAgICBsZXQgZGlnaXQ7XG5cbiAgICB3aGlsZSAoKGRpZ2l0ID0gZGlnaXRUb051bWJlcltjb250ZXh0LmZ1dHVyZSgpLnRleHRdKSAhPSBudWxsICYmIGRpZ2l0IDwgYmFzZSkge1xuICAgICAgbnVtYmVyICo9IGJhc2U7XG4gICAgICBudW1iZXIgKz0gZGlnaXQ7XG4gICAgICBjb250ZXh0LnBvcFRva2VuKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXFxcXEBjaGFye1wiICsgbnVtYmVyICsgXCJ9XCI7XG59KTsgLy8gXFxuZXdjb21tYW5ke1xcbWFjcm99W2FyZ3Nde2RlZmluaXRpb259XG4vLyBcXHJlbmV3Y29tbWFuZHtcXG1hY3JvfVthcmdzXXtkZWZpbml0aW9ufVxuLy8gVE9ETzogT3B0aW9uYWwgYXJndW1lbnRzOiBcXG5ld2NvbW1hbmR7XFxtYWNyb31bYXJnc11bZGVmYXVsdF17ZGVmaW5pdGlvbn1cblxuY29uc3QgbmV3Y29tbWFuZCA9IChjb250ZXh0LCBleGlzdHNPSywgbm9uZXhpc3RzT0ssIHNraXBJZkV4aXN0cykgPT4ge1xuICBsZXQgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuXG4gIGlmIChhcmcubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXG5ld2NvbW1hbmQncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgbWFjcm8gbmFtZVwiKTtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBhcmdbMF0udGV4dDtcbiAgY29uc3QgZXhpc3RzID0gY29udGV4dC5pc0RlZmluZWQobmFtZSk7XG5cbiAgaWYgKGV4aXN0cyAmJiAhZXhpc3RzT0spIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcbmV3Y29tbWFuZHtcIiArIG5hbWUgKyBcIn0gYXR0ZW1wdGluZyB0byByZWRlZmluZSBcIiArIChuYW1lICsgXCI7IHVzZSBcXFxccmVuZXdjb21tYW5kXCIpKTtcbiAgfVxuXG4gIGlmICghZXhpc3RzICYmICFub25leGlzdHNPSykge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxyZW5ld2NvbW1hbmR7XCIgKyBuYW1lICsgXCJ9IHdoZW4gY29tbWFuZCBcIiArIG5hbWUgKyBcIiBcIiArIFwiZG9lcyBub3QgeWV0IGV4aXN0OyB1c2UgXFxcXG5ld2NvbW1hbmRcIik7XG4gIH1cblxuICBsZXQgbnVtQXJncyA9IDA7XG4gIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcblxuICBpZiAoYXJnLmxlbmd0aCA9PT0gMSAmJiBhcmdbMF0udGV4dCA9PT0gXCJbXCIpIHtcbiAgICBsZXQgYXJnVGV4dCA9ICcnO1xuICAgIGxldCB0b2tlbiA9IGNvbnRleHQuZXhwYW5kTmV4dFRva2VuKCk7XG5cbiAgICB3aGlsZSAodG9rZW4udGV4dCAhPT0gXCJdXCIgJiYgdG9rZW4udGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgLy8gVE9ETzogU2hvdWxkIHByb3Blcmx5IGV4cGFuZCBhcmcsIGUuZy4sIGlnbm9yZSB7fXNcbiAgICAgIGFyZ1RleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgIHRva2VuID0gY29udGV4dC5leHBhbmROZXh0VG9rZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoIWFyZ1RleHQubWF0Y2goL15cXHMqWzAtOV0rXFxzKiQvKSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzOiBcIiArIGFyZ1RleHQpO1xuICAgIH1cblxuICAgIG51bUFyZ3MgPSBwYXJzZUludChhcmdUZXh0KTtcbiAgICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIH1cblxuICBpZiAoIShleGlzdHMgJiYgc2tpcElmRXhpc3RzKSkge1xuICAgIC8vIEZpbmFsIGFyZyBpcyB0aGUgZXhwYW5zaW9uIG9mIHRoZSBtYWNyb1xuICAgIGNvbnRleHQubWFjcm9zLnNldChuYW1lLCB7XG4gICAgICB0b2tlbnM6IGFyZyxcbiAgICAgIG51bUFyZ3NcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbmRlZmluZU1hY3JvKFwiXFxcXG5ld2NvbW1hbmRcIiwgY29udGV4dCA9PiBuZXdjb21tYW5kKGNvbnRleHQsIGZhbHNlLCB0cnVlLCBmYWxzZSkpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVuZXdjb21tYW5kXCIsIGNvbnRleHQgPT4gbmV3Y29tbWFuZChjb250ZXh0LCB0cnVlLCBmYWxzZSwgZmFsc2UpKTtcbmRlZmluZU1hY3JvKFwiXFxcXHByb3ZpZGVjb21tYW5kXCIsIGNvbnRleHQgPT4gbmV3Y29tbWFuZChjb250ZXh0LCB0cnVlLCB0cnVlLCB0cnVlKSk7IC8vIHRlcm1pbmFsIChjb25zb2xlKSB0b29sc1xuXG5kZWZpbmVNYWNybyhcIlxcXFxtZXNzYWdlXCIsIGNvbnRleHQgPT4ge1xuICBjb25zdCBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gIGNvbnNvbGUubG9nKGFyZy5yZXZlcnNlKCkubWFwKHRva2VuID0+IHRva2VuLnRleHQpLmpvaW4oXCJcIikpO1xuICByZXR1cm4gJyc7XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGVycm1lc3NhZ2VcIiwgY29udGV4dCA9PiB7XG4gIGNvbnN0IGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgY29uc29sZS5lcnJvcihhcmcucmV2ZXJzZSgpLm1hcCh0b2tlbiA9PiB0b2tlbi50ZXh0KS5qb2luKFwiXCIpKTtcbiAgcmV0dXJuICcnO1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxzaG93XCIsIGNvbnRleHQgPT4ge1xuICBjb25zdCB0b2sgPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIGNvbnN0IG5hbWUgPSB0b2sudGV4dDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuICBjb25zb2xlLmxvZyh0b2ssIGNvbnRleHQubWFjcm9zLmdldChuYW1lKSwgc3JjX2Z1bmN0aW9uc1tuYW1lXSwgc3JjX3N5bWJvbHMubWF0aFtuYW1lXSwgc3JjX3N5bWJvbHMudGV4dFtuYW1lXSk7XG4gIHJldHVybiAnJztcbn0pOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBHcm91cGluZ1xuLy8gXFxsZXRcXGJncm91cD17IFxcbGV0XFxlZ3JvdXA9fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxiZ3JvdXBcIiwgXCJ7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZWdyb3VwXCIsIFwifVwiKTsgLy8gU3ltYm9scyBmcm9tIGxhdGV4Lmx0eDpcbi8vIFxcZGVmfntcXG5vYnJlYWtzcGFjZXt9fVxuLy8gXFxkZWZcXGxxe2B9XG4vLyBcXGRlZlxccnF7J31cbi8vIFxcZGVmIFxcYWEge1xcciBhfVxuLy8gXFxkZWYgXFxBQSB7XFxyIEF9XG5cbmRlZmluZU1hY3JvKFwiflwiLCBcIlxcXFxub2JyZWFrc3BhY2VcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxscVwiLCBcImBcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxycVwiLCBcIidcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhYVwiLCBcIlxcXFxyIGFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxBQVwiLCBcIlxcXFxyIEFcIik7IC8vIENvcHlyaWdodCAoQykgYW5kIHJlZ2lzdGVyZWQgKFIpIHN5bWJvbHMuIFVzZSByYXcgc3ltYm9sIGluIE1hdGhNTC5cbi8vIFxcRGVjbGFyZVRleHRDb21tYW5kRGVmYXVsdHtcXHRleHRjb3B5cmlnaHR9e1xcdGV4dGNpcmNsZWR7Y319XG4vLyBcXERlY2xhcmVUZXh0Q29tbWFuZERlZmF1bHR7XFx0ZXh0cmVnaXN0ZXJlZH17XFx0ZXh0Y2lyY2xlZHslXG4vLyAgICAgIFxcY2hlY2tAbWF0aGZvbnRzXFxmb250c2l6ZVxcc2ZAc2l6ZVxcekBcXG1hdGhAZm9udHNmYWxzZVxcc2VsZWN0Zm9udCBSfX1cbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFxjb3B5cmlnaHR9eyVcbi8vICAgIFxcaWZtbW9kZXtcXG5mc3NAdGV4dHtcXHRleHRjb3B5cmlnaHR9fVxcZWxzZVxcdGV4dGNvcHlyaWdodFxcZml9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHRleHRjb3B5cmlnaHRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHRleHRjaXJjbGVke2N9fXtcXFxcY2hhcmDCqX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb3B5cmlnaHRcIiwgXCJcXFxcVGV4dE9yTWF0aHtcXFxcdGV4dGNvcHlyaWdodH17XFxcXHRleHR7XFxcXHRleHRjb3B5cmlnaHR9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRleHRyZWdpc3RlcmVkXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFx0ZXh0Y2lyY2xlZHtcXFxcc2NyaXB0c2l6ZSBSfX17XFxcXGNoYXJgwq59XCIpOyAvLyBDaGFyYWN0ZXJzIG9taXR0ZWQgZnJvbSBVbmljb2RlIHJhbmdlIDFENDAw4oCTMUQ3RkZcblxuZGVmaW5lTWFjcm8oXCJcXHUyMTJDXCIsIFwiXFxcXG1hdGhzY3J7Qn1cIik7IC8vIHNjcmlwdFxuXG5kZWZpbmVNYWNybyhcIlxcdTIxMzBcIiwgXCJcXFxcbWF0aHNjcntFfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEzMVwiLCBcIlxcXFxtYXRoc2Nye0Z9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTBCXCIsIFwiXFxcXG1hdGhzY3J7SH1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMTBcIiwgXCJcXFxcbWF0aHNjcntJfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjExMlwiLCBcIlxcXFxtYXRoc2Nye0x9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTMzXCIsIFwiXFxcXG1hdGhzY3J7TX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMUJcIiwgXCJcXFxcbWF0aHNjcntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEyRFwiLCBcIlxcXFxtYXRoZnJha3tDfVwiKTsgLy8gRnJha3R1clxuXG5kZWZpbmVNYWNybyhcIlxcdTIxMENcIiwgXCJcXFxcbWF0aGZyYWt7SH1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMjhcIiwgXCJcXFxcbWF0aGZyYWt7Wn1cIik7IC8vIERlZmluZSBcXEJiYmsgd2l0aCBhIG1hY3JvIHRoYXQgd29ya3MgaW4gYm90aCBIVE1MIGFuZCBNYXRoTUwuXG5cbmRlZmluZU1hY3JvKFwiXFxcXEJiYmtcIiwgXCJcXFxcQmJie2t9XCIpOyAvLyBVbmljb2RlIG1pZGRsZSBkb3Rcbi8vIFRoZSBLYVRlWCBmb250cyBkbyBub3QgY29udGFpbiBVKzAwQjcuIEluc3RlYWQsIFxcY2RvdHAgZGlzcGxheXNcbi8vIHRoZSBkb3QgYXQgVSsyMkM1IGFuZCBnaXZlcyBpdCBwdW5jdCBzcGFjaW5nLlxuXG5kZWZpbmVNYWNybyhcIlxcdTAwYjdcIiwgXCJcXFxcY2RvdHBcIik7IC8vIFxcbGxhcCBhbmQgXFxybGFwIHJlbmRlciB0aGVpciBjb250ZW50cyBpbiB0ZXh0IG1vZGVcblxuZGVmaW5lTWFjcm8oXCJcXFxcbGxhcFwiLCBcIlxcXFxtYXRobGxhcHtcXFxcdGV4dHJteyMxfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxybGFwXCIsIFwiXFxcXG1hdGhybGFwe1xcXFx0ZXh0cm17IzF9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNsYXBcIiwgXCJcXFxcbWF0aGNsYXB7XFxcXHRleHRybXsjMX19XCIpOyAvLyBcXG1hdGhzdHJ1dCBmcm9tIHRoZSBUZVhib29rLCBwIDM2MFxuXG5kZWZpbmVNYWNybyhcIlxcXFxtYXRoc3RydXRcIiwgXCJcXFxcdnBoYW50b217KH1cIik7IC8vIFxcdW5kZXJiYXIgZnJvbSBUZVhib29rIHAgMzUzXG5cbmRlZmluZU1hY3JvKFwiXFxcXHVuZGVyYmFyXCIsIFwiXFxcXHVuZGVybGluZXtcXFxcdGV4dHsjMX19XCIpOyAvLyBcXG5vdCBpcyBkZWZpbmVkIGJ5IGJhc2UvZm9udG1hdGgubHR4IHZpYVxuLy8gXFxEZWNsYXJlTWF0aFN5bWJvbHtcXG5vdH17XFxtYXRocmVsfXtzeW1ib2xzfXtcIjM2fVxuLy8gSXQncyB0aHVzIHRyZWF0ZWQgbGlrZSBhIFxcbWF0aHJlbCwgYnV0IGRlZmluZWQgYnkgYSBzeW1ib2wgdGhhdCBoYXMgemVyb1xuLy8gd2lkdGggYnV0IGV4dGVuZHMgdG8gdGhlIHJpZ2h0LiAgV2UgdXNlIFxccmxhcCB0byBnZXQgdGhhdCBzcGFjaW5nLlxuLy8gRm9yIE1hdGhNTCB3ZSB3cml0ZSBVKzAzMzggaGVyZS4gYnVpbGRNYXRoTUwuanMgd2lsbCB0aGVuIGRvIHRoZSBvdmVybGF5LlxuXG5kZWZpbmVNYWNybyhcIlxcXFxub3RcIiwgJ1xcXFxodG1sQG1hdGhtbHtcXFxcbWF0aHJlbHtcXFxcbWF0aHJsYXBcXFxcQG5vdH19e1xcXFxjaGFyXCIzMzh9Jyk7IC8vIE5lZ2F0ZWQgc3ltYm9scyBmcm9tIGJhc2UvZm9udG1hdGgubHR4OlxuLy8gXFxkZWZcXG5lcXtcXG5vdD19IFxcbGV0XFxuZT1cXG5lcVxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxuLy8gICBcXG5vdGlue1xcbWF0aHJlbHtcXG1AdGhcXG1hdGhwYWxldHRlXFxjQG5jZWxcXGlufX1cbi8vIFxcZGVmXFxjQG5jZWwjMSMye1xcbUB0aFxcb29hbGlnbnskXFxoZmlsIzFcXG1rZXJuMW11L1xcaGZpbCRcXGNyY3IkIzEjMiR9fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxuZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXG1hdGhyZWx7XFxcXG5vdD19fXtcXFxcbWF0aHJlbHtcXFxcY2hhcmDiiaB9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5lXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjI2MFwiLCBcIlxcXFxuZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxub3RpblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcbWF0aHJlbHt7XFxcXGlufVxcXFxtYXRobGxhcHsvXFxcXG1za2lwMW11fX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmDiiIl9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjIwOVwiLCBcIlxcXFxub3RpblwiKTsgLy8gVW5pY29kZSBzdGFja2VkIHJlbGF0aW9uc1xuXG5kZWZpbmVNYWNybyhcIlxcdTIyNThcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVsez1cXFxca2VybnstMWVtfVxcXFxyYWlzZWJveHswLjRlbX17JFxcXFxzY3JpcHRzaXplXFxcXGZyb3duJH19XCIgKyBcIn17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1OH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjU5XCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFx3ZWRnZX17PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNTh9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjI1QVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcc3RhY2tyZWx7XFxcXHRpbnlcXFxcdmVlfXs9fX17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1QX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVCXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcc2NyaXB0c2l6ZVxcXFxzdGFyfXs9fX1cIiArIFwie1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNUJ9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjI1RFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcc3RhY2tyZWx7XFxcXHRpbnlcXFxcbWF0aHJte2RlZn19ez19fVwiICsgXCJ7XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1RH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVFXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFxtYXRocm17bX19ez19fVwiICsgXCJ7XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1RX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVGXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueT99ez19fXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVGfX1cIik7IC8vIE1pc2MgVW5pY29kZVxuXG5kZWZpbmVNYWNybyhcIlxcdTI3QzJcIiwgXCJcXFxccGVycFwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjAzQ1wiLCBcIlxcXFxtYXRoY2xvc2V7IVxcXFxta2Vybi0wLjhtdSF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjBDXCIsIFwiXFxcXG5vdG5pXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMzFDXCIsIFwiXFxcXHVsY29ybmVyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMzFEXCIsIFwiXFxcXHVyY29ybmVyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMzFFXCIsIFwiXFxcXGxsY29ybmVyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMzFGXCIsIFwiXFxcXGxyY29ybmVyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUwMEE5XCIsIFwiXFxcXGNvcHlyaWdodFwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MDBBRVwiLCBcIlxcXFx0ZXh0cmVnaXN0ZXJlZFwiKTtcbmRlZmluZU1hY3JvKFwiXFx1RkUwRlwiLCBcIlxcXFx0ZXh0cmVnaXN0ZXJlZFwiKTsgLy8gVGhlIEthVGVYIGZvbnRzIGhhdmUgY29ybmVycyBhdCBjb2RlcG9pbnRzIHRoYXQgZG9uJ3QgbWF0Y2ggVW5pY29kZS5cbi8vIEZvciBNYXRoTUwgcHVycG9zZXMsIHVzZSB0aGUgVW5pY29kZSBjb2RlIHBvaW50LlxuXG5kZWZpbmVNYWNybyhcIlxcXFx1bGNvcm5lclwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHVsY29ybmVyfXtcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIzMWN9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVyY29ybmVyXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdXJjb3JuZXJ9e1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjMxZH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGxjb3JuZXJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBsbGNvcm5lcn17XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMzFlfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxscmNvcm5lclwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGxyY29ybmVyfXtcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIzMWZ9fVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTGFUZVhfMs61XG4vLyBcXHZkb3Rze1xcdmJveHtcXGJhc2VsaW5lc2tpcDRcXHBAICBcXGxpbmVza2lwbGltaXRcXHpAXG4vLyBcXGtlcm42XFxwQFxcaGJveHsufVxcaGJveHsufVxcaGJveHsufX19XG4vLyBXZSdsbCBjYWxsIFxcdmFydmRvdHMsIHdoaWNoIGdldHMgYSBnbHlwaCBmcm9tIHN5bWJvbHMuanMuXG4vLyBUaGUgemVyby13aWR0aCBydWxlIGdldHMgdXMgYW4gZXF1aXZhbGVudCB0byB0aGUgdmVydGljYWwgNnB0IGtlcm4uXG5cbmRlZmluZU1hY3JvKFwiXFxcXHZkb3RzXCIsIFwie1xcXFx2YXJ2ZG90c1xcXFxydWxlezBwdH17MTVwdH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMmVlXCIsIFwiXFxcXHZkb3RzXCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBhbXNtYXRoLnN0eVxuLy8gaHR0cDovL21pcnJvcnMuY29uY2VydHBhc3MuY29tL3RleC1hcmNoaXZlL21hY3Jvcy9sYXRleC9yZXF1aXJlZC9hbXNtYXRoL2Ftc21hdGgucGRmXG4vLyBJdGFsaWMgR3JlZWsgY2FwaXRhbCBsZXR0ZXJzLiAgQU1TIGRlZmluZXMgdGhlc2Ugd2l0aCBcXERlY2xhcmVNYXRoU3ltYm9sLFxuLy8gYnV0IHRoZXkgYXJlIGVxdWl2YWxlbnQgdG8gXFxtYXRoaXR7XFxMZXR0ZXJ9LlxuXG5kZWZpbmVNYWNybyhcIlxcXFx2YXJHYW1tYVwiLCBcIlxcXFxtYXRoaXR7XFxcXEdhbW1hfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhckRlbHRhXCIsIFwiXFxcXG1hdGhpdHtcXFxcRGVsdGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyVGhldGFcIiwgXCJcXFxcbWF0aGl0e1xcXFxUaGV0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJMYW1iZGFcIiwgXCJcXFxcbWF0aGl0e1xcXFxMYW1iZGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyWGlcIiwgXCJcXFxcbWF0aGl0e1xcXFxYaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJQaVwiLCBcIlxcXFxtYXRoaXR7XFxcXFBpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclNpZ21hXCIsIFwiXFxcXG1hdGhpdHtcXFxcU2lnbWF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyVXBzaWxvblwiLCBcIlxcXFxtYXRoaXR7XFxcXFVwc2lsb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyUGhpXCIsIFwiXFxcXG1hdGhpdHtcXFxcUGhpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclBzaVwiLCBcIlxcXFxtYXRoaXR7XFxcXFBzaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJPbWVnYVwiLCBcIlxcXFxtYXRoaXR7XFxcXE9tZWdhfVwiKTsgLy9cXG5ld2NvbW1hbmR7XFxzdWJzdGFja31bMV17XFxzdWJhcnJheXtjfSMxXFxlbmRzdWJhcnJheX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcc3Vic3RhY2tcIiwgXCJcXFxcYmVnaW57c3ViYXJyYXl9e2N9IzFcXFxcZW5ke3N1YmFycmF5fVwiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFxjb2xvbn17XFxub2JyZWFrXFxtc2tpcDJtdVxcbWF0aHB1bmN0e31cXG5vbnNjcmlwdFxuLy8gXFxta2Vybi1cXHRoaW5tdXNraXB7On1cXG1za2lwNm11cGx1czFtdVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uXCIsIFwiXFxcXG5vYnJlYWtcXFxcbXNraXAybXVcXFxcbWF0aHB1bmN0e31cIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1rZXJuLTNtdX17XFxcXG1rZXJuLTNtdX17fXt9ezp9XFxcXG1za2lwNm11XFxcXHJlbGF4XCIpOyAvLyBcXG5ld2NvbW1hbmR7XFxib3hlZH1bMV17XFxmYm94e1xcbUB0aCRcXGRpc3BsYXlzdHlsZSMxJH19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJveGVkXCIsIFwiXFxcXGZib3h7JFxcXFxkaXNwbGF5c3R5bGV7IzF9JH1cIik7IC8vIFxcZGVmXFxpZmZ7XFxET1RTQlxcO1xcTG9uZ2xlZnRyaWdodGFycm93XFw7fVxuLy8gXFxkZWZcXGltcGxpZXN7XFxET1RTQlxcO1xcTG9uZ3JpZ2h0YXJyb3dcXDt9XG4vLyBcXGRlZlxcaW1wbGllZGJ5e1xcRE9UU0JcXDtcXExvbmdsZWZ0YXJyb3dcXDt9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGlmZlwiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdsZWZ0cmlnaHRhcnJvd1xcXFw7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1wbGllc1wiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdyaWdodGFycm93XFxcXDtcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbXBsaWVkYnlcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25nbGVmdGFycm93XFxcXDtcIik7IC8vIFxcZGVmXFxkZGRvdCMxe3tcXG1hdGhvcHsjMX1cXGxpbWl0c157XFx2Ym94IHRvLTEuNFxcZXhAe1xca2Vybi1cXHR3QFxcZXhAXG4vLyAgXFxoYm94e1xcbm9ybWFsZm9udCAuLi59XFx2c3N9fX19XG4vLyBXZSB1c2UgXFxvdmVyc2V0IHdoaWNoIGF2b2lkcyB0aGUgdmVydGljYWwgc2hpZnQgb2YgXFxtYXRob3AuXG5cbmRlZmluZU1hY3JvKFwiXFxcXGRkZG90XCIsIFwie1xcXFxvdmVyc2V0e1xcXFxyYWlzZWJveHstMC4xZXh9e1xcXFxub3JtYWxzaXplIC4uLn19eyMxfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkZGRkb3RcIiwgXCJ7XFxcXG92ZXJzZXR7XFxcXHJhaXNlYm94ey0wLjFleH17XFxcXG5vcm1hbHNpemUgLi4uLn19eyMxfX1cIik7IC8vIEFNU01hdGgncyBhdXRvbWF0aWMgXFxkb3RzLCBiYXNlZCBvbiBcXG1kb3RzQEAgbWFjcm8uXG5cbmNvbnN0IGRvdHNCeVRva2VuID0ge1xuICAnLCc6ICdcXFxcZG90c2MnLFxuICAnXFxcXG5vdCc6ICdcXFxcZG90c2InLFxuICAvLyBcXGtleWJpbkAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICAnKyc6ICdcXFxcZG90c2InLFxuICAnPSc6ICdcXFxcZG90c2InLFxuICAnPCc6ICdcXFxcZG90c2InLFxuICAnPic6ICdcXFxcZG90c2InLFxuICAnLSc6ICdcXFxcZG90c2InLFxuICAnKic6ICdcXFxcZG90c2InLFxuICAnOic6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTQjpcbiAgJ1xcXFxET1RTQic6ICdcXFxcZG90c2InLFxuICAnXFxcXGNvcHJvZCc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3ZlZSc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3dlZGdlJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlndXBsdXMnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdjYXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdjdXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxwcm9kJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcc3VtJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnb3RpbWVzJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnb3BsdXMnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdvZG90JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnc3FjdXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxBbmQnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25ncmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXExvbmdyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ2xlZnRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXExvbmdsZWZ0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25nbGVmdHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxMb25nbGVmdHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxtYXBzdG8nOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25nbWFwc3RvJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcaG9va3JpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxkb3RlcSc6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxtYXRoYmluOlxuICAnXFxcXG1hdGhiaW4nOiAnXFxcXGRvdHNiJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcbWF0aHJlbDpcbiAgJ1xcXFxtYXRocmVsJzogJ1xcXFxkb3RzYicsXG4gICdcXFxccmVsYmFyJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcUmVsYmFyJzogJ1xcXFxkb3RzYicsXG4gICdcXFxceHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFx4bGVmdGFycm93JzogJ1xcXFxkb3RzYicsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNJOlxuICAnXFxcXERPVFNJJzogJ1xcXFxkb3RzaScsXG4gICdcXFxcaW50JzogJ1xcXFxkb3RzaScsXG4gICdcXFxcb2ludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlpbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpaWludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlpaWludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlkb3RzaW50JzogJ1xcXFxkb3RzaScsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNYOlxuICAnXFxcXERPVFNYJzogJ1xcXFxkb3RzeCdcbn07XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIFRPRE86IElmIHVzZWQgaW4gdGV4dCBtb2RlLCBzaG91bGQgZXhwYW5kIHRvIFxcdGV4dGVsbGlwc2lzLlxuICAvLyBIb3dldmVyLCBpbiBLYVRlWCwgXFx0ZXh0ZWxsaXBzaXMgYW5kIFxcbGRvdHMgYmVoYXZlIHRoZSBzYW1lXG4gIC8vIChpbiB0ZXh0IG1vZGUpLCBhbmQgaXQncyB1bmxpa2VseSB3ZSdkIHNlZSBhbnkgb2YgdGhlIG1hdGggY29tbWFuZHNcbiAgLy8gdGhhdCBhZmZlY3QgdGhlIGJlaGF2aW9yIG9mIFxcZG90cyB3aGVuIGluIHRleHQgbW9kZS4gIFNvIGZpbmUgZm9yIG5vd1xuICAvLyAodW50aWwgd2Ugc3VwcG9ydCBcXGlmbW1vZGUgLi4uIFxcZWxzZSAuLi4gXFxmaSkuXG4gIGxldCB0aGVkb3RzID0gJ1xcXFxkb3Rzbyc7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmV4cGFuZEFmdGVyRnV0dXJlKCkudGV4dDtcblxuICBpZiAobmV4dCBpbiBkb3RzQnlUb2tlbikge1xuICAgIHRoZWRvdHMgPSBkb3RzQnlUb2tlbltuZXh0XTtcbiAgfSBlbHNlIGlmIChuZXh0LnNsaWNlKDAsIDQpID09PSAnXFxcXG5vdCcpIHtcbiAgICB0aGVkb3RzID0gJ1xcXFxkb3RzYic7XG4gIH0gZWxzZSBpZiAobmV4dCBpbiBzcmNfc3ltYm9scy5tYXRoKSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKFsnYmluJywgJ3JlbCddLCBzcmNfc3ltYm9scy5tYXRoW25leHRdLmdyb3VwKSkge1xuICAgICAgdGhlZG90cyA9ICdcXFxcZG90c2InO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGVkb3RzO1xufSk7XG5jb25zdCBzcGFjZUFmdGVyRG90cyA9IHtcbiAgLy8gXFxyaWdodGRlbGltQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICcpJzogdHJ1ZSxcbiAgJ10nOiB0cnVlLFxuICAnXFxcXHJicmFjayc6IHRydWUsXG4gICdcXFxcfSc6IHRydWUsXG4gICdcXFxccmJyYWNlJzogdHJ1ZSxcbiAgJ1xcXFxyYW5nbGUnOiB0cnVlLFxuICAnXFxcXHJjZWlsJzogdHJ1ZSxcbiAgJ1xcXFxyZmxvb3InOiB0cnVlLFxuICAnXFxcXHJncm91cCc6IHRydWUsXG4gICdcXFxccm1vdXN0YWNoZSc6IHRydWUsXG4gICdcXFxccmlnaHQnOiB0cnVlLFxuICAnXFxcXGJpZ3InOiB0cnVlLFxuICAnXFxcXGJpZ2dyJzogdHJ1ZSxcbiAgJ1xcXFxCaWdyJzogdHJ1ZSxcbiAgJ1xcXFxCaWdncic6IHRydWUsXG4gIC8vIFxcZXh0cmFAIGFsc28gdGVzdHMgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICckJzogdHJ1ZSxcbiAgLy8gXFxleHRyYXBAIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgJzsnOiB0cnVlLFxuICAnLic6IHRydWUsXG4gICcsJzogdHJ1ZVxufTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG5cbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMpIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1wiO1xuICB9XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNjXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7IC8vIFxcZG90c2MgdXNlcyBcXGV4dHJhQCBidXQgbm90IFxcZXh0cmFwQCwgaW5zdGVhZCBzcGVjaWFsbHkgY2hlY2tpbmcgZm9yXG4gIC8vICc7JyBhbmQgJy4nLCBidXQgZG9lc24ndCBjaGVjayBmb3IgJywnLlxuXG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzICYmIG5leHQgIT09ICcsJykge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1xcXFwsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXCI7XG4gIH1cbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2RvdHNcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgY29uc3QgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcblxuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cykge1xuICAgIHJldHVybiBcIlxcXFxAY2RvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxAY2RvdHNcIjtcbiAgfVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzYlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNtXCIsIFwiXFxcXGNkb3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2lcIiwgXCJcXFxcIVxcXFxjZG90c1wiKTsgLy8gYW1zbWF0aCBkb2Vzbid0IGFjdHVhbGx5IGRlZmluZSBcXGRvdHN4LCBidXQgXFxkb3RzIGZvbGxvd2VkIGJ5IGEgbWFjcm9cbi8vIHN0YXJ0aW5nIHdpdGggXFxET1RTWCBpbXBsaWVzIFxcZG90c28sIGFuZCB0aGVuIFxcZXh0cmFAIGRldGVjdHMgdGhpcyBjYXNlXG4vLyBhbmQgZm9yY2VzIHRoZSBhZGRlZCBgXFwsYC5cblxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c3hcIiwgXCJcXFxcbGRvdHNcXFxcLFwiKTsgLy8gXFxsZXRcXERPVFNJXFxyZWxheFxuLy8gXFxsZXRcXERPVFNCXFxyZWxheFxuLy8gXFxsZXRcXERPVFNYXFxyZWxheFxuXG5kZWZpbmVNYWNybyhcIlxcXFxET1RTSVwiLCBcIlxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNCXCIsIFwiXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU1hcIiwgXCJcXFxccmVsYXhcIik7IC8vIFNwYWNpbmcsIGJhc2VkIG9uIGFtc21hdGguc3R5J3Mgb3ZlcnJpZGUgb2YgTGFUZVggZGVmYXVsdHNcbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFx0bXNwYWNlfVszXXslXG4vLyAgIFxcaWZtbW9kZVxcbXNraXAjMSMyXFxlbHNlXFxrZXJuIzEjM1xcZmlcXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFx0bXNwYWNlXCIsIFwiXFxcXFRleHRPck1hdGh7XFxcXGtlcm4jMSMzfXtcXFxcbXNraXAjMSMyfVxcXFxyZWxheFwiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFwsfXtcXHRtc3BhY2UrXFx0aGlubXVza2lwey4xNjY3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlubXVza2lwXG5cbmRlZmluZU1hY3JvKFwiXFxcXCxcIiwgXCJcXFxcdG1zcGFjZSt7M211fXsuMTY2N2VtfVwiKTsgLy8gXFxsZXRcXHRoaW5zcGFjZVxcLFxuXG5kZWZpbmVNYWNybyhcIlxcXFx0aGluc3BhY2VcIiwgXCJcXFxcLFwiKTsgLy8gXFxkZWZcXD57XFxtc2tpcFxcbWVkbXVza2lwfVxuLy8gXFxyZW5ld2NvbW1hbmR7XFw6fXtcXHRtc3BhY2UrXFxtZWRtdXNraXB7LjIyMjJlbX19XG4vLyBUT0RPOiBcXD4gYW5kIG1hdGggbW9kZSBvZiBcXDogc2hvdWxkIHVzZSBcXG1lZG11c2tpcCA9IDRtdSBwbHVzIDJtdSBtaW51cyA0bXVcblxuZGVmaW5lTWFjcm8oXCJcXFxcPlwiLCBcIlxcXFxtc2tpcHs0bXV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcOlwiLCBcIlxcXFx0bXNwYWNlK3s0bXV9ey4yMjIyZW19XCIpOyAvLyBcXGxldFxcbWVkc3BhY2VcXDpcblxuZGVmaW5lTWFjcm8oXCJcXFxcbWVkc3BhY2VcIiwgXCJcXFxcOlwiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFw7fXtcXHRtc3BhY2UrXFx0aGlja211c2tpcHsuMjc3N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpY2ttdXNraXAgPSA1bXUgcGx1cyA1bXVcblxuZGVmaW5lTWFjcm8oXCJcXFxcO1wiLCBcIlxcXFx0bXNwYWNlK3s1bXV9ey4yNzc3ZW19XCIpOyAvLyBcXGxldFxcdGhpY2tzcGFjZVxcO1xuXG5kZWZpbmVNYWNybyhcIlxcXFx0aGlja3NwYWNlXCIsIFwiXFxcXDtcIik7IC8vIFxccmVuZXdjb21tYW5ke1xcIX17XFx0bXNwYWNlLVxcdGhpbm11c2tpcHsuMTY2N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpbm11c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFwhXCIsIFwiXFxcXHRtc3BhY2UtezNtdX17LjE2NjdlbX1cIik7IC8vIFxcbGV0XFxuZWd0aGluc3BhY2VcXCFcblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpbnNwYWNlXCIsIFwiXFxcXCFcIik7IC8vIFxcbmV3Y29tbWFuZHtcXG5lZ21lZHNwYWNlfXtcXHRtc3BhY2UtXFxtZWRtdXNraXB7LjIyMjJlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXG1lZG11c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFxuZWdtZWRzcGFjZVwiLCBcIlxcXFx0bXNwYWNlLXs0bXV9ey4yMjIyZW19XCIpOyAvLyBcXG5ld2NvbW1hbmR7XFxuZWd0aGlja3NwYWNlfXtcXHRtc3BhY2UtXFx0aGlja211c2tpcHsuMjc3N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpY2ttdXNraXBcblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpY2tzcGFjZVwiLCBcIlxcXFx0bXNwYWNlLXs1bXV9ey4yNzdlbX1cIik7IC8vIFxcZGVmXFxlbnNwYWNle1xca2Vybi41ZW0gfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlbnNwYWNlXCIsIFwiXFxcXGtlcm4uNWVtIFwiKTsgLy8gXFxkZWZcXGVuc2tpcHtcXGhza2lwLjVlbVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGVuc2tpcFwiLCBcIlxcXFxoc2tpcC41ZW1cXFxccmVsYXhcIik7IC8vIFxcZGVmXFxxdWFke1xcaHNraXAxZW1cXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxxdWFkXCIsIFwiXFxcXGhza2lwMWVtXFxcXHJlbGF4XCIpOyAvLyBcXGRlZlxccXF1YWR7XFxoc2tpcDJlbVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHFxdWFkXCIsIFwiXFxcXGhza2lwMmVtXFxcXHJlbGF4XCIpOyAvLyBcXHRhZ0BpbkBkaXNwbGF5IGZvcm0gb2YgXFx0YWdcblxuZGVmaW5lTWFjcm8oXCJcXFxcdGFnXCIsIFwiXFxcXEBpZnN0YXJcXFxcdGFnQGxpdGVyYWxcXFxcdGFnQHBhcmVuXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnQHBhcmVuXCIsIFwiXFxcXHRhZ0BsaXRlcmFseyh7IzF9KX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0YWdAbGl0ZXJhbFwiLCBjb250ZXh0ID0+IHtcbiAgaWYgKGNvbnRleHQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJNdWx0aXBsZSBcXFxcdGFnXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiXFxcXGdkZWZcXFxcZGZAdGFne1xcXFx0ZXh0eyMxfX1cIjtcbn0pOyAvLyBcXHJlbmV3Y29tbWFuZHtcXGJtb2R9e1xcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcFxcbWtlcm41bXVcXG1hdGhiaW5cbi8vICAge1xcb3BlcmF0b3JAZm9udCBtb2R9XFxwZW5hbHR5OTAwXG4vLyAgIFxcbWtlcm41bXVcXG5vbnNjcmlwdFxcbXNraXAtXFxtZWRtdXNraXB9XG4vLyBcXG5ld2NvbW1hbmR7XFxwb2R9WzFde1xcYWxsb3dicmVha1xuLy8gICBcXGlmQGRpc3BsYXlcXG1rZXJuMThtdVxcZWxzZVxcbWtlcm44bXVcXGZpKCMxKX1cbi8vIFxccmVuZXdjb21tYW5ke1xccG1vZH1bMV17XFxwb2R7e1xcb3BlcmF0b3JAZm9udCBtb2R9XFxta2VybjZtdSMxfX1cbi8vIFxcbmV3Y29tbWFuZHtcXG1vZH1bMV17XFxhbGxvd2JyZWFrXFxpZkBkaXNwbGF5XFxta2VybjE4bXVcbi8vICAgXFxlbHNlXFxta2VybjEybXVcXGZpe1xcb3BlcmF0b3JAZm9udCBtb2R9XFwsXFwsIzF9XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXG1lZG11c2tpcCA9IDRtdSBwbHVzIDJtdSBtaW51cyA0bXVcblxuZGVmaW5lTWFjcm8oXCJcXFxcYm1vZFwiLCBcIlxcXFxtYXRoY2hvaWNle1xcXFxtc2tpcDFtdX17XFxcXG1za2lwMW11fXtcXFxcbXNraXA1bXV9e1xcXFxtc2tpcDVtdX1cIiArIFwiXFxcXG1hdGhiaW57XFxcXHJtIG1vZH1cIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1za2lwMW11fXtcXFxcbXNraXAxbXV9e1xcXFxtc2tpcDVtdX17XFxcXG1za2lwNW11fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBvZFwiLCBcIlxcXFxhbGxvd2JyZWFrXCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2VybjE4bXV9e1xcXFxta2VybjhtdX17XFxcXG1rZXJuOG11fXtcXFxcbWtlcm44bXV9KCMxKVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBtb2RcIiwgXCJcXFxccG9ke3tcXFxccm0gbW9kfVxcXFxta2VybjZtdSMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1vZFwiLCBcIlxcXFxhbGxvd2JyZWFrXCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2VybjE4bXV9e1xcXFxta2VybjEybXV9e1xcXFxta2VybjEybXV9e1xcXFxta2VybjEybXV9XCIgKyBcIntcXFxccm0gbW9kfVxcXFwsXFxcXCwjMVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTGFUZVggc291cmNlMmVcbi8vIFxcZXhwYW5kYWZ0ZXJcXGxldFxcZXhwYW5kYWZ0ZXJcXEBub3JtYWxjclxuLy8gICAgIFxcY3NuYW1lXFxleHBhbmRhZnRlclxcQGdvYmJsZVxcc3RyaW5nXFxcXCBcXGVuZGNzbmFtZVxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxcbmV3bGluZXtcXEBub3JtYWxjclxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXG5ld2xpbmVcIiwgXCJcXFxcXFxcXFxcXFxyZWxheFwiKTsgLy8gXFxkZWZcXFRlWHtUXFxrZXJuLS4xNjY3ZW1cXGxvd2VyLjVleFxcaGJveHtFfVxca2Vybi0uMTI1ZW1YXFxAfVxuLy8gVE9ETzogRG9lc24ndCBub3JtYWxseSB3b3JrIGluIG1hdGggbW9kZSBiZWNhdXNlIFxcQCBmYWlscy4gIEthVGVYIGRvZXNuJ3Rcbi8vIHN1cHBvcnQgXFxAIHlldCwgc28gdGhhdCdzIG9taXR0ZWQsIGFuZCB3ZSBhZGQgXFx0ZXh0IHNvIHRoYXQgdGhlIHJlc3VsdFxuLy8gZG9lc24ndCBsb29rIGZ1bm55IGluIG1hdGggbW9kZS5cblxuZGVmaW5lTWFjcm8oXCJcXFxcVGVYXCIsIFwiXFxcXHRleHRybXtcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlRcXFxca2Vybi0uMTY2N2VtXFxcXHJhaXNlYm94ey0uNWV4fXtFfVxcXFxrZXJuLS4xMjVlbVhcIiArIFwifXtUZVh9fVwiKTsgLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXExhVGVYfXtMXFxrZXJuLS4zNmVtJVxuLy8gICAgICAgICB7XFxzYm94XFx6QCBUJVxuLy8gICAgICAgICAgXFx2Ym94IHRvXFxodFxcekB7XFxoYm94e1xcY2hlY2tAbWF0aGZvbnRzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXGZvbnRzaXplXFxzZkBzaXplXFx6QFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxtYXRoQGZvbnRzZmFsc2VcXHNlbGVjdGZvbnRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF9JVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgXFx2c3N9JVxuLy8gICAgICAgICB9JVxuLy8gICAgICAgICBcXGtlcm4tLjE1ZW0lXG4vLyAgICAgICAgIFxcVGVYfVxuLy8gVGhpcyBjb2RlIGFsaWducyB0aGUgdG9wIG9mIHRoZSBBIHdpdGggdGhlIFQgKGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIFRlWCdzXG4vLyBib3hlcywgdGhvdWdoIHZpc3VhbGx5IHRoZSBBIGFwcGVhcnMgdG8gZXh0ZW5kIGFib3ZlIHNsaWdodGx5KS5cbi8vIFdlIGNvbXB1dGUgdGhlIGNvcnJlc3BvbmRpbmcgXFxyYWlzZWJveCB3aGVuIEEgaXMgcmVuZGVyZWQgaW4gXFxub3JtYWxzaXplXG4vLyBcXHNjcmlwdHN0eWxlLCB3aGljaCBoYXMgYSBzY2FsZSBmYWN0b3Igb2YgMC43IChzZWUgT3B0aW9ucy5qcykuXG5cbmNvbnN0IGxhdGV4UmFpc2VBID0gbWFrZUVtKGZvbnRNZXRyaWNzRGF0YVsnTWFpbi1SZWd1bGFyJ11bXCJUXCIuY2hhckNvZGVBdCgwKV1bMV0gLSAwLjcgKiBmb250TWV0cmljc0RhdGFbJ01haW4tUmVndWxhciddW1wiQVwiLmNoYXJDb2RlQXQoMCldWzFdKTtcbmRlZmluZU1hY3JvKFwiXFxcXExhVGVYXCIsIFwiXFxcXHRleHRybXtcXFxcaHRtbEBtYXRobWx7XCIgKyAoXCJMXFxcXGtlcm4tLjM2ZW1cXFxccmFpc2Vib3h7XCIgKyBsYXRleFJhaXNlQSArIFwifXtcXFxcc2NyaXB0c3R5bGUgQX1cIikgKyBcIlxcXFxrZXJuLS4xNWVtXFxcXFRlWH17TGFUZVh9fVwiKTsgLy8gTmV3IEthVGVYIGxvZ28gYmFzZWQgb24gdHdlYWtpbmcgTGFUZVggbG9nb1xuXG5kZWZpbmVNYWNybyhcIlxcXFxLYVRlWFwiLCBcIlxcXFx0ZXh0cm17XFxcXGh0bWxAbWF0aG1se1wiICsgKFwiS1xcXFxrZXJuLS4xN2VtXFxcXHJhaXNlYm94e1wiICsgbGF0ZXhSYWlzZUEgKyBcIn17XFxcXHNjcmlwdHN0eWxlIEF9XCIpICsgXCJcXFxca2Vybi0uMTVlbVxcXFxUZVh9e0thVGVYfX1cIik7IC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXGhzcGFjZXtcXEBpZnN0YXJcXEBoc3BhY2VyXFxAaHNwYWNlfVxuLy8gXFxkZWZcXEBoc3BhY2UjMXtcXGhza2lwICAjMVxccmVsYXh9XG4vLyBcXGRlZlxcQGhzcGFjZXIjMXtcXHZydWxlIFxcQHdpZHRoXFx6QFxcbm9icmVha1xuLy8gICAgICAgICAgICAgICAgIFxcaHNraXAgIzFcXGhza2lwIFxcekBza2lwfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxoc3BhY2VcIiwgXCJcXFxcQGlmc3RhclxcXFxAaHNwYWNlclxcXFxAaHNwYWNlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZVwiLCBcIlxcXFxoc2tpcCAjMVxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEBoc3BhY2VyXCIsIFwiXFxcXHJ1bGV7MHB0fXswcHR9XFxcXGhza2lwICMxXFxcXHJlbGF4XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYXRodG9vbHMuc3R5XG4vL1xccHJvdmlkZWNvbW1hbmRcXG9yZGluYXJ5Y29sb257On1cblxuZGVmaW5lTWFjcm8oXCJcXFxcb3JkaW5hcnljb2xvblwiLCBcIjpcIik7IC8vXFxkZWZcXHZjZW50Y29sb257XFxtYXRocmVse1xcbWF0aG9wXFxvcmRpbmFyeWNvbG9ufX1cbi8vVE9ETyhlZGVtYWluZSk6IE5vdCB5ZXQgY2VudGVyZWQuIEZpeCB2aWEgXFxyYWlzZWJveCBvciAjNzI2XG5cbmRlZmluZU1hY3JvKFwiXFxcXHZjZW50Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aG9wXFxcXG9yZGluYXJ5Y29sb259XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZGJsY29sb257XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tLjltdX1cXHZjZW50Y29sb259XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRibGNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0uOW11fVxcXFx2Y2VudGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIzN319XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25lcXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9PX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fT19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjU0fX1cIik7IC8vIOKJlFxuLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uZXFxe1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX09fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXGRibGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fT19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiM2R9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uZXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcbWF0aHJlbHstfX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNhXFxcXGNoYXJcXFwiMjIxMn19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25lcXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXG1hdGhyZWx7LX19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiMjIxMn19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZXFxY29sb257PVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcdmNlbnRjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZXFxY29sb25cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVsez1cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHZjZW50Y29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjU1fX1cIik7IC8vIOKJlVxuLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxcWNvbG9uez1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxFcXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIzZFxcXFxjaGFyXFxcIjIyMzd9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFx2Y2VudGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlcWNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aHJlbHstfVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzl9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxkYmxjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcRXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXG1hdGhyZWx7LX1cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGRibGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIxMlxcXFxjaGFyXFxcIjIyMzd9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uYXBwcm94e1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmFwcHJveFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXHZjZW50Y29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGFwcHJveH19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNhXFxcXGNoYXJcXFwiMjI0OH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25hcHByb3h7XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmFwcHJveFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXGRibGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxhcHByb3h9fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiMjI0OH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25zaW17XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uc2ltXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcc2ltfX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiM2FcXFxcY2hhclxcXCIyMjNjfX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbnNpbXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uc2ltXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHNpbX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIyMjNjfX1cIik7IC8vIFNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSBpbXBsZW1lbnRlZCB3aXRoIG1hY3JvcyB0byBtYXRodG9vbHMgZnVuY3Rpb25zLlxuXG5kZWZpbmVNYWNybyhcIlxcdTIyMzdcIiwgXCJcXFxcZGJsY29sb25cIik7IC8vIDo6XG5cbmRlZmluZU1hY3JvKFwiXFx1MjIzOVwiLCBcIlxcXFxlcWNvbG9uXCIpOyAvLyAtOlxuXG5kZWZpbmVNYWNybyhcIlxcdTIyNTRcIiwgXCJcXFxcY29sb25lcXFcIik7IC8vIDo9XG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1NVwiLCBcIlxcXFxlcXFjb2xvblwiKTsgLy8gPTpcblxuZGVmaW5lTWFjcm8oXCJcXHUyQTc0XCIsIFwiXFxcXENvbG9uZXFxXCIpOyAvLyA6Oj1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbG9uZXF1YWxzLnN0eVxuLy8gQWx0ZXJuYXRlIG5hbWVzIGZvciBtYXRodG9vbHMncyBtYWNyb3M6XG5cbmRlZmluZU1hY3JvKFwiXFxcXHJhdGlvXCIsIFwiXFxcXHZjZW50Y29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uXCIsIFwiXFxcXGRibGNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXVhbHNcIiwgXCJcXFxcY29sb25lcXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uZXF1YWxzXCIsIFwiXFxcXENvbG9uZXFxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXF1YWxzY29sb25cIiwgXCJcXFxcZXFxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcXVhbHNjb2xvbmNvbG9uXCIsIFwiXFxcXEVxcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25taW51c1wiLCBcIlxcXFxjb2xvbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbm1pbnVzXCIsIFwiXFxcXENvbG9uZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uXCIsIFwiXFxcXGVxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uY29sb25cIiwgXCJcXFxcRXFjb2xvblwiKTsgLy8gXFxjb2xvbmFwcHJveCBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbmFwcHJveFwiLCBcIlxcXFxDb2xvbmFwcHJveFwiKTsgLy8gXFxjb2xvbnNpbSBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbnNpbVwiLCBcIlxcXFxDb2xvbnNpbVwiKTsgLy8gQWRkaXRpb25hbCBtYWNyb3MsIGltcGxlbWVudGVkIGJ5IGFuYWxvZ3kgd2l0aCBtYXRodG9vbHMgZGVmaW5pdGlvbnM6XG5cbmRlZmluZU1hY3JvKFwiXFxcXHNpbWNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHNpbVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzaW1jb2xvbmNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHNpbVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXBwcm94Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcYXBwcm94XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFx2Y2VudGNvbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFwcHJveGNvbG9uY29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcYXBwcm94XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxkYmxjb2xvbn1cIik7IC8vIFByZXNlbnQgaW4gbmV3dHhtYXRoLCBweGZvbnRzIGFuZCB0eGZvbnRzXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vdG5pXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxub3RcXFxcbml9e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyMEN9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsc3VwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbWluZlwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsaW5mfVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRnJvbSBhbXNvcG4uc3R5XG5cbmRlZmluZU1hY3JvKFwiXFxcXGluamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2lualxcXFwsbGltfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHByb2psaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntwcm9qXFxcXCxsaW19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFybGltc3VwXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXG92ZXJsaW5le2xpbX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFybGltaW5mXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVybGluZXtsaW19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcmluamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFx1bmRlcnJpZ2h0YXJyb3d7bGltfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJwcm9qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVybGVmdGFycm93e2xpbX19XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNYXRoTUwgYWx0ZXJuYXRlcyBmb3IgS2FUZVggZ2x5cGhzIGluIHRoZSBVbmljb2RlIHByaXZhdGUgYXJlYVxuXG5kZWZpbmVNYWNybyhcIlxcXFxndmVydG5lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBndmVydG5lcXF9e1xcdTIyNjl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHZlcnRuZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbHZlcnRuZXFxfXtcXHUyMjY4fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5nZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbmdlcXF9e1xcdTIyNzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmdlcXNsYW50XCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbmdlcXNsYW50fXtcXHUyMjcxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5sZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbmxlcXF9e1xcdTIyNzB9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmxlcXNsYW50XCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbmxlcXNsYW50fXtcXHUyMjcwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5zaG9ydG1pZFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5zaG9ydG1pZH174oikfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbnNob3J0cGFyYWxsZWx9e+KIpn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuc3Vic2V0ZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbnN1YnNldGVxcX17XFx1MjI4OH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuc3Vwc2V0ZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbnN1cHNldGVxcX17XFx1MjI4OX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJzdWJzZXRuZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB2YXJzdWJzZXRuZXF9e+KKin1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJzdWJzZXRuZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdmFyc3Vic2V0bmVxcX174quLfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnN1cHNldG5lcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHZhcnN1cHNldG5lcX174oqLfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnN1cHNldG5lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB2YXJzdXBzZXRuZXFxfXviq4x9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1hdGhcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBpbWF0aH17XFx1MDEzMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxqbWF0aFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGptYXRofXtcXHUwMjM3fVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gc3RtYXJ5cmQgYW5kIHNlbWFudGljXG4vLyBUaGUgc3RtYXJ5cmQgYW5kIHNlbWFudGljIHBhY2thZ2VzIHJlbmRlciB0aGUgbmV4dCBmb3VyIGl0ZW1zIGJ5IGNhbGxpbmcgYVxuLy8gZ2x5cGguIFRob3NlIGdseXBocyBkbyBub3QgZXhpc3QgaW4gdGhlIEthVGVYIGZvbnRzLiBIZW5jZSB0aGUgbWFjcm9zLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxsbGJyYWNrZXRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRob3BlbntbXFxcXG1rZXJuLTMuMm11W319XCIgKyBcIntcXFxcbWF0aG9wZW57XFxcXGNoYXJgXFx1MjdlNn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccnJicmFja2V0XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aGNsb3Nle11cXFxcbWtlcm4tMy4ybXVdfX1cIiArIFwie1xcXFxtYXRoY2xvc2V7XFxcXGNoYXJgXFx1MjdlN319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyN2U2XCIsIFwiXFxcXGxsYnJhY2tldFwiKTsgLy8gYmxhY2tib2FyZCBib2xkIFtcblxuZGVmaW5lTWFjcm8oXCJcXHUyN2U3XCIsIFwiXFxcXHJyYnJhY2tldFwiKTsgLy8gYmxhY2tib2FyZCBib2xkIF1cblxuZGVmaW5lTWFjcm8oXCJcXFxcbEJyYWNlXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aG9wZW57XFxcXHtcXFxcbWtlcm4tMy4ybXVbfX1cIiArIFwie1xcXFxtYXRob3BlbntcXFxcY2hhcmBcXHUyOTgzfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyQnJhY2VcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRoY2xvc2V7XVxcXFxta2Vybi0zLjJtdVxcXFx9fX1cIiArIFwie1xcXFxtYXRoY2xvc2V7XFxcXGNoYXJgXFx1Mjk4NH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyOTgzXCIsIFwiXFxcXGxCcmFjZVwiKTsgLy8gYmxhY2tib2FyZCBib2xkIHtcblxuZGVmaW5lTWFjcm8oXCJcXHUyOTg0XCIsIFwiXFxcXHJCcmFjZVwiKTsgLy8gYmxhY2tib2FyZCBib2xkIH1cbi8vIFRPRE86IENyZWF0ZSB2YXJpYWJsZSBzaXplZCB2ZXJzaW9ucyBvZiB0aGUgbGFzdCB0d28gaXRlbXMuIEkgYmVsaWV2ZSB0aGF0XG4vLyB3aWxsIHJlcXVpcmUgbmV3IGZvbnQgZ2x5cGhzLlxuLy8gVGhlIHN0bWFyeXJkIGZ1bmN0aW9uIGBcXG1pbnVzb2AgcHJvdmlkZXMgYSBcIlBsaW1zb2xsXCIgc3ltYm9sIHRoYXRcbi8vIHN1cGVyaW1wb3NlcyB0aGUgY2hhcmFjdGVycyBcXGNpcmMgYW5kIFxcbWF0aG1pbnVzLiBVc2VkIGluIGNoZW1pc3RyeS5cblxuZGVmaW5lTWFjcm8oXCJcXFxcbWludXNvXCIsIFwiXFxcXG1hdGhiaW57XFxcXGh0bWxAbWF0aG1se1wiICsgXCJ7XFxcXG1hdGhybGFwe1xcXFxtYXRoY2hvaWNle1xcXFxrZXJuezAuMTQ1ZW19fXtcXFxca2VybnswLjE0NWVtfX1cIiArIFwie1xcXFxrZXJuezAuMTAxNWVtfX17XFxcXGtlcm57MC4wNzI1ZW19fVxcXFxjaXJjfXstfX19XCIgKyBcIntcXFxcY2hhcmDiprV9fVwiKTtcbmRlZmluZU1hY3JvKFwi4qa1XCIsIFwiXFxcXG1pbnVzb1wiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdGV4dmMuc3R5XG4vLyBUaGUgdGV4dmMgcGFja2FnZSBjb250YWlucyBtYWNyb3MgYXZhaWxhYmxlIGluIG1lZGlhd2lraSBwYWdlcy5cbi8vIFdlIG9taXQgdGhlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIGF0XG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWxwOkRpc3BsYXlpbmdfYV9mb3JtdWxhI0RlcHJlY2F0ZWRfc3ludGF4XG4vLyBXZSBhbHNvIG9taXQgdGV4dmMncyBcXE8sIHdoaWNoIGNvbmZsaWN0cyB3aXRoIFxcdGV4dHtcXE99XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRhcnJcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZEFyclwiLCBcIlxcXFxEb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxEYXJyXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxhbmdcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFuZ1wiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1YXJyXCIsIFwiXFxcXHVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1QXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxVYXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJcIiwgXCJcXFxcbWF0aGJie1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcWlwiLCBcIlxcXFxtYXRoYmJ7Wn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbGVmXCIsIFwiXFxcXGFsZXBoXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWxlZnN5bVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEFscGhhXCIsIFwiXFxcXG1hdGhybXtBfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJldGFcIiwgXCJcXFxcbWF0aHJte0J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnVsbFwiLCBcIlxcXFxidWxsZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDaGlcIiwgXCJcXFxcbWF0aHJte1h9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2x1YnNcIiwgXCJcXFxcY2x1YnN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbnVtc1wiLCBcIlxcXFxtYXRoYmJ7Q31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDb21wbGV4XCIsIFwiXFxcXG1hdGhiYntDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERhZ2dlclwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGlhbW9uZHNcIiwgXCJcXFxcZGlhbW9uZHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlbXB0eVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEVwc2lsb25cIiwgXCJcXFxcbWF0aHJte0V9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRXRhXCIsIFwiXFxcXG1hdGhybXtIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4aXN0XCIsIFwiXFxcXGV4aXN0c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSGFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhlYXJ0c1wiLCBcIlxcXFxoZWFydHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbWFnZVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGluZmluXCIsIFwiXFxcXGluZnR5XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSW90YVwiLCBcIlxcXFxtYXRocm17SX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpc2luXCIsIFwiXFxcXGluXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcS2FwcGFcIiwgXCJcXFxcbWF0aHJte0t9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFyclwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsQXJyXCIsIFwiXFxcXExlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExhcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHJhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsckFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExyYXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTXVcIiwgXCJcXFxcbWF0aHJte019XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmF0bnVtc1wiLCBcIlxcXFxtYXRoYmJ7Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOdVwiLCBcIlxcXFxtYXRocm17Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxPbWljcm9uXCIsIFwiXFxcXG1hdGhybXtPfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBsdXNtblwiLCBcIlxcXFxwbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhcnJcIiwgXCJcXFxccmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJBcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJhcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxcIiwgXCJcXFxcUmVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSaG9cIiwgXCJcXFxcbWF0aHJte1B9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2RvdFwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2VjdFwiLCBcIlxcXFxTXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3BhZGVzXCIsIFwiXFxcXHNwYWRlc3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdWJlXCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3VwZVwiLCBcIlxcXFxzdXBzZXRlcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFRhdVwiLCBcIlxcXFxtYXRocm17VH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0aGV0YXN5bVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTsgLy8gVE9ETzogZGVmaW5lTWFjcm8oXCJcXFxcdmFyY29wcGFcIiwgXCJcXFxcXFxtYm94e1xcXFxjb3BwYX1cIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXHdlaWVycFwiLCBcIlxcXFx3cFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFpldGFcIiwgXCJcXFxcbWF0aHJte1p9XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzdGF0bWF0aC5zdHlcbi8vIGh0dHBzOi8vY3Rhbi5tYXRoLmlsbGlub2lzLmVkdS9tYWNyb3MvbGF0ZXgvY29udHJpYi9zdGF0bWF0aC9zdGF0bWF0aC5wZGZcblxuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWluXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7YXJnXFxcXCxtaW59XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWF4XCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7YXJnXFxcXCxtYXh9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGxpbVwiLCBcIlxcXFxET1RTQlxcXFxtYXRob3B7XFxcXG9wZXJhdG9ybmFtZXtwbGltfX1cXFxcbGltaXRzXCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBicmFrZXQuc3R5XG4vLyBodHRwOi8vY3Rhbi5tYXRoLndhc2hpbmd0b24uZWR1L3RleC1hcmNoaXZlL21hY3Jvcy9sYXRleC9jb250cmliL2JyYWtldC9icmFrZXQucGRmXG5cbmRlZmluZU1hY3JvKFwiXFxcXGJyYVwiLCBcIlxcXFxtYXRoaW5uZXJ7XFxcXGxhbmdsZXsjMX18fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGtldFwiLCBcIlxcXFxtYXRoaW5uZXJ7fHsjMX1cXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJyYWtldFwiLCBcIlxcXFxtYXRoaW5uZXJ7XFxcXGxhbmdsZXsjMX1cXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJyYVwiLCBcIlxcXFxsZWZ0XFxcXGxhbmdsZSMxXFxcXHJpZ2h0fFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEtldFwiLCBcIlxcXFxsZWZ0fCMxXFxcXHJpZ2h0XFxcXHJhbmdsZVwiKTtcblxuY29uc3QgYnJha2V0SGVscGVyID0gb25lID0+IGNvbnRleHQgPT4ge1xuICBjb25zdCBsZWZ0ID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuICBjb25zdCBtaWRkbGUgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIGNvbnN0IG1pZGRsZURvdWJsZSA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgY29uc3QgcmlnaHQgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIGNvbnN0IG9sZE1pZGRsZSA9IGNvbnRleHQubWFjcm9zLmdldChcInxcIik7XG4gIGNvbnN0IG9sZE1pZGRsZURvdWJsZSA9IGNvbnRleHQubWFjcm9zLmdldChcIlxcXFx8XCIpO1xuICBjb250ZXh0Lm1hY3Jvcy5iZWdpbkdyb3VwKCk7XG5cbiAgY29uc3QgbWlkTWFjcm8gPSBkb3VibGUgPT4gY29udGV4dCA9PiB7XG4gICAgaWYgKG9uZSkge1xuICAgICAgLy8gT25seSBtb2RpZnkgdGhlIGZpcnN0IGluc3RhbmNlIG9mIHwgb3IgXFx8XG4gICAgICBjb250ZXh0Lm1hY3Jvcy5zZXQoXCJ8XCIsIG9sZE1pZGRsZSk7XG5cbiAgICAgIGlmIChtaWRkbGVEb3VibGUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRleHQubWFjcm9zLnNldChcIlxcXFx8XCIsIG9sZE1pZGRsZURvdWJsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRvdWJsZWQgPSBkb3VibGU7XG5cbiAgICBpZiAoIWRvdWJsZSAmJiBtaWRkbGVEb3VibGUubGVuZ3RoKSB7XG4gICAgICAvLyBNaW1pYyBcXEBpZm5leHRjaGFyXG4gICAgICBjb25zdCBuZXh0VG9rZW4gPSBjb250ZXh0LmZ1dHVyZSgpO1xuXG4gICAgICBpZiAobmV4dFRva2VuLnRleHQgPT09IFwifFwiKSB7XG4gICAgICAgIGNvbnRleHQucG9wVG9rZW4oKTtcbiAgICAgICAgZG91YmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogZG91YmxlZCA/IG1pZGRsZURvdWJsZSA6IG1pZGRsZSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9O1xuXG4gIGNvbnRleHQubWFjcm9zLnNldChcInxcIiwgbWlkTWFjcm8oZmFsc2UpKTtcblxuICBpZiAobWlkZGxlRG91YmxlLmxlbmd0aCkge1xuICAgIGNvbnRleHQubWFjcm9zLnNldChcIlxcXFx8XCIsIG1pZE1hY3JvKHRydWUpKTtcbiAgfVxuXG4gIGNvbnN0IGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgY29uc3QgZXhwYW5kZWQgPSBjb250ZXh0LmV4cGFuZFRva2VucyhbLi4ucmlnaHQsIC4uLmFyZywgLi4ubGVmdCAvLyByZXZlcnNlZFxuICBdKTtcbiAgY29udGV4dC5tYWNyb3MuZW5kR3JvdXAoKTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IGV4cGFuZGVkLnJldmVyc2UoKSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59O1xuXG5kZWZpbmVNYWNybyhcIlxcXFxicmFAa2V0XCIsIGJyYWtldEhlbHBlcihmYWxzZSkpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnJhQHNldFwiLCBicmFrZXRIZWxwZXIodHJ1ZSkpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQnJha2V0XCIsIFwiXFxcXGJyYUBrZXR7XFxcXGxlZnRcXFxcbGFuZ2xlfVwiICsgXCJ7XFxcXCxcXFxcbWlkZGxlXFxcXHZlcnRcXFxcLH17XFxcXCxcXFxcbWlkZGxlXFxcXHZlcnRcXFxcLH17XFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxTZXRcIiwgXCJcXFxcYnJhQHNldHtcXFxcbGVmdFxcXFx7XFxcXDp9XCIgKyBcIntcXFxcO1xcXFxtaWRkbGVcXFxcdmVydFxcXFw7fXtcXFxcO1xcXFxtaWRkbGVcXFxcVmVydFxcXFw7fXtcXFxcOlxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNldFwiLCBcIlxcXFxicmFAc2V0e1xcXFx7XFxcXCx9e1xcXFxtaWR9e317XFxcXCxcXFxcfX1cIik7IC8vIGhhcyBubyBzdXBwb3J0IGZvciBzcGVjaWFsIHx8IG9yIFxcfFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYWN0dWFyaWFsYW5nbGUuZHR4XG5cbmRlZmluZU1hY3JvKFwiXFxcXGFuZ2xuXCIsIFwie1xcXFxhbmdsIG59XCIpOyAvLyBDdXN0b20gS2hhbiBBY2FkZW15IGNvbG9ycywgc2hvdWxkIGJlIG1vdmVkIHRvIGFuIG9wdGlvbmFsIHBhY2thZ2VcblxuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM2NDk1ZWR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9yYW5nZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmE1MDB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBpbmtcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmYwMGFmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZGYwMDMwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlblwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyOGFlN2J9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlcIiwgXCJcXFxcdGV4dGNvbG9ye2dyYXl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM5ZDM4YmR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2NjZmFmZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZUJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjODBmNmZmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyM2M2Q5ZWF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVEXCIsIFwiXFxcXHRleHRjb2xvcnsjIzExYWNjZH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZUVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMGM3Zjk5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM5NGZmZjV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxCXCIsIFwiXFxcXHRleHRjb2xvcnsjIzI2ZWRkNX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbENcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMDFkMWMxfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMwMWE5OTV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxFXCIsIFwiXFxcXHRleHRjb2xvcnsjIzIwODE3MH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5BXCIsIFwiXFxcXHRleHRjb2xvcnsjI2I2ZmZiMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5CXCIsIFwiXFxcXHRleHRjb2xvcnsjIzhhZjI4MX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5DXCIsIFwiXFxcXHRleHRjb2xvcnsjIzc0Y2Y3MH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5EXCIsIFwiXFxcXHRleHRjb2xvcnsjIzFmYWI1NH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5FXCIsIFwiXFxcXHRleHRjb2xvcnsjIzBkOTIzZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZEFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmZkMGE5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmJiNzF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGRDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmOWMzOX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZERcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZTA3ZDEwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNhNzVhMDV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZEFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmNhOWE5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmODQ4Mn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmOTY4NWR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZERcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZTg0ZDM5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRFXCIsIFwiXFxcXHRleHRjb2xvcnsjI2JjMjYxMn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmJkZTB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmY5MmM2fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25DXCIsIFwiXFxcXHRleHRjb2xvcnsjI2VkNWZhNn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNjYTMzN2N9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjOWUwMzRlfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2RkZDdmZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNjNmI5ZmN9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZUNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYWE4N2ZmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVEXCIsIFwiXFxcXHRleHRjb2xvcnsjIzc4NTRhYn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM1NDNiNzh9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnRBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2Y1ZjllOH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludEJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZWRmMmRmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW50Q1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlMGU1Y2N9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2Y2ZjdmN317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZjBmMWYyfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5Q1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlM2U1ZTZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlEXCIsIFwiXFxcXHRleHRjb2xvcnsjI2Q2ZDhkYX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYmFiZWMyfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5RlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM4ODhkOTN9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlHXCIsIFwiXFxcXHRleHRjb2xvcnsjIzYyNjU2OX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUhcIiwgXCJcXFxcdGV4dGNvbG9yeyMjM2IzZTQwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5SVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyMTI0MmN9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGthQmx1ZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMzMTQ0NTN9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGthR3JlZW5cIiwgXCJcXFxcdGV4dGNvbG9yeyMjNzFCMzA3fXsjMX1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvTWFjcm9FeHBhbmRlci5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIOKAnGd1bGxldOKAnSB3aGVyZSBtYWNyb3MgYXJlIGV4cGFuZGVkXG4gKiB1bnRpbCBvbmx5IG5vbi1tYWNybyB0b2tlbnMgcmVtYWluLlxuICovXG5cblxuXG5cblxuXG5cbi8vIExpc3Qgb2YgY29tbWFuZHMgdGhhdCBhY3QgbGlrZSBtYWNyb3MgYnV0IGFyZW4ndCBkZWZpbmVkIGFzIGEgbWFjcm8sXG4vLyBmdW5jdGlvbiwgb3Igc3ltYm9sLiAgVXNlZCBpbiBgaXNEZWZpbmVkYC5cbmNvbnN0IGltcGxpY2l0Q29tbWFuZHMgPSB7XG4gIFwiXlwiOiB0cnVlLFxuICAvLyBQYXJzZXIuanNcbiAgXCJfXCI6IHRydWUsXG4gIC8vIFBhcnNlci5qc1xuICBcIlxcXFxsaW1pdHNcIjogdHJ1ZSxcbiAgLy8gUGFyc2VyLmpzXG4gIFwiXFxcXG5vbGltaXRzXCI6IHRydWUgLy8gUGFyc2VyLmpzXG5cbn07XG5jbGFzcyBNYWNyb0V4cGFuZGVyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzLCBtb2RlKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ID0gdm9pZCAwO1xuICAgIHRoaXMubGV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tYWNyb3MgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFjayA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQgPSAwO1xuICAgIHRoaXMuZmVlZChpbnB1dCk7IC8vIE1ha2UgbmV3IGdsb2JhbCBuYW1lc3BhY2VcblxuICAgIHRoaXMubWFjcm9zID0gbmV3IE5hbWVzcGFjZShzcmNfbWFjcm9zLCBzZXR0aW5ncy5tYWNyb3MpO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICB9XG4gIC8qKlxuICAgKiBGZWVkIGEgbmV3IGlucHV0IHN0cmluZyB0byB0aGUgc2FtZSBNYWNyb0V4cGFuZGVyXG4gICAqICh3aXRoIGV4aXN0aW5nIG1hY3JvcyBldGMuKS5cbiAgICovXG5cblxuICBmZWVkKGlucHV0KSB7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcihpbnB1dCwgdGhpcy5zZXR0aW5ncyk7XG4gIH1cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cblxuXG4gIHN3aXRjaE1vZGUobmV3TW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cblxuXG4gIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy5tYWNyb3MuYmVnaW5Hcm91cCgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgY3VycmVudCBncm91cCBuZXN0aW5nIHdpdGhpbiBhbGwgbmFtZXNwYWNlcy5cbiAgICovXG5cblxuICBlbmRHcm91cCgpIHtcbiAgICB0aGlzLm1hY3Jvcy5lbmRHcm91cCgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmRzIGFsbCBjdXJyZW50bHkgbmVzdGVkIGdyb3VwcyAoaWYgYW55KSwgcmVzdG9yaW5nIHZhbHVlcyBiZWZvcmUgdGhlXG4gICAqIGdyb3VwcyBiZWdhbi4gIFVzZWZ1bCBpbiBjYXNlIG9mIGFuIGVycm9yIGluIHRoZSBtaWRkbGUgb2YgcGFyc2luZy5cbiAgICovXG5cblxuICBlbmRHcm91cHMoKSB7XG4gICAgdGhpcy5tYWNyb3MuZW5kR3JvdXBzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvcG1vc3QgdG9rZW4gb24gdGhlIHN0YWNrLCB3aXRob3V0IGV4cGFuZGluZyBpdC5cbiAgICogU2ltaWxhciBpbiBiZWhhdmlvciB0byBUZVgncyBgXFxmdXR1cmVsZXRgLlxuICAgKi9cblxuXG4gIGZ1dHVyZSgpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRoaXMubGV4ZXIubGV4KCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBuZXh0IHVuZXhwYW5kZWQgdG9rZW4uXG4gICAqL1xuXG5cbiAgcG9wVG9rZW4oKSB7XG4gICAgdGhpcy5mdXR1cmUoKTsgLy8gZW5zdXJlIG5vbi1lbXB0eSBzdGFja1xuXG4gICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGdpdmVuIHRva2VuIHRvIHRoZSB0b2tlbiBzdGFjay4gIEluIHBhcnRpY3VsYXIsIHRoaXMgZ2V0IGJlIHVzZWRcbiAgICogdG8gcHV0IGJhY2sgYSB0b2tlbiByZXR1cm5lZCBmcm9tIG9uZSBvZiB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgICovXG5cblxuICBwdXNoVG9rZW4odG9rZW4pIHtcbiAgICB0aGlzLnN0YWNrLnB1c2godG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmQgYW4gYXJyYXkgb2YgdG9rZW5zIHRvIHRoZSB0b2tlbiBzdGFjay5cbiAgICovXG5cblxuICBwdXNoVG9rZW5zKHRva2Vucykge1xuICAgIHRoaXMuc3RhY2sucHVzaCguLi50b2tlbnMpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFuIG1hY3JvIGFyZ3VtZW50IHdpdGhvdXQgZXhwYW5kaW5nIHRva2VucyBhbmQgYXBwZW5kIHRoZSBhcnJheSBvZlxuICAgKiB0b2tlbnMgdG8gdGhlIHRva2VuIHN0YWNrLiBVc2VzIFRva2VuIGFzIGEgY29udGFpbmVyIGZvciB0aGUgcmVzdWx0LlxuICAgKi9cblxuXG4gIHNjYW5Bcmd1bWVudChpc09wdGlvbmFsKSB7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGxldCBlbmQ7XG4gICAgbGV0IHRva2VucztcblxuICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsgLy8gXFxAaWZuZXh0Y2hhciBnb2JibGVzIGFueSBzcGFjZSBmb2xsb3dpbmcgaXRcblxuICAgICAgaWYgKHRoaXMuZnV0dXJlKCkudGV4dCAhPT0gXCJbXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ID0gdGhpcy5wb3BUb2tlbigpOyAvLyBkb24ndCBpbmNsdWRlIFsgaW4gdG9rZW5zXG5cbiAgICAgICh7XG4gICAgICAgIHRva2VucyxcbiAgICAgICAgZW5kXG4gICAgICB9ID0gdGhpcy5jb25zdW1lQXJnKFtcIl1cIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKHtcbiAgICAgICAgdG9rZW5zLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kXG4gICAgICB9ID0gdGhpcy5jb25zdW1lQXJnKCkpO1xuICAgIH0gLy8gaW5kaWNhdGUgdGhlIGVuZCBvZiBhbiBhcmd1bWVudFxuXG5cbiAgICB0aGlzLnB1c2hUb2tlbihuZXcgVG9rZW4oXCJFT0ZcIiwgZW5kLmxvYykpO1xuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHJldHVybiBzdGFydC5yYW5nZShlbmQsIFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdW1lIGFsbCBmb2xsb3dpbmcgc3BhY2UgdG9rZW5zLCB3aXRob3V0IGV4cGFuc2lvbi5cbiAgICovXG5cblxuICBjb25zdW1lU3BhY2VzKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5mdXR1cmUoKTtcblxuICAgICAgaWYgKHRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnN1bWUgYW4gYXJndW1lbnQgZnJvbSB0aGUgdG9rZW4gc3RyZWFtLCBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgYXJyYXlcbiAgICogb2YgdG9rZW5zIGFuZCBzdGFydC9lbmQgdG9rZW4uXG4gICAqL1xuXG5cbiAgY29uc3VtZUFyZyhkZWxpbXMpIHtcbiAgICAvLyBUaGUgYXJndW1lbnQgZm9yIGEgZGVsaW1pdGVkIHBhcmFtZXRlciBpcyB0aGUgc2hvcnRlc3QgKHBvc3NpYmx5XG4gICAgLy8gZW1wdHkpIHNlcXVlbmNlIG9mIHRva2VucyB3aXRoIHByb3Blcmx5IG5lc3RlZCB7Li4ufSBncm91cHMgdGhhdCBpc1xuICAgIC8vIGZvbGxvd2VkIC4uLiBieSB0aGlzIHBhcnRpY3VsYXIgbGlzdCBvZiBub24tcGFyYW1ldGVyIHRva2Vucy5cbiAgICAvLyBUaGUgYXJndW1lbnQgZm9yIGFuIHVuZGVsaW1pdGVkIHBhcmFtZXRlciBpcyB0aGUgbmV4dCBub25ibGFua1xuICAgIC8vIHRva2VuLCB1bmxlc3MgdGhhdCB0b2tlbiBpcyDigJh74oCZLCB3aGVuIHRoZSBhcmd1bWVudCB3aWxsIGJlIHRoZVxuICAgIC8vIGVudGlyZSB7Li4ufSBncm91cCB0aGF0IGZvbGxvd3MuXG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgaXNEZWxpbWl0ZWQgPSBkZWxpbXMgJiYgZGVsaW1zLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAoIWlzRGVsaW1pdGVkKSB7XG4gICAgICAvLyBJZ25vcmUgc3BhY2VzIGJldHdlZW4gYXJndW1lbnRzLiAgQXMgdGhlIFRlWGJvb2sgc2F5czpcbiAgICAgIC8vIFwiQWZ0ZXIgeW91IGhhdmUgc2FpZCDigJhcXGRlZlxccm93IzEjMnsuLi594oCZLCB5b3UgYXJlIGFsbG93ZWQgdG9cbiAgICAgIC8vICBwdXQgc3BhY2VzIGJldHdlZW4gdGhlIGFyZ3VtZW50cyAoZS5nLiwg4oCYXFxyb3cgeCBu4oCZKSwgYmVjYXVzZVxuICAgICAgLy8gIFRlWCBkb2VzbuKAmXQgdXNlIHNpbmdsZSBzcGFjZXMgYXMgdW5kZWxpbWl0ZWQgYXJndW1lbnRzLlwiXG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZnV0dXJlKCk7XG4gICAgbGV0IHRvaztcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGxldCBtYXRjaCA9IDA7XG5cbiAgICBkbyB7XG4gICAgICB0b2sgPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgICB0b2tlbnMucHVzaCh0b2spO1xuXG4gICAgICBpZiAodG9rLnRleHQgPT09IFwie1wiKSB7XG4gICAgICAgICsrZGVwdGg7XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIn1cIikge1xuICAgICAgICAtLWRlcHRoO1xuXG4gICAgICAgIGlmIChkZXB0aCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHRyYSB9XCIsIHRvayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQgaW4gYSBtYWNybyBhcmd1bWVudFwiICsgXCIsIGV4cGVjdGVkICdcIiArIChkZWxpbXMgJiYgaXNEZWxpbWl0ZWQgPyBkZWxpbXNbbWF0Y2hdIDogXCJ9XCIpICsgXCInXCIsIHRvayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWxpbXMgJiYgaXNEZWxpbWl0ZWQpIHtcbiAgICAgICAgaWYgKChkZXB0aCA9PT0gMCB8fCBkZXB0aCA9PT0gMSAmJiBkZWxpbXNbbWF0Y2hdID09PSBcIntcIikgJiYgdG9rLnRleHQgPT09IGRlbGltc1ttYXRjaF0pIHtcbiAgICAgICAgICArK21hdGNoO1xuXG4gICAgICAgICAgaWYgKG1hdGNoID09PSBkZWxpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIGRlbGltcyBpbiB0b2tlbnNcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoLW1hdGNoLCBtYXRjaCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAoZGVwdGggIT09IDAgfHwgaXNEZWxpbWl0ZWQpOyAvLyBJZiB0aGUgYXJndW1lbnQgZm91bmQgLi4uIGhhcyB0aGUgZm9ybSDigJh7PG5lc3RlZCB0b2tlbnM+feKAmSxcbiAgICAvLyAuLi4gdGhlIG91dGVybW9zdCBicmFjZXMgZW5jbG9zaW5nIHRoZSBhcmd1bWVudCBhcmUgcmVtb3ZlZFxuXG5cbiAgICBpZiAoc3RhcnQudGV4dCA9PT0gXCJ7XCIgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50ZXh0ID09PSBcIn1cIikge1xuICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgdG9rZW5zLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgb3JkZXJcblxuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZDogdG9rXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29uc3VtZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiAoZGVsaW1pdGVkKSBhcmd1bWVudHMgZnJvbSB0aGUgdG9rZW5cbiAgICogc3RyZWFtIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAqL1xuXG5cbiAgY29uc3VtZUFyZ3MobnVtQXJncywgZGVsaW1pdGVycykge1xuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICBpZiAoZGVsaW1pdGVycy5sZW5ndGggIT09IG51bUFyZ3MgKyAxKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlRoZSBsZW5ndGggb2YgZGVsaW1pdGVycyBkb2Vzbid0IG1hdGNoIHRoZSBudW1iZXIgb2YgYXJncyFcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbGltcyA9IGRlbGltaXRlcnNbMF07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRvayA9IHRoaXMucG9wVG9rZW4oKTtcblxuICAgICAgICBpZiAoZGVsaW1zW2ldICE9PSB0b2sudGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVzZSBvZiB0aGUgbWFjcm8gZG9lc24ndCBtYXRjaCBpdHMgZGVmaW5pdGlvblwiLCB0b2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYXJncyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BcmdzOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLmNvbnN1bWVBcmcoZGVsaW1pdGVycyAmJiBkZWxpbWl0ZXJzW2kgKyAxXSkudG9rZW5zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncztcbiAgfVxuICAvKipcbiAgICogSW5jcmVtZW50IGBleHBhbnNpb25Db3VudGAgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuXG4gICAqIFRocm93IGFuIGVycm9yIGlmIGl0IGV4Y2VlZHMgYG1heEV4cGFuZGAuXG4gICAqL1xuXG5cbiAgY291bnRFeHBhbnNpb24oYW1vdW50KSB7XG4gICAgdGhpcy5leHBhbnNpb25Db3VudCArPSBhbW91bnQ7XG5cbiAgICBpZiAodGhpcy5leHBhbnNpb25Db3VudCA+IHRoaXMuc2V0dGluZ3MubWF4RXhwYW5kKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJUb28gbWFueSBleHBhbnNpb25zOiBpbmZpbml0ZSBsb29wIG9yIFwiICsgXCJuZWVkIHRvIGluY3JlYXNlIG1heEV4cGFuZCBzZXR0aW5nXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhwYW5kIHRoZSBuZXh0IHRva2VuIG9ubHkgb25jZSBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogSWYgdGhlIHRva2VuIGlzIGV4cGFuZGVkLCB0aGUgcmVzdWx0aW5nIHRva2VucyB3aWxsIGJlIHB1c2hlZCBvbnRvXG4gICAqIHRoZSBzdGFjayBpbiByZXZlcnNlIG9yZGVyLCBhbmQgdGhlIG51bWJlciBvZiBzdWNoIHRva2VucyB3aWxsIGJlXG4gICAqIHJldHVybmVkLiAgVGhpcyBudW1iZXIgbWlnaHQgYmUgemVybyBvciBwb3NpdGl2ZS5cbiAgICpcbiAgICogSWYgbm90LCB0aGUgcmV0dXJuIHZhbHVlIGlzIGBmYWxzZWAsIGFuZCB0aGUgbmV4dCB0b2tlbiByZW1haW5zIGF0IHRoZVxuICAgKiB0b3Agb2YgdGhlIHN0YWNrLlxuICAgKlxuICAgKiBJbiBlaXRoZXIgY2FzZSwgdGhlIG5leHQgdG9rZW4gd2lsbCBiZSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFjayxcbiAgICogb3IgdGhlIHN0YWNrIHdpbGwgYmUgZW1wdHkgKGluIGNhc2Ugb2YgZW1wdHkgZXhwYW5zaW9uXG4gICAqIGFuZCBubyBvdGhlciB0b2tlbnMpLlxuICAgKlxuICAgKiBVc2VkIHRvIGltcGxlbWVudCBgZXhwYW5kQWZ0ZXJGdXR1cmVgIGFuZCBgZXhwYW5kTmV4dFRva2VuYC5cbiAgICpcbiAgICogSWYgZXhwYW5kYWJsZU9ubHksIG9ubHkgZXhwYW5kYWJsZSB0b2tlbnMgYXJlIGV4cGFuZGVkIGFuZFxuICAgKiBhbiB1bmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZSByZXN1bHRzIGluIGFuIGVycm9yLlxuICAgKi9cblxuXG4gIGV4cGFuZE9uY2UoZXhwYW5kYWJsZU9ubHkpIHtcbiAgICBjb25zdCB0b3BUb2tlbiA9IHRoaXMucG9wVG9rZW4oKTtcbiAgICBjb25zdCBuYW1lID0gdG9wVG9rZW4udGV4dDtcbiAgICBjb25zdCBleHBhbnNpb24gPSAhdG9wVG9rZW4ubm9leHBhbmQgPyB0aGlzLl9nZXRFeHBhbnNpb24obmFtZSkgOiBudWxsO1xuXG4gICAgaWYgKGV4cGFuc2lvbiA9PSBudWxsIHx8IGV4cGFuZGFibGVPbmx5ICYmIGV4cGFuc2lvbi51bmV4cGFuZGFibGUpIHtcbiAgICAgIGlmIChleHBhbmRhYmxlT25seSAmJiBleHBhbnNpb24gPT0gbnVsbCAmJiBuYW1lWzBdID09PSBcIlxcXFxcIiAmJiAhdGhpcy5pc0RlZmluZWQobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5kZWZpbmVkIGNvbnRyb2wgc2VxdWVuY2U6IFwiICsgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaFRva2VuKHRvcFRva2VuKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvdW50RXhwYW5zaW9uKDEpO1xuICAgIGxldCB0b2tlbnMgPSBleHBhbnNpb24udG9rZW5zO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmNvbnN1bWVBcmdzKGV4cGFuc2lvbi5udW1BcmdzLCBleHBhbnNpb24uZGVsaW1pdGVycyk7XG5cbiAgICBpZiAoZXhwYW5zaW9uLm51bUFyZ3MpIHtcbiAgICAgIC8vIHBhc3RlIGFyZ3VtZW50cyBpbiBwbGFjZSBvZiB0aGUgcGxhY2Vob2xkZXJzXG4gICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTsgLy8gbWFrZSBhIHNoYWxsb3cgY29weVxuXG4gICAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGxldCB0b2sgPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbmNvbXBsZXRlIHBsYWNlaG9sZGVyIGF0IGVuZCBvZiBtYWNybyBib2R5XCIsIHRvayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rID0gdG9rZW5zWy0taV07IC8vIG5leHQgdG9rZW4gb24gc3RhY2tcblxuICAgICAgICAgIGlmICh0b2sudGV4dCA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIC8vICMjIOKGkiAjXG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAxKTsgLy8gZHJvcCBmaXJzdCAjXG4gICAgICAgICAgfSBlbHNlIGlmICgvXlsxLTldJC8udGVzdCh0b2sudGV4dCkpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdpdGggdGhlIGluZGljYXRlZCBhcmd1bWVudFxuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAyLCAuLi5hcmdzWyt0b2sudGV4dCAtIDFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTm90IGEgdmFsaWQgYXJndW1lbnQgbnVtYmVyXCIsIHRvayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBDb25jYXRlbmF0ZSBleHBhbnNpb24gb250byB0b3Agb2Ygc3RhY2suXG5cblxuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHJldHVybiB0b2tlbnMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBFeHBhbmQgdGhlIG5leHQgdG9rZW4gb25seSBvbmNlIChpZiBwb3NzaWJsZSksIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZ1xuICAgKiB0b3AgdG9rZW4gb24gdGhlIHN0YWNrICh3aXRob3V0IHJlbW92aW5nIGFueXRoaW5nIGZyb20gdGhlIHN0YWNrKS5cbiAgICogU2ltaWxhciBpbiBiZWhhdmlvciB0byBUZVgncyBgXFxleHBhbmRhZnRlclxcZnV0dXJlbGV0YC5cbiAgICogRXF1aXZhbGVudCB0byBleHBhbmRPbmNlKCkgZm9sbG93ZWQgYnkgZnV0dXJlKCkuXG4gICAqL1xuXG5cbiAgZXhwYW5kQWZ0ZXJGdXR1cmUoKSB7XG4gICAgdGhpcy5leHBhbmRPbmNlKCk7XG4gICAgcmV0dXJuIHRoaXMuZnV0dXJlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGV4cGFuZCBmaXJzdCB0b2tlbiwgdGhlbiByZXR1cm4gZmlyc3Qgbm9uLWV4cGFuZGFibGUgdG9rZW4uXG4gICAqL1xuXG5cbiAgZXhwYW5kTmV4dFRva2VuKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLmV4cGFuZE9uY2UoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZnVsbHkgZXhwYW5kZWRcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnN0YWNrLnBvcCgpOyAvLyB0aGUgdG9rZW4gYWZ0ZXIgXFxub2V4cGFuZCBpcyBpbnRlcnByZXRlZCBhcyBpZiBpdHMgbWVhbmluZ1xuICAgICAgICAvLyB3ZXJlIOKAmFxccmVsYXjigJlcblxuICAgICAgICBpZiAodG9rZW4udHJlYXRBc1JlbGF4KSB7XG4gICAgICAgICAgdG9rZW4udGV4dCA9IFwiXFxcXHJlbGF4XCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfSAvLyBGbG93IHVuYWJsZSB0byBmaWd1cmUgb3V0IHRoYXQgdGhpcyBwYXRod2F5IGlzIGltcG9zc2libGUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzQ4MDhcblxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgfVxuICAvKipcbiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiBtYWNybyBuYW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBsaXN0IG9mXG4gICAqIHRva2Vucywgb3IgcmV0dXJuIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggbWFjcm8gaXMgZGVmaW5lZC5cbiAgICovXG5cblxuICBleHBhbmRNYWNybyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFjcm9zLmhhcyhuYW1lKSA/IHRoaXMuZXhwYW5kVG9rZW5zKFtuZXcgVG9rZW4obmFtZSldKSA6IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiB0b2tlbiBzdHJlYW0gYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGxpc3Qgb2ZcbiAgICogdG9rZW5zLiAgTm90ZSB0aGF0IHRoZSBpbnB1dCB0b2tlbnMgYXJlIGluIHJldmVyc2Ugb3JkZXIsIGJ1dCB0aGVcbiAgICogb3V0cHV0IHRva2VucyBhcmUgaW4gZm9yd2FyZCBvcmRlci5cbiAgICovXG5cblxuICBleHBhbmRUb2tlbnModG9rZW5zKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3Qgb2xkU3RhY2tMZW5ndGggPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcblxuICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IG9sZFN0YWNrTGVuZ3RoKSB7XG4gICAgICAvLyBFeHBhbmQgb25seSBleHBhbmRhYmxlIHRva2Vuc1xuICAgICAgaWYgKHRoaXMuZXhwYW5kT25jZSh0cnVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZnVsbHkgZXhwYW5kZWRcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50cmVhdEFzUmVsYXgpIHtcbiAgICAgICAgICAvLyB0aGUgZXhwYW5zaW9uIG9mIFxcbm9leHBhbmQgaXMgdGhlIHRva2VuIGl0c2VsZlxuICAgICAgICAgIHRva2VuLm5vZXhwYW5kID0gZmFsc2U7XG4gICAgICAgICAgdG9rZW4udHJlYXRBc1JlbGF4ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfSAvLyBDb3VudCBhbGwgb2YgdGhlc2UgdG9rZW5zIGFzIGFkZGl0aW9uYWwgZXhwYW5zaW9ucywgdG8gcHJldmVudFxuICAgIC8vIGV4cG9uZW50aWFsIGJsb3d1cCBmcm9tIGxpbmVhcmx5IG1hbnkgXFxlZGVmJ3MuXG5cblxuICAgIHRoaXMuY291bnRFeHBhbnNpb24ob3V0cHV0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICAvKipcbiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiBtYWNybyBuYW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIHN0cmluZyxcbiAgICogb3IgcmV0dXJuIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggbWFjcm8gaXMgZGVmaW5lZC5cbiAgICovXG5cblxuICBleHBhbmRNYWNyb0FzVGV4dChuYW1lKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy5leHBhbmRNYWNybyhuYW1lKTtcblxuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHJldHVybiB0b2tlbnMubWFwKHRva2VuID0+IHRva2VuLnRleHQpLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBleHBhbmRlZCBtYWNybyBhcyBhIHJldmVyc2VkIGFycmF5IG9mIHRva2VucyBhbmQgYSBtYWNyb1xuICAgKiBhcmd1bWVudCBjb3VudC4gIE9yIHJldHVybnMgYG51bGxgIGlmIG5vIHN1Y2ggbWFjcm8uXG4gICAqL1xuXG5cbiAgX2dldEV4cGFuc2lvbihuYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMubWFjcm9zLmdldChuYW1lKTtcblxuICAgIGlmIChkZWZpbml0aW9uID09IG51bGwpIHtcbiAgICAgIC8vIG1haW5seSBjaGVja2luZyBmb3IgdW5kZWZpbmVkIGhlcmVcbiAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH0gLy8gSWYgYSBzaW5nbGUgY2hhcmFjdGVyIGhhcyBhbiBhc3NvY2lhdGVkIGNhdGNvZGUgb3RoZXIgdGhhbiAxM1xuICAgIC8vIChhY3RpdmUgY2hhcmFjdGVyKSwgdGhlbiBkb24ndCBleHBhbmQgaXQuXG5cblxuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY2F0Y29kZSA9IHRoaXMubGV4ZXIuY2F0Y29kZXNbbmFtZV07XG5cbiAgICAgIGlmIChjYXRjb2RlICE9IG51bGwgJiYgY2F0Y29kZSAhPT0gMTMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGV4cGFuc2lvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBkZWZpbml0aW9uKHRoaXMpIDogZGVmaW5pdGlvbjtcblxuICAgIGlmICh0eXBlb2YgZXhwYW5zaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBsZXQgbnVtQXJncyA9IDA7XG5cbiAgICAgIGlmIChleHBhbnNpb24uaW5kZXhPZihcIiNcIikgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkID0gZXhwYW5zaW9uLnJlcGxhY2UoLyMjL2csIFwiXCIpO1xuXG4gICAgICAgIHdoaWxlIChzdHJpcHBlZC5pbmRleE9mKFwiI1wiICsgKG51bUFyZ3MgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgKytudW1BcmdzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHlMZXhlciA9IG5ldyBMZXhlcihleHBhbnNpb24sIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICBsZXQgdG9rID0gYm9keUxleGVyLmxleCgpO1xuXG4gICAgICB3aGlsZSAodG9rLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICAgICAgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgfVxuXG4gICAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayB1c2luZyBwdXNoIGFuZCBwb3BcblxuICAgICAgY29uc3QgZXhwYW5kZWQgPSB7XG4gICAgICAgIHRva2VucyxcbiAgICAgICAgbnVtQXJnc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwYW5zaW9uO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgY3VycmVudGx5IFwiZGVmaW5lZFwiIChoYXMgc29tZVxuICAgKiBmdW5jdGlvbmFsaXR5KSwgbWVhbmluZyB0aGF0IGl0J3MgYSBtYWNybyAoaW4gdGhlIGN1cnJlbnQgZ3JvdXApLFxuICAgKiBhIGZ1bmN0aW9uLCBhIHN5bWJvbCwgb3Igb25lIG9mIHRoZSBzcGVjaWFsIGNvbW1hbmRzIGxpc3RlZCBpblxuICAgKiBgaW1wbGljaXRDb21tYW5kc2AuXG4gICAqL1xuXG5cbiAgaXNEZWZpbmVkKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNyb3MuaGFzKG5hbWUpIHx8IHNyY19mdW5jdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgc3JjX3N5bWJvbHMubWF0aC5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBzcmNfc3ltYm9scy50ZXh0Lmhhc093blByb3BlcnR5KG5hbWUpIHx8IGltcGxpY2l0Q29tbWFuZHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBleHBhbmRhYmxlLlxuICAgKi9cblxuXG4gIGlzRXhwYW5kYWJsZShuYW1lKSB7XG4gICAgY29uc3QgbWFjcm8gPSB0aGlzLm1hY3Jvcy5nZXQobmFtZSk7XG4gICAgcmV0dXJuIG1hY3JvICE9IG51bGwgPyB0eXBlb2YgbWFjcm8gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hY3JvID09PSBcImZ1bmN0aW9uXCIgfHwgIW1hY3JvLnVuZXhwYW5kYWJsZSA6IHNyY19mdW5jdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIXNyY19mdW5jdGlvbnNbbmFtZV0ucHJpbWl0aXZlO1xuICB9XG5cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91bmljb2RlU3VwT3JTdWIuanNcbi8vIEhlbHBlcnMgZm9yIFBhcnNlci5qcyBoYW5kbGluZyBvZiBVbmljb2RlIChzdWJ8c3VwZXIpc2NyaXB0IGNoYXJhY3RlcnMuXG5jb25zdCB1bmljb2RlU3ViUmVnRXggPSAvXlvigorigovigozigo3igo7igoDigoHigoLigoPigoTigoXigobigofigojigonigpDigpHigpXhtaLisbzigpbigpfigpjigpnigpLigprhtaPigpvigpzhtaThtaXigpPhtabhtafhtajhtanhtapdLztcbmNvbnN0IHVTdWJzQW5kU3VwcyA9IE9iamVjdC5mcmVlemUoe1xuICAn4oKKJzogJysnLFxuICAn4oKLJzogJy0nLFxuICAn4oKMJzogJz0nLFxuICAn4oKNJzogJygnLFxuICAn4oKOJzogJyknLFxuICAn4oKAJzogJzAnLFxuICAn4oKBJzogJzEnLFxuICAn4oKCJzogJzInLFxuICAn4oKDJzogJzMnLFxuICAn4oKEJzogJzQnLFxuICAn4oKFJzogJzUnLFxuICAn4oKGJzogJzYnLFxuICAn4oKHJzogJzcnLFxuICAn4oKIJzogJzgnLFxuICAn4oKJJzogJzknLFxuICAnXFx1MjA5MCc6ICdhJyxcbiAgJ1xcdTIwOTEnOiAnZScsXG4gICdcXHUyMDk1JzogJ2gnLFxuICAnXFx1MUQ2Mic6ICdpJyxcbiAgJ1xcdTJDN0MnOiAnaicsXG4gICdcXHUyMDk2JzogJ2snLFxuICAnXFx1MjA5Nyc6ICdsJyxcbiAgJ1xcdTIwOTgnOiAnbScsXG4gICdcXHUyMDk5JzogJ24nLFxuICAnXFx1MjA5Mic6ICdvJyxcbiAgJ1xcdTIwOUEnOiAncCcsXG4gICdcXHUxRDYzJzogJ3InLFxuICAnXFx1MjA5Qic6ICdzJyxcbiAgJ1xcdTIwOUMnOiAndCcsXG4gICdcXHUxRDY0JzogJ3UnLFxuICAnXFx1MUQ2NSc6ICd2JyxcbiAgJ1xcdTIwOTMnOiAneCcsXG4gICdcXHUxRDY2JzogJ86yJyxcbiAgJ1xcdTFENjcnOiAnzrMnLFxuICAnXFx1MUQ2OCc6ICfPgScsXG4gICdcXHUxRDY5JzogJ1xcdTAzZDUnLFxuICAnXFx1MUQ2QSc6ICfPhycsXG4gICfigbonOiAnKycsXG4gICfigbsnOiAnLScsXG4gICfigbwnOiAnPScsXG4gICfigb0nOiAnKCcsXG4gICfigb4nOiAnKScsXG4gICfigbAnOiAnMCcsXG4gICfCuSc6ICcxJyxcbiAgJ8KyJzogJzInLFxuICAnwrMnOiAnMycsXG4gICfigbQnOiAnNCcsXG4gICfigbUnOiAnNScsXG4gICfigbYnOiAnNicsXG4gICfigbcnOiAnNycsXG4gICfigbgnOiAnOCcsXG4gICfigbknOiAnOScsXG4gICdcXHUxRDJDJzogJ0EnLFxuICAnXFx1MUQyRSc6ICdCJyxcbiAgJ1xcdTFEMzAnOiAnRCcsXG4gICdcXHUxRDMxJzogJ0UnLFxuICAnXFx1MUQzMyc6ICdHJyxcbiAgJ1xcdTFEMzQnOiAnSCcsXG4gICdcXHUxRDM1JzogJ0knLFxuICAnXFx1MUQzNic6ICdKJyxcbiAgJ1xcdTFEMzcnOiAnSycsXG4gICdcXHUxRDM4JzogJ0wnLFxuICAnXFx1MUQzOSc6ICdNJyxcbiAgJ1xcdTFEM0EnOiAnTicsXG4gICdcXHUxRDNDJzogJ08nLFxuICAnXFx1MUQzRSc6ICdQJyxcbiAgJ1xcdTFEM0YnOiAnUicsXG4gICdcXHUxRDQwJzogJ1QnLFxuICAnXFx1MUQ0MSc6ICdVJyxcbiAgJ1xcdTJDN0QnOiAnVicsXG4gICdcXHUxRDQyJzogJ1cnLFxuICAnXFx1MUQ0Myc6ICdhJyxcbiAgJ1xcdTFENDcnOiAnYicsXG4gICdcXHUxRDlDJzogJ2MnLFxuICAnXFx1MUQ0OCc6ICdkJyxcbiAgJ1xcdTFENDknOiAnZScsXG4gICdcXHUxREEwJzogJ2YnLFxuICAnXFx1MUQ0RCc6ICdnJyxcbiAgJ1xcdTAyQjAnOiAnaCcsXG4gICdcXHUyMDcxJzogJ2knLFxuICAnXFx1MDJCMic6ICdqJyxcbiAgJ1xcdTFENEYnOiAnaycsXG4gICdcXHUwMkUxJzogJ2wnLFxuICAnXFx1MUQ1MCc6ICdtJyxcbiAgJ1xcdTIwN0YnOiAnbicsXG4gICdcXHUxRDUyJzogJ28nLFxuICAnXFx1MUQ1Nic6ICdwJyxcbiAgJ1xcdTAyQjMnOiAncicsXG4gICdcXHUwMkUyJzogJ3MnLFxuICAnXFx1MUQ1Nyc6ICd0JyxcbiAgJ1xcdTFENTgnOiAndScsXG4gICdcXHUxRDVCJzogJ3YnLFxuICAnXFx1MDJCNyc6ICd3JyxcbiAgJ1xcdTAyRTMnOiAneCcsXG4gICdcXHUwMkI4JzogJ3knLFxuICAnXFx1MURCQic6ICd6JyxcbiAgJ1xcdTFENUQnOiAnzrInLFxuICAnXFx1MUQ1RSc6ICfOsycsXG4gICdcXHUxRDVGJzogJ860JyxcbiAgJ1xcdTFENjAnOiAnXFx1MDNkNScsXG4gICdcXHUxRDYxJzogJ8+HJyxcbiAgJ1xcdTFEQkYnOiAnzrgnXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9QYXJzZXIuanNcbi8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246MCAqL1xuXG5cblxuXG5cblxuXG5cblxuXG4gLy8gUHJlLWV2YWx1YXRlIGJvdGggbW9kdWxlcyBhcyB1bmljb2RlU3ltYm9scyByZXF1aXJlIFN0cmluZy5ub3JtYWxpemUoKVxuXG5jb25zdCB1bmljb2RlQWNjZW50cyA9IHtcbiAgXCLMgVwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXCdcIixcbiAgICBcIm1hdGhcIjogXCJcXFxcYWN1dGVcIlxuICB9LFxuICBcIsyAXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcYFwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxncmF2ZVwiXG4gIH0sXG4gIFwizIhcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFxcXFwiXCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGRkb3RcIlxuICB9LFxuICBcIsyDXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcflwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFx0aWxkZVwiXG4gIH0sXG4gIFwizIRcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFw9XCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGJhclwiXG4gIH0sXG4gIFwizIZcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFx1XCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGJyZXZlXCJcbiAgfSxcbiAgXCLMjFwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXHZcIixcbiAgICBcIm1hdGhcIjogXCJcXFxcY2hlY2tcIlxuICB9LFxuICBcIsyCXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcXlwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxoYXRcIlxuICB9LFxuICBcIsyHXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcLlwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxkb3RcIlxuICB9LFxuICBcIsyKXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcclwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxtYXRocmluZ1wiXG4gIH0sXG4gIFwizItcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFxIXCJcbiAgfSxcbiAgXCLMp1wiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXGNcIlxuICB9XG59O1xuY29uc3QgdW5pY29kZVN5bWJvbHMgPSB7XG4gIFwiw6FcIjogXCJhzIFcIixcbiAgXCLDoFwiOiBcImHMgFwiLFxuICBcIsOkXCI6IFwiYcyIXCIsXG4gIFwix59cIjogXCJhzIjMhFwiLFxuICBcIsOjXCI6IFwiYcyDXCIsXG4gIFwixIFcIjogXCJhzIRcIixcbiAgXCLEg1wiOiBcImHMhlwiLFxuICBcIuG6r1wiOiBcImHMhsyBXCIsXG4gIFwi4bqxXCI6IFwiYcyGzIBcIixcbiAgXCLhurVcIjogXCJhzIbMg1wiLFxuICBcIseOXCI6IFwiYcyMXCIsXG4gIFwiw6JcIjogXCJhzIJcIixcbiAgXCLhuqVcIjogXCJhzILMgVwiLFxuICBcIuG6p1wiOiBcImHMgsyAXCIsXG4gIFwi4bqrXCI6IFwiYcyCzINcIixcbiAgXCLIp1wiOiBcImHMh1wiLFxuICBcIsehXCI6IFwiYcyHzIRcIixcbiAgXCLDpVwiOiBcImHMilwiLFxuICBcIse7XCI6IFwiYcyKzIFcIixcbiAgXCLhuINcIjogXCJizIdcIixcbiAgXCLEh1wiOiBcImPMgVwiLFxuICBcIuG4iVwiOiBcImPMp8yBXCIsXG4gIFwixI1cIjogXCJjzIxcIixcbiAgXCLEiVwiOiBcImPMglwiLFxuICBcIsSLXCI6IFwiY8yHXCIsXG4gIFwiw6dcIjogXCJjzKdcIixcbiAgXCLEj1wiOiBcImTMjFwiLFxuICBcIuG4i1wiOiBcImTMh1wiLFxuICBcIuG4kVwiOiBcImTMp1wiLFxuICBcIsOpXCI6IFwiZcyBXCIsXG4gIFwiw6hcIjogXCJlzIBcIixcbiAgXCLDq1wiOiBcImXMiFwiLFxuICBcIuG6vVwiOiBcImXMg1wiLFxuICBcIsSTXCI6IFwiZcyEXCIsXG4gIFwi4biXXCI6IFwiZcyEzIFcIixcbiAgXCLhuJVcIjogXCJlzITMgFwiLFxuICBcIsSVXCI6IFwiZcyGXCIsXG4gIFwi4bidXCI6IFwiZcynzIZcIixcbiAgXCLEm1wiOiBcImXMjFwiLFxuICBcIsOqXCI6IFwiZcyCXCIsXG4gIFwi4bq/XCI6IFwiZcyCzIFcIixcbiAgXCLhu4FcIjogXCJlzILMgFwiLFxuICBcIuG7hVwiOiBcImXMgsyDXCIsXG4gIFwixJdcIjogXCJlzIdcIixcbiAgXCLIqVwiOiBcImXMp1wiLFxuICBcIuG4n1wiOiBcImbMh1wiLFxuICBcIse1XCI6IFwiZ8yBXCIsXG4gIFwi4bihXCI6IFwiZ8yEXCIsXG4gIFwixJ9cIjogXCJnzIZcIixcbiAgXCLHp1wiOiBcImfMjFwiLFxuICBcIsSdXCI6IFwiZ8yCXCIsXG4gIFwixKFcIjogXCJnzIdcIixcbiAgXCLEo1wiOiBcImfMp1wiLFxuICBcIuG4p1wiOiBcImjMiFwiLFxuICBcIsifXCI6IFwiaMyMXCIsXG4gIFwixKVcIjogXCJozIJcIixcbiAgXCLhuKNcIjogXCJozIdcIixcbiAgXCLhuKlcIjogXCJozKdcIixcbiAgXCLDrVwiOiBcImnMgVwiLFxuICBcIsOsXCI6IFwiacyAXCIsXG4gIFwiw69cIjogXCJpzIhcIixcbiAgXCLhuK9cIjogXCJpzIjMgVwiLFxuICBcIsSpXCI6IFwiacyDXCIsXG4gIFwixKtcIjogXCJpzIRcIixcbiAgXCLErVwiOiBcImnMhlwiLFxuICBcIseQXCI6IFwiacyMXCIsXG4gIFwiw65cIjogXCJpzIJcIixcbiAgXCLHsFwiOiBcImrMjFwiLFxuICBcIsS1XCI6IFwiasyCXCIsXG4gIFwi4bixXCI6IFwia8yBXCIsXG4gIFwix6lcIjogXCJrzIxcIixcbiAgXCLEt1wiOiBcImvMp1wiLFxuICBcIsS6XCI6IFwibMyBXCIsXG4gIFwixL5cIjogXCJszIxcIixcbiAgXCLEvFwiOiBcImzMp1wiLFxuICBcIuG4v1wiOiBcIm3MgVwiLFxuICBcIuG5gVwiOiBcIm3Mh1wiLFxuICBcIsWEXCI6IFwibsyBXCIsXG4gIFwix7lcIjogXCJuzIBcIixcbiAgXCLDsVwiOiBcIm7Mg1wiLFxuICBcIsWIXCI6IFwibsyMXCIsXG4gIFwi4bmFXCI6IFwibsyHXCIsXG4gIFwixYZcIjogXCJuzKdcIixcbiAgXCLDs1wiOiBcIm/MgVwiLFxuICBcIsOyXCI6IFwib8yAXCIsXG4gIFwiw7ZcIjogXCJvzIhcIixcbiAgXCLIq1wiOiBcIm/MiMyEXCIsXG4gIFwiw7VcIjogXCJvzINcIixcbiAgXCLhuY1cIjogXCJvzIPMgVwiLFxuICBcIuG5j1wiOiBcIm/Mg8yIXCIsXG4gIFwiyK1cIjogXCJvzIPMhFwiLFxuICBcIsWNXCI6IFwib8yEXCIsXG4gIFwi4bmTXCI6IFwib8yEzIFcIixcbiAgXCLhuZFcIjogXCJvzITMgFwiLFxuICBcIsWPXCI6IFwib8yGXCIsXG4gIFwix5JcIjogXCJvzIxcIixcbiAgXCLDtFwiOiBcIm/MglwiLFxuICBcIuG7kVwiOiBcIm/MgsyBXCIsXG4gIFwi4buTXCI6IFwib8yCzIBcIixcbiAgXCLhu5dcIjogXCJvzILMg1wiLFxuICBcIsivXCI6IFwib8yHXCIsXG4gIFwiyLFcIjogXCJvzIfMhFwiLFxuICBcIsWRXCI6IFwib8yLXCIsXG4gIFwi4bmVXCI6IFwicMyBXCIsXG4gIFwi4bmXXCI6IFwicMyHXCIsXG4gIFwixZVcIjogXCJyzIFcIixcbiAgXCLFmVwiOiBcInLMjFwiLFxuICBcIuG5mVwiOiBcInLMh1wiLFxuICBcIsWXXCI6IFwicsynXCIsXG4gIFwixZtcIjogXCJzzIFcIixcbiAgXCLhuaVcIjogXCJzzIHMh1wiLFxuICBcIsWhXCI6IFwic8yMXCIsXG4gIFwi4bmnXCI6IFwic8yMzIdcIixcbiAgXCLFnVwiOiBcInPMglwiLFxuICBcIuG5oVwiOiBcInPMh1wiLFxuICBcIsWfXCI6IFwic8ynXCIsXG4gIFwi4bqXXCI6IFwidMyIXCIsXG4gIFwixaVcIjogXCJ0zIxcIixcbiAgXCLhuatcIjogXCJ0zIdcIixcbiAgXCLFo1wiOiBcInTMp1wiLFxuICBcIsO6XCI6IFwidcyBXCIsXG4gIFwiw7lcIjogXCJ1zIBcIixcbiAgXCLDvFwiOiBcInXMiFwiLFxuICBcIseYXCI6IFwidcyIzIFcIixcbiAgXCLHnFwiOiBcInXMiMyAXCIsXG4gIFwix5ZcIjogXCJ1zIjMhFwiLFxuICBcIseaXCI6IFwidcyIzIxcIixcbiAgXCLFqVwiOiBcInXMg1wiLFxuICBcIuG5uVwiOiBcInXMg8yBXCIsXG4gIFwixatcIjogXCJ1zIRcIixcbiAgXCLhubtcIjogXCJ1zITMiFwiLFxuICBcIsWtXCI6IFwidcyGXCIsXG4gIFwix5RcIjogXCJ1zIxcIixcbiAgXCLDu1wiOiBcInXMglwiLFxuICBcIsWvXCI6IFwidcyKXCIsXG4gIFwixbFcIjogXCJ1zItcIixcbiAgXCLhub1cIjogXCJ2zINcIixcbiAgXCLhuoNcIjogXCJ3zIFcIixcbiAgXCLhuoFcIjogXCJ3zIBcIixcbiAgXCLhuoVcIjogXCJ3zIhcIixcbiAgXCLFtVwiOiBcInfMglwiLFxuICBcIuG6h1wiOiBcInfMh1wiLFxuICBcIuG6mFwiOiBcInfMilwiLFxuICBcIuG6jVwiOiBcInjMiFwiLFxuICBcIuG6i1wiOiBcInjMh1wiLFxuICBcIsO9XCI6IFwiecyBXCIsXG4gIFwi4buzXCI6IFwiecyAXCIsXG4gIFwiw79cIjogXCJ5zIhcIixcbiAgXCLhu7lcIjogXCJ5zINcIixcbiAgXCLIs1wiOiBcInnMhFwiLFxuICBcIsW3XCI6IFwiecyCXCIsXG4gIFwi4bqPXCI6IFwiecyHXCIsXG4gIFwi4bqZXCI6IFwiecyKXCIsXG4gIFwixbpcIjogXCJ6zIFcIixcbiAgXCLFvlwiOiBcInrMjFwiLFxuICBcIuG6kVwiOiBcInrMglwiLFxuICBcIsW8XCI6IFwiesyHXCIsXG4gIFwiw4FcIjogXCJBzIFcIixcbiAgXCLDgFwiOiBcIkHMgFwiLFxuICBcIsOEXCI6IFwiQcyIXCIsXG4gIFwix55cIjogXCJBzIjMhFwiLFxuICBcIsODXCI6IFwiQcyDXCIsXG4gIFwixIBcIjogXCJBzIRcIixcbiAgXCLEglwiOiBcIkHMhlwiLFxuICBcIuG6rlwiOiBcIkHMhsyBXCIsXG4gIFwi4bqwXCI6IFwiQcyGzIBcIixcbiAgXCLhurRcIjogXCJBzIbMg1wiLFxuICBcIseNXCI6IFwiQcyMXCIsXG4gIFwiw4JcIjogXCJBzIJcIixcbiAgXCLhuqRcIjogXCJBzILMgVwiLFxuICBcIuG6plwiOiBcIkHMgsyAXCIsXG4gIFwi4bqqXCI6IFwiQcyCzINcIixcbiAgXCLIplwiOiBcIkHMh1wiLFxuICBcIsegXCI6IFwiQcyHzIRcIixcbiAgXCLDhVwiOiBcIkHMilwiLFxuICBcIse6XCI6IFwiQcyKzIFcIixcbiAgXCLhuIJcIjogXCJCzIdcIixcbiAgXCLEhlwiOiBcIkPMgVwiLFxuICBcIuG4iFwiOiBcIkPMp8yBXCIsXG4gIFwixIxcIjogXCJDzIxcIixcbiAgXCLEiFwiOiBcIkPMglwiLFxuICBcIsSKXCI6IFwiQ8yHXCIsXG4gIFwiw4dcIjogXCJDzKdcIixcbiAgXCLEjlwiOiBcIkTMjFwiLFxuICBcIuG4ilwiOiBcIkTMh1wiLFxuICBcIuG4kFwiOiBcIkTMp1wiLFxuICBcIsOJXCI6IFwiRcyBXCIsXG4gIFwiw4hcIjogXCJFzIBcIixcbiAgXCLDi1wiOiBcIkXMiFwiLFxuICBcIuG6vFwiOiBcIkXMg1wiLFxuICBcIsSSXCI6IFwiRcyEXCIsXG4gIFwi4biWXCI6IFwiRcyEzIFcIixcbiAgXCLhuJRcIjogXCJFzITMgFwiLFxuICBcIsSUXCI6IFwiRcyGXCIsXG4gIFwi4bicXCI6IFwiRcynzIZcIixcbiAgXCLEmlwiOiBcIkXMjFwiLFxuICBcIsOKXCI6IFwiRcyCXCIsXG4gIFwi4bq+XCI6IFwiRcyCzIFcIixcbiAgXCLhu4BcIjogXCJFzILMgFwiLFxuICBcIuG7hFwiOiBcIkXMgsyDXCIsXG4gIFwixJZcIjogXCJFzIdcIixcbiAgXCLIqFwiOiBcIkXMp1wiLFxuICBcIuG4nlwiOiBcIkbMh1wiLFxuICBcIse0XCI6IFwiR8yBXCIsXG4gIFwi4bigXCI6IFwiR8yEXCIsXG4gIFwixJ5cIjogXCJHzIZcIixcbiAgXCLHplwiOiBcIkfMjFwiLFxuICBcIsScXCI6IFwiR8yCXCIsXG4gIFwixKBcIjogXCJHzIdcIixcbiAgXCLEolwiOiBcIkfMp1wiLFxuICBcIuG4plwiOiBcIkjMiFwiLFxuICBcIsieXCI6IFwiSMyMXCIsXG4gIFwixKRcIjogXCJIzIJcIixcbiAgXCLhuKJcIjogXCJIzIdcIixcbiAgXCLhuKhcIjogXCJIzKdcIixcbiAgXCLDjVwiOiBcIknMgVwiLFxuICBcIsOMXCI6IFwiScyAXCIsXG4gIFwiw49cIjogXCJJzIhcIixcbiAgXCLhuK5cIjogXCJJzIjMgVwiLFxuICBcIsSoXCI6IFwiScyDXCIsXG4gIFwixKpcIjogXCJJzIRcIixcbiAgXCLErFwiOiBcIknMhlwiLFxuICBcIsePXCI6IFwiScyMXCIsXG4gIFwiw45cIjogXCJJzIJcIixcbiAgXCLEsFwiOiBcIknMh1wiLFxuICBcIsS0XCI6IFwiSsyCXCIsXG4gIFwi4biwXCI6IFwiS8yBXCIsXG4gIFwix6hcIjogXCJLzIxcIixcbiAgXCLEtlwiOiBcIkvMp1wiLFxuICBcIsS5XCI6IFwiTMyBXCIsXG4gIFwixL1cIjogXCJMzIxcIixcbiAgXCLEu1wiOiBcIkzMp1wiLFxuICBcIuG4vlwiOiBcIk3MgVwiLFxuICBcIuG5gFwiOiBcIk3Mh1wiLFxuICBcIsWDXCI6IFwiTsyBXCIsXG4gIFwix7hcIjogXCJOzIBcIixcbiAgXCLDkVwiOiBcIk7Mg1wiLFxuICBcIsWHXCI6IFwiTsyMXCIsXG4gIFwi4bmEXCI6IFwiTsyHXCIsXG4gIFwixYVcIjogXCJOzKdcIixcbiAgXCLDk1wiOiBcIk/MgVwiLFxuICBcIsOSXCI6IFwiT8yAXCIsXG4gIFwiw5ZcIjogXCJPzIhcIixcbiAgXCLIqlwiOiBcIk/MiMyEXCIsXG4gIFwiw5VcIjogXCJPzINcIixcbiAgXCLhuYxcIjogXCJPzIPMgVwiLFxuICBcIuG5jlwiOiBcIk/Mg8yIXCIsXG4gIFwiyKxcIjogXCJPzIPMhFwiLFxuICBcIsWMXCI6IFwiT8yEXCIsXG4gIFwi4bmSXCI6IFwiT8yEzIFcIixcbiAgXCLhuZBcIjogXCJPzITMgFwiLFxuICBcIsWOXCI6IFwiT8yGXCIsXG4gIFwix5FcIjogXCJPzIxcIixcbiAgXCLDlFwiOiBcIk/MglwiLFxuICBcIuG7kFwiOiBcIk/MgsyBXCIsXG4gIFwi4buSXCI6IFwiT8yCzIBcIixcbiAgXCLhu5ZcIjogXCJPzILMg1wiLFxuICBcIsiuXCI6IFwiT8yHXCIsXG4gIFwiyLBcIjogXCJPzIfMhFwiLFxuICBcIsWQXCI6IFwiT8yLXCIsXG4gIFwi4bmUXCI6IFwiUMyBXCIsXG4gIFwi4bmWXCI6IFwiUMyHXCIsXG4gIFwixZRcIjogXCJSzIFcIixcbiAgXCLFmFwiOiBcIlLMjFwiLFxuICBcIuG5mFwiOiBcIlLMh1wiLFxuICBcIsWWXCI6IFwiUsynXCIsXG4gIFwixZpcIjogXCJTzIFcIixcbiAgXCLhuaRcIjogXCJTzIHMh1wiLFxuICBcIsWgXCI6IFwiU8yMXCIsXG4gIFwi4bmmXCI6IFwiU8yMzIdcIixcbiAgXCLFnFwiOiBcIlPMglwiLFxuICBcIuG5oFwiOiBcIlPMh1wiLFxuICBcIsWeXCI6IFwiU8ynXCIsXG4gIFwixaRcIjogXCJUzIxcIixcbiAgXCLhuapcIjogXCJUzIdcIixcbiAgXCLFolwiOiBcIlTMp1wiLFxuICBcIsOaXCI6IFwiVcyBXCIsXG4gIFwiw5lcIjogXCJVzIBcIixcbiAgXCLDnFwiOiBcIlXMiFwiLFxuICBcIseXXCI6IFwiVcyIzIFcIixcbiAgXCLHm1wiOiBcIlXMiMyAXCIsXG4gIFwix5VcIjogXCJVzIjMhFwiLFxuICBcIseZXCI6IFwiVcyIzIxcIixcbiAgXCLFqFwiOiBcIlXMg1wiLFxuICBcIuG5uFwiOiBcIlXMg8yBXCIsXG4gIFwixapcIjogXCJVzIRcIixcbiAgXCLhubpcIjogXCJVzITMiFwiLFxuICBcIsWsXCI6IFwiVcyGXCIsXG4gIFwix5NcIjogXCJVzIxcIixcbiAgXCLDm1wiOiBcIlXMglwiLFxuICBcIsWuXCI6IFwiVcyKXCIsXG4gIFwixbBcIjogXCJVzItcIixcbiAgXCLhubxcIjogXCJWzINcIixcbiAgXCLhuoJcIjogXCJXzIFcIixcbiAgXCLhuoBcIjogXCJXzIBcIixcbiAgXCLhuoRcIjogXCJXzIhcIixcbiAgXCLFtFwiOiBcIlfMglwiLFxuICBcIuG6hlwiOiBcIlfMh1wiLFxuICBcIuG6jFwiOiBcIljMiFwiLFxuICBcIuG6ilwiOiBcIljMh1wiLFxuICBcIsOdXCI6IFwiWcyBXCIsXG4gIFwi4buyXCI6IFwiWcyAXCIsXG4gIFwixbhcIjogXCJZzIhcIixcbiAgXCLhu7hcIjogXCJZzINcIixcbiAgXCLIslwiOiBcIlnMhFwiLFxuICBcIsW2XCI6IFwiWcyCXCIsXG4gIFwi4bqOXCI6IFwiWcyHXCIsXG4gIFwixblcIjogXCJazIFcIixcbiAgXCLFvVwiOiBcIlrMjFwiLFxuICBcIuG6kFwiOiBcIlrMglwiLFxuICBcIsW7XCI6IFwiWsyHXCIsXG4gIFwizqxcIjogXCLOscyBXCIsXG4gIFwi4b2wXCI6IFwizrHMgFwiLFxuICBcIuG+sVwiOiBcIs6xzIRcIixcbiAgXCLhvrBcIjogXCLOscyGXCIsXG4gIFwizq1cIjogXCLOtcyBXCIsXG4gIFwi4b2yXCI6IFwizrXMgFwiLFxuICBcIs6uXCI6IFwizrfMgVwiLFxuICBcIuG9tFwiOiBcIs63zIBcIixcbiAgXCLOr1wiOiBcIs65zIFcIixcbiAgXCLhvbZcIjogXCLOucyAXCIsXG4gIFwiz4pcIjogXCLOucyIXCIsXG4gIFwizpBcIjogXCLOucyIzIFcIixcbiAgXCLhv5JcIjogXCLOucyIzIBcIixcbiAgXCLhv5FcIjogXCLOucyEXCIsXG4gIFwi4b+QXCI6IFwizrnMhlwiLFxuICBcIs+MXCI6IFwizr/MgVwiLFxuICBcIuG9uFwiOiBcIs6/zIBcIixcbiAgXCLPjVwiOiBcIs+FzIFcIixcbiAgXCLhvbpcIjogXCLPhcyAXCIsXG4gIFwiz4tcIjogXCLPhcyIXCIsXG4gIFwizrBcIjogXCLPhcyIzIFcIixcbiAgXCLhv6JcIjogXCLPhcyIzIBcIixcbiAgXCLhv6FcIjogXCLPhcyEXCIsXG4gIFwi4b+gXCI6IFwiz4XMhlwiLFxuICBcIs+OXCI6IFwiz4nMgVwiLFxuICBcIuG9vFwiOiBcIs+JzIBcIixcbiAgXCLOjlwiOiBcIs6lzIFcIixcbiAgXCLhv6pcIjogXCLOpcyAXCIsXG4gIFwizqtcIjogXCLOpcyIXCIsXG4gIFwi4b+pXCI6IFwizqXMhFwiLFxuICBcIuG/qFwiOiBcIs6lzIZcIixcbiAgXCLOj1wiOiBcIs6pzIFcIixcbiAgXCLhv7pcIjogXCLOqcyAXCJcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBwYXJzZXIgdXNlZCB0byBwYXJzZSBvdXQgYSBUZVggZXhwcmVzc2lvbiBmcm9tIHRoZVxuICogaW5wdXQuIFNpbmNlIFRlWCBpc24ndCBjb250ZXh0LWZyZWUsIHN0YW5kYXJkIHBhcnNlcnMgZG9uJ3Qgd29yayBwYXJ0aWN1bGFybHlcbiAqIHdlbGwuXG4gKlxuICogVGhlIHN0cmF0ZWd5IG9mIHRoaXMgcGFyc2VyIGlzIGFzIHN1Y2g6XG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zICh0aGUgYC5wYXJzZS4uLmAgb25lcykgdGFrZSBhIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50XG4gKiBwYXJzZSBzdHJpbmcgdG8gcGFyc2UgdG9rZW5zIGZyb20uIFRoZSBsZXhlciAoZm91bmQgaW4gTGV4ZXIuanMsIHN0b3JlZCBhdFxuICogdGhpcy5ndWxsZXQubGV4ZXIpIGFsc28gc3VwcG9ydHMgcHVsbGluZyBvdXQgdG9rZW5zIGF0IGFyYml0cmFyeSBwbGFjZXMuIFdoZW5cbiAqIGluZGl2aWR1YWwgdG9rZW5zIGFyZSBuZWVkZWQgYXQgYSBwb3NpdGlvbiwgdGhlIGxleGVyIGlzIGNhbGxlZCB0byBwdWxsIG91dCBhXG4gKiB0b2tlbiwgd2hpY2ggaXMgdGhlbiB1c2VkLlxuICpcbiAqIFRoZSBwYXJzZXIgaGFzIGEgcHJvcGVydHkgY2FsbGVkIFwibW9kZVwiIGluZGljYXRpbmcgdGhlIG1vZGUgdGhhdFxuICogdGhlIHBhcnNlciBpcyBjdXJyZW50bHkgaW4uIEN1cnJlbnRseSBpdCBoYXMgdG8gYmUgb25lIG9mIFwibWF0aFwiIG9yXG4gKiBcInRleHRcIiwgd2hpY2ggZGVub3RlcyB3aGV0aGVyIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIGEgbWF0aC15XG4gKiBvbmUgb3IgYSB0ZXh0LXkgb25lIChlLmcuIGluc2lkZSBcXHRleHQpLiBDdXJyZW50bHksIHRoaXMgc2VydmVzIHRvXG4gKiBsaW1pdCB0aGUgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSB1c2VkIGluIHRleHQgbW9kZS5cbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgdGhlbiByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSB1c2VmdWwgZGF0YSB0aGF0XG4gKiB3YXMgcGFyc2VkIGF0IGl0cyBnaXZlbiBwb2ludCwgYW5kIGEgbmV3IHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHBhcnNlZFxuICogZGF0YS4gVGhlIG1haW4gZnVuY3Rpb25zIGNhbiBjYWxsIGVhY2ggb3RoZXIgYW5kIGNvbnRpbnVlIHRoZSBwYXJzaW5nIGJ5XG4gKiB1c2luZyB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYXMgYSBuZXcgc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogVGhlcmUgYXJlIGFsc28gZXh0cmEgYC5oYW5kbGUuLi5gIGZ1bmN0aW9ucywgd2hpY2ggcHVsbCBvdXQgc29tZSByZXVzZWRcbiAqIGZ1bmN0aW9uYWxpdHkgaW50byBzZWxmLWNvbnRhaW5lZCBmdW5jdGlvbnMuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyByZXR1cm4gUGFyc2VOb2Rlcy5cbiAqL1xuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzKSB7XG4gICAgdGhpcy5tb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuZ3VsbGV0ID0gdm9pZCAwO1xuICAgIHRoaXMuc2V0dGluZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sZWZ0cmlnaHREZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm5leHRUb2tlbiA9IHZvaWQgMDtcbiAgICAvLyBTdGFydCBpbiBtYXRoIG1vZGVcbiAgICB0aGlzLm1vZGUgPSBcIm1hdGhcIjsgLy8gQ3JlYXRlIGEgbmV3IG1hY3JvIGV4cGFuZGVyIChndWxsZXQpIGFuZCAoaW5kaXJlY3RseSB2aWEgdGhhdCkgYWxzbyBhXG4gICAgLy8gbmV3IGxleGVyIChtb3V0aCkgZm9yIHRoaXMgcGFyc2VyIChzdG9tYWNoLCBpbiB0aGUgbGFuZ3VhZ2Ugb2YgVGVYKVxuXG4gICAgdGhpcy5ndWxsZXQgPSBuZXcgTWFjcm9FeHBhbmRlcihpbnB1dCwgc2V0dGluZ3MsIHRoaXMubW9kZSk7IC8vIFN0b3JlIHRoZSBzZXR0aW5ncyBmb3IgdXNlIGluIHBhcnNpbmdcblxuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5nczsgLy8gQ291bnQgbGVmdHJpZ2h0IGRlcHRoIChmb3IgXFxtaWRkbGUgZXJyb3JzKVxuXG4gICAgdGhpcy5sZWZ0cmlnaHREZXB0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBhIHJlc3VsdCB0byBtYWtlIHN1cmUgaXQgaGFzIHRoZSByaWdodCB0eXBlLCBhbmQgdGhyb3dzIGFuXG4gICAqIGFwcHJvcHJpYXRlIGVycm9yIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBleHBlY3QodGV4dCwgY29uc3VtZSkge1xuICAgIGlmIChjb25zdW1lID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN1bWUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZldGNoKCkudGV4dCAhPT0gdGV4dCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgdGV4dCArIFwiJywgZ290ICdcIiArIHRoaXMuZmV0Y2goKS50ZXh0ICsgXCInXCIsIHRoaXMuZmV0Y2goKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnN1bWUpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY2FyZHMgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLCBjb25zaWRlcmluZyBpdCBjb25zdW1lZC5cbiAgICovXG5cblxuICBjb25zdW1lKCkge1xuICAgIHRoaXMubmV4dFRva2VuID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IGxvb2thaGVhZCB0b2tlbiwgb3IgaWYgdGhlcmUgaXNuJ3Qgb25lIChhdCB0aGVcbiAgICogYmVnaW5uaW5nLCBvciBpZiB0aGUgcHJldmlvdXMgbG9va2FoZWFkIHRva2VuIHdhcyBjb25zdW1lKClkKSxcbiAgICogZmV0Y2ggdGhlIG5leHQgdG9rZW4gYXMgdGhlIG5ldyBsb29rYWhlYWQgdG9rZW4gYW5kIHJldHVybiBpdC5cbiAgICovXG5cblxuICBmZXRjaCgpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5leHBhbmROZXh0VG9rZW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW47XG4gIH1cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cblxuXG4gIHN3aXRjaE1vZGUobmV3TW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5ndWxsZXQuc3dpdGNoTW9kZShuZXdNb2RlKTtcbiAgfVxuICAvKipcbiAgICogTWFpbiBwYXJzaW5nIGZ1bmN0aW9uLCB3aGljaCBwYXJzZXMgYW4gZW50aXJlIGlucHV0LlxuICAgKi9cblxuXG4gIHBhcnNlKCkge1xuICAgIGlmICghdGhpcy5zZXR0aW5ncy5nbG9iYWxHcm91cCkge1xuICAgICAgLy8gQ3JlYXRlIGEgZ3JvdXAgbmFtZXNwYWNlIGZvciB0aGUgbWF0aCBleHByZXNzaW9uLlxuICAgICAgLy8gKExhVGVYIGNyZWF0ZXMgYSBuZXcgZ3JvdXAgZm9yIGV2ZXJ5ICQuLi4kLCAkJC4uLiQkLCBcXFsuLi5cXF0uKVxuICAgICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIH0gLy8gVXNlIG9sZCBcXGNvbG9yIGJlaGF2aW9yIChzYW1lIGFzIExhVGVYJ3MgXFx0ZXh0Y29sb3IpIGlmIHJlcXVlc3RlZC5cbiAgICAvLyBXZSBkbyB0aGlzIHdpdGhpbiB0aGUgZ3JvdXAgZm9yIHRoZSBtYXRoIGV4cHJlc3Npb24sIHNvIGl0IGRvZXNuJ3RcbiAgICAvLyBwb2xsdXRlIHNldHRpbmdzLm1hY3Jvcy5cblxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuY29sb3JJc1RleHRDb2xvcikge1xuICAgICAgdGhpcy5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjb2xvclwiLCBcIlxcXFx0ZXh0Y29sb3JcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgaW5wdXRcbiAgICAgIGNvbnN0IHBhcnNlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpOyAvLyBJZiB3ZSBzdWNjZWVkZWQsIG1ha2Ugc3VyZSB0aGVyZSdzIGFuIEVPRiBhdCB0aGUgZW5kXG5cbiAgICAgIHRoaXMuZXhwZWN0KFwiRU9GXCIpOyAvLyBFbmQgdGhlIGdyb3VwIG5hbWVzcGFjZSBmb3IgdGhlIGV4cHJlc3Npb25cblxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmdsb2JhbEdyb3VwKSB7XG4gICAgICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZTsgLy8gQ2xvc2UgYW55IGxlZnRvdmVyIGdyb3VwcyBpbiBjYXNlIG9mIGEgcGFyc2UgZXJyb3IuXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwcygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRnVsbHkgcGFyc2UgYSBzZXBhcmF0ZSBzZXF1ZW5jZSBvZiB0b2tlbnMgYXMgYSBzZXBhcmF0ZSBqb2IuXG4gICAqIFRva2VucyBzaG91bGQgYmUgc3BlY2lmaWVkIGluIHJldmVyc2Ugb3JkZXIsIGFzIGluIGEgTWFjcm9EZWZpbml0aW9uLlxuICAgKi9cblxuXG4gIHN1YnBhcnNlKHRva2Vucykge1xuICAgIC8vIFNhdmUgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgY3VycmVudCBqb2IuXG4gICAgY29uc3Qgb2xkVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gUnVuIHRoZSBuZXcgam9iLCB0ZXJtaW5hdGluZyBpdCB3aXRoIGFuIGV4Y2VzcyAnfSdcblxuICAgIHRoaXMuZ3VsbGV0LnB1c2hUb2tlbihuZXcgVG9rZW4oXCJ9XCIpKTtcbiAgICB0aGlzLmd1bGxldC5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgY29uc3QgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7XG4gICAgdGhpcy5leHBlY3QoXCJ9XCIpOyAvLyBSZXN0b3JlIHRoZSBuZXh0IHRva2VuIGZyb20gdGhlIGN1cnJlbnQgam9iLlxuXG4gICAgdGhpcy5uZXh0VG9rZW4gPSBvbGRUb2tlbjtcbiAgICByZXR1cm4gcGFyc2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIFwiZXhwcmVzc2lvblwiLCB3aGljaCBpcyBhIGxpc3Qgb2YgYXRvbXMuXG4gICAqXG4gICAqIGBicmVha09uSW5maXhgOiBTaG91bGQgdGhlIHBhcnNpbmcgc3RvcCB3aGVuIHdlIGhpdCBpbmZpeCBub2Rlcz8gVGhpc1xuICAgKiAgICAgICAgICAgICAgICAgaGFwcGVucyB3aGVuIGZ1bmN0aW9ucyBoYXZlIGhpZ2hlciBwcmVjZWRlbmNlIGhhbiBpbmZpeFxuICAgKiAgICAgICAgICAgICAgICAgbm9kZXMgaW4gaW1wbGljaXQgcGFyc2VzLlxuICAgKlxuICAgKiBgYnJlYWtPblRva2VuVGV4dGA6IFRoZSB0ZXh0IG9mIHRoZSB0b2tlbiB0aGF0IHRoZSBleHByZXNzaW9uIHNob3VsZCBlbmRcbiAgICogICAgICAgICAgICAgICAgICAgICB3aXRoLCBvciBgbnVsbGAgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkIGVuZCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLlxuICAgKi9cbiAgcGFyc2VFeHByZXNzaW9uKGJyZWFrT25JbmZpeCwgYnJlYWtPblRva2VuVGV4dCkge1xuICAgIGNvbnN0IGJvZHkgPSBbXTsgLy8gS2VlcCBhZGRpbmcgYXRvbXMgdG8gdGhlIGJvZHkgdW50aWwgd2UgY2FuJ3QgcGFyc2UgYW55IG1vcmUgYXRvbXMgKGVpdGhlclxuICAgIC8vIHdlIHJlYWNoZWQgdGhlIGVuZCwgYSB9LCBvciBhIFxccmlnaHQpXG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWdub3JlIHNwYWNlcyBpbiBtYXRoIG1vZGVcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsZXggPSB0aGlzLmZldGNoKCk7XG5cbiAgICAgIGlmIChQYXJzZXIuZW5kT2ZFeHByZXNzaW9uLmluZGV4T2YobGV4LnRleHQpICE9PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGJyZWFrT25Ub2tlblRleHQgJiYgbGV4LnRleHQgPT09IGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmVha09uSW5maXggJiYgc3JjX2Z1bmN0aW9uc1tsZXgudGV4dF0gJiYgc3JjX2Z1bmN0aW9uc1tsZXgudGV4dF0uaW5maXgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0b20gPSB0aGlzLnBhcnNlQXRvbShicmVha09uVG9rZW5UZXh0KTtcblxuICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChhdG9tLnR5cGUgPT09IFwiaW50ZXJuYWxcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYm9keS5wdXNoKGF0b20pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICB0aGlzLmZvcm1MaWdhdHVyZXMoYm9keSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5maXhOb2Rlcyhib2R5KTtcbiAgfVxuICAvKipcbiAgICogUmV3cml0ZXMgaW5maXggb3BlcmF0b3JzIHN1Y2ggYXMgXFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoXG4gICAqIGFzIFxcZnJhYy5cbiAgICpcbiAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cC4gIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZVxuICAgKiB0aGVuIHRoZSBleHByZXNzaW9uIGlzIGFtYmlndW91cy4gIFRoaXMgY2FuIGJlIHJlc29sdmVkIGJ5IGFkZGluZyB7fS5cbiAgICovXG5cblxuICBoYW5kbGVJbmZpeE5vZGVzKGJvZHkpIHtcbiAgICBsZXQgb3ZlckluZGV4ID0gLTE7XG4gICAgbGV0IGZ1bmNOYW1lO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYm9keVtpXS50eXBlID09PSBcImluZml4XCIpIHtcbiAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJvbmx5IG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXBcIiwgYm9keVtpXS50b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBvdmVySW5kZXggPSBpO1xuICAgICAgICBmdW5jTmFtZSA9IGJvZHlbaV0ucmVwbGFjZVdpdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJJbmRleCAhPT0gLTEgJiYgZnVuY05hbWUpIHtcbiAgICAgIGxldCBudW1lck5vZGU7XG4gICAgICBsZXQgZGVub21Ob2RlO1xuICAgICAgY29uc3QgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpO1xuICAgICAgY29uc3QgZGVub21Cb2R5ID0gYm9keS5zbGljZShvdmVySW5kZXggKyAxKTtcblxuICAgICAgaWYgKG51bWVyQm9keS5sZW5ndGggPT09IDEgJiYgbnVtZXJCb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICBudW1lck5vZGUgPSBudW1lckJvZHlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1lck5vZGUgPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBib2R5OiBudW1lckJvZHlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbm9tQm9keS5sZW5ndGggPT09IDEgJiYgZGVub21Cb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICBkZW5vbU5vZGUgPSBkZW5vbUJvZHlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZW5vbU5vZGUgPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBib2R5OiBkZW5vbUJvZHlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbGV0IG5vZGU7XG5cbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGFib3ZlZnJhY1wiKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW251bWVyTm9kZSwgYm9keVtvdmVySW5kZXhdLCBkZW5vbU5vZGVdLCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIFtdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzdWJzY3JpcHQgb3Igc3VwZXJzY3JpcHQgd2l0aCBuaWNlIGVycm9ycy5cbiAgICovXG5cblxuICBoYW5kbGVTdXBTdWJzY3JpcHQobmFtZSAvLyBGb3IgZXJyb3IgcmVwb3J0aW5nLlxuICApIHtcbiAgICBjb25zdCBzeW1ib2xUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICBjb25zdCBzeW1ib2wgPSBzeW1ib2xUb2tlbi50ZXh0O1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOyAvLyBpZ25vcmUgc3BhY2VzIGJlZm9yZSBzdXAvc3Vic2NyaXB0IGFyZ3VtZW50XG5cbiAgICBjb25zdCBncm91cCA9IHRoaXMucGFyc2VHcm91cChuYW1lKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkIGdyb3VwIGFmdGVyICdcIiArIHN5bWJvbCArIFwiJ1wiLCBzeW1ib2xUb2tlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dHVhbCBpbnB1dCBvZiBhbiB1bnN1cHBvcnRlZCBjb21tYW5kIGludG8gYSB0ZXh0IG5vZGVcbiAgICogY29udGFpbmVkIHdpdGhpbiBhIGNvbG9yIG5vZGUgd2hvc2UgY29sb3IgaXMgZGV0ZXJtaW5lZCBieSBlcnJvckNvbG9yXG4gICAqL1xuXG5cbiAgZm9ybWF0VW5zdXBwb3J0ZWRDbWQodGV4dCkge1xuICAgIGNvbnN0IHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0b3JkQXJyYXkucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogdGV4dFtpXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dE5vZGUgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGJvZHk6IHRleHRvcmRBcnJheVxuICAgIH07XG4gICAgY29uc3QgY29sb3JOb2RlID0ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgY29sb3I6IHRoaXMuc2V0dGluZ3MuZXJyb3JDb2xvcixcbiAgICAgIGJvZHk6IFt0ZXh0Tm9kZV1cbiAgICB9O1xuICAgIHJldHVybiBjb2xvck5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGdyb3VwIHdpdGggb3B0aW9uYWwgc3VwZXIvc3Vic2NyaXB0cy5cbiAgICovXG5cblxuICBwYXJzZUF0b20oYnJlYWtPblRva2VuVGV4dCkge1xuICAgIC8vIFRoZSBib2R5IG9mIGFuIGF0b20gaXMgYW4gaW1wbGljaXQgZ3JvdXAsIHNvIHRoYXQgdGhpbmdzIGxpa2VcbiAgICAvLyBcXGxlZnQoeFxccmlnaHQpXjIgd29yayBjb3JyZWN0bHkuXG4gICAgY29uc3QgYmFzZSA9IHRoaXMucGFyc2VHcm91cChcImF0b21cIiwgYnJlYWtPblRva2VuVGV4dCk7IC8vIEluIHRleHQgbW9kZSwgd2UgZG9uJ3QgaGF2ZSBzdXBlcnNjcmlwdHMgb3Igc3Vic2NyaXB0c1xuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH0gLy8gTm90ZSB0aGF0IGJhc2UgbWF5IGJlIGVtcHR5IChpLmUuIG51bGwpIGF0IHRoaXMgcG9pbnQuXG5cblxuICAgIGxldCBzdXBlcnNjcmlwdDtcbiAgICBsZXQgc3Vic2NyaXB0O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIEd1YXJhbnRlZWQgaW4gbWF0aCBtb2RlLCBzbyBlYXQgYW55IHNwYWNlcyBmaXJzdC5cbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOyAvLyBMZXggdGhlIGZpcnN0IHRva2VuXG5cbiAgICAgIGNvbnN0IGxleCA9IHRoaXMuZmV0Y2goKTtcblxuICAgICAgaWYgKGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIiB8fCBsZXgudGV4dCA9PT0gXCJcXFxcbm9saW1pdHNcIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBsaW1pdCBjb250cm9sXG4gICAgICAgIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJvcFwiKSB7XG4gICAgICAgICAgY29uc3QgbGltaXRzID0gbGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiO1xuICAgICAgICAgIGJhc2UubGltaXRzID0gbGltaXRzO1xuICAgICAgICAgIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIikge1xuICAgICAgICAgIGlmIChiYXNlLmFsd2F5c0hhbmRsZVN1cFN1Yikge1xuICAgICAgICAgICAgYmFzZS5saW1pdHMgPSBsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkxpbWl0IGNvbnRyb2xzIG11c3QgZm9sbG93IGEgbWF0aCBvcGVyYXRvclwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl5cIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBzdXBlcnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyc2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdXBlcnNjcmlwdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiX1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHN1YnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRG91YmxlIHN1YnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdWJzY3JpcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBwcmltZVxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByaW1lID0ge1xuICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICB0ZXh0OiBcIlxcXFxwcmltZVwiXG4gICAgICAgIH07IC8vIE1hbnkgcHJpbWVzIGNhbiBiZSBncm91cGVkIHRvZ2V0aGVyLCBzbyB3ZSBoYW5kbGUgdGhpcyBoZXJlXG5cbiAgICAgICAgY29uc3QgcHJpbWVzID0gW3ByaW1lXTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7IC8vIEtlZXAgbGV4aW5nIHRva2VucyB1bnRpbCB3ZSBnZXQgc29tZXRoaW5nIHRoYXQncyBub3QgYSBwcmltZVxuXG4gICAgICAgIHdoaWxlICh0aGlzLmZldGNoKCkudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAvLyBGb3IgZWFjaCBvbmUsIGFkZCBhbm90aGVyIHByaW1lIHRvIHRoZSBsaXN0XG4gICAgICAgICAgcHJpbWVzLnB1c2gocHJpbWUpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9IC8vIElmIHRoZXJlJ3MgYSBzdXBlcnNjcmlwdCBmb2xsb3dpbmcgdGhlIHByaW1lcywgY29tYmluZSB0aGF0XG4gICAgICAgIC8vIHN1cGVyc2NyaXB0IGluIHdpdGggdGhlIHByaW1lcy5cblxuXG4gICAgICAgIGlmICh0aGlzLmZldGNoKCkudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgICBwcmltZXMucHVzaCh0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpKTtcbiAgICAgICAgfSAvLyBQdXQgZXZlcnl0aGluZyBpbnRvIGFuIG9yZGdyb3VwIGFzIHRoZSBzdXBlcnNjcmlwdFxuXG5cbiAgICAgICAgc3VwZXJzY3JpcHQgPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBib2R5OiBwcmltZXNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodVN1YnNBbmRTdXBzW2xleC50ZXh0XSkge1xuICAgICAgICAvLyBBIFVuaWNvZGUgc3Vic2NyaXB0IG9yIHN1cGVyc2NyaXB0IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gV2UgdHJlYXQgdGhlc2Ugc2ltaWxhcmx5IHRvIHRoZSB1bmljb2RlLW1hdGggcGFja2FnZS5cbiAgICAgICAgLy8gU28gd2UgcmVuZGVyIGEgc3RyaW5nIG9mIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHRzIHRoZVxuICAgICAgICAvLyBzYW1lIGFzIGEgKHN1YnxzdXBlcilzY3JpcHQgb2YgcmVndWxhciBjaGFyYWN0ZXJzLlxuICAgICAgICBjb25zdCBpc1N1YiA9IHVuaWNvZGVTdWJSZWdFeC50ZXN0KGxleC50ZXh0KTtcbiAgICAgICAgY29uc3Qgc3Vic3VwVG9rZW5zID0gW107XG4gICAgICAgIHN1YnN1cFRva2Vucy5wdXNoKG5ldyBUb2tlbih1U3Vic0FuZFN1cHNbbGV4LnRleHRdKSk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpOyAvLyBDb250aW51ZSBmZXRjaGluZyB0b2tlbnMgdG8gZmlsbCBvdXQgdGhlIHN0cmluZy5cblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5mZXRjaCgpLnRleHQ7XG5cbiAgICAgICAgICBpZiAoIXVTdWJzQW5kU3Vwc1t0b2tlbl0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1bmljb2RlU3ViUmVnRXgudGVzdCh0b2tlbikgIT09IGlzU3ViKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdWJzdXBUb2tlbnMudW5zaGlmdChuZXcgVG9rZW4odVN1YnNBbmRTdXBzW3Rva2VuXSkpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9IC8vIE5vdyBjcmVhdGUgYSAoc3VifHN1cGVyKXNjcmlwdC5cblxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnN1YnBhcnNlKHN1YnN1cFRva2Vucyk7XG5cbiAgICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgICAgc3Vic2NyaXB0ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdXBlcnNjcmlwdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0IHdhc24ndCBeLCBfLCBvciAnLCBzdG9wIHBhcnNpbmcgc3VwZXIvc3Vic2NyaXB0c1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIEJhc2UgbXVzdCBiZSBzZXQgaWYgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0IGFyZSBzZXQgcGVyIGxvZ2ljIGFib3ZlLFxuICAgIC8vIGJ1dCBuZWVkIHRvIGNoZWNrIGhlcmUgZm9yIHR5cGUgY2hlY2sgdG8gcGFzcy5cblxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgLy8gSWYgd2UgZ290IGVpdGhlciBhIHN1cGVyc2NyaXB0IG9yIHN1YnNjcmlwdCwgY3JlYXRlIGEgc3Vwc3ViXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHN1cDogc3VwZXJzY3JpcHQsXG4gICAgICAgIHN1Yjogc3Vic2NyaXB0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBlbnRpcmUgZnVuY3Rpb24sIGluY2x1ZGluZyBpdHMgYmFzZSBhbmQgYWxsIG9mIGl0cyBhcmd1bWVudHMuXG4gICAqL1xuXG5cbiAgcGFyc2VGdW5jdGlvbihicmVha09uVG9rZW5UZXh0LCBuYW1lIC8vIEZvciBkZXRlcm1pbmluZyBpdHMgY29udGV4dFxuICApIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICBjb25zdCBmdW5jID0gdG9rZW4udGV4dDtcbiAgICBjb25zdCBmdW5jRGF0YSA9IHNyY19mdW5jdGlvbnNbZnVuY107XG5cbiAgICBpZiAoIWZ1bmNEYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gY29uc3VtZSBjb21tYW5kIHRva2VuXG5cbiAgICBpZiAobmFtZSAmJiBuYW1lICE9PSBcImF0b21cIiAmJiAhZnVuY0RhdGEuYWxsb3dlZEluQXJndW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkdvdCBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIHdpdGggbm8gYXJndW1lbnRzXCIgKyAobmFtZSA/IFwiIGFzIFwiICsgbmFtZSA6IFwiXCIpLCB0b2tlbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5UZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJDYW4ndCB1c2UgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyBpbiB0ZXh0IG1vZGVcIiwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIiAmJiBmdW5jRGF0YS5hbGxvd2VkSW5NYXRoID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gbWF0aCBtb2RlXCIsIHRva2VuKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBhcmdzLFxuICAgICAgb3B0QXJnc1xuICAgIH0gPSB0aGlzLnBhcnNlQXJndW1lbnRzKGZ1bmMsIGZ1bmNEYXRhKTtcbiAgICByZXR1cm4gdGhpcy5jYWxsRnVuY3Rpb24oZnVuYywgYXJncywgb3B0QXJncywgdG9rZW4sIGJyZWFrT25Ub2tlblRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gaGFuZGxlciB3aXRoIGEgc3VpdGFibGUgY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICAgKi9cblxuXG4gIGNhbGxGdW5jdGlvbihuYW1lLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBmdW5jTmFtZTogbmFtZSxcbiAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgIHRva2VuLFxuICAgICAgYnJlYWtPblRva2VuVGV4dFxuICAgIH07XG4gICAgY29uc3QgZnVuYyA9IHNyY19mdW5jdGlvbnNbbmFtZV07XG5cbiAgICBpZiAoZnVuYyAmJiBmdW5jLmhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBmdW5jLmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk5vIGZ1bmN0aW9uIGhhbmRsZXIgZm9yIFwiICsgbmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50XG4gICAqL1xuXG5cbiAgcGFyc2VBcmd1bWVudHMoZnVuYywgLy8gU2hvdWxkIGxvb2sgbGlrZSBcIlxcbmFtZVwiIG9yIFwiXFxiZWdpbntuYW1lfVwiLlxuICBmdW5jRGF0YSkge1xuICAgIGNvbnN0IHRvdGFsQXJncyA9IGZ1bmNEYXRhLm51bUFyZ3MgKyBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3M7XG5cbiAgICBpZiAodG90YWxBcmdzID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgb3B0QXJnczogW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGNvbnN0IG9wdEFyZ3MgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxBcmdzOyBpKyspIHtcbiAgICAgIGxldCBhcmdUeXBlID0gZnVuY0RhdGEuYXJnVHlwZXMgJiYgZnVuY0RhdGEuYXJnVHlwZXNbaV07XG4gICAgICBjb25zdCBpc09wdGlvbmFsID0gaSA8IGZ1bmNEYXRhLm51bU9wdGlvbmFsQXJncztcblxuICAgICAgaWYgKGZ1bmNEYXRhLnByaW1pdGl2ZSAmJiBhcmdUeXBlID09IG51bGwgfHwgLy8gXFxzcXJ0IGV4cGFuZHMgaW50byBwcmltaXRpdmUgaWYgb3B0aW9uYWwgYXJndW1lbnQgZG9lc24ndCBleGlzdFxuICAgICAgZnVuY0RhdGEudHlwZSA9PT0gXCJzcXJ0XCIgJiYgaSA9PT0gMSAmJiBvcHRBcmdzWzBdID09IG51bGwpIHtcbiAgICAgICAgYXJnVHlwZSA9IFwicHJpbWl0aXZlXCI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZyA9IHRoaXMucGFyc2VHcm91cE9mVHlwZShcImFyZ3VtZW50IHRvICdcIiArIGZ1bmMgKyBcIidcIiwgYXJnVHlwZSwgaXNPcHRpb25hbCk7XG5cbiAgICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICAgIG9wdEFyZ3MucHVzaChhcmcpO1xuICAgICAgfSBlbHNlIGlmIChhcmcgIT0gbnVsbCkge1xuICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZVxuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJOdWxsIGFyZ3VtZW50LCBwbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWdcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZ3MsXG4gICAgICBvcHRBcmdzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2hlbiB0aGUgbW9kZSBpcyBjaGFuZ2luZy5cbiAgICovXG5cblxuICBwYXJzZUdyb3VwT2ZUeXBlKG5hbWUsIHR5cGUsIG9wdGlvbmFsKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb2xvckdyb3VwKG9wdGlvbmFsKTtcblxuICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTaXplR3JvdXAob3B0aW9uYWwpO1xuXG4gICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVXJsR3JvdXAob3B0aW9uYWwpO1xuXG4gICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCB0eXBlKTtcblxuICAgICAgY2FzZSBcImhib3hcIjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGhib3ggYXJndW1lbnQgdHlwZSB3cmFwcyB0aGUgYXJndW1lbnQgaW4gdGhlIGVxdWl2YWxlbnQgb2ZcbiAgICAgICAgICAvLyBcXGhib3gsIHdoaWNoIGlzIGxpa2UgXFx0ZXh0IGJ1dCBzd2l0Y2hpbmcgdG8gXFx0ZXh0c3R5bGUgc2l6ZS5cbiAgICAgICAgICBjb25zdCBncm91cCA9IHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCBcInRleHRcIik7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwICE9IG51bGwgPyB7XG4gICAgICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgICAgIG1vZGU6IGdyb3VwLm1vZGUsXG4gICAgICAgICAgICBib2R5OiBbZ3JvdXBdLFxuICAgICAgICAgICAgc3R5bGU6IFwidGV4dFwiIC8vIHNpbXVsYXRlIFxcdGV4dHN0eWxlXG5cbiAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInJhd1wiLCBvcHRpb25hbCk7XG4gICAgICAgICAgcmV0dXJuIHRva2VuICE9IG51bGwgPyB7XG4gICAgICAgICAgICB0eXBlOiBcInJhd1wiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBzdHJpbmc6IHRva2VuLnRleHRcbiAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwicHJpbWl0aXZlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkEgcHJpbWl0aXZlIGFyZ3VtZW50IGNhbm5vdCBiZSBvcHRpb25hbFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBncm91cCA9IHRoaXMucGFyc2VHcm91cChuYW1lKTtcblxuICAgICAgICAgIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFeHBlY3RlZCBncm91cCBhcyBcIiArIG5hbWUsIHRoaXMuZmV0Y2goKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJvcmlnaW5hbFwiOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gZ3JvdXAgdHlwZSBhcyBcIiArIG5hbWUsIHRoaXMuZmV0Y2goKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNjYXJkIGFueSBzcGFjZSB0b2tlbnMsIGZldGNoaW5nIHRoZSBuZXh0IG5vbi1zcGFjZSB0b2tlbi5cbiAgICovXG5cblxuICBjb25zdW1lU3BhY2VzKCkge1xuICAgIHdoaWxlICh0aGlzLmZldGNoKCkudGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAsIGVzc2VudGlhbGx5IHJldHVybmluZyB0aGUgc3RyaW5nIGZvcm1lZCBieSB0aGVcbiAgICogYnJhY2UtZW5jbG9zZWQgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG5cblxuICBwYXJzZVN0cmluZ0dyb3VwKG1vZGVOYW1lLCAvLyBVc2VkIHRvIGRlc2NyaWJlIHRoZSBtb2RlIGluIGVycm9yIG1lc3NhZ2VzLlxuICBvcHRpb25hbCkge1xuICAgIGNvbnN0IGFyZ1Rva2VuID0gdGhpcy5ndWxsZXQuc2NhbkFyZ3VtZW50KG9wdGlvbmFsKTtcblxuICAgIGlmIChhcmdUb2tlbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBsZXQgbmV4dFRva2VuO1xuXG4gICAgd2hpbGUgKChuZXh0VG9rZW4gPSB0aGlzLmZldGNoKCkpLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgIHN0ciArPSBuZXh0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cblxuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBjb25zdW1lIHRoZSBlbmQgb2YgdGhlIGFyZ3VtZW50XG5cbiAgICBhcmdUb2tlbi50ZXh0ID0gc3RyO1xuICAgIHJldHVybiBhcmdUb2tlbjtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgcmVnZXgtZGVsaW1pdGVkIGdyb3VwOiB0aGUgbGFyZ2VzdCBzZXF1ZW5jZSBvZiB0b2tlbnNcbiAgICogd2hvc2UgY29uY2F0ZW5hdGVkIHN0cmluZ3MgbWF0Y2ggYHJlZ2V4YC4gUmV0dXJucyB0aGUgc3RyaW5nXG4gICAqIGZvcm1lZCBieSB0aGUgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG5cblxuICBwYXJzZVJlZ2V4R3JvdXAocmVnZXgsIG1vZGVOYW1lIC8vIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXMuXG4gICkge1xuICAgIGNvbnN0IGZpcnN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgbGV0IGxhc3RUb2tlbiA9IGZpcnN0VG9rZW47XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgbGV0IG5leHRUb2tlbjtcblxuICAgIHdoaWxlICgobmV4dFRva2VuID0gdGhpcy5mZXRjaCgpKS50ZXh0ICE9PSBcIkVPRlwiICYmIHJlZ2V4LnRlc3Qoc3RyICsgbmV4dFRva2VuLnRleHQpKSB7XG4gICAgICBsYXN0VG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIFwiICsgbW9kZU5hbWUgKyBcIjogJ1wiICsgZmlyc3RUb2tlbi50ZXh0ICsgXCInXCIsIGZpcnN0VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgY29sb3IgZGVzY3JpcHRpb24uXG4gICAqL1xuXG5cbiAgcGFyc2VDb2xvckdyb3VwKG9wdGlvbmFsKSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwiY29sb3JcIiwgb3B0aW9uYWwpO1xuXG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IC9eKCNbYS1mMC05XXszfXwjP1thLWYwLTldezZ9fFthLXpdKykkL2kuZXhlYyhyZXMudGV4dCk7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGNvbG9yOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cblxuICAgIGxldCBjb2xvciA9IG1hdGNoWzBdO1xuXG4gICAgaWYgKC9eWzAtOWEtZl17Nn0kL2kudGVzdChjb2xvcikpIHtcbiAgICAgIC8vIFdlIGFsbG93IGEgNi1kaWdpdCBIVE1MIGNvbG9yIHNwZWMgd2l0aG91dCBhIGxlYWRpbmcgXCIjXCIuXG4gICAgICAvLyBUaGlzIGZvbGxvd3MgdGhlIHhjb2xvciBwYWNrYWdlJ3MgSFRNTCBjb2xvciBtb2RlbC5cbiAgICAgIC8vIFByZWRlZmluZWQgY29sb3IgbmFtZXMgYXJlIGFsbCBtaXNzZWQgYnkgdGhpcyBSZWdFeCBwYXR0ZXJuLlxuICAgICAgY29sb3IgPSBcIiNcIiArIGNvbG9yO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbG9yLXRva2VuXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjb2xvclxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNpemUgc3BlY2lmaWNhdGlvbiwgY29uc2lzdGluZyBvZiBtYWduaXR1ZGUgYW5kIHVuaXQuXG4gICAqL1xuXG5cbiAgcGFyc2VTaXplR3JvdXAob3B0aW9uYWwpIHtcbiAgICBsZXQgcmVzO1xuICAgIGxldCBpc0JsYW5rID0gZmFsc2U7IC8vIGRvbid0IGV4cGFuZCBiZWZvcmUgcGFyc2VTdHJpbmdHcm91cFxuXG4gICAgdGhpcy5ndWxsZXQuY29uc3VtZVNwYWNlcygpO1xuXG4gICAgaWYgKCFvcHRpb25hbCAmJiB0aGlzLmd1bGxldC5mdXR1cmUoKS50ZXh0ICE9PSBcIntcIikge1xuICAgICAgcmVzID0gdGhpcy5wYXJzZVJlZ2V4R3JvdXAoL15bLStdPyAqKD86JHxcXGQrfFxcZCtcXC5cXGQqfFxcLlxcZCopICpbYS16XXswLDJ9ICokLywgXCJzaXplXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJzaXplXCIsIG9wdGlvbmFsKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25hbCAmJiByZXMudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEJlY2F1c2Ugd2UndmUgdGVzdGVkIGZvciB3aGF0IGlzICFvcHRpb25hbCwgdGhpcyBibG9jayB3b24ndFxuICAgICAgLy8gYWZmZWN0IFxca2VybiwgXFxoc3BhY2UsIGV0Yy4gSXQgd2lsbCBjYXB0dXJlIHRoZSBtYW5kYXRvcnkgYXJndW1lbnRzXG4gICAgICAvLyB0byBcXGdlbmZyYWMgYW5kIFxcYWJvdmUuXG4gICAgICByZXMudGV4dCA9IFwiMHB0XCI7IC8vIEVuYWJsZSBcXGFib3Zle31cblxuICAgICAgaXNCbGFuayA9IHRydWU7IC8vIFRoaXMgaXMgaGVyZSBzcGVjaWZpY2FsbHkgZm9yIFxcZ2VuZnJhY1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gLyhbLStdPykgKihcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspICooW2Etel17Mn0pLy5leGVjKHJlcy50ZXh0KTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgc2l6ZTogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLFxuICAgICAgLy8gc2lnbiArIG1hZ25pdHVkZSwgY2FzdCB0byBudW1iZXJcbiAgICAgIHVuaXQ6IG1hdGNoWzNdXG4gICAgfTtcblxuICAgIGlmICghdmFsaWRVbml0KGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIGRhdGEudW5pdCArIFwiJ1wiLCByZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpemVcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgaXNCbGFua1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBVUkwsIGNoZWNraW5nIGVzY2FwZWQgbGV0dGVycyBhbmQgYWxsb3dlZCBwcm90b2NvbHMsXG4gICAqIGFuZCBzZXR0aW5nIHRoZSBjYXRjb2RlIG9mICUgYXMgYW4gYWN0aXZlIGNoYXJhY3RlciAoYXMgaW4gXFxoeXBlcnJlZikuXG4gICAqL1xuXG5cbiAgcGFyc2VVcmxHcm91cChvcHRpb25hbCkge1xuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCIlXCIsIDEzKTsgLy8gYWN0aXZlIGNoYXJhY3RlclxuXG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIn5cIiwgMTIpOyAvLyBvdGhlciBjaGFyYWN0ZXJcblxuICAgIGNvbnN0IHJlcyA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInVybFwiLCBvcHRpb25hbCk7XG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIiVcIiwgMTQpOyAvLyBjb21tZW50IGNoYXJhY3RlclxuXG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIn5cIiwgMTMpOyAvLyBhY3RpdmUgY2hhcmFjdGVyXG5cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gaHlwZXJyZWYgcGFja2FnZSBhbGxvd3MgYmFja3NsYXNoZXMgYWxvbmUgaW4gaHJlZiwgYnV0IGRvZXNuJ3RcbiAgICAvLyBnZW5lcmF0ZSB2YWxpZCBsaW5rcyBpbiBzdWNoIGNhc2VzOyB3ZSBpbnRlcnByZXQgdGhpcyBhc1xuICAgIC8vIFwidW5kZWZpbmVkXCIgYmVoYXZpb3VyLCBhbmQga2VlcCB0aGVtIGFzLWlzLiBTb21lIGJyb3dzZXIgd2lsbFxuICAgIC8vIHJlcGxhY2UgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXMuXG5cblxuICAgIGNvbnN0IHVybCA9IHJlcy50ZXh0LnJlcGxhY2UoL1xcXFwoWyMkJSZ+X157fV0pL2csICckMScpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVybFwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgdXJsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIGFyZ3VtZW50IHdpdGggdGhlIG1vZGUgc3BlY2lmaWVkLlxuICAgKi9cblxuXG4gIHBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgbW9kZSkge1xuICAgIGNvbnN0IGFyZ1Rva2VuID0gdGhpcy5ndWxsZXQuc2NhbkFyZ3VtZW50KG9wdGlvbmFsKTtcblxuICAgIGlmIChhcmdUb2tlbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICBpZiAobW9kZSkge1xuICAgICAgLy8gU3dpdGNoIHRvIHNwZWNpZmllZCBtb2RlXG4gICAgICB0aGlzLnN3aXRjaE1vZGUobW9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJFT0ZcIik7IC8vIFRPRE86IGZpbmQgYW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGRlbm90ZSB0aGUgZW5kXG5cbiAgICB0aGlzLmV4cGVjdChcIkVPRlwiKTsgLy8gZXhwZWN0IHRoZSBlbmQgb2YgdGhlIGFyZ3VtZW50XG5cbiAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGxvYzogYXJnVG9rZW4ubG9jLFxuICAgICAgYm9keTogZXhwcmVzc2lvblxuICAgIH07XG5cbiAgICBpZiAobW9kZSkge1xuICAgICAgLy8gU3dpdGNoIG1vZGUgYmFja1xuICAgICAgdGhpcy5zd2l0Y2hNb2RlKG91dGVyTW9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIG9yZGluYXJ5IGdyb3VwLCB3aGljaCBpcyBlaXRoZXIgYSBzaW5nbGUgbnVjbGV1cyAobGlrZSBcInhcIilcbiAgICogb3IgYW4gZXhwcmVzc2lvbiBpbiBicmFjZXMgKGxpa2UgXCJ7eCt5fVwiKSBvciBhbiBpbXBsaWNpdCBncm91cCwgYSBncm91cFxuICAgKiB0aGF0IHN0YXJ0cyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIGVuZHMgcmlnaHQgYmVmb3JlIGEgaGlnaGVyIGV4cGxpY2l0XG4gICAqIGdyb3VwIGVuZHMsIG9yIGF0IEVPRi5cbiAgICovXG5cblxuICBwYXJzZUdyb3VwKG5hbWUsIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gIGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICBjb25zdCBmaXJzdFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IHRleHQgPSBmaXJzdFRva2VuLnRleHQ7XG4gICAgbGV0IHJlc3VsdDsgLy8gVHJ5IHRvIHBhcnNlIGFuIG9wZW4gYnJhY2Ugb3IgXFxiZWdpbmdyb3VwXG5cbiAgICBpZiAodGV4dCA9PT0gXCJ7XCIgfHwgdGV4dCA9PT0gXCJcXFxcYmVnaW5ncm91cFwiKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIGNvbnN0IGdyb3VwRW5kID0gdGV4dCA9PT0gXCJ7XCIgPyBcIn1cIiA6IFwiXFxcXGVuZGdyb3VwXCI7XG4gICAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7IC8vIElmIHdlIGdldCBhIGJyYWNlLCBwYXJzZSBhbiBleHByZXNzaW9uXG5cbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgZ3JvdXBFbmQpO1xuICAgICAgY29uc3QgbGFzdFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgICAgdGhpcy5leHBlY3QoZ3JvdXBFbmQpOyAvLyBDaGVjayB0aGF0IHdlIGdvdCBhIG1hdGNoaW5nIGNsb3NpbmcgYnJhY2VcblxuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoZmlyc3RUb2tlbiwgbGFzdFRva2VuKSxcbiAgICAgICAgYm9keTogZXhwcmVzc2lvbixcbiAgICAgICAgLy8gQSBncm91cCBmb3JtZWQgYnkgXFxiZWdpbmdyb3VwLi4uXFxlbmRncm91cCBpcyBhIHNlbWktc2ltcGxlIGdyb3VwXG4gICAgICAgIC8vIHdoaWNoIGRvZXNuJ3QgYWZmZWN0IHNwYWNpbmcgaW4gbWF0aCBtb2RlLCBpLmUuLCBpcyB0cmFuc3BhcmVudC5cbiAgICAgICAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE5MzAvd2hlbi1zaG91bGQtb25lLVxuICAgICAgICAvLyB1c2UtYmVnaW5ncm91cC1pbnN0ZWFkLW9mLWJncm91cFxuICAgICAgICBzZW1pc2ltcGxlOiB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCIgfHwgdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBleGlzdHMgYSBmdW5jdGlvbiB3aXRoIHRoaXMgbmFtZSwgcGFyc2UgdGhlIGZ1bmN0aW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiBhIG51Y2xldXNcbiAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VGdW5jdGlvbihicmVha09uVG9rZW5UZXh0LCBuYW1lKSB8fCB0aGlzLnBhcnNlU3ltYm9sKCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiB0ZXh0WzBdID09PSBcIlxcXFxcIiAmJiAhaW1wbGljaXRDb21tYW5kcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0KSkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50aHJvd09uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZTogXCIgKyB0ZXh0LCBmaXJzdFRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZm9ybWF0VW5zdXBwb3J0ZWRDbWQodGV4dCk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEZvcm0gbGlnYXR1cmUtbGlrZSBjb21iaW5hdGlvbnMgb2YgY2hhcmFjdGVycyBmb3IgdGV4dCBtb2RlLlxuICAgKiBUaGlzIGluY2x1ZGVzIGlucHV0cyBsaWtlIFwiLS1cIiwgXCItLS1cIiwgXCJgYFwiIGFuZCBcIicnXCIuXG4gICAqIFRoZSByZXN1bHQgd2lsbCBzaW1wbHkgcmVwbGFjZSBtdWx0aXBsZSB0ZXh0b3JkIG5vZGVzIHdpdGggYSBzaW5nbGVcbiAgICogY2hhcmFjdGVyIGluIGVhY2ggdmFsdWUgYnkgYSBzaW5nbGUgdGV4dG9yZCBub2RlIGhhdmluZyBtdWx0aXBsZVxuICAgKiBjaGFyYWN0ZXJzIGluIGl0cyB2YWx1ZS4gIFRoZSByZXByZXNlbnRhdGlvbiBpcyBzdGlsbCBBU0NJSSBzb3VyY2UuXG4gICAqIFRoZSBncm91cCB3aWxsIGJlIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKi9cblxuXG4gIGZvcm1MaWdhdHVyZXMoZ3JvdXApIHtcbiAgICBsZXQgbiA9IGdyb3VwLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgYSA9IGdyb3VwW2ldOyAvLyAkRmxvd0ZpeE1lOiBOb3QgZXZlcnkgbm9kZSB0eXBlIGhhcyBhIGB0ZXh0YCBwcm9wZXJ0eS5cblxuICAgICAgY29uc3QgdiA9IGEudGV4dDtcblxuICAgICAgaWYgKHYgPT09IFwiLVwiICYmIGdyb3VwW2kgKyAxXS50ZXh0ID09PSBcIi1cIikge1xuICAgICAgICBpZiAoaSArIDEgPCBuICYmIGdyb3VwW2kgKyAyXS50ZXh0ID09PSBcIi1cIikge1xuICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAzLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMl0pLFxuICAgICAgICAgICAgdGV4dDogXCItLS1cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDFdKSxcbiAgICAgICAgICAgIHRleHQ6IFwiLS1cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKHYgPT09IFwiJ1wiIHx8IHYgPT09IFwiYFwiKSAmJiBncm91cFtpICsgMV0udGV4dCA9PT0gdikge1xuICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwge1xuICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDFdKSxcbiAgICAgICAgICB0ZXh0OiB2ICsgdlxuICAgICAgICB9KTtcbiAgICAgICAgbiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSBzaW5nbGUgc3ltYm9sIG91dCBvZiB0aGUgc3RyaW5nLiBIZXJlLCB3ZSBoYW5kbGUgc2luZ2xlIGNoYXJhY3RlclxuICAgKiBzeW1ib2xzIGFuZCBzcGVjaWFsIGZ1bmN0aW9ucyBsaWtlIFxcdmVyYi5cbiAgICovXG5cblxuICBwYXJzZVN5bWJvbCgpIHtcbiAgICBjb25zdCBudWNsZXVzID0gdGhpcy5mZXRjaCgpO1xuICAgIGxldCB0ZXh0ID0gbnVjbGV1cy50ZXh0O1xuXG4gICAgaWYgKC9eXFxcXHZlcmJbXmEtekEtWl0vLnRlc3QodGV4dCkpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgbGV0IGFyZyA9IHRleHQuc2xpY2UoNSk7XG4gICAgICBjb25zdCBzdGFyID0gYXJnLmNoYXJBdCgwKSA9PT0gXCIqXCI7XG5cbiAgICAgIGlmIChzdGFyKSB7XG4gICAgICAgIGFyZyA9IGFyZy5zbGljZSgxKTtcbiAgICAgIH0gLy8gTGV4ZXIncyB0b2tlblJlZ2V4IGlzIGNvbnN0cnVjdGVkIHRvIGFsd2F5cyBoYXZlIG1hdGNoaW5nXG4gICAgICAvLyBmaXJzdC9sYXN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgaWYgKGFyZy5sZW5ndGggPCAyIHx8IGFyZy5jaGFyQXQoMCkgIT09IGFyZy5zbGljZSgtMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXHZlcmIgYXNzZXJ0aW9uIGZhaWxlZCAtLVxcbiAgICAgICAgICAgICAgICAgICAgcGxlYXNlIHJlcG9ydCB3aGF0IGlucHV0IGNhdXNlZCB0aGlzIGJ1Z1wiKTtcbiAgICAgIH1cblxuICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTsgLy8gcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IGNoYXJcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ2ZXJiXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICBib2R5OiBhcmcsXG4gICAgICAgIHN0YXJcbiAgICAgIH07XG4gICAgfSAvLyBBdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhIHN5bWJvbCwgcG9zc2libHkgd2l0aCBhY2NlbnRzLlxuICAgIC8vIEZpcnN0IGV4cGFuZCBhbnkgYWNjZW50ZWQgYmFzZSBzeW1ib2wgYWNjb3JkaW5nIHRvIHVuaWNvZGVTeW1ib2xzLlxuXG5cbiAgICBpZiAodW5pY29kZVN5bWJvbHMuaGFzT3duUHJvcGVydHkodGV4dFswXSkgJiYgIXNyY19zeW1ib2xzW3RoaXMubW9kZV1bdGV4dFswXV0pIHtcbiAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgbm90IHN0cmljdCAoWGVUZVgtY29tcGF0aWJsZSkgaW4gbWF0aCBtb2RlLlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0ICYmIHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJ1bmljb2RlVGV4dEluTWF0aE1vZGVcIiwgXCJBY2NlbnRlZCBVbmljb2RlIHRleHQgY2hhcmFjdGVyIFxcXCJcIiArIHRleHRbMF0gKyBcIlxcXCIgdXNlZCBpbiBcIiArIFwibWF0aCBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gdW5pY29kZVN5bWJvbHNbdGV4dFswXV0gKyB0ZXh0LnNsaWNlKDEpO1xuICAgIH0gLy8gU3RyaXAgb2ZmIGFueSBjb21iaW5pbmcgY2hhcmFjdGVyc1xuXG5cbiAgICBjb25zdCBtYXRjaCA9IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleC5leGVjKHRleHQpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpO1xuXG4gICAgICBpZiAodGV4dCA9PT0gJ2knKSB7XG4gICAgICAgIHRleHQgPSAnXFx1MDEzMSc7IC8vIGRvdGxlc3MgaSwgaW4gbWF0aCBhbmQgdGV4dCBtb2RlXG4gICAgICB9IGVsc2UgaWYgKHRleHQgPT09ICdqJykge1xuICAgICAgICB0ZXh0ID0gJ1xcdTAyMzcnOyAvLyBkb3RsZXNzIGosIGluIG1hdGggYW5kIHRleHQgbW9kZVxuICAgICAgfVxuICAgIH0gLy8gUmVjb2duaXplIGJhc2Ugc3ltYm9sXG5cblxuICAgIGxldCBzeW1ib2w7XG5cbiAgICBpZiAoc3JjX3N5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0XSkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0ICYmIHRoaXMubW9kZSA9PT0gJ21hdGgnICYmIGV4dHJhTGF0aW4uaW5kZXhPZih0ZXh0KSA+PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiTGF0aW4tMS9Vbmljb2RlIHRleHQgY2hhcmFjdGVyIFxcXCJcIiArIHRleHRbMF0gKyBcIlxcXCIgdXNlZCBpbiBcIiArIFwibWF0aCBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBncm91cCA9IHNyY19zeW1ib2xzW3RoaXMubW9kZV1bdGV4dF0uZ3JvdXA7XG4gICAgICBjb25zdCBsb2MgPSBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKTtcbiAgICAgIGxldCBzO1xuXG4gICAgICBpZiAoQVRPTVMuaGFzT3duUHJvcGVydHkoZ3JvdXApKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgY29uc3QgZmFtaWx5ID0gZ3JvdXA7XG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogXCJhdG9tXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGZhbWlseSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBzID0ge1xuICAgICAgICAgIHR5cGU6IGdyb3VwLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9O1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgc3ltYm9sID0gcztcbiAgICB9IGVsc2UgaWYgKHRleHQuY2hhckNvZGVBdCgwKSA+PSAweDgwKSB7XG4gICAgICAvLyBubyBzeW1ib2wgZm9yIGUuZy4gXlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQ29kZXBvaW50KHRleHQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVua25vd25TeW1ib2xcIiwgXCJVbnJlY29nbml6ZWQgVW5pY29kZSBjaGFyYWN0ZXIgXFxcIlwiICsgdGV4dFswXSArIFwiXFxcIlwiICsgKFwiIChcIiArIHRleHQuY2hhckNvZGVBdCgwKSArIFwiKVwiKSwgbnVjbGV1cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gbWF0aCBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFsbCBub25tYXRoZW1hdGljYWwgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSByZW5kZXJlZCBhcyBpZiB0aGV5XG4gICAgICAvLyBhcmUgaW4gdGV4dCBtb2RlICh3cmFwcGVkIGluIFxcdGV4dCkgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpdFxuICAgICAgLy8gdGFrZXMgdG8gcmVuZGVyIHRoZW0gaW4gTGFUZVguICBTZXR0aW5nIGBtb2RlOiB0aGlzLm1vZGVgIGlzXG4gICAgICAvLyBhbm90aGVyIG5hdHVyYWwgY2hvaWNlICh0aGUgdXNlciByZXF1ZXN0ZWQgbWF0aCBtb2RlKSwgYnV0XG4gICAgICAvLyB0aGlzIG1ha2VzIGl0IG1vcmUgZGlmZmljdWx0IGZvciBnZXRDaGFyYWN0ZXJNZXRyaWNzKCkgdG9cbiAgICAgIC8vIGRpc3Rpbmd1aXNoIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRob3V0IG1ldHJpY3MgYW5kIHRob3NlIGZvclxuICAgICAgLy8gd2hpY2ggd2Ugd2FudCB0byBzaW11bGF0ZSB0aGUgbGV0dGVyIE0uXG5cblxuICAgICAgc3ltYm9sID0ge1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksXG4gICAgICAgIHRleHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBFT0YsIF4sIF8sIHssIH0sIGV0Yy5cbiAgICB9XG5cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gVHJhbnNmb3JtIGNvbWJpbmluZyBjaGFyYWN0ZXJzIGludG8gYWNjZW50c1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFjY2VudCA9IG1hdGNoWzBdW2ldO1xuXG4gICAgICAgIGlmICghdW5pY29kZUFjY2VudHNbYWNjZW50XSkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gYWNjZW50ICcgXCIgKyBhY2NlbnQgKyBcIidcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb21tYW5kID0gdW5pY29kZUFjY2VudHNbYWNjZW50XVt0aGlzLm1vZGVdIHx8IHVuaWNvZGVBY2NlbnRzW2FjY2VudF0udGV4dDtcblxuICAgICAgICBpZiAoIWNvbW1hbmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJBY2NlbnQgXCIgKyBhY2NlbnQgKyBcIiB1bnN1cHBvcnRlZCBpbiBcIiArIHRoaXMubW9kZSArIFwiIG1vZGVcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBzeW1ib2wgPSB7XG4gICAgICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgICBsYWJlbDogY29tbWFuZCxcbiAgICAgICAgICBpc1N0cmV0Y2h5OiBmYWxzZSxcbiAgICAgICAgICBpc1NoaWZ0eTogdHJ1ZSxcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgYmFzZTogc3ltYm9sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICAgIHJldHVybiBzeW1ib2w7XG4gIH1cblxufVxuUGFyc2VyLmVuZE9mRXhwcmVzc2lvbiA9IFtcIn1cIiwgXCJcXFxcZW5kZ3JvdXBcIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiJlwiXTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wYXJzZVRyZWUuanNcbi8qKlxuICogUHJvdmlkZXMgYSBzaW5nbGUgZnVuY3Rpb24gZm9yIHBhcnNpbmcgYW4gZXhwcmVzc2lvbiB1c2luZyBhIFBhcnNlclxuICogVE9ETyhlbWlseSk6IFJlbW92ZSB0aGlzXG4gKi9cblxuXG5cblxuLyoqXG4gKiBQYXJzZXMgYW4gZXhwcmVzc2lvbiB1c2luZyBhIFBhcnNlciwgdGhlbiByZXR1cm5zIHRoZSBwYXJzZWQgcmVzdWx0LlxuICovXG5jb25zdCBwYXJzZVRyZWUgPSBmdW5jdGlvbiAodG9QYXJzZSwgc2V0dGluZ3MpIHtcbiAgaWYgKCEodHlwZW9mIHRvUGFyc2UgPT09ICdzdHJpbmcnIHx8IHRvUGFyc2UgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2FUZVggY2FuIG9ubHkgcGFyc2Ugc3RyaW5nIHR5cGVkIGV4cHJlc3Npb24nKTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIodG9QYXJzZSwgc2V0dGluZ3MpOyAvLyBCbGFuayBvdXQgYW55IFxcZGZAdGFnIHRvIGF2b2lkIHNwdXJpb3VzIFwiRHVwbGljYXRlIFxcdGFnXCIgZXJyb3JzXG5cbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcZGZAdGFnXCJdO1xuICBsZXQgdHJlZSA9IHBhcnNlci5wYXJzZSgpOyAvLyBQcmV2ZW50IGEgY29sb3IgZGVmaW5pdGlvbiBmcm9tIHBlcnNpc3RpbmcgYmV0d2VlbiBjYWxscyB0byBrYXRleC5yZW5kZXIoKS5cblxuICBkZWxldGUgcGFyc2VyLmd1bGxldC5tYWNyb3MuY3VycmVudFtcIlxcXFxjdXJyZW50QGNvbG9yXCJdO1xuICBkZWxldGUgcGFyc2VyLmd1bGxldC5tYWNyb3MuY3VycmVudFtcIlxcXFxjb2xvclwiXTsgLy8gSWYgdGhlIGlucHV0IHVzZWQgXFx0YWcsIGl0IHdpbGwgc2V0IHRoZSBcXGRmQHRhZyBtYWNybyB0byB0aGUgdGFnLlxuICAvLyBJbiB0aGlzIGNhc2UsIHdlIHNlcGFyYXRlbHkgcGFyc2UgdGhlIHRhZyBhbmQgd3JhcCB0aGUgdHJlZS5cblxuICBpZiAocGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgIGlmICghc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFx0YWcgd29ya3Mgb25seSBpbiBkaXNwbGF5IGVxdWF0aW9uc1wiKTtcbiAgICB9XG5cbiAgICB0cmVlID0gW3tcbiAgICAgIHR5cGU6IFwidGFnXCIsXG4gICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgIGJvZHk6IHRyZWUsXG4gICAgICB0YWc6IHBhcnNlci5zdWJwYXJzZShbbmV3IFRva2VuKFwiXFxcXGRmQHRhZ1wiKV0pXG4gICAgfV07XG4gIH1cblxuICByZXR1cm4gdHJlZTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19wYXJzZVRyZWUgPSAocGFyc2VUcmVlKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2thdGV4LmpzXG4vKiBlc2xpbnQgbm8tY29uc29sZTowICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgS2FUZVguIEhlcmUsIHdlIGV4cG9zZSBmdW5jdGlvbnMgZm9yXG4gKiByZW5kZXJpbmcgZXhwcmVzc2lvbnMgZWl0aGVyIHRvIERPTSBub2RlcyBvciB0byBtYXJrdXAgc3RyaW5ncy5cbiAqXG4gKiBXZSBhbHNvIGV4cG9zZSB0aGUgUGFyc2VFcnJvciBjbGFzcyB0byBjaGVjayBpZiBlcnJvcnMgdGhyb3duIGZyb20gS2FUZVggYXJlXG4gKiBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24sIG9yIGVycm9ycyBpbiBqYXZhc2NyaXB0IGhhbmRsaW5nLlxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHBsYWNlIHRoYXQgZXhwcmVzc2lvbiBpbiB0aGUgRE9NIG5vZGVcbiAqIGdpdmVuLlxuICovXG5sZXQgcmVuZGVyID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGJhc2VOb2RlLCBvcHRpb25zKSB7XG4gIGJhc2VOb2RlLnRleHRDb250ZW50ID0gXCJcIjtcbiAgY29uc3Qgbm9kZSA9IHJlbmRlclRvRG9tVHJlZShleHByZXNzaW9uLCBvcHRpb25zKS50b05vZGUoKTtcbiAgYmFzZU5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG59OyAvLyBLYVRlWCdzIHN0eWxlcyBkb24ndCB3b3JrIHByb3Blcmx5IGluIHF1aXJrcyBtb2RlLiBQcmludCBvdXQgYW4gZXJyb3IsIGFuZFxuLy8gZGlzYWJsZSByZW5kZXJpbmcuXG5cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBpZiAoZG9jdW1lbnQuY29tcGF0TW9kZSAhPT0gXCJDU1MxQ29tcGF0XCIpIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBLYVRlWCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuIE1ha2Ugc3VyZSB5b3VyIFwiICsgXCJ3ZWJzaXRlIGhhcyBhIHN1aXRhYmxlIGRvY3R5cGUuXCIpO1xuXG4gICAgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLlwiKTtcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcmV0dXJuIHRoZSBtYXJrdXAgZm9yIHRoYXQuXG4gKi9cblxuXG5jb25zdCByZW5kZXJUb1N0cmluZyA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1hcmt1cCA9IHJlbmRlclRvRG9tVHJlZShleHByZXNzaW9uLCBvcHRpb25zKS50b01hcmt1cCgpO1xuICByZXR1cm4gbWFya3VwO1xufTtcbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBhbmQgcmV0dXJuIHRoZSBwYXJzZSB0cmVlLlxuICovXG5cblxuY29uc3QgZ2VuZXJhdGVQYXJzZVRyZWUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgcmV0dXJuIHNyY19wYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xufTtcbi8qKlxuICogSWYgdGhlIGdpdmVuIGVycm9yIGlzIGEgS2FUZVggUGFyc2VFcnJvciBhbmQgb3B0aW9ucy50aHJvd09uRXJyb3IgaXMgZmFsc2UsXG4gKiByZW5kZXJzIHRoZSBpbnZhbGlkIExhVGVYIGFzIGEgc3BhbiB3aXRoIGhvdmVyIHRpdGxlIGdpdmluZyB0aGUgS2FUZVhcbiAqIGVycm9yIG1lc3NhZ2UuICBPdGhlcndpc2UsIHNpbXBseSB0aHJvd3MgdGhlIGVycm9yLlxuICovXG5cblxuY29uc3QgcmVuZGVyRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudGhyb3dPbkVycm9yIHx8ICEoZXJyb3IgaW5zdGFuY2VvZiBzcmNfUGFyc2VFcnJvcikpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleC1lcnJvclwiXSwgW25ldyBTeW1ib2xOb2RlKGV4cHJlc3Npb24pXSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgZXJyb3IudG9TdHJpbmcoKSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJjb2xvcjpcIiArIG9wdGlvbnMuZXJyb3JDb2xvcik7XG4gIHJldHVybiBub2RlO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIHRoZSBrYXRleCBidWlsZCB0cmVlLiBUaGlzIGlzIHVzZWQgZm9yIGFkdmFuY2VkXG4gKiB1c2UgY2FzZXMgKGxpa2UgcmVuZGVyaW5nIHRvIGN1c3RvbSBvdXRwdXQpLlxuICovXG5cblxuY29uc3QgcmVuZGVyVG9Eb21UcmVlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0cmVlID0gc3JjX3BhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgcmV0dXJuIGJ1aWxkVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHJlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH1cbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyB0aGUga2F0ZXggYnVpbGQgdHJlZSwgd2l0aCBqdXN0IEhUTUwgKG5vIE1hdGhNTCkuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGFkdmFuY2VkIHVzZSBjYXNlcyAobGlrZSByZW5kZXJpbmcgdG8gY3VzdG9tIG91dHB1dCkuXG4gKi9cblxuXG5jb25zdCByZW5kZXJUb0hUTUxUcmVlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0cmVlID0gc3JjX3BhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgcmV0dXJuIGJ1aWxkSFRNTFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiByZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9XG59O1xuXG5jb25zdCB2ZXJzaW9uID0gXCIwLjE2LjIxXCI7XG5jb25zdCBfX2RvbVRyZWUgPSB7XG4gIFNwYW46IFNwYW4sXG4gIEFuY2hvcjogQW5jaG9yLFxuICBTeW1ib2xOb2RlOiBTeW1ib2xOb2RlLFxuICBTdmdOb2RlOiBTdmdOb2RlLFxuICBQYXRoTm9kZTogUGF0aE5vZGUsXG4gIExpbmVOb2RlOiBMaW5lTm9kZVxufTsgLy8gRVNNIGV4cG9ydHNcblxuIC8vIENKUyBleHBvcnRzIGFuZCBFU00gZGVmYXVsdCBleHBvcnRcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIga2F0ZXggPSAoe1xuICAvKipcbiAgICogQ3VycmVudCBLYVRlWCB2ZXJzaW9uXG4gICAqL1xuICB2ZXJzaW9uLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGNvbWJpbmF0aW9uLCBhbmQgYWRkc1xuICAgKiBpdCBhcyBhIGNoaWxkIHRvIHRoZSBzcGVjaWZpZWQgRE9NIG5vZGUuXG4gICAqL1xuICByZW5kZXIsXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gYW4gSFRNTCtNYXRoTUwgY29tYmluYXRpb24gc3RyaW5nLFxuICAgKiBmb3Igc2VuZGluZyB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVuZGVyVG9TdHJpbmcsXG5cbiAgLyoqXG4gICAqIEthVGVYIGVycm9yLCB1c3VhbGx5IGR1cmluZyBwYXJzaW5nLlxuICAgKi9cbiAgUGFyc2VFcnJvcjogc3JjX1BhcnNlRXJyb3IsXG5cbiAgLyoqXG4gICAqIFRoZSBzY2hlbWEgb2YgU2V0dGluZ3NcbiAgICovXG4gIFNFVFRJTkdTX1NDSEVNQTogU0VUVElOR1NfU0NIRU1BLFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIExhVGVYIGludG8gS2FUZVgncyBpbnRlcm5hbCBwYXJzZSB0cmVlIHN0cnVjdHVyZSxcbiAgICogd2l0aG91dCByZW5kZXJpbmcgdG8gSFRNTCBvciBNYXRoTUwuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuXG4gICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgX19wYXJzZTogZ2VuZXJhdGVQYXJzZVRyZWUsXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gYW4gSFRNTCtNYXRoTUwgaW50ZXJuYWwgRE9NIHRyZWVcbiAgICogcmVwcmVzZW50YXRpb24sIHdpdGhvdXQgZmxhdHRlbmluZyB0aGF0IHJlcHJlc2VudGF0aW9uIHRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fcmVuZGVyVG9Eb21UcmVlOiByZW5kZXJUb0RvbVRyZWUsXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gYW4gSFRNTCBpbnRlcm5hbCBET00gdHJlZSByZXByZXNlbnRhdGlvbixcbiAgICogd2l0aG91dCBNYXRoTUwgYW5kIHdpdGhvdXQgZmxhdHRlbmluZyB0aGF0IHJlcHJlc2VudGF0aW9uIHRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fcmVuZGVyVG9IVE1MVHJlZTogcmVuZGVyVG9IVE1MVHJlZSxcblxuICAvKipcbiAgICogZXh0ZW5kcyBpbnRlcm5hbCBmb250IG1ldHJpY3Mgb2JqZWN0IHdpdGggYSBuZXcgb2JqZWN0XG4gICAqIGVhY2gga2V5IGluIHRoZSBuZXcgb2JqZWN0IHJlcHJlc2VudHMgYSBmb250IG5hbWVcbiAgKi9cbiAgX19zZXRGb250TWV0cmljczogc2V0Rm9udE1ldHJpY3MsXG5cbiAgLyoqXG4gICAqIGFkZHMgYSBuZXcgc3ltYm9sIHRvIGJ1aWx0aW4gc3ltYm9scyB0YWJsZVxuICAgKi9cbiAgX19kZWZpbmVTeW1ib2w6IGRlZmluZVN5bWJvbCxcblxuICAvKipcbiAgICogYWRkcyBhIG5ldyBmdW5jdGlvbiB0byBidWlsdGluIGZ1bmN0aW9uIGxpc3QsXG4gICAqIHdoaWNoIGRpcmVjdGx5IHByb2R1Y2UgcGFyc2UgdHJlZSBlbGVtZW50c1xuICAgKiBhbmQgaGF2ZSB0aGVpciBvd24gaHRtbC9tYXRobWwgYnVpbGRlcnNcbiAgICovXG4gIF9fZGVmaW5lRnVuY3Rpb246IGRlZmluZUZ1bmN0aW9uLFxuXG4gIC8qKlxuICAgKiBhZGRzIGEgbmV3IG1hY3JvIHRvIGJ1aWx0aW4gbWFjcm8gbGlzdFxuICAgKi9cbiAgX19kZWZpbmVNYWNybzogZGVmaW5lTWFjcm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZSB0aGUgZG9tIHRyZWUgbm9kZSB0eXBlcywgd2hpY2ggY2FuIGJlIHVzZWZ1bCBmb3IgdHlwZSBjaGVja2luZyBub2Rlcy5cbiAgICpcbiAgICogTk9URTogVGhlc2UgbWV0aG9kcyBhcmUgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX2RvbVRyZWVcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4va2F0ZXgud2VicGFjay5qc1xuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWJwYWNrIGVudHJ5IHBvaW50IGZvciBLYVRlWC4gQXMgRUNNQVNjcmlwdCwgZmxvd1sxXSBhbmQgamVzdFsyXVxuICogZG9lc24ndCBzdXBwb3J0IENTUyBtb2R1bGVzIG5hdGl2ZWx5LCBhIHNlcGFyYXRlIGVudHJ5IHBvaW50IGlzIHVzZWQgYW5kXG4gKiBpdCBpcyBub3QgZmxvd3R5cGVkLlxuICpcbiAqIFsxXSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9sYW1iZGFoYW5kcy9kMTllMGRhOTYyODViNzQ5ZjBlZlxuICogWzJdIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL2plc3QvZG9jcy9lbi93ZWJwYWNrLmh0bWxcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGthdGV4X3dlYnBhY2sgPSAoa2F0ZXgpO1xuX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdO1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsImltcG9ydCB7IFBhcnNlciwgVG9rZW5pemUgfSBmcm9tIFwidHMtcGFyc28vaW5kZXhcIjtcbmltcG9ydCBrYXRleCBmcm9tIFwia2F0ZXhcIjtcblxuY29uc3QgdG9rZW5fZGVzY19saXN0OiBUb2tlbkRlc2NyaXB0aW9uW10gPSBbXG4gIHtcbiAgICBuYW1lOiBcIkhBU0hcIixcbiAgICBkZXNjcmlwdGlvbjogLyMvLFxuICAgIHByZWNlZGVuY2U6IDEyLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJTVEFSXCIsXG4gICAgZGVzY3JpcHRpb246IC9cXCovLFxuICAgIHByZWNlZGVuY2U6IDEzLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJVTkRFUlwiLFxuICAgIGRlc2NyaXB0aW9uOiAvXy8sXG4gICAgcHJlY2VkZW5jZTogMTMsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkdUXCIsXG4gICAgZGVzY3JpcHRpb246IC8+LyxcbiAgICBwcmVjZWRlbmNlOiAxMyxcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiVEFCXCIsXG4gICAgZGVzY3JpcHRpb246IC9cXHQvLFxuICAgIHByZWNlZGVuY2U6IDEwLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJOVU1fRE9UXCIsXG4gICAgZGVzY3JpcHRpb246IC9cXGQrXFwuLyxcbiAgICBwcmVjZWRlbmNlOiAxMyxcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiREFTSFwiLFxuICAgIGRlc2NyaXB0aW9uOiAvLS8sXG4gICAgcHJlY2VkZW5jZTogMTMsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkxCUkFDS0VUXCIsXG4gICAgZGVzY3JpcHRpb246IC9cXFsvLFxuICAgIHByZWNlZGVuY2U6IDEzLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJSQlJBQ0tFVFwiLFxuICAgIGRlc2NyaXB0aW9uOiAvXFxdLyxcbiAgICBwcmVjZWRlbmNlOiAxMyxcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiTFBBUkVOXCIsXG4gICAgZGVzY3JpcHRpb246IC9cXCgvLFxuICAgIHByZWNlZGVuY2U6IDEzLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJSUEFSRU5cIixcbiAgICBkZXNjcmlwdGlvbjogL1xcKS8sXG4gICAgcHJlY2VkZW5jZTogMTMsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkVTQ0FQRV9TRVFcIixcbiAgICBkZXNjcmlwdGlvbjogL1xcXFwvLFxuICAgIHByZWNlZGVuY2U6IDE0LFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJTVFJcIixcbiAgICBkZXNjcmlwdGlvbjogL1teKl9gXFxuXFwkXFxbXFxdXFwoXFwpXFxcXF0rLyxcbiAgICBwcmVjZWRlbmNlOiAwLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJDT0RFX0JMT0NLXCIsXG4gICAgZGVzY3JpcHRpb246IC9cXGBbXmBdK1xcYC8sXG4gICAgcHJlY2VkZW5jZTogMTMsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIktBVEVYXCIsXG4gICAgZGVzY3JpcHRpb246IC9cXCRbXlxcJF0rXFwkLyxcbiAgICBwcmVjZWRlbmNlOiAzLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJFU0NBUEVfRE9MTEFSXCIsXG4gICAgZGVzY3JpcHRpb246IC9cXFxcXFwkLyxcbiAgICBwcmVjZWRlbmNlOiAxNSxcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQlJcIixcbiAgICBkZXNjcmlwdGlvbjogL1xcbi8sXG4gICAgcHJlY2VkZW5jZTogMTAsXG4gIH0sXG5dO1xuXG50eXBlIEdyYW1tYXJSdWxlPFQsIFI+ID0ge1xuICB0eXBlOiBcIlJ1bGVcIjtcbiAgbmFtZTogc3RyaW5nO1xuICBwYXR0ZXJuOiBHcmFtbWFyUGF0dGVybltdOyAvLyBUT0RPOiBTaG91bGQgcmVhbGx5IGJlIHVzaW5nIGFuIGFic3RyYWN0aW9uIGhlcmUgdG8gYmUgbW9yZSBjbGVhclxuICBjYWxsYmFjazogKHI6IFJ1bGVNYXRjaDxULCBSPiwgY29udGV4dD86IGFueSkgPT4gUjtcbn07XG5cbnR5cGUgUnVsZU1hdGNoPFQsIFI+ID0ge1xuICB0eXBlOiBcIlJ1bGVcIjtcbiAgbmFtZTogc3RyaW5nO1xuICBjYWxsYmFjazogKGNvbnRleHQ/OiBhbnkpID0+IFI7XG4gIG1hdGNoOiBNYXRjaDxULCBSPltdO1xufTtcblxudHlwZSBUb2tlbk1hdGNoPFQ+ID0ge1xuICB0eXBlOiBcIlRva2VuXCI7XG4gIG5hbWU6IHN0cmluZztcbiAgbWF0Y2g6IHN0cmluZztcbn07XG5cbnR5cGUgTWF0Y2g8VCwgUj4gPSBSdWxlTWF0Y2g8VCwgUj4gfCBUb2tlbk1hdGNoPFQ+O1xuLy8ge1xuLy8gICAvLyBydWxlOiBHcmFtbWFyUnVsZTxUPiB8IFRva2VuO1xuLy8gICB0eXBlOiBcIlJ1bGVcIiB8IFwiVG9rZW5cIjtcbi8vICAgbmFtZTogc3RyaW5nO1xuLy8gICBjYWxsYmFjazogKGNvbnRleHQ/OiBhbnkpID0+IFQ7XG4vLyAgIG1hdGNoOiBSdWxlTWF0Y2g8VD5bXSB8IHN0cmluZztcbi8vIH07XG5cbnR5cGUgR3JhbW1hcjxULCBSPiA9IEdyYW1tYXJSdWxlPFQsIFI+W107XG5cblxuY29uc3QgZ3JhbTogR3JhbW1hcjxzdHJpbmcsIEhUTUxFbGVtZW50PiA9IFtcbiAge1xuICAgIHR5cGU6IFwiUnVsZVwiLFxuICAgIG5hbWU6IFwiSG9yaXpvbnRhbFJ1bGVcIixcbiAgICBwYXR0ZXJuOiBbW1wiREFTSFwiLCBcIkRBU0hcIiwgXCJEQVNIXCJdXSxcbiAgICBjYWxsYmFjazogKHI6IFJ1bGVNYXRjaDxzdHJpbmcsIEhUTUxFbGVtZW50PikgPT4ge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoclwiKTtcbiAgICB9LFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJSdWxlXCIsXG4gICAgbmFtZTogXCJIZWFkMVwiLFxuICAgIHBhdHRlcm46IFtbXCJIQVNIXCIsIFwiU1RSXCIsIFwiQlJcIl1dLFxuICAgIGNhbGxiYWNrOiAocjogUnVsZU1hdGNoPHN0cmluZywgSFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgICBjb25zdCBzdHJUb2tlbiA9IHIubWF0Y2hbMV07XG4gICAgICBpZiAoc3RyVG9rZW4udHlwZSA9PT0gXCJUb2tlblwiKSB7XG4gICAgICAgIGNvbnN0IHJldF9lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgxXCIpO1xuICAgICAgICByZXRfZWxlbS50ZXh0Q29udGVudCA9IHN0clRva2VuLm1hdGNoO1xuICAgICAgICByZXR1cm4gcmV0X2VsZW07XG4gICAgICAgIC8vIHJldHVybiBgPGgxPiR7c3RyVG9rZW4ubWF0Y2h9PC9oMT5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSEVBRDE6IEV4cGVjdGluZyBhIFNUUiwgd2hlbiB3ZSBpbnN0ZWFkIGdvdCBhbiBleHRlbmRlZCBydWxlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiUnVsZVwiLFxuICAgIG5hbWU6IFwiSGVhZDJcIixcbiAgICBwYXR0ZXJuOiBbW1wiSEFTSFwiLCBcIkhBU0hcIiwgXCJTVFJcIiwgXCJCUlwiXV0sXG4gICAgY2FsbGJhY2s6IChyOiBSdWxlTWF0Y2g8c3RyaW5nLCBIVE1MRWxlbWVudD4pID0+IHtcbiAgICAgIGNvbnN0IHN0clRva2VuID0gci5tYXRjaFsyXTtcbiAgICAgIGlmIChzdHJUb2tlbi50eXBlID09PSBcIlRva2VuXCIpIHtcbiAgICAgICAgY29uc3QgcmV0X2VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDJcIik7XG4gICAgICAgIHJldF9lbGVtLnRleHRDb250ZW50ID0gc3RyVG9rZW4ubWF0Y2g7XG4gICAgICAgIHJldHVybiByZXRfZWxlbTtcbiAgICAgICAgLy8gcmV0dXJuIGA8aDI+JHtzdHJUb2tlbi5tYXRjaH08L2gyPmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJIRUFEMjogRXhwZWN0aW5nIGEgU1RSLCB3aGVuIHdlIGluc3RlYWQgZ290IGFuIGV4dGVuZGVkIHJ1bGUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJSdWxlXCIsXG4gICAgbmFtZTogXCJIZWFkM1wiLFxuICAgIHBhdHRlcm46IFtbXCJIQVNIXCIsIFwiSEFTSFwiLCBcIkhBU0hcIiwgXCJTVFJcIiwgXCJCUlwiXV0sXG4gICAgY2FsbGJhY2s6IChyOiBSdWxlTWF0Y2g8c3RyaW5nLCBIVE1MRWxlbWVudD4pID0+IHtcbiAgICAgIGNvbnN0IHN0clRva2VuID0gci5tYXRjaFszXTtcbiAgICAgIGlmIChzdHJUb2tlbi50eXBlID09PSBcIlRva2VuXCIpIHtcbiAgICAgICAgY29uc3QgcmV0X2VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDNcIik7XG4gICAgICAgIHJldF9lbGVtLnRleHRDb250ZW50ID0gc3RyVG9rZW4ubWF0Y2g7XG4gICAgICAgIHJldHVybiByZXRfZWxlbTtcbiAgICAgICAgLy8gcmV0dXJuIGA8aDM+JHtzdHJUb2tlbi5tYXRjaH08L2gzPmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJIRUFEMzogRXhwZWN0aW5nIGEgU1RSLCB3aGVuIHdlIGluc3RlYWQgZ290IGFuIGV4dGVuZGVkIHJ1bGUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJSdWxlXCIsXG4gICAgbmFtZTogXCJJbmRlbnRcIixcbiAgICBwYXR0ZXJuOiBbW1wiVEFCXCJdXSxcbiAgICBjYWxsYmFjazogKHI6IFJ1bGVNYXRjaDxzdHJpbmcsIEhUTUxFbGVtZW50PikgPT4ge1xuICAgICAgY29uc3QgcmV0X2VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHJldF9lbGVtO1xuICAgIH0sXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICBuYW1lOiBcIkJsb2NrUXVvdGVcIixcbiAgICAvLyBUT0RPOiBBZGQgYmV0dGVyIG5lc3RpbmcgaGFuZGxpbmdcbiAgICBwYXR0ZXJuOiBbXG4gICAgICBbXCJHVFwiLCBcIkJyZWFrRnJlZVRleHRcIiwgXCJCUlwiXSxcbiAgICAgIFtcIkdUXCIsIFwiQmxvY2tRdW90ZVwiXSxcbiAgICBdLFxuICAgIGNhbGxiYWNrOiAocjogUnVsZU1hdGNoPHN0cmluZywgSFRNTEVsZW1lbnQ+LCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzdWJQcm9nUnVsZSA9IHIubWF0Y2hbMV07XG4gICAgICBpZiAoc3ViUHJvZ1J1bGUudHlwZSA9PT0gXCJSdWxlXCIpIHtcbiAgICAgICAgY29uc3QgcmV0X2VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYmxvY2txdW90ZVwiKTtcbiAgICAgICAgcmV0X2VsZW0udGV4dENvbnRlbnQgPSBgJHtzdWJQcm9nUnVsZS5jYWxsYmFjayhjb250ZXh0KX1gXG4gICAgICAgIHJldHVybiByZXRfZWxlbTtcbiAgICAgICAgLy8gcmV0dXJuIGA8YmxvY2txdW90ZT4ke3N1YlByb2dSdWxlLmNhbGxiYWNrKGNvbnRleHQpfTwvYmxvY2txdW90ZT5gO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gJ0Jsb2NrUXVvdGUnLCBzdWJQcm9nIGlzIG5vdCBhIHJ1bGVcIik7XG4gICAgfSxcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiUnVsZVwiLFxuICAgIG5hbWU6IFwiT3JkZXJlZExpc3RFbGVtXCIsXG4gICAgcGF0dGVybjogW1tcIk5VTV9ET1RcIiwgXCJUZXh0XCIsIFwiQlJcIl1dLFxuICAgIGNhbGxiYWNrOiAocjogUnVsZU1hdGNoPHN0cmluZywgSFRNTEVsZW1lbnQ+LCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCB0ZXh0VG9rZW4gPSByLm1hdGNoWzFdO1xuICAgICAgaWYgKHRleHRUb2tlbi50eXBlID09PSBcIlJ1bGVcIikge1xuICAgICAgICBjb25zdCByZXRfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgcmV0X2VsZW0udGV4dENvbnRlbnQgPSBgJHt0ZXh0VG9rZW4uY2FsbGJhY2soY29udGV4dCl9YDtcbiAgICAgICAgcmV0dXJuIHJldF9lbGVtO1xuICAgICAgICAvLyByZXR1cm4gYDxsaT4ke3RleHRUb2tlbi5jYWxsYmFjayhjb250ZXh0KX08L2xpPmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJPcmRlcmVkTGlzdEVsZW06IEV4cGVjdGluZyBhIFRleHQsIHdoZW4gd2UgaW5zdGVhZCBnb3QgYSBUb2tlbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICBuYW1lOiBcIlVub3JkZXJlZExpc3RFbGVtXCIsXG4gICAgcGF0dGVybjogW1tcIkRBU0hcIiwgXCJUZXh0XCIsIFwiQlJcIl1dLFxuICAgIGNhbGxiYWNrOiAocjogUnVsZU1hdGNoPHN0cmluZywgSFRNTEVsZW1lbnQ+LCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCB0ZXh0VG9rZW4gPSByLm1hdGNoWzFdO1xuICAgICAgaWYgKHRleHRUb2tlbi50eXBlID09PSBcIlJ1bGVcIikge1xuICAgICAgICBjb25zdCByZXRfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcbiAgICAgICAgcmV0X2VsZW0udGV4dENvbnRlbnQgPSBgJHt0ZXh0VG9rZW4uY2FsbGJhY2soY29udGV4dCl9YDtcbiAgICAgICAgcmV0dXJuIHJldF9lbGVtO1xuICAgICAgICAvLyByZXR1cm4gYDxsaT4ke3RleHRUb2tlbi5jYWxsYmFjayhjb250ZXh0KX08L2xpPmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJVbm9yZGVyZWRMaXN0RWxlbTogRXhwZWN0aW5nIGEgVGV4dCwgd2hlbiB3ZSBpbnN0ZWFkIGdvdCBhIFRva2VuLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgLy8ge1xuICAvLyAgIHR5cGU6IFwiUnVsZVwiLFxuICAvLyAgIG5hbWU6IFwiQmxvY2tRdW90ZVwiLFxuICAvLyAgIHBhdHRlcm46IFtbXCJHVFwiLCBcIlByb2dcIl1dLFxuICAvLyAgIGNhbGxiYWNrOiAoKSA9PiB7fSxcbiAgLy8gfSxcbiAge1xuICAgIHR5cGU6IFwiUnVsZVwiLFxuICAgIG5hbWU6IFwiQm9sZFwiLFxuICAgIHBhdHRlcm46IFtcbiAgICAgIFtcIlNUQVJcIiwgXCJTVEFSXCIsIFwiU1RSXCIsIFwiU1RBUlwiLCBcIlNUQVJcIl0sXG4gICAgICBbXCJVTkRFUlwiLCBcIlVOREVSXCIsIFwiU1RSXCIsIFwiVU5ERVJcIiwgXCJVTkRFUlwiXSxcbiAgICBdLFxuICAgIGNhbGxiYWNrOiAocjogUnVsZU1hdGNoPHN0cmluZywgSFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgICBjb25zdCBzdHJUb2tlbiA9IHIubWF0Y2hbMl07XG4gICAgICBpZiAoc3RyVG9rZW4udHlwZSA9PT0gXCJUb2tlblwiKSB7XG4gICAgICAgIC8vIFJldHVybiBhIGJvbGQgZWxlbWVudFxuICAgICAgICBjb25zdCByZXRfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiXCIpO1xuICAgICAgICByZXRfZWxlbS50ZXh0Q29udGVudCA9IHN0clRva2VuLm1hdGNoO1xuICAgICAgICByZXR1cm4gcmV0X2VsZW07XG4gICAgICAgIC8vIHJldHVybiBgPGI+JHtzdHJUb2tlbi5tYXRjaH08L2I+YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkJvbGQ6IEV4cGVjdGluZyBhIFNUUiwgd2hlbiB3ZSBpbnN0ZWFkIGdvdCBhbiBleHRlbmRlZCBydWxlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiUnVsZVwiLFxuICAgIG5hbWU6IFwiTGlua1wiLFxuICAgIHBhdHRlcm46IFtbXCJMQlJBQ0tFVFwiLCBcIlNUUlwiLCBcIlJCUkFDS0VUXCIsIFwiTFBBUkVOXCIsIFwiU1RSXCIsIFwiUlBBUkVOXCJdXSxcbiAgICBjYWxsYmFjazogKHI6IFJ1bGVNYXRjaDxzdHJpbmcsIEhUTUxFbGVtZW50PikgPT4ge1xuICAgICAgY29uc3Qgc3RyTmFtZVRva2VuID0gci5tYXRjaFsxXTtcbiAgICAgIGNvbnN0IHN0ckhyZWZUb2tlbiA9IHIubWF0Y2hbNF07XG4gICAgICBpZiAoc3RyTmFtZVRva2VuLnR5cGUgPT09IFwiVG9rZW5cIiAmJiBzdHJIcmVmVG9rZW4udHlwZSA9PT0gXCJUb2tlblwiKSB7XG4gICAgICAgIGNvbnN0IHJldF9lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIHJldF9lbGVtLmhyZWYgPSBzdHJIcmVmVG9rZW4ubWF0Y2g7XG4gICAgICAgIHJldF9lbGVtLnRleHRDb250ZW50ID0gc3RyTmFtZVRva2VuLm1hdGNoO1xuICAgICAgICByZXR1cm4gcmV0X2VsZW07XG4gICAgICAgIC8vIHJldHVybiBgPGEgaHJlZj1cIiR7c3RySHJlZlRva2VuLm1hdGNofVwiPiR7c3RyTmFtZVRva2VuLm1hdGNofTwvYT5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiTGluayBFbGVtZW50OiBFeHBlY3RpbmcgYSBTVFIsIHdoZW4gd2UgaW5zdGVhZCBnb3QgYW4gZXh0ZW5kZWQgcnVsZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICBuYW1lOiBcIkl0YWxpY1wiLFxuICAgIHBhdHRlcm46IFtcbiAgICAgIFtcIlNUQVJcIiwgXCJTVFJcIiwgXCJTVEFSXCJdLFxuICAgICAgW1wiVU5ERVJcIiwgXCJTVFJcIiwgXCJVTkRFUlwiXSxcbiAgICBdLFxuICAgIGNhbGxiYWNrOiAocjogUnVsZU1hdGNoPHN0cmluZywgSFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgICBjb25zdCBzdHJUb2tlbiA9IHIubWF0Y2hbMV07XG4gICAgICBpZiAoc3RyVG9rZW4udHlwZSA9PT0gXCJUb2tlblwiKSB7XG4gICAgICAgIGNvbnN0IHJldF9lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImVtXCIpO1xuICAgICAgICByZXRfZWxlbS50ZXh0Q29udGVudCA9IHN0clRva2VuLm1hdGNoO1xuICAgICAgICByZXR1cm4gcmV0X2VsZW07XG4gICAgICAgIC8vIHJldHVybiBgPGVtPiR7c3RyVG9rZW4ubWF0Y2h9PC9lbT5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSXRhbGljOiBFeHBlY3RpbmcgYSBTVFIsIHdoZW4gd2UgaW5zdGVhZCBnb3QgYW4gZXh0ZW5kZWQgcnVsZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICBuYW1lOiBcIkJyZWFrRnJlZVRleHRcIixcbiAgICBwYXR0ZXJuOiBbXG4gICAgICBbXCJFU0NBUEVfU0VRXCIsIFwiU1RBUlwiXSxcbiAgICAgIFtcIkVTQ0FQRV9TRVFcIiwgXCJFU0NBUEVfU0VRXCJdLFxuICAgICAgW1wiRVNDQVBFX1NFUVwiLCBcIkhBU0hcIl0sXG4gICAgICBbXCJFU0NBUEVfU0VRXCIsIFwiVU5ERVJcIl0sXG4gICAgICBbXCJFU0NBUEVfU0VRXCIsIFwiQkFDS1RJQ0tcIl0sXG4gICAgICBbXCJFU0NBUEVfU0VRXCIsIFwiTEJSQUNLRVRcIl0sXG4gICAgICBbXCJFU0NBUEVfU0VRXCIsIFwiUkJSQUNLRVRcIl0sXG4gICAgICBbXCJFU0NBUEVfU0VRXCIsIFwiTFBBUkVOXCJdLFxuICAgICAgW1wiRVNDQVBFX1NFUVwiLCBcIlJQQVJFTlwiXSxcbiAgICAgIFtcIkVTQ0FQRV9ET0xMQVJcIl0sXG4gICAgICBbXCJLQVRFWFwiXSxcbiAgICAgIFtcIlNUUlwiXSxcbiAgICAgIFtcIkl0YWxpY1wiXSxcbiAgICAgIFtcIkJvbGRcIl0sXG4gICAgICBbXCJDT0RFX0JMT0NLXCJdLFxuICAgICAgW1wiTGlua1wiXSxcbiAgICAgIC8vIFtcIkVNUFRZXCJdLFxuICAgIF0sXG4gICAgY2FsbGJhY2s6IChyOiBSdWxlTWF0Y2g8c3RyaW5nLCBIVE1MRWxlbWVudD4sIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHJldF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZm9yIChjb25zdCBydWxlIG9mIHIubWF0Y2gpIHtcbiAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gXCJUb2tlblwiKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIGEgdG9rZW4sIHdlIHNob3VsZCBiZSBhIFNUUiBvciBFU0NBUEVEXG4gICAgICAgICAgaWYgKHJ1bGUubmFtZSA9PT0gXCJFU0NBUEVfRE9MTEFSXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldF9lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgICAgICByZXRfZWxlbS50ZXh0Q29udGVudCA9IFwiJFwiO1xuICAgICAgICAgICAgcmV0X2FuY2hvci5hcHBlbmRDaGlsZChyZXRfZWxlbSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChydWxlLm5hbWUgPT09IFwiRVNDQVBFX1NFUVwiKSB7XG4gICAgICAgICAgICBpZiAoci5tYXRjaFsxXS50eXBlID09PSBcIlRva2VuXCIpIHtcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGFsd2F5cyBob2xkXG4gICAgICAgICAgICAgIGNvbnN0IHJldF9lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgICAgICAgIHJldF9lbGVtLnRleHRDb250ZW50ID0gci5tYXRjaFsxXS5tYXRjaDtcbiAgICAgICAgICAgICAgcmV0X2FuY2hvci5hcHBlbmRDaGlsZChyZXRfZWxlbSk7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByLm1hdGNoWzFdLm1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5uYW1lID09PSBcIktBVEVYXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGthdGV4U2xpY2UgPSBydWxlLm1hdGNoO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coa2F0ZXgpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coa2F0ZXhTbGljZSk7XG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlOiBVbnJlYWNoYWJsZSBjb2RlIGVycm9yXG5cdFx0XHRcdFx0XHR3aW5kb3cua2F0ZXggPSBrYXRleDtcblx0XHRcdFx0XHRcdGNvbnN0IGthdGV4VmFsID0ga2F0ZXhTbGljZS5zbGljZSgxLCBrYXRleFNsaWNlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY29uc3Qga2F0ZXhfcm9vdF9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGthdGV4LnJlbmRlcihrYXRleFZhbCwga2F0ZXhfcm9vdF9ub2RlKTtcbiAgICAgICAgICAgIHJldF9hbmNob3IuYXBwZW5kQ2hpbGQoa2F0ZXhfcm9vdF9ub2RlKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBSZW5kZXJpbmcgTGF0ZXggZm9yOiAke2thdGV4VmFsfWApO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coa2F0ZXhWYWwubGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUubmFtZSA9PT0gXCJDT0RFX0JMT0NLXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldF9lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNvZGVcIik7XG4gICAgICAgICAgICByZXRfZWxlbS50ZXh0Q29udGVudCA9IHJ1bGUubWF0Y2guc2xpY2UoMSwgcnVsZS5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldF9hbmNob3IuYXBwZW5kQ2hpbGQocmV0X2VsZW0pO1xuICAgICAgICAgICAgLy8gY29uc3QgY29kZVNsaWNlID0gcnVsZS5tYXRjaC5zbGljZSgxLCBydWxlLm1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgLy8gb3V0cHV0cyArPSBgPGNvZGU+JHtjb2RlU2xpY2V9PC9jb2RlPmA7XG4gICAgICAgICAgfSBlbHNlIGlmIChydWxlLm5hbWUgPT09IFwiU1RSXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldF9lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgICAgICByZXRfZWxlbS50ZXh0Q29udGVudCA9IHJ1bGUubWF0Y2g7XG4gICAgICAgICAgICByZXRfYW5jaG9yLmFwcGVuZENoaWxkKHJldF9lbGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBXZSBzaG91bGQgb25seSBiZSBhIFNUUiwgYnV0IGluc3RlYWQgd2VyZSBhICcke3J1bGUubmFtZX0nYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocnVsZS50eXBlID09PSBcIlJ1bGVcIikge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRPdXRwdXQgPSBydWxlLmNhbGxiYWNrKGNvbnRleHQpO1xuICAgICAgICAgIHJldF9hbmNob3IuYXBwZW5kQ2hpbGQoY3VycmVudE91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRfYW5jaG9yO1xuICAgIH0sXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICBuYW1lOiBcIlRleHRcIixcbiAgICBwYXR0ZXJuOiBbW1wiQnJlYWtGcmVlVGV4dFwiLCBcIlRleHRcIl0sIFtcIkVNUFRZXCJdXSxcbiAgICBjYWxsYmFjazogKHI6IFJ1bGVNYXRjaDxzdHJpbmcsIEhUTUxFbGVtZW50PiwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgcmV0X2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygci5tYXRjaCkge1xuICAgICAgICBpZiAocnVsZS50eXBlID09PSBcIlJ1bGVcIikge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRPdXRwdXQgPSBydWxlLmNhbGxiYWNrKGNvbnRleHQpO1xuICAgICAgICAgIHJldF9hbmNob3IuYXBwZW5kQ2hpbGQoY3VycmVudE91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRfYW5jaG9yO1xuICAgIH0sXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICBuYW1lOiBcIk5vbkVtcHR5VGV4dFwiLFxuICAgIHBhdHRlcm46IFtbXCJCcmVha0ZyZWVUZXh0XCIsIFwiVGV4dFwiXV0sXG4gICAgY2FsbGJhY2s6IChyOiBSdWxlTWF0Y2g8c3RyaW5nLCBIVE1MRWxlbWVudD4sIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHJldF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZm9yIChjb25zdCBydWxlIG9mIHIubWF0Y2gpIHtcbiAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gXCJSdWxlXCIpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50T3V0cHV0ID0gcnVsZS5jYWxsYmFjayhjb250ZXh0KTtcbiAgICAgICAgICByZXRfYW5jaG9yLmFwcGVuZENoaWxkKGN1cnJlbnRPdXRwdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0X2FuY2hvcjtcbiAgICB9LFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJSdWxlXCIsXG4gICAgbmFtZTogXCJQcm9nXCIsXG4gICAgcGF0dGVybjogW1xuICAgICAgW1wiSG9yaXpvbnRhbFJ1bGVcIiwgXCJQcm9nXCJdLFxuICAgICAgW1wiSGVhZDFcIiwgXCJQcm9nXCJdLFxuICAgICAgW1wiSGVhZDJcIiwgXCJQcm9nXCJdLFxuICAgICAgW1wiSGVhZDNcIiwgXCJQcm9nXCJdLFxuICAgICAgW1wiSW5kZW50XCIsIFwiUHJvZ1wiXSxcbiAgICAgIFtcIkJsb2NrUXVvdGVcIiwgXCJQcm9nXCJdLFxuICAgICAgW1wiT3JkZXJlZExpc3RFbGVtXCIsIFwiUHJvZ1wiXSxcbiAgICAgIFtcIlVub3JkZXJlZExpc3RFbGVtXCIsIFwiUHJvZ1wiXSxcbiAgICAgIFtcIk5vbkVtcHR5VGV4dFwiLCBcIlByb2dcIl0sXG4gICAgICBbXCJCUlwiLCBcIlByb2dcIl0sXG4gICAgICBbXCJFTVBUWVwiXSwgLy8gSU1QT1JUQU5UIFRIQVQgVEhJUyBCRSBIRVJFXG4gICAgICAvLyBUT0RPOiBNYWtlIG1vcmUgZmxleGlibGUgc28gRW1wdHkgbmVlZCBub3QgYmUgdGhlIGxhc3QgcnVsZVxuICAgIF0sXG4gICAgY2FsbGJhY2s6IChyOiBSdWxlTWF0Y2g8c3RyaW5nLCBIVE1MRWxlbWVudD4sIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHJldF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3Qgb3Blbkl0ZW1zOiBzdHJpbmdbXSA9IGNvbnRleHQub3Blbkl0ZW1zO1xuICAgICAgbGV0IHByZXZpb3VzQlIgPSBjb250ZXh0LnByZXZpb3VzQlI7XG4gICAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygci5tYXRjaCkge1xuICAgICAgICBpZiAocnVsZS50eXBlID09PSBcIlJ1bGVcIikge1xuICAgICAgICAgIC8vIGNvbnN0IHJ1bGVPdXRwdXQgPVxuICAgICAgICAgIGlmIChydWxlLm5hbWUgPT09IFwiT3JkZXJlZExpc3RFbGVtXCIpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGl0ZW0gaXMgYSBhbiBvcmRlcmVkIGxpc3QgZWxlbWVudFxuICAgICAgICAgICAgaWYgKG9wZW5JdGVtc1swXSA9PT0gXCJPcmRlcmVkTGlzdEVsZW1cIikge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgICAgICAgcmV0X2FuY2hvci5hcHBlbmRDaGlsZChydWxlLmNhbGxiYWNrKHsgb3Blbkl0ZW1zOiBvcGVuSXRlbXMsIHByZXZpb3VzQlI6IHByZXZpb3VzQlIgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG9wZW5JdGVtc1swXSA9PT0gXCJVbm9yZGVyZWRMaXN0RWxlbVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG90aGVyIG9uZSB3YXMgb3BlbiFcbiAgICAgICAgICAgICAgICBjb25zdCB1bEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgICAgICAgICAgcmV0X2FuY2hvci5hcHBlbmRDaGlsZCh1bEVsZW0pO1xuICAgICAgICAgICAgICAgIG9wZW5JdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBXZSBhcmUganVzdCBzdGFydGluZyBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgICAgICAgb3Blbkl0ZW1zLnB1c2goXCJPcmRlcmVkTGlzdEVsZW1cIik7XG4gICAgICAgICAgICAgIGNvbnN0IG9sRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvbFwiKTtcbiAgICAgICAgICAgICAgcmV0X2FuY2hvci5hcHBlbmRDaGlsZChvbEVsZW0pO1xuICAgICAgICAgICAgICByZXRfYW5jaG9yLmFwcGVuZENoaWxkKHJ1bGUuY2FsbGJhY2soeyBvcGVuSXRlbXM6IG9wZW5JdGVtcywgcHJldmlvdXNCUjogcHJldmlvdXNCUiB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChydWxlLm5hbWUgPT09IFwiVW5vcmRlcmVkTGlzdEVsZW1cIikge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgaXRlbSBpcyBhIGFuIHVuLW9yZGVyZWQgbGlzdCBlbGVtZW50XG4gICAgICAgICAgICBpZiAob3Blbkl0ZW1zWzBdID09PSBcIlVub3JkZXJlZExpc3RFbGVtXCIpIHtcbiAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYW4gdW4tb3JkZXJlZCBsaXN0XG4gICAgICAgICAgICAgIHJldF9hbmNob3IuYXBwZW5kQ2hpbGQocnVsZS5jYWxsYmFjayh7IG9wZW5JdGVtczogb3Blbkl0ZW1zLCBwcmV2aW91c0JSOiBwcmV2aW91c0JSIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChvcGVuSXRlbXNbMF0gPT09IFwiT3JkZXJlZExpc3RFbGVtXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3RoZXIgb25lIHdhcyBvcGVuIVxuICAgICAgICAgICAgICAgIGNvbnN0IG9sRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvbFwiKTtcbiAgICAgICAgICAgICAgICByZXRfYW5jaG9yLmFwcGVuZENoaWxkKG9sRWxlbSk7XG4gICAgICAgICAgICAgICAgb3Blbkl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFdlIGFyZSBqdXN0IHN0YXJ0aW5nIGFuIHVuLW9yZGVyZWQgbGlzdFxuICAgICAgICAgICAgICBvcGVuSXRlbXMucHVzaChcIlVub3JkZXJlZExpc3RFbGVtXCIpO1xuICAgICAgICAgICAgICBjb25zdCB1bEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgICAgICAgIHJldF9hbmNob3IuYXBwZW5kQ2hpbGQodWxFbGVtKTtcbiAgICAgICAgICAgICAgcmV0X2FuY2hvci5hcHBlbmRDaGlsZChydWxlLmNhbGxiYWNrKHsgb3Blbkl0ZW1zOiBvcGVuSXRlbXMsIHByZXZpb3VzQlI6IHByZXZpb3VzQlIgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5uYW1lID09PSBcIlByb2dcIikge1xuICAgICAgICAgICAgLy8gV2UgY291bGQgYmUgaW4gYmV0d2VlblxuICAgICAgICAgICAgcmV0X2FuY2hvci5hcHBlbmRDaGlsZChydWxlLmNhbGxiYWNrKHsgb3Blbkl0ZW1zOiBvcGVuSXRlbXMsIHByZXZpb3VzQlI6IHByZXZpb3VzQlIgfSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBuZWl0aGVyXG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgcG9zc2libHkgc3dpdGNoZWQgb2ZmIG9uZSB0byB0aGUgb3RoZXJcbiAgICAgICAgICAgIHN3aXRjaCAob3Blbkl0ZW1zWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJVbm9yZGVyZWRMaXN0RWxlbVwiOlxuICAgICAgICAgICAgICAgIG9wZW5JdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcbiAgICAgICAgICAgICAgICByZXRfYW5jaG9yLmFwcGVuZENoaWxkKHJldF9lbGVtKTtcbiAgICAgICAgICAgICAgICByZXRfYW5jaG9yLmFwcGVuZENoaWxkKHJ1bGUuY2FsbGJhY2soeyBvcGVuSXRlbXM6IG9wZW5JdGVtcywgcHJldmlvdXNCUjogcHJldmlvdXNCUiB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJPcmRlcmVkTGlzdEVsZW1cIjpcbiAgICAgICAgICAgICAgICBvcGVuSXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0X2VsZW0yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9sXCIpO1xuICAgICAgICAgICAgICAgIHJldF9hbmNob3IuYXBwZW5kQ2hpbGQocmV0X2VsZW0yKTtcbiAgICAgICAgICAgICAgICByZXRfYW5jaG9yLmFwcGVuZENoaWxkKHJ1bGUuY2FsbGJhY2soeyBvcGVuSXRlbXM6IG9wZW5JdGVtcywgcHJldmlvdXNCUjogcHJldmlvdXNCUiB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXRfYW5jaG9yLmFwcGVuZENoaWxkKHJ1bGUuY2FsbGJhY2soeyBvcGVuSXRlbXM6IG9wZW5JdGVtcywgcHJldmlvdXNCUjogcHJldmlvdXNCUiB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJ1bGUudHlwZSA9PT0gXCJUb2tlblwiICYmIHJ1bGUubmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIGEgQlJcbiAgICAgICAgICBpZiAocHJldmlvdXNCUiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gQWRkIGEgYnJlYWtcbiAgICAgICAgICAgIGNvbnN0IGJyRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgICAgICAgIHJldF9hbmNob3IuYXBwZW5kQ2hpbGQoYnJFbGVtKTtcbiAgICAgICAgICAgIHByZXZpb3VzQlIgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIG5vdCBzZWVuIGEgcHJldmlvdXMgQlIsIHNvIHNldCBmbGFnXG4gICAgICAgICAgICBwcmV2aW91c0JSID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRVJST1I6IFByb2cgc2hvdWxkIG5ldmVyIGVuY291bnRlciBhIHJhdyB0b2tlbiwgYnV0IGRpZDogJyR7cnVsZS5uYW1lfSdgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldF9hbmNob3I7XG4gICAgfSxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBJbnRlcnByZXQgPSAoc3RyOiBzdHJpbmcpOiBIVE1MRWxlbWVudCA9PiB7XG4gIGNvbnN0IHRva2VucyA9IFRva2VuaXplKHN0ciwgdG9rZW5fZGVzY19saXN0KTtcbiAgY29uc3QgcHJvZ1J1bGUgPSBncmFtLmZpbmQoKHZhbCkgPT4gdmFsLm5hbWUgPT09IFwiUHJvZ1wiKTtcbiAgaWYgKHByb2dSdWxlKSB7XG4gICAgY29uc3QgcnVsZVJlcyA9IFBhcnNlcig0LCB0b2tlbnMsIGdyYW0sIHByb2dSdWxlKTtcbiAgICBpZiAocnVsZVJlcyAmJiBydWxlUmVzLnR5cGUgPT09IFwiUnVsZVwiKSB7XG4gICAgICByZXR1cm4gcnVsZVJlcy5jYWxsYmFjayh7IG9wZW5JdGVtczogW10gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJldHVybiBvZiBwYXJzZXIgZmFpbGVkXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgaW50ZXJwcmV0IG1hcmt1cFwiKTtcbiAgfVxufTtcbiIsIi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiBhbGwgcnVsZXMgaW4gYSBncmFtbWFyXG4gKiBAcGFyYW0gZyB0aGUgZ3JhbW1hciB0byBnZXQgdGhlIHJ1bGVzIG5hbWVzIGZyb21cbiAqL1xuY29uc3QgcnVsZV9uYW1lcyA9IDxUPihnOiBHcmFtbWFyPFQ+KTogc3RyaW5nW10gPT4ge1xuICByZXR1cm4gZy5tYXAoKHJ1bGUpID0+IHJ1bGUubmFtZSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBzcGVjaWZpYyBncmFtbWFyIHJ1bGUgZm9yIGZyb20gYSBncmFtbWFyXG4gKiB3aGVyZSB0aGUgcnVsZSBuYW1lIGlzIHByb3ZpZGVkXG4gKiBAcGFyYW0gZyB0aGUgZ3JhbW1hciB0byBnZXQgdGhlIHJ1bGUgZnJvbVxuICogQHBhcmFtIHIgdGhlIG5hbWUgb2YgdGhlIHJ1bGUgdG8gZmluZFxuICogQHRocm93cyBJZiB0aGUgcnVsZSBuYW1lIHIgaXMgbm90IGluIGdyYW1tYXIgZ1xuICovXG5jb25zdCBnZXRfcnVsZSA9IDxUPihnOiBHcmFtbWFyPFQ+LCByOiBzdHJpbmcpOiBHcmFtbWFyUnVsZTxUPiA9PiB7XG4gIGNvbnN0IGdyID0gZy5maW5kKCh2YWwpID0+IHZhbC5uYW1lID09PSByKTtcbiAgaWYgKGdyKSB7XG4gICAgcmV0dXJuIGdyO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgUnVsZSAnJHtyfScgZG9lcyBub3QgZXhpc3QgaW4gZ3JhbW1hciAke2d9YCk7XG59O1xuXG4vKipcbiAqIEEgTEwoaykgcGFyc2VyIGZvciBhIHNwZWNpZmljIGdyYW1tYXIgcnVsZXMgcGF0dGVyblxuICogQHBhcmFtIGsgdGhlIG51bWJlciBvZiBsb29rYWhlYWQgdG9rZW5zIGZvciB0aGlzIHBhcnNlclxuICogQHBhcmFtIHRzIHRoZSBzdHJlYW0gb2YgdG9rZW5zIHRvIHBhcnNlXG4gKiBAcGFyYW0gZyB0aGUgZ3JhbW1hciB0byB1c2UgZm9yIHBhcnNpbmdcbiAqIEBwYXJhbSByIHRoZSB0b3AtbGV2ZWwgZ3JhbW1hciBydWxlIHRvIGF0dGVtcHQgdG8gcGFyc2VcbiAqIEBwYXJhbSBwIHRoZSBzcGVjaWZpYyBwYXR0ZXJuIHRvIGF0dGVtcHQgdG8gcGFyc2VcbiAqIEBwYXJhbSBmaW5hbCB3aGV0aGVyIG9yIG5vdCB0aGlzIHBhcnNlciBzaG91bGQgY29uc3VtZSBhbGwgcmVtYWluaW5nIHRva2Vuc1xuICovXG5jb25zdCBMTF9wYXR0ZXJuID0gPFQ+KFxuICBrOiBudW1iZXIsXG4gIHRzOiBUb2tlbnMsXG4gIGc6IEdyYW1tYXI8VD4sXG4gIHI6IEdyYW1tYXJSdWxlPFQ+LFxuICBwOiBHcmFtbWFyUGF0dGVybixcbiAgZmluYWw6IGJvb2xlYW5cbik6IFtNYXRjaDxUPiwgbnVtYmVyXSB8IHVuZGVmaW5lZCA9PiB7XG4gIC8qKiBXZSBhcmUgYXR0ZW1wdGluZyB0byBmb3JjZSBtYXRjaCBwYXR0ZXJuIFwicFwiIHdpdGggdG9rZW5zIFwidHNcIlxuICAgICAgV2UgaGF2ZSB0byBtYXRjaCBcImtcIiB0b2tlbnMsIGFuZCB0aGVuIGlmIHRoZXkgYWxsIG1hdGNoLCBcbiAgICAgIGNvbnN1bWUgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4uXG4gICAgICBcbiAgICAgIElmIHdlIGZpbmlzaCBvdXIgbWF0Y2ggYmVmb3JlIFwia1wiIHRva2VucywgXG4gICAgICB0aGVuIHdlIGNhbiBmdWxseSBjb25zdW1lIHRoYXQgYXMgdGhlIHBhdHRlcm4gaXMgYXBwbGljYWJsZVxuXG4gICAgICBJZiB3ZSBoYXZlIG1hdGNoZWQgYXMgd2UgcmVhY2ggXCJrXCIgdG9rZW5zLCBcbiAgICAgIHRoZW4gY29udGludWUgZ29pbmcuIChJZiB3ZSBmYWlsIGxhdGVyLCB0aGUgZ3JhbW1hciBpcyBub3QgTEwoaylcbiAgICAgIHdoaWNoIHdpbGwgbm90IGJlIG91ciBmYXVsdClcbiAgKi9cblxuICBjb25zdCBydWxlTmFtZXMgPSBydWxlX25hbWVzKGcpO1xuICBjb25zdCBydW5uaW5nX3J1bGU6IFJ1bGVNYXRjaDxUPiA9IHtcbiAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICBuYW1lOiByLm5hbWUsXG4gICAgY2FsbGJhY2s6IChjb250ZXh0PzogYW55KSA9PiByLmNhbGxiYWNrKHJ1bm5pbmdfcnVsZSwgY29udGV4dCksXG4gICAgbWF0Y2g6IFtdLFxuICB9O1xuXG4gIC8vIENoZWNraW5nIHRoZSBmaXJzdCBcImtcIiB0b2tlbnNcbiAgbGV0IHRva2VuSW5kID0gMDtcbiAgZm9yIChcbiAgICBsZXQgcGF0dGVybkluZCA9IDA7XG4gICAgcGF0dGVybkluZCA8IHAubGVuZ3RoICYmIHRva2VuSW5kIDwgdHMubGVuZ3RoO1xuICAgIHBhdHRlcm5JbmQrK1xuICApIHtcbiAgICBjb25zdCB0b2tJID0gdHNbdG9rZW5JbmRdO1xuICAgIGNvbnN0IHBhdHRlcm5JID0gcFtwYXR0ZXJuSW5kXTtcbiAgICBpZiAocGF0dGVybkkgPT09IFwiRU1QVFlcIikge1xuICAgICAgY29uc3QgZW1wdHlNYXRjaDogVG9rZW5NYXRjaDxUPiA9IHtcbiAgICAgICAgdHlwZTogXCJUb2tlblwiLFxuICAgICAgICBuYW1lOiBcIkVNUFRZXCIsXG4gICAgICAgIG1hdGNoOiBcIlwiLFxuICAgICAgfTtcbiAgICAgIHJ1bm5pbmdfcnVsZS5tYXRjaC5wdXNoKGVtcHR5TWF0Y2gpO1xuICAgICAgcmV0dXJuIFtydW5uaW5nX3J1bGUsIDBdO1xuICAgIH1cbiAgICBpZiAodG9rSS5uYW1lID09PSBwYXR0ZXJuSSkge1xuICAgICAgLy8gVGhpcyBtYXRjaCBhdCBwb2ludCAnaSdcbiAgICAgIGNvbnN0IHRva2VuTWF0Y2g6IFRva2VuTWF0Y2g8VD4gPSB7XG4gICAgICAgIHR5cGU6IFwiVG9rZW5cIixcbiAgICAgICAgbmFtZTogdG9rSS5uYW1lLFxuICAgICAgICBtYXRjaDogdG9rSS5tYXRjaCxcbiAgICAgIH07XG4gICAgICBydW5uaW5nX3J1bGUubWF0Y2gucHVzaCh0b2tlbk1hdGNoKTtcbiAgICAgIHRva2VuSW5kKys7XG4gICAgfSBlbHNlIGlmIChydWxlTmFtZXMuaW5jbHVkZXMocGF0dGVybkkpKSB7XG4gICAgICAvLyBwYXR0ZXJuW2ldIGlzIGEgc2VwYXJhdGUgcnVsZSwgcmVjdXJzZSBkb3duIHRvIG1hdGNoXG4gICAgICAvLyBJZiBvdXIgcGF0dGVybiBpcyB0aGUgbGFzdCBpbiB0aGUgbGlzdCwgaXQgc2hvdWxkIGNvbnN1bWUgYWxsXG4gICAgICBjb25zdCBjb25zdW1lQWxsID0gZmluYWwgJiYgcGF0dGVybkluZCA9PT0gcC5sZW5ndGggLSAxO1xuICAgICAgY29uc3QgcGF0UnVsZSA9IGdldF9ydWxlKGcsIHBhdHRlcm5JKTtcblxuICAgICAgY29uc3QgbWF0Y2hlZFJ1bGUgPSBMTF9ydWxlKFxuICAgICAgICBrLFxuICAgICAgICB0cy5zbGljZSh0b2tlbkluZCksXG4gICAgICAgIGcsXG4gICAgICAgIHBhdFJ1bGUsXG4gICAgICAgIGNvbnN1bWVBbGxcbiAgICAgICk7XG5cbiAgICAgIGlmIChtYXRjaGVkUnVsZSkge1xuICAgICAgICAvLyBXZSBkaWQgbm90IGhhdmUgYW4gdW5kZWZpbmVkIHRyYXZlcnNhbC5cbiAgICAgICAgLy8gQWRkIHRoZSBtYXRjaGVzXG4gICAgICAgIHJ1bm5pbmdfcnVsZS5tYXRjaC5wdXNoKG1hdGNoZWRSdWxlWzBdKTtcbiAgICAgICAgdG9rZW5JbmQgKz0gbWF0Y2hlZFJ1bGVbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5JbmQgPCBrKSB7XG4gICAgICAgICAgLy8gTWF0Y2hlZCBydWxlIHdhcyB1bmRlZmluZWQsIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBcImtcIlxuICAgICAgICAgIC8vIHRva2Vucywgc28gd2UgaGF2ZSB0byBiYWlsIG91dFxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2UgbWFkZSBpdCAnaycgdG9rZW5zLCBidXQgaXQgZmFpbGVkIGFmdGVyd2FyZHNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRva2VuSW5kIDwgaykge1xuICAgICAgICAvLyBTbyB3ZSBkaWRuJ3QgY29uc3VtZSBcImtcIiB0b2tlbnMgYW5kIGZhaWxlZCxcbiAgICAgICAgLy8gc28gdGhpcyBpcyBub3QgYSB0cnVlIGVycm9yLCBqdXN0IGEgYmFpbCBvdXRcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlIG1hZGUgaXQgJ2snIHRva2VucywgYnV0IGl0IGZhaWxlZCBhZnRlcndhcmRzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBXZSBoYXZlIGNvbnN1bWVkIGFsbCB0aGUgd2F5IHdlIG5lZWQgdG9cbiAgcmV0dXJuIFtydW5uaW5nX3J1bGUsIHRva2VuSW5kXTtcbn07XG5cbi8qKlxuICogQSBMTChrKSBwYXJzZXIgZm9yIGEgc3BlY2lmaWMgZ3JhbW1hciBydWxlXG4gKiBAcGFyYW0gayB0aGUgbnVtYmVyIG9mIGxvb2thaGVhZCB0b2tlbnMgZm9yIHRoaXMgcGFyc2VyXG4gKiBAcGFyYW0gdHMgdGhlIHN0cmVhbSBvZiB0b2tlbnMgdG8gcGFyc2VcbiAqIEBwYXJhbSBnIHRoZSBncmFtbWFyIHRvIHVzZSBmb3IgcGFyc2luZ1xuICogQHBhcmFtIHIgdGhlIHRvcC1sZXZlbCBncmFtbWFyIHJ1bGUgdG8gYXR0ZW1wdCB0byBwYXJzZVxuICogQHBhcmFtIGZpbmFsIHdoZXRoZXIgb3Igbm90IHRoaXMgcGFyc2VyIHNob3VsZCBjb25zdW1lIGFsbCByZW1haW5pbmcgdG9rZW5zXG4gKi9cbmNvbnN0IExMX3J1bGUgPSA8VD4oXG4gIGs6IG51bWJlcixcbiAgdHM6IFRva2VucyxcbiAgZzogR3JhbW1hcjxUPixcbiAgcjogR3JhbW1hclJ1bGU8VD4sXG4gIGZpbmFsOiBib29sZWFuXG4pOiBbTWF0Y2g8VD4sIG51bWJlcl0gfCB1bmRlZmluZWQgPT4ge1xuICAvLyBXaGlsZSB3ZSBzdGlsbCBoYXZlIHRva2VucyB0byBjb25zdW1lLCB0cnkgdGhlIHJ1bGVzIHBhdHRlcm5zXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiByLnBhdHRlcm4pIHtcbiAgICAvLyBGb3IgZWFjaCBwb3NzaWJsZSBwYXR0ZXJuXG4gICAgLy8gVHJ5IHRvIGFwcGx5IHRoYXQgcGF0dGVybixcbiAgICBjb25zdCBwYXR0ZXJuUmV0dXJuID0gTExfcGF0dGVybihrLCB0cywgZywgciwgcGF0dGVybiwgZmluYWwpO1xuICAgIGlmIChwYXR0ZXJuUmV0dXJuKSB7XG4gICAgICBjb25zdCBbcGF0dGVyblRyeSwgaW5kXSA9IHBhdHRlcm5SZXR1cm47XG4gICAgICAvLyBJZiB3ZSBoYXZlIHZhbGlkbHkgcmVhY2hlZCB0aGlzIHBvaW50LFxuICAgICAgLy8gdGhlIGVudGlyZSBwYXR0ZXJuIGhhcyBiZWVuIGNvbnN1bWVkIVxuXG4gICAgICBpZiAoZmluYWwgJiYgaW5kIDwgdHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgc3VwcG9zZWQgdG8gY29uc3VtZSBhbGwsIGJ1dCBpdCBkaWRudFxuICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gVGhpcyBjYW5ub3QgYmUgdGhlIHBhdHRlcm4sIHNvIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gW3BhdHRlcm5UcnksIGluZF07XG4gICAgfVxuICB9XG4gIGlmIChmaW5hbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCBwYXR0ZXJucyBleGhhdXN0ZWQsIGFuZCBub25lIHZhbGlkbHkgcGFyc2VkXCIpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgdG9rZW4gc3RyZWFtIHdpdGggYW4gTEwoaykgcGFyc2VyXG4gKiB1c2luZyB0aGUgcHJvdmlkZWQgR3JhbW1lciBhbmQgYSB0b3AtbGV2ZWwgZ3JhbW1hciBydWxlXG4gKiB0aGF0IHRoZSB0b2tlbiBzdHJlYW0gbXVzdCBjb25mb3JtIHRvLlxuICogQHBhcmFtIGsgdGhlIG51bWJlciBvZiB0aGUgTEwoaykgcGFyc2VyXG4gKiBAcGFyYW0gdG9rU3RyZWFtIHRoZSBzdHJlYW0gb2YgdG9rZW5zIHRvIHBhcnNlXG4gKiBAcGFyYW0gbGFuZ0dyYW1tYXIgdGhlIGdyYW1tYXIgdG8gdXNlIGZvciBwYXJzaW5nXG4gKiBAcGFyYW0gdG9wTGV2ZWxSdWxlIHRoZSB0b3AtbGV2ZWwgcnVsZSB0aGF0IHRoZSB0b2tlbiBzdHJlYW0gbXVzdCBjb25mb3JtIHRvXG4gKi9cbmV4cG9ydCBjb25zdCBQYXJzZXIgPSA8VD4oXG4gIGs6IG51bWJlcixcbiAgdG9rU3RyZWFtOiBUb2tlbnMsXG4gIGxhbmdHcmFtbWFyOiBHcmFtbWFyPFQ+LFxuICB0b3BMZXZlbFJ1bGU6IEdyYW1tYXJSdWxlPFQ+XG4pOiBNYXRjaDxUPiA9PiB7XG4gIGNvbnN0IHJ1bGVPdXQgPSBMTF9ydWxlKGssIHRva1N0cmVhbSwgbGFuZ0dyYW1tYXIsIHRvcExldmVsUnVsZSwgdHJ1ZSk7XG4gIGlmIChydWxlT3V0KSB7XG4gICAgcmV0dXJuIHJ1bGVPdXRbMF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlciFcIik7XG59O1xuIiwiLyoqXG4gKiBWZXJ5IHNpbWlsYXIgdG8gVG9rZW5pemUsIGJ1dCB3ZSBwcmVzdW1lZCB0aGF0IHRoZVxuICogdG9rZW4gZGVzY3JpcHRpb24gbGlzdCBcInRkc1wiIGlzIHNvcnRlZCBiYXNlZCBvblxuICogdG9rZW4gcHJlY2VkZW5jZVxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHRva2VuaXplXG4gKiBAcGFyYW0gdGRzIHRoZSBsaXN0IG9mIHRva2VuIGRlc2NyaXB0aW9uc1xuICovXG5jb25zdCBUb2tlbml6ZV9wcmltZSA9IChzdHI6IHN0cmluZywgdGRzOiBUb2tlbkRlc2NyaXB0aW9uW10pOiBUb2tlbnMgPT4ge1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIEVuZCBvZiBpbnB1dFxuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBnb29kTWF0Y2hlcyA9IHRkc1xuICAgIC5tYXAoKGRlc2MpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlc2MubmFtZSxcbiAgICAgICAgbWF0Y2g6IHN0ci5tYXRjaChkZXNjLmRlc2NyaXB0aW9uKSxcbiAgICAgIH07XG4gICAgfSlcbiAgICAuZmlsdGVyKCh2YWwpID0+IHZhbC5tYXRjaCAmJiB2YWwubWF0Y2guaW5kZXggPT09IDApO1xuICBpZiAoIWdvb2RNYXRjaGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZSBjb3VsZCBub3QgdG9rZW5pemUsIGVycm9yIHdpdGggc3RyaW5nICcke3N0cn0nYCk7XG4gIH1cbiAgY29uc3Qgb3B0aW1hbE1hdGNoID0gZ29vZE1hdGNoZXNbMF07XG4gIGlmIChvcHRpbWFsTWF0Y2ggJiYgb3B0aW1hbE1hdGNoLm1hdGNoKSB7XG4gICAgY29uc3QgYmVzdF90b2tlbjogVG9rZW4gPSB7XG4gICAgICB0eXBlOiBcIlRva2VuXCIsXG4gICAgICBuYW1lOiBvcHRpbWFsTWF0Y2gubmFtZSxcbiAgICAgIG1hdGNoOiBvcHRpbWFsTWF0Y2gubWF0Y2hbMF0sXG4gICAgfTtcbiAgICByZXR1cm4gW1xuICAgICAgYmVzdF90b2tlbixcbiAgICAgIC4uLlRva2VuaXplX3ByaW1lKHN0ci5zbGljZShiZXN0X3Rva2VuLm1hdGNoLmxlbmd0aCksIHRkcyksXG4gICAgXTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0b2tlbml6aW5nXCIpO1xufTtcblxuLyoqXG4gKiBUb2tlbml6ZXMgYSBzdHJpbmcgXCJzdHJcIiB1c2luZyB0b2tlbnMgYXMgZGVzY3JpYmVkXG4gKiBpbiB0aGUgbGlzdCBvZiB0b2tlbiBkZXNjcmlwdGlvbnMgXCJ0ZHNcIlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHRva2VuaXplXG4gKiBAcGFyYW0gdGRzIHRoZSBsaXN0IG9mIHRva2VuIGRlc2NyaXB0aW9uc1xuICovXG5leHBvcnQgY29uc3QgVG9rZW5pemUgPSAoc3RyOiBzdHJpbmcsIHRkczogVG9rZW5EZXNjcmlwdGlvbltdKTogVG9rZW5zID0+IHtcbiAgY29uc3QgdG9rZW5zID0gVG9rZW5pemVfcHJpbWUoXG4gICAgc3RyLFxuICAgIHRkcy5zb3J0KChhLCBiKSA9PiBiLnByZWNlZGVuY2UgLSBhLnByZWNlZGVuY2UpXG4gICk7XG4gIHJldHVybiB0b2tlbnM7XG59O1xuIiwiZXhwb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vUGFyc2VyXCI7XG5leHBvcnQgeyBUb2tlbml6ZSB9IGZyb20gXCIuL1Rva2VuaXplclwiO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsImltcG9ydCB7IEludGVycHJldCB9IGZyb20gXCIuL01hcmtVcFwiO1xuXG5sZXQgaW50ZXJwcmV0U2hvd24gPSBmYWxzZTtcblxuY29uc3Qgcm9vdEVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxEaXZFbGVtZW50PihcIiNyb290XCIpO1xuY29uc3QgdGV4dEJveEVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxUZXh0QXJlYUVsZW1lbnQ+KFwiI3RleHRCb3hcIik7XG5cbmNvbnN0IHRvZ2dsZURpc3BsYXkgPSAoKSA9PiB7XG4gIGludGVycHJldFNob3duID0gIWludGVycHJldFNob3duO1xuICBpZiAoIXJvb3RFbGVtIHx8ICF0ZXh0Qm94RWxlbSkgcmV0dXJuO1xuICByb290RWxlbS5oaWRkZW4gPSAhaW50ZXJwcmV0U2hvd247XG4gIHRleHRCb3hFbGVtLmhpZGRlbiA9IGludGVycHJldFNob3duO1xuICBpZiAoaW50ZXJwcmV0U2hvd24gPT09IHRydWUpIHtcbiAgICBpZiAodGV4dEJveEVsZW0udmFsdWUpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IEludGVycHJldCh0ZXh0Qm94RWxlbS52YWx1ZSArIFwiXFxuXFxuXCIpO1xuICAgICAgcm9vdEVsZW0uYXBwZW5kQ2hpbGQob3V0cHV0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGV4dEJveEVsZW0uZm9jdXMoKTtcbiAgfVxufTtcblxuZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gIGlmIChlLmtleSA9PT0gXCJFbnRlclwiICYmIGUuc2hpZnRLZXkpIHtcbiAgICB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgaWYgKHRleHRCb3hFbGVtKSB7XG4gICAgICB0ZXh0Qm94RWxlbS52YWx1ZSArPSBcIlxcdFwiO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=